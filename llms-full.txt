# Inspect Scout


## Welcome

Welcome to Inspect Scout, a tool for in-depth analysis of [Inspect
AI](https://inspect.aisi.org.uk/) transcripts. Scout has the following
core features:

1.  Scan full sample transcripts or individual messages or events.
2.  High performance parallel processing of transcript content.
3.  Resume scans that are stopped due to errors or interruptions.
4.  Tightly integrated with Inspect [data
    frames](https://inspect.aisi.org.uk/dataframe.html) for input and
    analysis.

### Installation

Install the `inspect_scout` package from GitHub as follows:

``` bash
pip install git+https://github.com/meridianlabs-ai/inspect_scout
```

Inspect Scout also depends on the development version of Inspect AI,
which will be installed automatically when you install Scout.

## Scout Basics

Below we’ll provide some simple examples of creating and using Scout
scanners. Some core components we’ll make use of here include:

- `Transcript` — LLM conversation to analyze (e.g. an Inspect sample
  trajectory).

- `Scanner` — Function that takes an input from a `Transcript` and
  returns a `Result` (conceptually very similar to an Inspect `Scorer`).

- `Results` — Data frame(s) that includes the results of scanners
  applied to transcripts.

### Creating a Scanner

The following illustrates the implementation of a simple LLM scanner
(click on the numbers at right for further explanation):

**scanner.py**

``` python
from inspect_scout import (
    Result, Scanner, Transcript, scanner, messages_as_str
)

from inspect_ai.model import get_model

@scanner(messages="all")
def ctf_environment() -> Scanner[Transcript]:
    
    async def scan(transcript: Transcript) -> Result:

        # call model
        output = await get_model().generate(
            "Here is a transcript of an LLM agent " +
            "solving a cybersecurity challenge:\n\n" +
            "===================================" +
            messages_as_str(transcript.messages) +
            "===================================\n\n" +
            "In the transcript above do you detect any " +
            "instances of environment misconfiguration " +
            "preventing the agent from completing it's " + 
            "task? If no, simply respond with 'No'. " +
            "If yes, respond with 'Yes' followed by an " +
            "explanation."
        )

        # return result (value + full model completion)
        return Result(
            value=output.completion.lower().startswith("yes"),
            explanation=result.completion
        )

    return scan
```

Line 7  
Scanners are decorated with `@scanner` so they can specify the exact
subset of content they need to read. In this case only messages (and not
events) will be read from the log, decreasing load time.

Line 13  
Scanners frequently use models to perform scanning. Calling
`get_model()` utilizes the default model for the scan job (which can be
specified in the top level call to scan).

Lines 16-18  
Convert the message history into a string for presentation to the model.

Lines 28-31  
As with scorers, results also include additional context (here the full
model completion).

### Running a Scan

We can now run that scanner on our log files. The `Scanner` will be
called once for each sample trajectory in the log (total samples \*
epochs):

``` bash
scout scan scanner.py --transcripts ./logs -model openai/gpt-5
```

### Adding a Scanner

Let’s add another scanner that looks for uses of Java in tool calls:

``` python
@scanner(events=["tool"]) 
def java_tool_usages() -> Scanner[ToolEvent]:
    
    async def scan(event: ToolEvent) -> Result:
        if "java" in str(event.arguments).lower():
            return Result(
                value=True, 
                explanation=str(event.arguments)
            )
        else:
            return Result(value=False)
       
    return scan
```

Note that we specify `events=["tool"]` to constrain reading to only tool
events, and that our function takes an individual event rather than a
`Transcript`.

If you add this scanner to the same source file as the
`ctf_environment()` scanner then `scout scan` will run both of the
scanners using the same `scout scan scanner.py` command,

### Scan Jobs

You may want to import scanners from other modules and compose them into
a `ScanJob`. To do this, add a `@scanjob` decorated function to your
source file (it will be used in preference to `@scanner` decorated
functions).

A `ScanJob` can also include `transcripts` or any other option that you
can pass to `scout scan` (e.g. `model`). For example:

**scanner.py**

``` python
from inspect_scout import ScanJob, scanjob

@scanjob
def job() -> ScanJob:
    return ScanJob(
        scanners=[ctf_environment(), java_tool_usages()],
        transcripts="./logs",
        model="openai/gpt-5"
    )
```

You can then use the same command to run the job (`scout scan` will
prefer a @scanjob defined in a file to individual scanners):

``` bash
scout scan scanner.py
```

You can also specify a scan job using YAML or JSON. For example, the
following is equivalent to the example above:

**scan.yaml**

``` yaml
scanners:
  - name: deception
    file: scanner.py
  - name: java_tool_usages
    file: scanner.py

transcripts: logs

model: openai/gpt-5
```

Which can be executed with:

``` bash
scout scan scan.yaml
```

### Scan Results

By default, the results of scans are written into the `./scans`
directory. You can override this using the `--results` option—both file
paths and S3 buckets are supported.

Each scan is stored in its own directory and has both metadata about the
scan (configuration, errors, summary of results) as well as parquet
files that contain the results. You can read the results either as a
dict of Pandas data frames or as a DuckDB database (there will be a
table for each scanner).

``` python
# results as pandas data frames
results = scan_results("scans/scan_id=iGEYSF6N7J3AoxzQmGgrZs")
deception_df = results.scanners["deception"]
tool_errors_df = results.scanners["tool_errors"]

# results as duckdb database 
results = scan_results_db("scans/scan_id=iGEYSF6N7J3AoxzQmGgrZs")
with results:
    # run queries to read data frames
    df = results.conn.execute("SELECT ...").fetch_df()

    # export entire database as file
    results.to_file("results.duckdb")
```

### Handling Errors

If a scan job is interrupted either due to cancellation (Ctrl+C) or a
runtime error, you can resume the scan from where it left off using the
`scan resume` command. For example:

``` bash
scout scan resume "scans/scan_id=iGEYSF6N7J3AoxzQmGgrZs"
```

If errors occur during an individual scan, they are caught and reported.
You can then either retry the failed scans with `scan resume` or
complete the scan (ignoring errors) with `scan complete`:

![](images/scan-resume.png)

## Transcripts

In the example(s) above we scanned the samples from a single Inspect log
file. More commonly though you’ll target an entire log directory or a
subset of logs in that directory. For example, here we scan all of
Cybench logs in the `./logs` directory:

``` python
from inspect_scout (
    import scan, transcripts_from_logs, log_metadata as m
)

from .scanners import deception, tool_errors

transcripts = transcripts_from_logs("./logs")
transcripts = transcripts.where(m.task_name == "cybench")

status = scan(
    scanners = [ctf_environment(), tool_errors()],
    transcripts = transcripts
)
```

The `log_metadata` object (aliased to `m`) provides a typed way to
specified `where()` clauses for filtering transcripts.

Note that doing this query required us to switch to the Python `scan()`
API. We can still use the CLI if we wrap our transcript query in a
`ScanJob`:

**cybench_scan.py**

``` python
from inspect_scout (
    import ScanJob, scanjob, transcripts_from_logs, log_metadata as m
)

from .scanners import deception, tool_errors

@scanjob
def cybench_job(logs: str = "./logs") -> ScanJob:

    transcripts = transcripts_from_logs(logs)
    transcripts = transcripts.where(m.task_name == "cybench")

    return ScanJob(
        scanners = [deception(), java_tool_usages()],
        transcripts = transcripts
    )
```

Then from the CLI:

``` bash
scout scan cybench.py -S logs=./logs --model openai/gpt-5
```

The `-S` argument enables you to pass arguments to the `@scanjob`
function (in this case determining what directory to read logs from).

## Parallelism

The Scout scanning pipeline is optimized for parallel reading and
scanning as well as minimal memory consumption. There are a few options
you can use to tune parallelism:

| Option | Description |
|----|----|
| `--max-transcripts` | The maximum number of transcripts to scan in parallel (defaults to 25). You can set this higher if your model API endpoint can handle larger numbers of concurrent requests. |
| `--max-connections` | The maximum number of concurrent requests to the model provider (defaults to `--max-transcripts`). |
| `--max-processes` | The maximum number of processes to use for parsing and scanning (defaults to the number of CPUs on the system). |

## Learning More

See the following articles to learn more about using Scout:

- [Transcripts](transcripts.qmd): Reading and filtering transcripts for
  scanning.

- [Scanners](scanners.qmd): Implementing custom scanners and loaders.

- [Results](results.qmd): Collecting and analyzing scanner results.

- [Reference](reference/index.qmd): Detailed documentation on the Scout
  Python API and CLI commands.

# Transcripts


## Overview

Transcripts are the fundamental input to scanners, and are read from one
or more Inspect logs. The `Transcripts` class represents a collection of
transcripts that has been selected for scanning. This is an index of
`TranscriptInfo` rather than full transcript content, and supports
various filtering operations to refine the collection.

## Reading Transcripts

Use the `transcripts_from_logs()` function to read a collection of
`Transcripts` from one or more Inspect logs:

``` python
from inspect_scout import transcripts_from_logs

# read from a log directory
transcripts = transcripts_from_logs("./logs")

# read from an S3 log directory
transcripts = transcripts_from_logs("s3://my-inspect-logs")

# read multiple log directories
transcripts = transcripts_from_logs(["./logs", "./logs2"])

# read from one or more log files
transcripts = transcripts_from_logs(
    ["logs/cybench.eval", "logs/swebench.eval"]
)
```

You can also specify transcripts using an
[evals_df()](https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#evals_df)
or
[samples_df()](https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#samples_df)
read using the Inspect log data frame functions:

``` python
from inspect_ai.analysis import samples_df
from inspect_scout import transcripts_from_logs

# read samples, filter as required, etc.
samples = samples_df("./logs")

# transcripts
transcripts = transcripts_from_logs(samples)
```

## Filtering Transcripts

If you want to scan only a subset of transcripts, you can use the
`.where()` method to narrow down the collection. For example:

``` python
from inspect_scout import transcripts_from_logs, log_metadata as m

transcripts = (
    transcripts_from_logs("./logs")
    .where(m.task_name == "cybench")
    .where(m.model.like("openai/%"))
)
```

See the `Column` documentation for additional details on supported
filtering operations.

See the `LogMetadata` documentation for the standard metadata fields
that are exposed from logs for filtering.

You can also limit the total number of transcripts as well as shuffle
the order of transcripts read (both are useful during scanner
development when you don’t want to process all transcripts). For
example:

``` python
from inspect_scout import transcripts_from_logs, log_metadata as m

transcripts = (
    transcripts_from_logs("./logs")
    .limit(10)
    .shuffle(42)
)
```

## Scanning Transcripts

Once you have established your list of transcripts to scan, just pass
them to the `scan()` function:

``` python
from inspect_scout import scan, transcripts_from_logs

from .scanners import ctf_environment, java_tool_calls

scan(
    scanners = [ctf_environment(), java_tool_calls()],
    transcripts = transcripts_from_logs("./logs")
)
```

If you want to do transcript filtering and then invoke your scan from
the CLI using `scout scan`, then perform the filtering inside a
`@scanjob`. For example:

**cybench_scan.py**

``` python
from inspect_scout (
    import ScanJob, scanjob, transcripts_from_logs, log_metadata as m
)

from .scanners import deception, tool_errors

@scanjob
def cybench_job(logs: str = "./logs") -> ScanJob:

    transcripts = transcripts_from_logs(logs)
    transcripts = transcripts.where(m.task_name == "cybench")

    return ScanJob(
        scanners = [deception(), java_tool_usages()],
        transcripts = transcripts
    )
```

Then from the CLI:

``` bash
scout scan cybench.py -S logs=./logs --model openai/gpt-5
```

The `-S` argument enables you to pass arguments to the `@scanjob`
function (in this case determining what directory to read logs from).

# Scanners


## Overview

Scanners are the main unit of processing in Inspect Scout and can target
a wide variety of content types. In this article we’ll cover the basic
scanning concepts, and then drill into creating scanners that target
various types (`Transcript`, `Event`, or `ChatMessage`) as well as
creating custom loaders which enable scanning of lists of events or
messages.

## Scanner Basics

A `Scanner` is a function that takes a `ScannerInput` (typically a
`Transcript`, but possibly an `Event`, `ChatMessage`, or list of events
or messages) and returns a `Result`. The result includes a `value` which
can be of any type—this might be `True` to indicate that something was
found but might equally be a number to indicate a count. More elaborate
scanner values (`dict` or `list`) are also possible.

Here is a simple scanner that uses a model to look for agent
“confusion”—whether or not it finds confusion, it still returns the
model completion as an `explanation`:

``` python
@scanner(messages="all")
def confusion() -> Scanner[Transcript]:
    
    async def scan(transcript: Transcript) -> Result:

        # call model
        output = await get_model().generate(
            "Here is a transcript of an LLM agent " +
            "solving a puzzle:\n\n" +
            "===================================" +
            messages_as_str(transcript.messages) +
            "===================================\n\n" +
            "In the transcript above do you see the agent " +
            "becoming confused? Repond beginning with 'Yes' " +
            "or 'No', followed by an explanation."
        )

        # return result (value + full model completion)
        return Result(
            value=output.completion.lower().startswith("yes"),
            explanation=result.completion
        )

    return scan
```

If a scanner doesn’t find anything, it still returns a `Result` with
`value=None` so that the explanation is preserved for later review.

### Input Types

`Transcript` is the most common `ScannerInput` however several other
types are possible:

- `Event` — Single event from the transcript (e.g. `ModelEvent`,
  `ToolEvent`, etc.). More than one `Event` in a `Transcript` can be
  scanned.

- `ChatMessage` — Single chat message from the transcript message
  history. More than one `ChatMessage` in a `Transcript` can be scanned.

- `list[Event]` or `list[ChatMessage]` — Arbitrary sets of events or
  messages extracted from the `Transcript` (see [Loaders](#loaders)
  below for details).

See the sections on [Transcripts](#transcripts), [Events](#events),
[Messages](#messages), and [Loaders](#loaders) below for additional
details on handling various input types.

### Input Filtering

One important principle of the Inspect Scout transcript pipeline is that
only the precise data to be scanned should be read, and nothing more.
This can dramatically improve performance as messages and events that
won’t be seen by scanners are never deserialized. Scanner input filters
are specified as arguments to the `@scanner` decorator (you may have
noticed the `messages="all"` attached to the scanner decorator in the
example above).

For example, here we are looking for instances of assistants
swearing—for this task we only need to look at assistant messages so we
specify `messages=["assistant"]`

``` python
@scanner(messages=["assistant"])
def assistant_swearing() -> Scanner[Transcript]:

    async def scan(transcript: Transcript) -> Result:
        swear_words = [
            word 
            for m in transcript.messages 
            for word in extract_swear_words(m.text)
        ]
        return Result(
            value=swear_words if len(swear_words) > 0 else None,
            explanation=",".join(swear_words)
        )

    return scan
```

With this filter, only assistant messages and no events whatsoever will
be loaded from transcripts during scanning.

Note that by default, no filters are active, so if you don’t specify
values for `messages` and/or `events` your scanner will not be called!

## Transcripts

Transcripts are the most common input to scanners, and are read from one
or more Inspect logs. A `Transcript` represents a single epoch from an
Inspect sample—so each Inspect log file will have `samples * epochs`
transcripts.

### Transcript Fields

Each `Transcript` has the following fields:

| Field | Type | Description |
|----|----|----|
| `id` | str | Globally unique identifier for a transcript (maps to `EvalSample.uuid` in the Inspect log). |
| `source_id` | str | Globally unique identifier for a transcript source (maps to `eval_id` in the Inspect log) |
| `source_uri` | str | URI for source data (e.g. full path to the Inspect log file). |
| `metadata` | dict\[str, JsonValue\] | Eval configuration metadata (e.g. task, model, scores, etc.). See `LogMetadata` for details. |
| `messages` | list\[ChatMessage\] | Message history from `EvalSample` |
| `events` | list\[Event\] | Event history from `EvalSample` |

### Content Filtering

Note that the `messages` and `events` fields will not be populated
unless you specify a `messages` or `events` filter on your scanner. For
example, this scanner will see all messages and events:

``` python
@scanner(messages="all", events="all")
def my_scanner() -> Scanner[Transcript]: ...
```

This scanner will see only model and tool events:

``` python
@scanner(events=["model", "tool"])
def my_scanner() -> Scanner[Transcript]: ...
```

This scanner will see only assistant messages:

``` python
@scanner(messages=["assistant"])
def my_scanner() -> Scanner[Transcript]: ...
```

### Presenting Messages

When processing transcripts, you will often want to present an entire
message history to model for analysis. Above, we used the
`messages_as_str()` function to do this:

``` python
# call model
result = await get_model().generate(
    "Here is a transcript of an LLM agent " +
    "solving a puzzle:\n\n" +
    "===================================" +
    messages_as_str(transcript.messages) +
    "===================================\n\n" +
    "In the transcript above do you see the agent " +
    "becoming confused? Repond beginning with 'Yes' " +
    "or 'No', followed by an explanation."
)
```

## Events

To write a scanner that targets events, write a function that takes the
event type(s) you want to process. For example, this scanner will see
only model events:

``` python
@scanner
def my_scanner() -> Scanner[ModelEvent]:
    def scan(event: ModelEvent) -> Result: 
        ...

    return scan
```

Note that the `events="model"` filter was not required since we had
already declared our scanner to take only model events. If we wanted to
take both model and tool events we’d do this:

``` python
@scanner
def my_scanner() -> Scanner[ModelEvent | ToolEvent]:
    def scan(event: ModelEvent | ToolEvent) -> Result: 
        ...

    return scan
```

## Messages

To write a scanner that targets messages, write a function that takes
the message type(s) you want to process. For example, this scanner will
only see tool messages:

``` python
@scanner
def my_scanner() -> Scanner[ChatMessageTool]:
    def scan(message: ChatMessageTool) -> Result: 
        ...

    return scan
```

This scanner will see only user and assistant messages:

``` python
@scanner
def my_scanner() -> Scanner[ChatMessageUser | ChatMessageAssistant]:
    def scan(message: ChatMessageUser | ChatMessageAssistant) -> Result: 
        ...

    return scan
```

## Loaders

When you want to process multiple discrete items from a `Transcript`
this might not always fall neatly into single messages or events. For
example, you might want to process pairs of user/assistant messages. To
do this, create a custom `Loader` that yields the content as required.

For example, here is a `Loader` that yields user/assistant message
pairs:

``` python
@loader(messages=["user", "assistant"])
def conversation_turns():
    async def load(
        transcript: Transcript
    ) -> AsyncGenerator[list[ChatMessage], None]:
        
        for user,assistant in message_pairs(transcript.messages):
            yield [user, assistant]

    return load
```

Note that just like with scanners, the loader still needs to provide a
`messages=["user", "assistant"]` in order to see those messages.

We can now use this loader in a scanner that looks for refusals:

``` python
@scanner(loader=conversation_turns())
def assistant_refusals() -> Scanner[list[ChatMessage]]:

    async def scan(messages: list[ChatMessage]) -> Result:
        user, assistant = messages
        return Result(
            value=is_refusal(assistant.text), 
            explanation=messages_as_str(messages)
        )

    return scan
```

# Results


## Overview

The results of scans are stored in directory on the local filesystem (by
default `./scans`) or in a remote S3 bucket. When a scan job is
completed its directory is printed, and you can also use the
`scan_list()` function or `scout scan list` command to enumerate scan
jobs.

Scan results include the following:

- Scan configuration (e.g. options passed to `scan()` or to
  `scout scan`).

- Transcripts scanned and scanners executed and errors which occurred
  during the last scan.

- A set of [Parquet](https://parquet.apache.org/docs/) files with scan
  results (one for each scanner). There are functions available to
  interface with these files as Pandas data frames or DuckDB databases.

## Workflow

### Scout CLI

The `scout scan` command will print its status at the end of its run. If
all of the scanners completed without errors you’ll see a message
indicating the scan is complete along with a pointer to the scan
directory where results are stored:

![](images/scan-complete.png)

You can then pass that directory to the `scan_results()` function to get
access to the underlying data frames for each scanner:

``` python
from inspect_scout import scan_results

results = scan_results("scans/scan_id=3ibJe9cg7eM5zo3h5Hpbr8")
deception_df = results.scanners["deception"]
tool_errors_df = results.scanners["tool_errors"]
```

### Python API

The `scan()` function returns a `Status` object which indicates whether
the scan completed successfully (in which case the scanner results are
available for analysis). You’ll therefore want to check the `.completed`
field before proceeding to read the results. For example:

``` python
from inspect_scout import (
    scan, scan_results, transcripts_from_logs
)

from .scanners import ctf_environment, java_tool_calls

status = scan(
    transcripts=transcripts_from_logs("./logs"),
    scanners=[ctf_environment(), java_tool_calls()]
)

if status.complete:
    results = scan_results(status.location)
    deception_df = results.scanners["deception"]
    tool_errors_df = results.scanners["tool_errors"]
```

### DuckDB

The above examples demonstrated reading scanner output as Pandas data
frames. If you prefer, you can also read scanner data from a DuckDB
database as follows:

``` python
results = scan_results_db("scans/scan_id=3ibJe9cg7eM5zo3h5Hpbr8")
with results:
    # run queries to read data frames
    df = results.conn.execute("SELECT ...").fetch_df()

    # export entire database as file
    results.to_file("results.duckdb")
```

## Results Data

The `Results` object returned from `scan_results()` includes both
metadata about the scan as well as the scanner data frames:

| Field | Type | Description |
|----|----|----|
| `complete` | bool | Is the job complete? (all transcripts scanned) |
| `spec` | ScanSpec | Scan specification (transcripts, scanners, options, etc.) |
| `location` | str | Location of scan directory |
| `summary` | Summary | Summary of scan (results, errors, tokens, etc.) |
| `errors` | list\[Error\] | Errors during last scan attempt. |
| `scanners` | dict\[str, pd.DataFrame\] | Results data for each scanner (see [Data Frames](#scanner-data) for details) |

### Data Frames

<style type="text/css">
#scanner-data td:nth-child(2) {
  font-size: 0.9em;
  line-height: 1.2;
}
#scanner-data small {
  font-size: x-small;
}
</style>

The data frames available for each scanner contain information about the
source evaluation and transcript, the results found for each transcript,
as well as data on token usage, model calls, and errors which may have
occurred during the scan.

The data frame includes the following fields (note that some fields
included embedded JSON data, these are all noted below):

[TABLE]

Several of these fields can be used to link back to the source eval log
and sample for the transcript:

- `transcript_id` — This is the same as the `EvalSample.uuid` in the
  Inspect log or the `sample_id` in data frames created by
  [samples_df()](https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#samples_df).

- `transcript_source_id` — This is the same as the `eval_id` in both the
  Inspect log and Inspect data frames.

- `transcript_source_uri` — This is the full path (filesystem or S3) to
  the actual log file where the transcript was read from.

# Scanning


## Scanning

### scan

Scan transcripts.

Scan transcripts using one or more scanners. Note that scanners must
each have a unique name. If you have more than one instance of a scanner
with the same name, numbered prefixes will be automatically assigned.
Alternatively, you can pass tuples of (name,scanner) or a dict with
explicit names for each scanner.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scan.py#L64)

``` python
def scan(
    scanners: Sequence[Scanner[ScannerInput] | tuple[str, Scanner[ScannerInput]]]
    | dict[str, Scanner[ScannerInput]]
    | ScanJob
    | ScanJobConfig,
    transcripts: Transcripts | None = None,
    results: str | None = None,
    model: str | Model | None = None,
    model_config: GenerateConfig | None = None,
    model_base_url: str | None = None,
    model_args: dict[str, Any] | str | None = None,
    model_roles: dict[str, str | Model] | None = None,
    max_transcripts: int | None = None,
    max_processes: int | None = None,
    limit: int | None = None,
    shuffle: bool | int | None = None,
    tags: list[str] | None = None,
    metadata: dict[str, Any] | None = None,
    display: DisplayType | None = None,
    log_level: str | None = None,
) -> Status
```

`scanners` Sequence\[[Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\] \| tuple\[str, [Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\]\]\] \| dict\[str, [Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\]\] \| [ScanJob](scanning.qmd#scanjob) \| [ScanJobConfig](scanning.qmd#scanjobconfig)  
Scanners to execute (list, dict with explicit names, or ScanJob). If a
`ScanJob` or `ScanJobConfig` is specified, then its options are used as
the default options for the scan.

`transcripts` [Transcripts](transcript.qmd#transcripts) \| None  
Transcripts to scan.

`results` str \| None  
Location to write results (filesystem or S3 bucket). Defaults to
“./scans”.

`model` str \| Model \| None  
Model to use for scanning by default (individual scanners can always
call `get_model()` to us arbitrary models). If not specified use the
value of the SCOUT_SCAN_MODEL environment variable.

`model_config` GenerateConfig \| None  
`GenerationConfig` for calls to the model.

`model_base_url` str \| None  
Base URL for communicating with the model API.

`model_args` dict\[str, Any\] \| str \| None  
Model creation args (as a dictionary or as a path to a JSON or YAML
config file).

`model_roles` dict\[str, str \| Model\] \| None  
Named roles for use in `get_model()`.

`max_transcripts` int \| None  
The maximum number of transcripts to process concurrently (this also
serves as the default value for `max_connections`). Defaults to 25.

`max_processes` int \| None  
The maximum number of concurrent processes (for multiproccesing).
Defaults to `multiprocessing.cpu_count()`.

`limit` int \| None  
Limit the number of transcripts processed.

`shuffle` bool \| int \| None  
Shuffle the order of transcripts (pass an `int` to set a seed for
shuffling).

`tags` list\[str\] \| None  
One or more tags for this scan.

`metadata` dict\[str, Any\] \| None  
Metadata for this scan.

`display` DisplayType \| None  
Display type: “rich”, “plain”, or “none” (defaults to “rich”).

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”)

### scan_resume

Resume a previous scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scan.py#L247)

``` python
def scan_resume(
    scan_location: str,
    display: DisplayType | None = None,
    log_level: str | None = None,
) -> Status
```

`scan_location` str  
Scan location to resume from.

`display` DisplayType \| None  
Display type: “rich”, “plain”, or “none” (defaults to “rich”).

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”)

### scan_complete

Complete a scan.

This function is used to indicate that a scan with errors in some
transcripts should be completed in spite of the errors.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scan.py#L307)

``` python
def scan_complete(
    scan_location: str,
    display: DisplayType | None = None,
    log_level: str | None = None,
) -> Status
```

`scan_location` str  
Scan location to complete.

`display` DisplayType \| None  
Display type: “rich”, “plain”, or “none” (defaults to “rich”).

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”)

## Jobs

### scanjob

Decorator for registering scan jobs.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanjob.py#L298)

``` python
def scanjob(
    func: ScanJobType | None = None, *, name: str | None = None
) -> ScanJobType | Callable[[ScanJobType], ScanJobType]
```

`func` ScanJobType \| None  
Function returning `ScanJob`.

`name` str \| None  
Optional name for scanjob (defaults to function name).

### ScanJob

Scan job definition.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanjob.py#L99)

``` python
class ScanJob
```

#### Attributes

`name` str  
Name of scan job (defaults to @scanjob function name).

`transcripts` [Transcripts](transcript.qmd#transcripts) \| None  
Trasnscripts to scan.

`scanners` dict\[str, [Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\]\]  
Scanners to apply to transcripts.

`results` str \| None  
Location to write results (filesystem or S3 bucket). Defaults to
“./scans”.

`model` Model \| None  
Model to use for scanning by default (individual scanners can always
call `get_model()` to us arbitrary models).

If not specified use the value of the SCOUT_SCAN_MODEL environment
variable.

`model_base_url` str \| None  
Base URL for communicating with the model API.

`model_args` dict\[str, Any\] \| None  
Model creation args (as a dictionary or as a path to a JSON or YAML
config file).

`generate_config` GenerateConfig \| None  
`GenerationConfig` for calls to the model.

`model_roles` dict\[str, Model\] \| None  
Named roles for use in `get_model()`.

`max_transcripts` int \| None  
The maximum number of transcripts to process concurrently (this also
serves as the default value for `max_connections`). Defaults to 25.

`max_processes` int \| None  
The maximum number of concurrent processes (for multiproccesing).
Defaults to `multiprocessing.cpu_count()`.

`limit` int \| None  
Limit the number of transcripts processed.

`shuffle` bool \| int \| None  
Shuffle the order of transcripts (pass an `int` to set a seed for
shuffling).

`tags` list\[str\] \| None  
One or more tags for this scan.

`metadata` dict\[str, Any\] \| None  
Metadata for this scan.

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”).

### ScanJobConfig

Scan job configuration.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanjob.py#L37)

``` python
class ScanJobConfig(BaseModel)
```

#### Attributes

`name` str  
Name of scan job (defaults to “job”).

`transcripts` str \| list\[str\] \| None  
Trasnscripts to scan.

`scanners` list\[[ScannerSpec](scanning.qmd#scannerspec)\] \| dict\[str, [ScannerSpec](scanning.qmd#scannerspec)\] \| None  
Scanners to apply to transcripts.

`results` str \| None  
Location to write results (filesystem or S3 bucket). Defaults to
“./scans”.

`model` str \| None  
Model to use for scanning by default (individual scanners can always
call `get_model()` to us arbitrary models).

If not specified use the value of the SCOUT_SCAN_MODEL environment
variable.

`model_base_url` str \| None  
Base URL for communicating with the model API.

`model_args` dict\[str, Any\] \| str \| None  
Model creation args (as a dictionary or as a path to a JSON or YAML
config file).

`generate_config` GenerateConfig \| None  
`GenerationConfig` for calls to the model.

`model_roles` dict\[str, ModelConfig \| str\] \| None  
Named roles for use in `get_model()`.

`max_transcripts` int \| None  
The maximum number of transcripts to process concurrently (this also
serves as the default value for `max_connections`). Defaults to 25.

`max_processes` int \| None  
The maximum number of concurrent processes (for multiproccesing).
Defaults to `multiprocessing.cpu_count()`.

`limit` int \| None  
Limit the number of transcripts processed.

`shuffle` bool \| int \| None  
Shuffle the order of transcripts (pass an `int` to set a seed for
shuffling).

`tags` list\[str\] \| None  
One or more tags for this scan.

`metadata` dict\[str, Any\] \| None  
Metadata for this scan.

`log_level` Literal\['debug', 'http', 'sandbox', 'info', 'warning', 'error', 'critical', 'notset'\] \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”).

### ScannerSpec

Scanner used by scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanspec.py#L18)

``` python
class ScannerSpec(BaseModel)
```

#### Attributes

`name` str  
Scanner name.

`file` str \| None  
Scanner source file (if not in a package).

`params` dict\[str, Any\]  
Scanner arguments.

## Status

### Status

Status of scan job.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_recorder/recorder.py#L15)

``` python
@dataclass
class Status
```

#### Attributes

`complete` bool  
Is the job complete (all transcripts scanned).

`spec` ScanSpec  
Scan spec (transcripts, scanners, options).

`location` str  
Location of scan directory.

`summary` [Summary](results.qmd#summary)  
Summary of scan (results, errors, tokens, etc.)

`errors` list\[[Error](scanner.qmd#error)\]  
Errors during last scan attempt.

### ScanOptions

Options used for scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanspec.py#L44)

``` python
class ScanOptions(BaseModel)
```

#### Attributes

`max_transcripts` int  
Maximum number of concurrent transcripts (defaults to 25).

`max_processes` int  
Number of worker processes. Defaults to `multiprocessing.cpu_count()`.

`limit` int \| None  
Transcript limit (maximum number of transcripts to read).

`shuffle` bool \| int \| None  
Shuffle order of transcripts.

### ScanRevision

Git revision for scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanspec.py#L31)

``` python
class ScanRevision(BaseModel)
```

#### Attributes

`type` Literal\['git'\]  
Type of revision (currently only “git”)

`origin` str  
Revision origin server

`commit` str  
Revision commit.

### ScanTranscripts

Transcripts target by a scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanspec.py#L73)

``` python
class ScanTranscripts(BaseModel)
```

#### Attributes

`type` str  
Transcripts backing store type (currently only ‘eval_log’).

`fields` list\[[TranscriptField](scanning.qmd#transcriptfield)\]  
Data types of transcripts fields.

`count` int  
Trancript count.

`data` str  
Transcript data as a csv.

### TranscriptField

Field in transcript data frame.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanspec.py#L60)

``` python
class TranscriptField(TypedDict, total=False)
```

#### Attributes

`name` Required\[str\]  
Field name.

`type` Required\[str\]  
Field type (“integer”, “number”, “boolean”, “string”, or “datetime”)

`tz` NotRequired\[str\]  
Timezone (for “datetime” fields).

# Transcript API


### transcripts_from_logs

Read sample transcripts from eval logs.

Logs can be specified by file or directory path(s) or alternatively an
[evals_df()](https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#evals_df)
or
[samples_df()](https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#samples_df)

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/database.py#L371)

``` python
def transcripts_from_logs(logs: LogPaths | pd.DataFrame) -> Transcripts
```

`logs` LogPaths \| pd.DataFrame  
Log paths as file(s), directories, or data frame.

### Transcripts

Collection of transcripts for scanning.

Transcript collections can be filtered using the `where()`, `limit()`,
and ’shuffle()\` methods. The transcripts are not modified in place so
the filtered transcripts should be referenced via the return value. For
example:

``` python
from inspect_scout import transcripts, log_metadata as m

transcripts = transcripts_from_logs("./logs")
transcripts = transcripts.where(m.task_name == "cybench")
```

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/transcripts.py#L13)

``` python
class Transcripts(abc.ABC)
```

#### Methods

where  
Filter the transcript collection by a `Condition`.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/transcripts.py#L35)

``` python
def where(self, condition: Condition) -> "Transcripts"
```

`condition` [Condition](transcript.qmd#condition)  
Filter condition.

limit  
Limit the number of transcripts processed.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/transcripts.py#L48)

``` python
def limit(self, n: int) -> "Transcripts"
```

`n` int  
Limit on transcripts.

shuffle  
Shuffle the order of transcripts.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/transcripts.py#L61)

``` python
def shuffle(self, seed: int | None = None) -> "Transcripts"
```

`seed` int \| None  
Random seed for shuffling.

count  
Number of transcripts in collection.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/transcripts.py#L87)

``` python
@abc.abstractmethod
async def count(self) -> int
```

index  
Index of `TranscriptInfo` for the collection.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/transcripts.py#L92)

``` python
@abc.abstractmethod
async def index(self) -> Iterator[TranscriptInfo]
```

### TranscriptInfo

Transcript identifier, location, and metadata.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/types.py#L36)

``` python
class TranscriptInfo(BaseModel)
```

#### Attributes

`id` str  
Globally unique id for transcript (e.g. sample uuid).

`source_id` str  
Globally unique ID for transcript source (e.g. eval_id).

`source_uri` str  
URI for source data (e.g. log file path)

`metadata` dict\[str, JsonValue\]  
e.g. eval config (model, scores, task params, etc.).

### Transcript

Transcript info and transcript content (messages and events).

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/types.py#L52)

``` python
class Transcript(TranscriptInfo)
```

#### Attributes

`messages` list\[ChatMessage\]  
Main message thread.

`events` list\[Event\]  
Events from transcript.

### Column

Database column with comparison operators.

Supports various predicate functions including `like()`, `not_like()`,
`between()`, etc. Additionally supports standard python equality and
comparison operators (e.g. `==`, ’\>\`, etc.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L521)

``` python
class Column
```

#### Methods

in\_  
Check if value is in a list.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L563)

``` python
def in_(self, values: list[Any]) -> Condition
```

`values` list\[Any\]  

not_in  
Check if value is not in a list.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L567)

``` python
def not_in(self, values: list[Any]) -> Condition
```

`values` list\[Any\]  

like  
SQL LIKE pattern matching (case-sensitive).

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L571)

``` python
def like(self, pattern: str) -> Condition
```

`pattern` str  

not_like  
SQL NOT LIKE pattern matching (case-sensitive).

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L575)

``` python
def not_like(self, pattern: str) -> Condition
```

`pattern` str  

ilike  
PostgreSQL ILIKE pattern matching (case-insensitive).

Note: For SQLite and DuckDB, this will use LIKE with LOWER() for
case-insensitivity.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L579)

``` python
def ilike(self, pattern: str) -> Condition
```

`pattern` str  

not_ilike  
PostgreSQL NOT ILIKE pattern matching (case-insensitive).

Note: For SQLite and DuckDB, this will use NOT LIKE with LOWER() for
case-insensitivity.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L586)

``` python
def not_ilike(self, pattern: str) -> Condition
```

`pattern` str  

is_null  
Check if value is NULL.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L593)

``` python
def is_null(self) -> Condition
```

is_not_null  
Check if value is not NULL.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L597)

``` python
def is_not_null(self) -> Condition
```

between  
Check if value is between two values.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L601)

``` python
def between(self, low: Any, high: Any) -> Condition
```

`low` Any  
Lower bound (inclusive). If None, raises ValueError.

`high` Any  
Upper bound (inclusive). If None, raises ValueError.

not_between  
Check if value is not between two values.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L615)

``` python
def not_between(self, low: Any, high: Any) -> Condition
```

`low` Any  
Lower bound (inclusive). If None, raises ValueError.

`high` Any  
Upper bound (inclusive). If None, raises ValueError.

### Condition

WHERE clause condition that can be combined with others.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L64)

``` python
class Condition
```

#### Methods

to_sql  
Generate SQL WHERE clause and parameters.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L116)

``` python
def to_sql(
    self,
    dialect: Union[
        SQLDialect, Literal["sqlite", "duckdb", "postgres"]
    ] = SQLDialect.SQLITE,
) -> tuple[str, list[Any]]
```

`dialect` Union\[SQLDialect, Literal\['sqlite', 'duckdb', 'postgres'\]\]  
Target SQL dialect (sqlite, duckdb, or postgres).

### Metadata

Entry point for building metadata filter expressions.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L630)

``` python
class Metadata
```

### metadata

Metadata selector for where expressions.

Typically aliased to a more compact expression (e.g. `m`) for use in
queries). For example:

``` python
from inspect_scout import metadata as m
filter = m.model == "gpt-4"
filter = (m.task_name == "math") & (m.epochs > 1)
```

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/metadata.py#L652)

``` python
metadata = Metadata()
```

### LogMetadata

Typed metadata interface for Inspect log transcripts.

Provides typed properties for standard Inspect log columns while
preserving the ability to access custom fields through the base Metadata
class methods.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/log.py#L10)

``` python
class LogMetadata(Metadata)
```

#### Attributes

`sample_id` [Column](transcript.qmd#column)  
Unique id for sample.

`eval_id` [Column](transcript.qmd#column)  
Globally unique id for eval.

`log` [Column](transcript.qmd#column)  
Location that the log file was read from.

`eval_created` [Column](transcript.qmd#column)  
Time eval was created.

`eval_tags` [Column](transcript.qmd#column)  
Tags associated with evaluation run.

`eval_metadata` [Column](transcript.qmd#column)  
Additional eval metadata.

`task_name` [Column](transcript.qmd#column)  
Task name.

`task_args` [Column](transcript.qmd#column)  
Task arguments.

`solver` [Column](transcript.qmd#column)  
Solver name.

`solver_args` [Column](transcript.qmd#column)  
Arguments used for invoking the solver.

`model` [Column](transcript.qmd#column)  
Model used for eval.

`generate_config` [Column](transcript.qmd#column)  
Generate config specified for model instance.

`model_roles` [Column](transcript.qmd#column)  
Model roles.

`id` [Column](transcript.qmd#column)  
Unique id for sample.

`epoch` [Column](transcript.qmd#column)  
Epoch number for sample.

`sample_metadata` [Column](transcript.qmd#column)  
Sample metadata.

`score` [Column](transcript.qmd#column)  
Headline score value.

`total_tokens` [Column](transcript.qmd#column)  
Total tokens used for sample.

`total_time` [Column](transcript.qmd#column)  
Total time that the sample was running.

`working_time` [Column](transcript.qmd#column)  
Time spent working (model generation, sandbox calls, etc.).

`error` [Column](transcript.qmd#column)  
Error that halted the sample.

`limit` [Column](transcript.qmd#column)  
Limit that halted the sample.

### log_metadata

Log metadata selector for where expressions.

Typically aliased to a more compact expression (e.g. `m`) for use in
queries). For example:

``` python
from inspect_scout import log_metadata as m

# typed access to standard fields
filter = m.model == "gpt-4"
filter = (m.task_name == "math") & (m.epochs > 1)

# dynamic access to custom fields
filter = m["custom_field"] > 100
```

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/log.py#L149)

``` python
log_metadata = LogMetadata()
```

# Scanner API


## Scanner

### Scanner

Scan transcript content.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/scanner.py#L67)

``` python
class Scanner(Protocol[T]):
    def __call__(self, input: T, /) -> Awaitable[Result]
```

`input` T  
Input to scan.

### ScannerInput

Union of all valid scanner input types.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/types.py#L11)

``` python
ScannerInput = Union[
    Transcript,
    ChatMessage,
    Sequence[ChatMessage],
    Event,
    Sequence[Event],
]
```

### Result

Scan result.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/result.py#L22)

``` python
class Result(BaseModel)
```

#### Attributes

`value` JsonValue  
Scan value (can be `None` if the scan didn’t find what is was looking
for).

`explanation` str \| None  
Explanation of result (optional).

`metadata` dict\[str, Any\] \| None  
Additional metadata related to the result (optional)

`references` list\[[Reference](scanner.qmd#reference)\]  
References to relevant messages or events.

### Reference

Reference to scanned content.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/result.py#L12)

``` python
class Reference(BaseModel)
```

#### Attributes

`type` Literal\['message', 'event'\]  
Reference type.

`id` str  
Reference id (message or event id)

### Error

Scan error (runtime error which occurred during scan).

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/result.py#L38)

``` python
class Error(BaseModel)
```

#### Attributes

`transcript_id` str  
Target transcript id.

`scanner` str  
Scanner name.

`error` str  
Error message.

`traceback` str  
Error traceback.

### Loader

Load transcript data.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/loader.py#L44)

``` python
class Loader(Protocol[TLoaderResult]):
    def __call__(
        self,
        transcript: Transcript,
    ) -> AsyncIterator[TLoaderResult]
```

`transcript` [Transcript](transcript.qmd#transcript)  
Transcript to yield from.

## Utils

### messages_as_str

Concatenate list of chat messages into a string.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/util.py#L15)

``` python
def messages_as_str(messages: list[ChatMessage]) -> str
```

`messages` list\[ChatMessage\]  
List of chat messages

## Types

### MessageType

Message types.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/types.py#L10)

``` python
MessageType = Literal["system", "user", "assistant", "tool"]
```

### EventType

Event types.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_transcript/types.py#L13)

``` python
EventType = Literal[
    "model",
    "tool",
    "approval",
    "sandbox",
    "info",
    "logger",
    "error",
    "span_begin",
    "span_end",
]
```

## Decorators

### scanner

Decorator for registering scanners.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/scanner.py#L179)

``` python
def scanner(
    factory: ScannerFactory[P, T] | None = None,
    *,
    loader: Loader[T] | None = None,
    messages: list[MessageType] | Literal["all"] | None = None,
    events: list[EventType] | Literal["all"] | None = None,
    name: str | None = None,
) -> (
    ScannerFactory[P, T]
    | Callable[[ScannerFactory[P, T]], ScannerFactory[P, T]]
    | Callable[[ScannerFactory[P, TM]], ScannerFactory[P, ScannerInput]]
    | Callable[[ScannerFactory[P, TE]], ScannerFactory[P, ScannerInput]]
)
```

`factory` ScannerFactory\[P, T\] \| None  
Decorated scanner function.

`loader` [Loader](scanner.qmd#loader)\[T\] \| None  
Custom data loader for scanner.

`messages` list\[[MessageType](scanner.qmd#messagetype)\] \| Literal\['all'\] \| None  
Message types to scan.

`events` list\[[EventType](scanner.qmd#eventtype)\] \| Literal\['all'\] \| None  
Event types to scan.

`name` str \| None  
Scanner name (defaults to function name).

### loader

Decorator for registering loaders.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanner/loader.py#L67)

``` python
def loader(
    *,
    name: str | None = None,
    messages: list[MessageType] | Literal["all"] | None = None,
    events: list[EventType] | Literal["all"] | None = None,
    content: TranscriptContent | None = None,
) -> Callable[[LoaderFactory[P, TLoaderResult]], LoaderFactory[P, TLoaderResult]]
```

`name` str \| None  
Loader name (defaults to function name).

`messages` list\[[MessageType](scanner.qmd#messagetype)\] \| Literal\['all'\] \| None  
Message types to load from.

`events` list\[[EventType](scanner.qmd#eventtype)\] \| Literal\['all'\] \| None  
Event types to load from.

`content` TranscriptContent \| None  
Transcript content filter.

# Async API


> [!NOTE]
>
> The Async API is available for async programs that want to use
> `inspect_scout` as an embedded library. Normal usage of Scout (e.g. in
> a script or notebook) should prefer the corresponding sync functions
> (e.g. `scan()`, `scan_resume().`, etc.)

### scan_async

Scan transcripts.

Scan transcripts using one or more scanners. Note that scanners must
each have a unique name. If you have more than one instance of a scanner
with the same name, numbered prefixes will be automatically assigned.
Alternatively, you can pass tuples of (name,scanner) or a dict with
explicit names for each scanner.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scan.py#L139)

``` python
async def scan_async(
    scanners: Sequence[Scanner[ScannerInput] | tuple[str, Scanner[ScannerInput]]]
    | dict[str, Scanner[ScannerInput]]
    | ScanJob
    | ScanJobConfig,
    transcripts: Transcripts | None = None,
    results: str | None = None,
    model: str | Model | None = None,
    model_config: GenerateConfig | None = None,
    model_base_url: str | None = None,
    model_args: dict[str, Any] | str | None = None,
    model_roles: dict[str, str | Model] | None = None,
    max_transcripts: int | None = None,
    max_processes: int | None = None,
    limit: int | None = None,
    shuffle: bool | int | None = None,
    tags: list[str] | None = None,
    metadata: dict[str, Any] | None = None,
    log_level: str | None = None,
) -> Status
```

`scanners` Sequence\[[Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\] \| tuple\[str, [Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\]\]\] \| dict\[str, [Scanner](scanner.qmd#scanner)\[[ScannerInput](scanner.qmd#scannerinput)\]\] \| [ScanJob](scanning.qmd#scanjob) \| [ScanJobConfig](scanning.qmd#scanjobconfig)  
Scanners to execute (list, dict with explicit names, or ScanJob). If a
`ScanJob` or `ScanJobConfig` is specified, then its options are used as
the default options for the scan.

`transcripts` [Transcripts](transcript.qmd#transcripts) \| None  
Transcripts to scan.

`results` str \| None  
Location to write results (filesystem or S3 bucket). Defaults to
“./scans”.

`model` str \| Model \| None  
Model to use for scanning by default (individual scanners can always
call `get_model()` to us arbitrary models). If not specified use the
value of the SCOUT_SCAN_MODEL environment variable.

`model_config` GenerateConfig \| None  
`GenerationConfig` for calls to the model.

`model_base_url` str \| None  
Base URL for communicating with the model API.

`model_args` dict\[str, Any\] \| str \| None  
Model creation args (as a dictionary or as a path to a JSON or YAML
config file).

`model_roles` dict\[str, str \| Model\] \| None  
Named roles for use in `get_model()`.

`max_transcripts` int \| None  
The maximum number of transcripts to process concurrently (this also
serves as the default value for `max_connections`). Defaults to 25.

`max_processes` int \| None  
The maximum number of concurrent processes (for multiproccesing).
Defaults to `multiprocessing.cpu_count()`.

`limit` int \| None  
Limit the number of transcripts processed.

`shuffle` bool \| int \| None  
Shuffle the order of transcripts (pass an `int` to set a seed for
shuffling).

`tags` list\[str\] \| None  
One or more tags for this scan.

`metadata` dict\[str, Any\] \| None  
Metadata for this scan.

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”)

### scan_resume_async

Resume a previous scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scan.py#L267)

``` python
async def scan_resume_async(scan_location: str, log_level: str | None = None) -> Status
```

`scan_location` str  
Scan location to resume from.

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”)

### scan_complete_async

Complete a scan.

This function is used to indicate that a scan with errors in some
transcripts should be completed in spite of the errors.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scan.py#L331)

``` python
async def scan_complete_async(
    scan_location: str, log_level: str | None = None
) -> Status
```

`scan_location` str  
Scan location to complete.

`log_level` str \| None  
Level for logging to the console: “debug”, “http”, “sandbox”, “info”,
“warning”, “error”, “critical”, or “notset” (defaults to “warning”)

### scan_list_async

List completed and pending scans.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanlist.py#L19)

``` python
async def scan_list_async(scans_location: str) -> list[Status]
```

`scans_location` str  
Location of scans to list.

### scan_status_async

Status of scan.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanresults.py#L23)

``` python
async def scan_status_async(scan_location: str) -> Status
```

`scan_location` str  
Location to get status for (e.g. directory or s3 bucket)

### scan_results_async

Scan results as Pandas data frames.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanresults.py#L49)

``` python
async def scan_results_async(
    scan_location: str, *, scanner: str | None = None
) -> Results
```

`scan_location` str  
Location of scan (e.g. directory or s3 bucket).

`scanner` str \| None  
Scanner name (defaults to all scanners).

### scan_results_db_async

Scan results as DuckDB database.

[Source](https://github.com/meridianlabs-ai/inspect_scout/blob/dcdd2ceb885291e7470291f91178635ecccccf0e/src/inspect_scout/_scanresults.py#L77)

``` python
async def scan_results_db_async(scan_location: str) -> ResultsDB
```

`scan_location` str  
Location of scan (e.g. directory or s3 bucket).

