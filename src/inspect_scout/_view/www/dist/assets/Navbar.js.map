{"version":3,"file":"Navbar.js","sources":["../../src/utils/uri.ts","../../src/app/components/EditableText.tsx","../../src/app/components/EditablePath.tsx","../../src/app/components/NavButtons.tsx","../../src/app/components/Navbar.tsx"],"sourcesContent":["export const directoryRelativeUrl = (file: string, dir?: string): string => {\n  if (!dir) {\n    return encodeURIComponent(file);\n  }\n\n  // Normalize paths to ensure consistent directory separators\n  const normalizedFile = file.replace(/\\\\/g, \"/\");\n  const normalizedLogDir = dir.replace(/\\\\/g, \"/\");\n\n  // Ensure log_dir ends with a trailing slash\n  const dirWithSlash = normalizedLogDir.endsWith(\"/\")\n    ? normalizedLogDir\n    : normalizedLogDir + \"/\";\n\n  // Check if file is within the log directory\n  if (normalizedFile.startsWith(dirWithSlash)) {\n    // Get the relative path\n    const relativePath = normalizedFile.substring(dirWithSlash.length);\n\n    // Split the path into segments and encode each segment\n    const segments = relativePath.split(\"/\");\n    const encodedSegments = segments.map((segment) =>\n      encodeURIComponent(segment)\n    );\n\n    // Join the encoded segments back together\n    return encodedSegments.join(\"/\");\n  }\n\n  // If path can't be made relative, return undefined\n  return encodeURIComponent(file);\n};\n\nexport const join = (file: string, dir?: string): string => {\n  if (!dir) {\n    return file;\n  }\n\n  // Normalize paths to ensure consistent directory separators\n  let normalizedFile = file.replace(/\\\\/g, \"/\");\n  if (normalizedFile.startsWith(\"./\")) {\n    normalizedFile = normalizedFile.slice(2);\n  }\n  const normalizedLogDir = dir.replace(/\\\\/g, \"/\");\n\n  // Ensure log_dir ends with a trailing slash\n  const dirWithSlash = normalizedLogDir.endsWith(\"/\")\n    ? normalizedLogDir\n    : normalizedLogDir + \"/\";\n\n  return dirWithSlash + normalizedFile;\n};\n\n/**\n * Encodes the path segments of a URL or relative path to ensure special characters\n * (like `+`, spaces, etc.) are properly encoded without affecting legal characters like `/`.\n *\n * This function will encode file names and path portions of both absolute URLs and\n * relative paths. It ensures that components of a full URL, such as the protocol and\n * query parameters, remain intact, while only encoding the path.\n */\nexport function encodePathParts(url: string): string {\n  if (!url) return url; // Handle empty strings\n\n  try {\n    // Parse a full Uri\n    const fullUrl = new URL(url);\n    fullUrl.pathname = fullUrl.pathname\n      .split(\"/\")\n      .map((segment) =>\n        segment ? encodeURIComponent(decodeURIComponent(segment)) : \"\"\n      )\n      .join(\"/\");\n    return fullUrl.toString();\n  } catch {\n    // This is a relative path that isn't parseable as Uri\n    return url\n      .split(\"/\")\n      .map((segment) =>\n        segment ? encodeURIComponent(decodeURIComponent(segment)) : \"\"\n      )\n      .join(\"/\");\n  }\n}\n\n/**\n * Tests whether a string is a valid URI.\n *\n * @param value - The string to test\n * @returns true if the string is a valid URI, false otherwise\n */\nexport const isUri = (value: string): boolean => {\n  if (!value) return false;\n\n  try {\n    new URL(value);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const prettyDirUri = (uri: string) => {\n  if (uri.startsWith(\"file://\")) {\n    return uri.replace(\"file://\", \"\");\n  } else {\n    return uri;\n  }\n};\n","import clsx from \"clsx\";\nimport { FC, useRef, useCallback, useState, useEffect, useMemo } from \"react\";\n\nimport { PopOver } from \"../../components/PopOver\";\n\nimport styles from \"./EditableText.module.css\";\n\ninterface EditableTextProps {\n  value?: string;\n  secondaryValue?: string | null;\n  onValueChanged: (value: string) => void;\n\n  mru?: string[];\n  mruMaxItems?: number;\n\n  label?: string;\n  title?: string;\n\n  icon?: string;\n  placeholder?: string;\n\n  editable?: boolean;\n\n  className?: string;\n}\n\nexport const EditableText: FC<EditableTextProps> = ({\n  value,\n  secondaryValue,\n  onValueChanged,\n  mru,\n  mruMaxItems = 10,\n  icon,\n  label,\n  title,\n  placeholder,\n  editable = true,\n  className,\n}) => {\n  const spanRef = useRef<HTMLSpanElement>(null);\n  const initialValueRef = useRef<string>(\"\");\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // MRU popover state: This isn't in the store because the values are transient (if the state is\n  // restored, it is assumed that the popover should be closed / state discarded)\n  const [showMruPopover, setShowMruPopover] = useState(false);\n  const [selectedMruIndex, setSelectedMruIndex] = useState<number>(-1);\n  const [currentText, setCurrentText] = useState<string>(\"\");\n  const [isEditing, setIsEditing] = useState(false);\n  const [isFocused, setIsFocused] = useState(false);\n\n  // Filter MRU list based on current text\n  const filteredMru = useMemo(() => {\n    if (!mru || mru.length === 0) return [];\n\n    // If not editing yet (just focused) or current text equals the initial value,\n    // show first mruMaxItems items\n    // eslint-disable-next-line react-hooks/refs -- initialValueRef stores a snapshot set in handleFocus; safe to read as it doesn't need to trigger re-renders\n    if (!isEditing || currentText === initialValueRef.current) {\n      return mru.slice(0, mruMaxItems);\n    }\n\n    // Otherwise, filter and limit to mruMaxItems\n    const filtered = mru\n      .filter((item) =>\n        item.toLowerCase().startsWith(currentText.toLowerCase())\n      )\n      .slice(0, mruMaxItems);\n\n    // If no matches, still show all items so the popover doesn't disappear\n    return filtered.length > 0 ? filtered : mru.slice(0, mruMaxItems);\n  }, [mru, mruMaxItems, currentText, isEditing]);\n\n  // Update showMruPopover based on whether we have filtered items and focus state\n  useEffect(() => {\n    setShowMruPopover(filteredMru.length > 0 && isFocused);\n  }, [filteredMru, isFocused]);\n\n  const handleFocus = () => {\n    // Store the initial value when focusing\n    if (spanRef.current) {\n      initialValueRef.current = spanRef.current.textContent || \"\";\n      setCurrentText(initialValueRef.current);\n      setSelectedMruIndex(-1);\n      setIsEditing(false); // Reset editing state on focus\n      setIsFocused(true); // Mark as focused\n\n      // Select all text on focus\n      const range = document.createRange();\n      range.selectNodeContents(spanRef.current);\n      const selection = window.getSelection();\n      selection?.removeAllRanges();\n      selection?.addRange(range);\n    }\n  };\n\n  const commitChanges = useCallback(() => {\n    if (spanRef.current) {\n      const newValue = spanRef.current.textContent?.trim() || \"\";\n      if (newValue !== \"\" && newValue !== initialValueRef.current) {\n        onValueChanged(newValue);\n      } else if (newValue === \"\") {\n        // Restore the original value if empty\n        spanRef.current.textContent = initialValueRef.current;\n      }\n    }\n    setShowMruPopover(false);\n    setSelectedMruIndex(-1);\n    setIsEditing(false);\n  }, [onValueChanged]);\n\n  const selectMruItem = useCallback(\n    (item: string | undefined) => {\n      if (spanRef.current && item) {\n        spanRef.current.textContent = item;\n        setCurrentText(item);\n        setShowMruPopover(false);\n        setSelectedMruIndex(-1);\n        setIsEditing(false);\n        spanRef.current.blur();\n        if (item !== initialValueRef.current) {\n          onValueChanged(item);\n        }\n      }\n    },\n    [onValueChanged]\n  );\n\n  const handleBlur = () => {\n    // Delay both focus state and commit changes to allow click on MRU item to register\n    setTimeout(() => {\n      setIsFocused(false); // Mark as not focused\n      commitChanges();\n    }, 150);\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLSpanElement>) => {\n    // Handle MRU navigation when popover is open\n    if (showMruPopover && filteredMru.length > 0) {\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedMruIndex((prev) =>\n          prev < filteredMru.length - 1 ? prev + 1 : prev\n        );\n        return;\n      } else if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedMruIndex((prev) => (prev > 0 ? prev - 1 : -1));\n        return;\n      } else if (e.key === \"Enter\") {\n        e.preventDefault();\n        if (selectedMruIndex >= 0 && selectedMruIndex < filteredMru.length) {\n          selectMruItem(filteredMru[selectedMruIndex]);\n        } else {\n          spanRef.current?.blur();\n        }\n        return;\n      } else if (e.key === \"Escape\") {\n        e.preventDefault();\n        setShowMruPopover(false);\n        setSelectedMruIndex(-1);\n        // Restore original value on escape\n        if (spanRef.current) {\n          spanRef.current.textContent = initialValueRef.current;\n          setCurrentText(initialValueRef.current);\n        }\n        spanRef.current?.blur();\n        return;\n      }\n    } else {\n      // Default behavior when popover is not open\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        spanRef.current?.blur();\n      } else if (e.key === \"Escape\") {\n        e.preventDefault();\n        // Restore original value on escape\n        if (spanRef.current) {\n          spanRef.current.textContent = initialValueRef.current;\n          setCurrentText(initialValueRef.current);\n        }\n        spanRef.current?.blur();\n      }\n    }\n  };\n\n  const handleInput = () => {\n    // Update current text for filtering\n    if (spanRef.current) {\n      const text = spanRef.current.textContent || \"\";\n      setCurrentText(text);\n      setSelectedMruIndex(-1); // Reset selection when user types\n      setIsEditing(true); // Mark as editing when user types\n    }\n\n    // Prevent empty content from collapsing the span\n    if (spanRef.current && spanRef.current.textContent === \"\") {\n      spanRef.current.textContent = \"\";\n    }\n  };\n\n  const displayValue = value || placeholder || \"\";\n\n  return (\n    <>\n      <div ref={containerRef} className={clsx(styles.container, className)}>\n        <div className={clsx(styles.labelContainer)} title={title}>\n          {icon && <i className={`${icon} ${styles.icon}`} />}\n          {label && <span className={styles.label}>{label}</span>}\n        </div>\n        <span\n          ref={spanRef}\n          contentEditable={editable}\n          className={clsx(\n            styles.text,\n            !value ? styles.placeholder : \"\",\n            !editable ? styles.readOnly : \"\"\n          )}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n          onKeyDown={handleKeyDown}\n          onInput={handleInput}\n          suppressContentEditableWarning\n        >\n          {displayValue}\n        </span>\n        {secondaryValue && (\n          <span\n            className={clsx(\n              styles.text,\n              styles.placeholder,\n              styles.secondary,\n              !editable ? styles.readOnly : \"\"\n            )}\n          >\n            {secondaryValue}\n          </span>\n        )}\n      </div>\n\n      {mru && mru.length > 0 && (\n        <PopOver\n          id=\"editable-text-mru-popover\"\n          isOpen={showMruPopover}\n          setIsOpen={setShowMruPopover}\n          // eslint-disable-next-line react-hooks/refs -- positionEl accepts null; PopOver/Popper handles this in effects and updates when ref is populated\n          positionEl={spanRef.current}\n          placement=\"bottom-start\"\n          hoverDelay={0}\n          showArrow={false}\n          offset={[0, 4]}\n          className={clsx(styles.mruPopover, \"text-size-smallest\")}\n        >\n          <div className={styles.mruList}>\n            {filteredMru.map((item, index) => (\n              <div\n                key={index}\n                className={clsx(\n                  styles.mruItem,\n                  index === selectedMruIndex && styles.mruItemSelected\n                )}\n                onClick={() => selectMruItem(item)}\n                onMouseEnter={() => setSelectedMruIndex(index)}\n              >\n                {item}\n              </div>\n            ))}\n          </div>\n        </PopOver>\n      )}\n    </>\n  );\n};\n","import { FC } from \"react\";\n\nimport { isUri, prettyDirUri } from \"../../utils/uri\";\n\nimport { EditableText } from \"./EditableText\";\n\ninterface EditablePathProps {\n  path?: string | null;\n  secondaryText?: string | null;\n  onPathChanged: (path: string) => void;\n\n  mru?: string[];\n\n  label?: string;\n  title?: string;\n\n  icon?: string;\n  placeholder?: string;\n\n  editable?: boolean;\n\n  className?: string;\n}\n\nexport const EditablePath: FC<EditablePathProps> = ({\n  path,\n  secondaryText,\n  onPathChanged,\n  mru,\n  label,\n  title,\n  icon,\n  placeholder,\n  editable = true,\n  className,\n}) => {\n  // Format a local path without the file:// prefix\n  const displayPath = prettyDirUri(path || \"\");\n\n  const onValueChanged = (newDisplayPath: string) => {\n    if (isUri(newDisplayPath)) {\n      onPathChanged(newDisplayPath);\n    } else {\n      const newUri = `file://${newDisplayPath}`;\n      onPathChanged(newUri);\n    }\n  };\n\n  return (\n    <EditableText\n      value={displayPath}\n      secondaryValue={secondaryText}\n      onValueChanged={onValueChanged}\n      mru={mru}\n      label={label}\n      title={title}\n      icon={icon}\n      placeholder={placeholder}\n      className={className}\n      editable={editable}\n    />\n  );\n};\n","import clsx from \"clsx\";\nimport { FC } from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport styles from \"./NavButtons.module.css\";\n\nexport interface NavButton {\n  // The title of the navigation button\n  title: string;\n\n  // The icon class for the navigation button\n  icon: string;\n\n  // The route URL for the navigation button\n  route: string;\n\n  // Whether the button is enabled or disabled (optional)\n  enabled?: boolean;\n}\n\ninterface NavButtonsProps {\n  buttons: NavButton[];\n}\n\nexport const NavButtons: FC<NavButtonsProps> = ({ buttons }) => {\n  return (\n    <>\n      {buttons.map((button, index) =>\n        button.enabled !== false ? (\n          <Link\n            key={index}\n            to={button.route}\n            className={clsx(styles.toolbarButton)}\n            title={button.title}\n            aria-label={button.title}\n          >\n            <i className={clsx(button.icon)} />\n          </Link>\n        ) : (\n          <span\n            key={index}\n            className={clsx(styles.toolbarButton, styles.disabled)}\n          >\n            <i className={clsx(button.icon)} />\n          </span>\n        )\n      )}\n    </>\n  );\n};\n","import clsx from \"clsx\";\nimport { FC, ReactNode } from \"react\";\n\nimport styles from \"./Navbar.module.css\";\nimport { NavButton, NavButtons } from \"./NavButtons\";\n\ninterface NavbarProps {\n  leftButtons?: NavButton[];\n  left?: ReactNode;\n  right?: ReactNode;\n  rightButtons?: NavButton[];\n  bordered?: boolean;\n}\n\nexport const Navbar: FC<NavbarProps> = ({\n  bordered = true,\n  left,\n  right,\n  leftButtons,\n  rightButtons,\n}) => {\n  return (\n    <nav\n      className={clsx(\n        \"text-size-smaller\",\n        \"header-nav\",\n        styles.header,\n        bordered ? styles.bordered : undefined\n      )}\n      aria-label=\"breadcrumb\"\n      data-unsearchable={true}\n    >\n      <div className={clsx(leftButtons ? styles.leftButtons : undefined)}>\n        {leftButtons && <NavButtons buttons={leftButtons} />}\n      </div>\n      <div className={clsx(leftButtons ? styles.left : undefined)}>{left}</div>\n      <div\n        className={clsx(styles.right, right ? styles.hasChildren : undefined)}\n      >\n        {right}\n      </div>\n      <div className={clsx(rightButtons ? styles.rightButtons : undefined)}>\n        {rightButtons && <NavButtons buttons={rightButtons} />}\n      </div>\n    </nav>\n  );\n};\n"],"names":["icon","placeholder","useRef","useState","useMemo","useEffect","useCallback","text","jsxs","Fragment","styles","jsx","bordered","left","leftButtons","rightButtons"],"mappings":"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"}