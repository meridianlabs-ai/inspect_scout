{"version":3,"file":"ScansPanel.js","sources":["../../src/app/hooks/useScanFilterConditions.ts","../../src/app/server/useScansColumnValues.ts","../../src/app/hooks/useScansFilterBarProps.ts","../../src/app/server/useScansInfinite.ts","../../src/app/scans/constants.ts","../../src/app/scans/columns.tsx","../../src/app/scans/ScansFilterBar.tsx","../../src/app/scans/columnSizing/useColumnSizing.ts","../../src/app/scans/ScansGrid.tsx","../../src/app/scans/ScansPanel.tsx"],"sourcesContent":["import { Condition } from \"../../query\";\nimport { SimpleCondition } from \"../../query/types\";\nimport { useStore } from \"../../state/store\";\n\n/**\n * Build a combined filter condition from scans column filters.\n * @param excludeColumnId - Optional column ID to exclude from the condition\n */\nexport const useScanFilterConditions = (excludeColumnId?: string) => {\n  // The applied filters\n  const columnFilters =\n    useStore((state) => state.scansTableState.columnFilters) ?? {};\n\n  // Get conditions, optionally excluding a specific column\n  const filterConditions = Object.values(columnFilters)\n    .filter((filter) => !excludeColumnId || filter.columnId !== excludeColumnId)\n    .map((filter) => filter.condition)\n    .filter((condition): condition is SimpleCondition => Boolean(condition));\n\n  // Reduce to a single condition using 'and'\n  const condition = filterConditions.reduce<Condition | undefined>(\n    (acc, condition) => (acc ? acc.and(condition) : condition),\n    undefined\n  );\n  return condition;\n};\n","import { skipToken } from \"@tanstack/react-query\";\n\nimport { ScalarValue } from \"../../api/api\";\nimport { Condition } from \"../../query\";\nimport { useApi } from \"../../state/store\";\nimport { AsyncData } from \"../../utils/asyncData\";\nimport { useAsyncDataFromQuery } from \"../../utils/asyncDataFromQuery\";\n\ntype ScansColumnValuesParams = {\n  location: string;\n  column: string;\n  filter: Condition | undefined;\n};\n\nexport const useScansColumnValues = (\n  params: ScansColumnValuesParams | typeof skipToken\n): AsyncData<ScalarValue[]> => {\n  const api = useApi();\n\n  return useAsyncDataFromQuery({\n    queryKey:\n      params === skipToken\n        ? [skipToken]\n        : [\"scansColumnValues\", params, \"scans-inv\"],\n    queryFn:\n      params === skipToken\n        ? skipToken\n        : () =>\n            api.getScansColumnValues(\n              params.location,\n              params.column,\n              params.filter\n            ),\n    staleTime: 10 * 60 * 1000, // We can be pretty liberal here\n  });\n};\n","import { skipToken } from \"@tanstack/react-query\";\nimport { useCallback, useState } from \"react\";\n\nimport { ScalarValue } from \"../../api/api\";\nimport { useScansColumnValues } from \"../server/useScansColumnValues\";\n\nimport { useScanFilterConditions } from \"./useScanFilterConditions\";\n\ninterface ScansFilterBarProps {\n  /** Autocomplete suggestions for the currently edited column. */\n  filterSuggestions: ScalarValue[];\n  /** Callback when filter column selection changes. */\n  onFilterColumnChange: (columnId: string | null) => void;\n}\n\n/**\n * Hook providing autocomplete props needed for ScansFilterBar.\n * Manages filter editing state and fetches autocomplete suggestions.\n */\nexport const useScansFilterBarProps = (\n  scansDir: string | undefined\n): ScansFilterBarProps => {\n  const [editingColumnId, setEditingColumnId] = useState<string | null>(null);\n\n  // Get filter condition excluding the currently editing column\n  const otherColumnsFilter = useScanFilterConditions(\n    editingColumnId ?? undefined\n  );\n\n  // Fetch autocomplete suggestions for editing column\n  const { data: filterSuggestions } = useScansColumnValues(\n    editingColumnId && scansDir\n      ? {\n          location: scansDir,\n          column: editingColumnId,\n          filter: otherColumnsFilter,\n        }\n      : skipToken\n  );\n\n  const onFilterColumnChange = useCallback(\n    (columnId: string | null) => setEditingColumnId(columnId),\n    []\n  );\n\n  return {\n    filterSuggestions: filterSuggestions ?? [],\n    onFilterColumnChange,\n  };\n};\n","import {\n  UseInfiniteQueryResult,\n  InfiniteData,\n  useInfiniteQuery,\n  QueryKey,\n  keepPreviousData,\n} from \"@tanstack/react-query\";\nimport { SortingState } from \"@tanstack/react-table\";\nimport { useMemo } from \"react\";\n\nimport { Condition } from \"../../query\";\nimport { useApi } from \"../../state/store\";\nimport { ScansResponse } from \"../../types/api-types\";\n\nimport { CursorType, sortingStateToOrderBy } from \".\";\n\nexport const useScansInfinite = (\n  scansDir: string,\n  pageSize: number = 50,\n  filter?: Condition,\n  sorting?: SortingState\n): UseInfiniteQueryResult<\n  InfiniteData<ScansResponse, CursorType | undefined>,\n  Error\n> => {\n  const api = useApi();\n\n  const orderBy = useMemo(\n    () => (sorting ? sortingStateToOrderBy(sorting) : undefined),\n    [sorting]\n  );\n\n  return useInfiniteQuery<\n    ScansResponse,\n    Error,\n    InfiniteData<ScansResponse, CursorType | undefined>,\n    QueryKey,\n    CursorType | undefined\n  >({\n    queryKey: [\n      \"scans-infinite\",\n      scansDir,\n      filter,\n      orderBy,\n      pageSize,\n      \"scans-inv\",\n    ],\n    queryFn: async ({ pageParam }) => {\n      const pagination = pageParam\n        ? { limit: pageSize, cursor: pageParam, direction: \"forward\" as const }\n        : { limit: pageSize, cursor: null, direction: \"forward\" as const };\n\n      return await api.getScans(scansDir, filter, orderBy, pagination);\n    },\n    initialPageParam: undefined,\n    getNextPageParam: (lastPage) => lastPage.next_cursor ?? undefined,\n    staleTime: 10000,\n    refetchInterval: 10000,\n    placeholderData: keepPreviousData,\n  });\n};\n","/**\n * Infinite Scroll Tuning\n *\n * Goal: user never hits bottom while waiting for next page.\n *\n * Formula: threshold >= scroll_speed × fetch_duration\n *\n * Assumptions:\n *   row_height = 29px\n *   fetch_duration = 300-1000ms (variable with fixed overhead)\n *   max_scroll_speed = 1500px/s (typical fast scroller)\n *\n * Check at typical speed (1500px/s):\n *   runway_time = 2000px / 1500px/s = 1333ms\n *   worst_case_fetch = 1000ms\n *   margin = 333ms ✓\n *\n * Check at extreme speed (5000px/s):\n *   runway_time = 2000px / 5000px/s = 400ms\n *   median_fetch = ~350ms\n *   margin = 50ms (tight but ok) ✓\n *\n * Why large pageSize? Fetch duration is mostly fixed overhead, so larger\n * pages = fewer fetches = fewer stall opportunities. 500 rows gives ~9.7s\n * of scrolling per page at 1500px/s.\n *\n * Note: If threshold > pageSize_px, the next page is prefetched immediately\n * after the current page loads. This is fine for maximum smoothness.\n */\nexport const SCANS_INFINITE_SCROLL_CONFIG = {\n  /** Number of rows to fetch per page (500 rows = 14,500px at 29px/row) */\n  pageSize: 500,\n  /** Distance from bottom (in px) at which to trigger fetch (~69 rows) */\n  threshold: 2000,\n} as const;\n","import clsx from \"clsx\";\n\nimport { ApplicationIcons } from \"../../components/icons\";\nimport type { ScanRow as ApiScanRow } from \"../../types/api-types\";\nimport { formatNumber } from \"../../utils/format\";\nimport { printObject } from \"../../utils/object\";\nimport type { AvailableColumn } from \"../components/columnFilter\";\nimport { ExtendedColumnDef, BaseColumnMeta } from \"../components/columnTypes\";\n\nimport styles from \"./columns.module.css\";\n\n/**\n * Scan row type for grid display.\n * Extends the API ScanRow with a client-computed relativeLocation.\n */\nexport type ScanRow = ApiScanRow & {\n  /** Relative path from results directory (computed client-side) */\n  relativeLocation: string;\n};\n\n// Define the keys that correspond to our scan columns\n// These match the database column names for filtering to work\nexport type ScanColumnKey =\n  // Original columns\n  | \"status\" // Status column\n  | \"scan_name\" // Name column\n  | \"scanners\"\n  | \"scan_id\"\n  | \"model\"\n  | \"location\" // Path column\n  | \"timestamp\" // Time column\n  // New columns from spec\n  | \"scan_file\"\n  | \"tags\"\n  | \"revision_version\"\n  | \"revision_commit\"\n  | \"revision_origin\"\n  | \"packages\"\n  | \"metadata\"\n  | \"scan_args\"\n  | \"transcript_count\"\n  // Aggregated summary columns\n  | \"total_results\"\n  | \"total_errors\"\n  | \"total_tokens\";\n\n// Column type for scan grid\nexport type ScanColumn = ExtendedColumnDef<ScanRow, BaseColumnMeta>;\n\n// Column headers for display (used in column picker and add filter dropdown)\nexport const COLUMN_LABELS: Record<ScanColumnKey, string> = {\n  // Original columns\n  status: \"Status\",\n  scan_name: \"Name\",\n  scanners: \"Scanners\",\n  scan_id: \"Scan ID\",\n  model: \"Model\",\n  location: \"Path\",\n  timestamp: \"Time\",\n  // New columns from spec\n  scan_file: \"Scan File\",\n  tags: \"Tags\",\n  revision_version: \"Version\",\n  revision_commit: \"Commit\",\n  revision_origin: \"Origin\",\n  packages: \"Packages\",\n  metadata: \"Metadata\",\n  scan_args: \"Scan Args\",\n  transcript_count: \"Transcripts\",\n  // Aggregated summary columns\n  total_results: \"Total Results\",\n  total_errors: \"Scanner Errors\",\n  total_tokens: \"Total Tokens\",\n};\n\n// Column header tooltips\nexport const COLUMN_HEADER_TITLES: Record<ScanColumnKey, string> = {\n  // Original columns\n  status: \"Scan completion status (complete, in progress, or error)\",\n  scan_name: \"Name of the scan configuration\",\n  scanners: \"List of scanners used in this scan\",\n  scan_id: \"Unique identifier for the scan\",\n  model: \"Model used for scanning\",\n  location: \"Path to the scan results\",\n  timestamp: \"Timestamp when the scan was started\",\n  // New columns from spec\n  scan_file: \"Source file path for the scan job\",\n  tags: \"Tags associated with this scan\",\n  revision_version: \"Git version of the scan code\",\n  revision_commit: \"Git commit hash of the scan code\",\n  revision_origin: \"Git origin URL of the scan code\",\n  packages: \"Package versions used in this scan\",\n  metadata: \"Custom metadata for this scan\",\n  scan_args: \"Arguments passed to the scan\",\n  // Aggregated summary columns\n  total_results: \"Total number of results across all scanners\",\n  total_errors: \"Errors reported by scanners while processing transcripts\",\n  total_tokens: \"Total tokens used across all scanners\",\n  transcript_count: \"Number of transcripts processed in this scan\",\n};\n\n// Helper to get status display (icon and color) for a scan\nfunction getStatusDisplay(scan: ScanRow): {\n  icon: string;\n  colorClass: string | undefined;\n} {\n  switch (scan.status) {\n    case \"complete\":\n      return { icon: ApplicationIcons.success, colorClass: styles.green };\n    case \"error\":\n      return { icon: ApplicationIcons.error, colorClass: styles.red };\n    case \"active\":\n    case \"incomplete\":\n    default:\n      return { icon: ApplicationIcons.pendingTask, colorClass: styles.yellow };\n  }\n}\n\n// Helper to format object values for display\nfunction formatObjectValue(\n  value: Record<string, unknown> | null | undefined,\n  maxLength: number = 1000\n): string {\n  if (!value || Object.keys(value).length === 0) {\n    return \"-\";\n  }\n  try {\n    return printObject(value, maxLength);\n  } catch {\n    return \"-\";\n  }\n}\n\n// Helper to get full JSON for tooltip\nfunction getObjectTitleValue(\n  value: Record<string, unknown> | null | undefined\n): string {\n  if (!value || Object.keys(value).length === 0) {\n    return \"\";\n  }\n  return JSON.stringify(value, null, 2);\n}\n\n// All available columns, keyed by their ID (using database column names)\nexport const ALL_COLUMNS: Record<ScanColumnKey, ScanColumn> = {\n  // ============================================\n  // Original columns\n  // ============================================\n  status: {\n    id: \"status\",\n    accessorKey: \"status\",\n    header: \"✓\",\n    headerTitle: COLUMN_HEADER_TITLES.status,\n    size: 70,\n    minSize: 70,\n    maxSize: 70,\n    meta: {\n      align: \"center\",\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const scan = info.row.original;\n\n      if (scan.active_completion_pct != null) {\n        return (\n          <span className={styles.blue}>\n            <i className={ApplicationIcons[\"play-circle\"]}></i>{\" \"}\n            {scan.active_completion_pct}%\n          </span>\n        );\n      }\n\n      const { icon, colorClass } = getStatusDisplay(scan);\n      return <i className={clsx(icon, colorClass)}></i>;\n    },\n    textValue: () => null,\n  },\n  scan_name: {\n    id: \"scan_name\",\n    accessorKey: \"scan_name\",\n    header: \"Name\",\n    headerTitle: COLUMN_HEADER_TITLES.scan_name,\n    size: 120,\n    minSize: 80,\n    maxSize: 300,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n  },\n  transcript_count: {\n    id: \"transcript_count\",\n    accessorKey: \"transcript_count\",\n    header: \"Transcripts\",\n    headerTitle: COLUMN_HEADER_TITLES.transcript_count,\n    size: 100,\n    minSize: 60,\n    maxSize: 200,\n    meta: {\n      filterable: true,\n      filterType: \"number\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as number;\n      return formatNumber(value);\n    },\n    textValue: (value) => {\n      return formatNumber(value as number);\n    },\n  },\n  scanners: {\n    id: \"scanners\",\n    accessorKey: \"scanners\",\n    header: \"Scanners\",\n    headerTitle: COLUMN_HEADER_TITLES.scanners,\n    size: 120,\n    minSize: 80,\n    maxSize: 400,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n  },\n  scan_id: {\n    id: \"scan_id\",\n    accessorKey: \"scan_id\",\n    header: \"Scan ID\",\n    headerTitle: COLUMN_HEADER_TITLES.scan_id,\n    size: 150,\n    minSize: 100,\n    maxSize: 400,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n  },\n  model: {\n    id: \"model\",\n    accessorKey: \"model\",\n    header: \"Model\",\n    headerTitle: COLUMN_HEADER_TITLES.model,\n    size: 150,\n    minSize: 80,\n    maxSize: 400,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n  },\n  location: {\n    id: \"location\",\n    accessorKey: \"relativeLocation\",\n    header: \"Path\",\n    headerTitle: COLUMN_HEADER_TITLES.location,\n    size: 200,\n    minSize: 100,\n    maxSize: 500,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n  },\n  timestamp: {\n    id: \"timestamp\",\n    accessorKey: \"timestamp\",\n    header: \"Time\",\n    headerTitle: COLUMN_HEADER_TITLES.timestamp,\n    size: 180,\n    minSize: 120,\n    maxSize: 300,\n    meta: {\n      filterable: true,\n      filterType: \"datetime\",\n    },\n    cell: (info) => {\n      const timestamp = info.getValue() as string;\n      if (!timestamp) return \"-\";\n      return new Date(timestamp).toLocaleString();\n    },\n    textValue: (value) => {\n      if (!value) return \"-\";\n      return new Date(value as string).toLocaleString();\n    },\n  },\n\n  // ============================================\n  // New columns from spec\n  // ============================================\n  scan_file: {\n    id: \"scan_file\",\n    accessorKey: \"scan_file\",\n    header: \"Scan File\",\n    headerTitle: COLUMN_HEADER_TITLES.scan_file,\n    size: 200,\n    minSize: 100,\n    maxSize: 500,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as string | null;\n      return value || \"-\";\n    },\n  },\n  tags: {\n    id: \"tags\",\n    accessorKey: \"tags\",\n    header: \"Tags\",\n    headerTitle: COLUMN_HEADER_TITLES.tags,\n    size: 150,\n    minSize: 80,\n    maxSize: 400,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as string;\n      return value || \"-\";\n    },\n  },\n  revision_version: {\n    id: \"revision_version\",\n    accessorKey: \"revision_version\",\n    header: \"Version\",\n    headerTitle: COLUMN_HEADER_TITLES.revision_version,\n    size: 150,\n    minSize: 80,\n    maxSize: 300,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as string | null;\n      return value || \"-\";\n    },\n  },\n  revision_commit: {\n    id: \"revision_commit\",\n    accessorKey: \"revision_commit\",\n    header: \"Commit\",\n    headerTitle: COLUMN_HEADER_TITLES.revision_commit,\n    size: 120,\n    minSize: 80,\n    maxSize: 300,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as string | null;\n      if (!value) return \"-\";\n      // Show first 7 characters of commit hash (standard git short hash)\n      return value.slice(0, 7);\n    },\n    textValue: (value) => {\n      if (!value) return \"-\";\n      const strValue = value as string;\n      return strValue.slice(0, 7);\n    },\n  },\n  revision_origin: {\n    id: \"revision_origin\",\n    accessorKey: \"revision_origin\",\n    header: \"Origin\",\n    headerTitle: COLUMN_HEADER_TITLES.revision_origin,\n    size: 200,\n    minSize: 100,\n    maxSize: 500,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as string | null;\n      return value || \"-\";\n    },\n  },\n  packages: {\n    id: \"packages\",\n    accessorKey: \"packages\",\n    header: \"Packages\",\n    headerTitle: COLUMN_HEADER_TITLES.packages,\n    size: 200,\n    minSize: 80,\n    maxSize: 500,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as Record<string, string> | undefined;\n      return formatObjectValue(value);\n    },\n    textValue: (value) => {\n      return formatObjectValue(value as Record<string, string> | undefined);\n    },\n    titleValue: (value) => {\n      return getObjectTitleValue(value as Record<string, string> | undefined);\n    },\n  },\n  metadata: {\n    id: \"metadata\",\n    accessorKey: \"metadata\",\n    header: \"Metadata\",\n    headerTitle: COLUMN_HEADER_TITLES.metadata,\n    size: 200,\n    minSize: 80,\n    maxSize: 500,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as Record<string, unknown> | undefined;\n      return formatObjectValue(value);\n    },\n    textValue: (value) => {\n      return formatObjectValue(value as Record<string, unknown> | undefined);\n    },\n    titleValue: (value) => {\n      return getObjectTitleValue(value as Record<string, unknown> | undefined);\n    },\n  },\n  scan_args: {\n    id: \"scan_args\",\n    accessorKey: \"scan_args\",\n    header: \"Scan Args\",\n    headerTitle: COLUMN_HEADER_TITLES.scan_args,\n    size: 200,\n    minSize: 80,\n    maxSize: 500,\n    meta: {\n      filterable: true,\n      filterType: \"string\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as Record<string, unknown> | undefined;\n      return formatObjectValue(value);\n    },\n    textValue: (value) => {\n      return formatObjectValue(value as Record<string, unknown> | undefined);\n    },\n    titleValue: (value) => {\n      return getObjectTitleValue(value as Record<string, unknown> | undefined);\n    },\n  },\n\n  // ============================================\n  // Aggregated summary columns\n  // ============================================\n  total_results: {\n    id: \"total_results\",\n    accessorKey: \"total_results\",\n    header: \"Results\",\n    headerTitle: COLUMN_HEADER_TITLES.total_results,\n    size: 100,\n    minSize: 60,\n    maxSize: 200,\n    meta: {\n      filterable: true,\n      filterType: \"number\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as number;\n      return formatNumber(value);\n    },\n    textValue: (value) => {\n      return formatNumber(value as number);\n    },\n  },\n  total_errors: {\n    id: \"total_errors\",\n    accessorKey: \"total_errors\",\n    header: \"Scanner Errors\",\n    headerTitle: COLUMN_HEADER_TITLES.total_errors,\n    size: 100,\n    minSize: 60,\n    maxSize: 200,\n    meta: {\n      filterable: true,\n      filterType: \"number\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as number;\n      return formatNumber(value);\n    },\n    textValue: (value) => {\n      return formatNumber(value as number);\n    },\n  },\n  total_tokens: {\n    id: \"total_tokens\",\n    accessorKey: \"total_tokens\",\n    header: \"Tokens\",\n    headerTitle: COLUMN_HEADER_TITLES.total_tokens,\n    size: 120,\n    minSize: 60,\n    maxSize: 200,\n    meta: {\n      filterable: true,\n      filterType: \"number\",\n    },\n    cell: (info) => {\n      const value = info.getValue() as number;\n      return formatNumber(value);\n    },\n    textValue: (value) => {\n      return formatNumber(value as number);\n    },\n  },\n};\n\n// Default column order - includes all columns\nexport const DEFAULT_COLUMN_ORDER: ScanColumnKey[] = [\n  // Original columns first\n  \"status\",\n  \"scan_name\",\n  \"scanners\",\n  \"scan_id\",\n  \"model\",\n  \"location\",\n  \"timestamp\",\n  // Aggregated summary columns\n  \"transcript_count\",\n  \"total_results\",\n  \"total_errors\",\n  \"total_tokens\",\n  // New columns from spec\n  \"scan_file\",\n  \"tags\",\n  \"revision_version\",\n  \"revision_commit\",\n  \"revision_origin\",\n  \"packages\",\n  \"metadata\",\n  \"scan_args\",\n];\n\n// Default visible columns - the original 7 plus total_results\nexport const DEFAULT_VISIBLE_COLUMNS: ScanColumnKey[] = [\n  \"status\",\n  \"scan_name\",\n  \"scanners\",\n  \"scan_id\",\n  \"model\",\n  \"location\",\n  \"timestamp\",\n  \"transcript_count\",\n  \"total_results\",\n];\n\n/**\n * Get columns for the ScansGrid.\n * @param visibleColumnKeys - Optional list of column keys to display. If not provided, returns default visible columns.\n * @returns Array of column definitions in the order specified or default visible columns.\n */\nexport function getScanColumns(\n  visibleColumnKeys?: ScanColumnKey[]\n): ScanColumn[] {\n  if (!visibleColumnKeys) {\n    return DEFAULT_VISIBLE_COLUMNS.map((key) => ALL_COLUMNS[key]);\n  }\n\n  return visibleColumnKeys.map((key) => ALL_COLUMNS[key]);\n}\n\n// Columns available for filtering (used by Add Filter popover)\nexport const FILTER_COLUMNS: AvailableColumn[] = DEFAULT_COLUMN_ORDER.map(\n  (columnId) => ({\n    id: columnId,\n    label: COLUMN_LABELS[columnId],\n    filterType: ALL_COLUMNS[columnId].meta?.filterType ?? \"string\",\n  })\n);\n","import { FC, useCallback } from \"react\";\n\nimport { ScalarValue } from \"../../api/api\";\nimport { ScansTableState, useStore } from \"../../state/store\";\nimport { useAddFilterPopover } from \"../components/columnFilter\";\nimport { FilterBar, type ColumnInfo } from \"../components/FilterBar\";\nimport { useFilterBarHandlers } from \"../components/useFilterBarHandlers\";\n\nimport {\n  COLUMN_LABELS,\n  COLUMN_HEADER_TITLES,\n  DEFAULT_COLUMN_ORDER,\n  DEFAULT_VISIBLE_COLUMNS,\n  FILTER_COLUMNS,\n  ScanColumnKey,\n} from \"./columns\";\n\n// Convert column definitions to ColumnInfo array\nconst COLUMNS_INFO: ColumnInfo[] = DEFAULT_COLUMN_ORDER.map((key) => ({\n  id: key,\n  label: COLUMN_LABELS[key],\n  headerTitle: COLUMN_HEADER_TITLES[key],\n}));\n\nexport const ScansFilterBar: FC<{\n  includeColumnPicker?: boolean;\n  filterSuggestions?: ScalarValue[];\n  onFilterColumnChange?: (columnId: string | null) => void;\n}> = ({\n  includeColumnPicker = true,\n  filterSuggestions = [],\n  onFilterColumnChange,\n}) => {\n  // Scans Filter State\n  const filters = useStore((state) => state.scansTableState.columnFilters);\n  const visibleColumns = useStore(\n    (state) => state.scansTableState.visibleColumns\n  );\n  const setScansTableState = useStore((state) => state.setScansTableState);\n\n  // Use shared filter bar handlers\n  const { handleFilterChange, removeFilter, handleAddFilter } =\n    useFilterBarHandlers<ScanColumnKey, ScansTableState>({\n      setTableState: setScansTableState,\n      defaultVisibleColumns: DEFAULT_VISIBLE_COLUMNS,\n    });\n\n  // Add filter popover state\n  const addFilterPopover = useAddFilterPopover({\n    columns: FILTER_COLUMNS,\n    filters,\n    onAddFilter: handleAddFilter,\n    onFilterColumnChange,\n  });\n\n  // Handle visible columns change\n  const handleVisibleColumnsChange = useCallback(\n    (newVisibleColumns: string[]) => {\n      setScansTableState((prevState) => ({\n        ...prevState,\n        visibleColumns: newVisibleColumns as ScanColumnKey[],\n      }));\n    },\n    [setScansTableState]\n  );\n\n  return (\n    <FilterBar\n      filters={filters}\n      onFilterChange={handleFilterChange}\n      onRemoveFilter={removeFilter}\n      filterSuggestions={filterSuggestions}\n      onFilterColumnChange={onFilterColumnChange}\n      popoverIdPrefix=\"scans\"\n      addFilterPopoverState={addFilterPopover}\n      columns={includeColumnPicker ? COLUMNS_INFO : undefined}\n      visibleColumns={visibleColumns ?? DEFAULT_VISIBLE_COLUMNS}\n      defaultVisibleColumns={DEFAULT_VISIBLE_COLUMNS}\n      onVisibleColumnsChange={\n        includeColumnPicker ? handleVisibleColumnsChange : undefined\n      }\n    />\n  );\n};\n","import { ColumnSizingState, OnChangeFn } from \"@tanstack/react-table\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\n\nimport { useStore } from \"../../../state/store\";\nimport {\n  clampSize,\n  ColumnSizingStrategyKey,\n  getColumnConstraints,\n  getSizingStrategy,\n  SizingStrategy,\n} from \"../../components/columnSizing\";\nimport { ScanColumn, ScanRow } from \"../columns\";\n\ninterface UseColumnSizingOptions {\n  /** Column definitions */\n  columns: ScanColumn[];\n  /** Reference to the table element for DOM measurement */\n  tableRef: React.RefObject<HTMLTableElement | null>;\n  /** Current data for content measurement */\n  data: ScanRow[];\n}\n\ninterface UseColumnSizingResult {\n  /** Current column sizing state */\n  columnSizing: ColumnSizingState;\n  /** Handler for column sizing changes with min/max enforcement */\n  handleColumnSizingChange: OnChangeFn<ColumnSizingState>;\n  /** Current sizing strategy key */\n  sizingStrategy: ColumnSizingStrategyKey;\n  /** Set the sizing strategy */\n  setSizingStrategy: (strategy: ColumnSizingStrategyKey) => void;\n  /** Apply auto-sizing based on current strategy (preserves manually resized columns) */\n  applyAutoSizing: () => void;\n  /** Reset a single column to its auto-calculated size */\n  resetColumnSize: (columnId: string) => void;\n  /** Reset all column sizing and clear manual resize tracking */\n  clearColumnSizing: () => void;\n}\n\n/**\n * Hook for managing column sizing with min/max constraints and auto-sizing.\n * Manually resized columns are preserved during auto-sizing operations.\n */\nexport function useColumnSizing({\n  columns,\n  tableRef,\n  data,\n}: UseColumnSizingOptions): UseColumnSizingResult {\n  const columnSizing = useStore((state) => state.scansTableState.columnSizing);\n  const sizingStrategy = useStore(\n    (state) => state.scansTableState.sizingStrategy\n  );\n  const manuallyResizedColumns = useStore(\n    (state) => state.scansTableState.manuallyResizedColumns\n  );\n  const setTableState = useStore((state) => state.setScansTableState);\n\n  // Track which columns have been manually resized\n  const manuallyResizedSet = useMemo(\n    () => new Set(manuallyResizedColumns),\n    [manuallyResizedColumns]\n  );\n\n  // Get constraints for all columns\n  const columnConstraints = useMemo(\n    () => getColumnConstraints(columns),\n    [columns]\n  );\n\n  // Track if we're in the middle of an auto-sizing operation\n  const isAutoSizingRef = useRef(false);\n\n  // Store latest values in refs for stable callbacks\n  const latestRef = useRef({\n    sizingStrategy,\n    columns,\n    data,\n    columnConstraints,\n    manuallyResizedSet,\n    columnSizing,\n  });\n\n  // Update refs when values change\n  useEffect(() => {\n    latestRef.current = {\n      sizingStrategy,\n      columns,\n      data,\n      columnConstraints,\n      manuallyResizedSet,\n      columnSizing,\n    };\n  });\n\n  // Handle column sizing changes with min/max enforcement\n  const handleColumnSizingChange: OnChangeFn<ColumnSizingState> = useCallback(\n    (updaterOrValue) => {\n      const newSizing =\n        typeof updaterOrValue === \"function\"\n          ? updaterOrValue(columnSizing)\n          : updaterOrValue;\n\n      // Clamp sizes to min/max constraints\n      const clampedSizing: ColumnSizingState = {};\n      const newManuallyResized = new Set(manuallyResizedSet);\n\n      for (const [columnId, size] of Object.entries(newSizing)) {\n        const constraints = columnConstraints.get(columnId);\n        if (constraints) {\n          clampedSizing[columnId] = clampSize(size, constraints);\n        } else {\n          clampedSizing[columnId] = size;\n        }\n\n        // Mark this column as manually resized (unless we're auto-sizing)\n        if (!isAutoSizingRef.current) {\n          newManuallyResized.add(columnId);\n        }\n      }\n\n      // Include existing sizes that weren't updated\n      for (const [columnId, size] of Object.entries(columnSizing)) {\n        if (!(columnId in clampedSizing)) {\n          clampedSizing[columnId] = size;\n        }\n      }\n\n      setTableState((prev) => ({\n        ...prev,\n        columnSizing: clampedSizing,\n        manuallyResizedColumns: isAutoSizingRef.current\n          ? prev.manuallyResizedColumns\n          : Array.from(newManuallyResized),\n      }));\n    },\n    [columnSizing, columnConstraints, manuallyResizedSet, setTableState]\n  );\n\n  // Set sizing strategy\n  const setSizingStrategy = useCallback(\n    (strategy: ColumnSizingStrategyKey) => {\n      setTableState((prev) => ({\n        ...prev,\n        sizingStrategy: strategy,\n      }));\n    },\n    [setTableState]\n  );\n\n  // Apply auto-sizing based on current strategy\n  // Preserves sizes of manually resized columns\n  const applyAutoSizing = useCallback(() => {\n    isAutoSizingRef.current = true;\n\n    try {\n      const {\n        sizingStrategy: strategyKey,\n        columns: cols,\n        data: rowData,\n        columnConstraints: constraints,\n        manuallyResizedSet: resizedSet,\n        columnSizing: currentSizing,\n      } = latestRef.current;\n\n      const strategy = getSizingStrategy(\n        strategyKey\n      ) as SizingStrategy<ScanRow>;\n      const calculatedSizing = strategy.computeSizes({\n        tableElement: tableRef.current,\n        columns: cols,\n        data: rowData,\n        constraints,\n      });\n\n      // Merge: use calculated sizes for non-manually-resized columns,\n      // preserve existing sizes for manually resized columns\n      const newSizing: ColumnSizingState = {};\n      for (const [columnId, size] of Object.entries(calculatedSizing)) {\n        if (resizedSet.has(columnId) && currentSizing[columnId] !== undefined) {\n          // Preserve manually resized column's current size\n          newSizing[columnId] = currentSizing[columnId];\n        } else {\n          // Use calculated size\n          newSizing[columnId] = size;\n        }\n      }\n\n      setTableState((prev) => ({\n        ...prev,\n        columnSizing: newSizing,\n      }));\n    } finally {\n      isAutoSizingRef.current = false;\n    }\n  }, [tableRef, setTableState]);\n\n  // Reset a single column to its auto-calculated size\n  const resetColumnSize = useCallback(\n    (columnId: string) => {\n      isAutoSizingRef.current = true;\n\n      try {\n        const {\n          sizingStrategy: strategyKey,\n          columns: cols,\n          data: rowData,\n          columnConstraints: constraints,\n        } = latestRef.current;\n\n        const strategy = getSizingStrategy(\n          strategyKey\n        ) as SizingStrategy<ScanRow>;\n        const allSizes = strategy.computeSizes({\n          tableElement: tableRef.current,\n          columns: cols,\n          data: rowData,\n          constraints,\n        });\n\n        const newSize = allSizes[columnId];\n        if (newSize !== undefined) {\n          setTableState((prev) => {\n            // Remove this column from manually resized list\n            const newManuallyResized = prev.manuallyResizedColumns.filter(\n              (id) => id !== columnId\n            );\n\n            return {\n              ...prev,\n              columnSizing: {\n                ...prev.columnSizing,\n                [columnId]: newSize,\n              },\n              manuallyResizedColumns: newManuallyResized,\n            };\n          });\n        }\n      } finally {\n        isAutoSizingRef.current = false;\n      }\n    },\n    [tableRef, setTableState]\n  );\n\n  // Reset all column sizing and clear manual resize tracking\n  const clearColumnSizing = useCallback(() => {\n    setTableState((prev) => ({\n      ...prev,\n      columnSizing: {},\n      manuallyResizedColumns: [],\n    }));\n  }, [setTableState]);\n\n  return {\n    columnSizing,\n    setSizingStrategy,\n    clearColumnSizing,\n    sizingStrategy,\n    handleColumnSizingChange,\n    applyAutoSizing,\n    resetColumnSize,\n  };\n}\n","import { FC, useEffect, useMemo, useRef } from \"react\";\n\nimport { ScalarValue } from \"../../api/api\";\nimport { scanRoute } from \"../../router/url\";\nimport { useStore } from \"../../state/store\";\nimport type { ScanRow as ApiScanRow } from \"../../types/api-types\";\nimport { toRelativePath } from \"../../utils/path\";\nimport { DataGrid } from \"../components/dataGrid\";\n\nimport {\n  DEFAULT_COLUMN_ORDER,\n  getScanColumns,\n  ScanColumn,\n  ScanRow,\n} from \"./columns\";\nimport { useColumnSizing } from \"./columnSizing\";\n\n// Generate a stable key for a scan item\nfunction scanItemKey(index: number, item?: ScanRow): string {\n  if (!item) {\n    return String(index);\n  }\n  return item.scan_id;\n}\n\ninterface ScansGridProps {\n  scans: ApiScanRow[];\n  resultsDir: string | undefined;\n  className?: string | string[];\n  loading?: boolean;\n  /** Called when scroll position nears end */\n  onScrollNearEnd?: (distanceFromBottom?: number) => void;\n  /** Whether more data is available to fetch */\n  hasMore?: boolean;\n  /** Distance from bottom (in px) at which to trigger callback */\n  fetchThreshold?: number;\n  /** Autocomplete suggestions for the currently editing filter column */\n  filterSuggestions?: ScalarValue[];\n  /** Called when a filter column starts/stops being edited */\n  onFilterColumnChange?: (columnId: string | null) => void;\n}\n\nexport const ScansGrid: FC<ScansGridProps> = ({\n  scans,\n  resultsDir,\n  className,\n  loading,\n  onScrollNearEnd,\n  hasMore = false,\n  fetchThreshold = 500,\n  filterSuggestions = [],\n  onFilterColumnChange,\n}) => {\n  // Table ref for DOM measurement (used by column sizing)\n  const tableRef = useRef<HTMLTableElement>(null);\n\n  // Table state from store\n  const sorting = useStore((state) => state.scansTableState.sorting);\n  const columnOrder = useStore((state) => state.scansTableState.columnOrder);\n  const columnFilters = useStore(\n    (state) => state.scansTableState.columnFilters\n  );\n  const rowSelection = useStore((state) => state.scansTableState.rowSelection);\n  const focusedRowId = useStore((state) => state.scansTableState.focusedRowId);\n  const visibleColumns = useStore(\n    (state) => state.scansTableState.visibleColumns\n  );\n  const setTableState = useStore((state) => state.setScansTableState);\n  const setVisibleScanJobCount = useStore(\n    (state) => state.setVisibleScanJobCount\n  );\n\n  // Add computed relativeLocation to each scan\n  const data = useMemo(\n    (): ScanRow[] =>\n      scans.map((scan) => ({\n        ...scan,\n        relativeLocation: toRelativePath(scan.location, resultsDir),\n      })),\n    [scans, resultsDir]\n  );\n\n  // Update visible count\n  useEffect(() => {\n    setVisibleScanJobCount(data.length);\n  }, [data.length, setVisibleScanJobCount]);\n\n  // Define table columns based on visible columns from store\n  const columns = useMemo<ScanColumn[]>(\n    () => getScanColumns(visibleColumns),\n    [visibleColumns]\n  );\n\n  // Column sizing with min/max constraints and auto-sizing\n  const {\n    columnSizing,\n    handleColumnSizingChange,\n    applyAutoSizing,\n    resetColumnSize,\n  } = useColumnSizing({\n    columns,\n    tableRef,\n    data,\n  });\n\n  // Track if we've done initial auto-sizing\n  const hasInitializedRef = useRef(false);\n\n  // Track previous visible columns to detect changes\n  const previousVisibleColumnsRef = useRef<typeof visibleColumns | null>(null);\n\n  // Auto-size columns on initial load when data is available\n  useEffect(() => {\n    if (!hasInitializedRef.current && data.length > 0) {\n      hasInitializedRef.current = true;\n      applyAutoSizing();\n    }\n  }, [data.length, applyAutoSizing]);\n\n  // Auto-size when visible columns change\n  // (applyAutoSizing preserves manually resized columns)\n  useEffect(() => {\n    const previousVisibleColumns = previousVisibleColumnsRef.current;\n    previousVisibleColumnsRef.current = visibleColumns;\n\n    if (previousVisibleColumns && previousVisibleColumns !== visibleColumns) {\n      applyAutoSizing();\n    }\n  }, [visibleColumns, applyAutoSizing]);\n\n  // Compute effective column order\n  const effectiveColumnOrder = useMemo(() => {\n    if (columnOrder && columnOrder.length > 0) {\n      return columnOrder;\n    }\n    return DEFAULT_COLUMN_ORDER;\n  }, [columnOrder]);\n\n  // Get row ID\n  const getRowId = (row: ScanRow): string => row.scan_id;\n\n  // Get route for navigation\n  const getRowRoute = (row: ScanRow): string => {\n    if (!resultsDir) return \"\";\n    return scanRoute(resultsDir, row.relativeLocation);\n  };\n\n  return (\n    <DataGrid\n      data={data}\n      columns={columns}\n      getRowId={getRowId}\n      getRowKey={scanItemKey}\n      state={{\n        sorting,\n        columnOrder: effectiveColumnOrder,\n        columnFilters,\n        columnSizing,\n        rowSelection,\n        focusedRowId,\n      }}\n      onStateChange={setTableState}\n      getRowRoute={getRowRoute}\n      onScrollNearEnd={onScrollNearEnd}\n      hasMore={hasMore}\n      fetchThreshold={fetchThreshold}\n      filterSuggestions={filterSuggestions}\n      onFilterColumnChange={onFilterColumnChange}\n      onColumnSizingChange={handleColumnSizingChange}\n      onResetColumnSize={resetColumnSize}\n      className={className}\n      loading={loading}\n      emptyMessage=\"No matching scans\"\n      noConfigMessage=\"No scans directory configured.\"\n    />\n  );\n};\n","import { clsx } from \"clsx\";\nimport { FC, useCallback, useEffect, useMemo } from \"react\";\n\nimport { ErrorPanel } from \"../../components/ErrorPanel\";\nimport { ExtendedFindProvider } from \"../../components/ExtendedFindProvider\";\nimport { ApplicationIcons } from \"../../components/icons\";\nimport { LoadingBar } from \"../../components/LoadingBar\";\nimport { NoContentsPanel } from \"../../components/NoContentsPanel\";\nimport { useDocumentTitle } from \"../../hooks/useDocumentTitle\";\nimport { useStore } from \"../../state/store\";\nimport { ScanRow } from \"../../types/api-types\";\nimport { Footer } from \"../components/Footer\";\nimport { ScansNavbar } from \"../components/ScansNavbar\";\nimport { useScanFilterConditions } from \"../hooks/useScanFilterConditions\";\nimport { useScansFilterBarProps } from \"../hooks/useScansFilterBarProps\";\nimport { useAppConfig } from \"../server/useAppConfig\";\nimport { useScansInfinite } from \"../server/useScansInfinite\";\nimport { useScansDir } from \"../utils/useScansDir\";\n\nimport { SCANS_INFINITE_SCROLL_CONFIG } from \"./constants\";\nimport { ScansFilterBar } from \"./ScansFilterBar\";\nimport { ScansGrid } from \"./ScansGrid\";\nimport styles from \"./ScansPanel.module.css\";\n\nexport const ScansPanel: FC = () => {\n  useDocumentTitle(\"Scans\");\n\n  const config = useAppConfig();\n  const scanDir = config.scans.dir;\n  const {\n    displayScansDir,\n    resolvedScansDir,\n    resolvedScansDirSource,\n    setScansDir,\n  } = useScansDir();\n\n  // Get filter condition and sorting from store\n  const condition = useScanFilterConditions();\n  const sorting = useStore((state) => state.scansTableState.sorting);\n\n  // Get autocomplete props for filter bar\n  const { filterSuggestions, onFilterColumnChange } =\n    useScansFilterBarProps(resolvedScansDir);\n\n  // Load scans data with filtering and sorting\n  const { data, error, fetchNextPage, hasNextPage, isFetching } =\n    useScansInfinite(\n      resolvedScansDir,\n      SCANS_INFINITE_SCROLL_CONFIG.pageSize,\n      condition,\n      sorting\n    );\n\n  // Flatten pages into scans array\n  const scans: ScanRow[] = useMemo(\n    () => data?.pages.flatMap((page) => page.items) ?? [],\n    [data]\n  );\n\n  // Handle infinite scroll\n  const handleScrollNearEnd = useCallback(() => {\n    fetchNextPage({ cancelRefetch: false }).catch(console.error);\n  }, [fetchNextPage]);\n\n  // Clear scan state from store on mount\n  const clearScansState = useStore((state) => state.clearScansState);\n  useEffect(() => {\n    clearScansState();\n  }, [clearScansState]);\n\n  return (\n    <div className={clsx(styles.container)}>\n      <ScansNavbar\n        scansDir={displayScansDir}\n        scansDirSource={resolvedScansDirSource}\n        setScansDir={setScansDir}\n        bordered={true}\n      />\n      <LoadingBar loading={isFetching} />\n      <ExtendedFindProvider>\n        {error && (\n          <ErrorPanel\n            title=\"Error Loading Scans\"\n            error={{ message: error.message }}\n          />\n        )}\n        {!data && !error && (\n          <NoContentsPanel icon={ApplicationIcons.running} text=\"Loading...\" />\n        )}\n        {data && !error && (\n          <div className={styles.gridContainer}>\n            <ScansFilterBar\n              filterSuggestions={filterSuggestions}\n              onFilterColumnChange={onFilterColumnChange}\n            />\n            <ScansGrid\n              scans={scans}\n              resultsDir={scanDir}\n              loading={isFetching && scans.length === 0}\n              className={styles.grid}\n              onScrollNearEnd={handleScrollNearEnd}\n              hasMore={hasNextPage}\n              fetchThreshold={SCANS_INFINITE_SCROLL_CONFIG.threshold}\n              filterSuggestions={filterSuggestions}\n              onFilterColumnChange={onFilterColumnChange}\n            />\n          </div>\n        )}\n        <Footer\n          id={\"scan-job-footer\"}\n          itemCount={data?.pages[0]?.total_count ?? 0}\n          paginated={false}\n        />\n      </ExtendedFindProvider>\n    </div>\n  );\n};\n"],"names":["condition","useState","useCallback","useMemo","styles","jsxs","jsx","useRef","useEffect"],"mappings":"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"}