{"version":3,"file":"TimelinePanel.js","sources":["../../src/app/timeline/components/TimelinePills.tsx","../../src/app/timeline/utils/swimlaneRows.ts","../../src/app/timeline/hooks/useTimeline.ts","../../src/app/timeline/utils/markers.ts","../../src/app/timeline/utils/swimlaneLayout.ts","../../src/app/timeline/components/TimelineMinimap.tsx","../../src/app/timeline/components/TimelineSwimLanes.tsx","../../src/app/timeline/syntheticNodes.ts","../../src/app/timeline/timelineEventNodes.ts","../../src/app/timeline/TimelinePanel.tsx"],"sourcesContent":["import clsx from \"clsx\";\nimport { FC } from \"react\";\n\nimport styles from \"./TimelinePills.module.css\";\n\ninterface TimelinePillsProps {\n  /** Available timeline views. */\n  timelines: ReadonlyArray<{ name: string; description: string }>;\n  /** Index of the active timeline. */\n  activeIndex: number;\n  /** Called when a pill is clicked. */\n  onSelect: (index: number) => void;\n}\n\nexport const TimelinePills: FC<TimelinePillsProps> = ({\n  timelines,\n  activeIndex,\n  onSelect,\n}) => {\n  if (timelines.length <= 1) return null;\n\n  return (\n    <div className={styles.pillRow}>\n      {timelines.map((tl, i) => (\n        <button\n          key={i}\n          className={clsx(styles.pill, i === activeIndex && styles.pillActive)}\n          onClick={() => onSelect(i)}\n          title={tl.description}\n        >\n          {tl.name}\n        </button>\n      ))}\n    </div>\n  );\n};\n","/**\n * Swimlane row computation for the timeline UI.\n *\n * Transforms a TimelineSpan's children into SwimlaneRow[] for rendering\n * as horizontal swimlane bars. Handles sequential, iterative (multiple spans),\n * and parallel (overlapping) span patterns.\n */\n\nimport type { TimelineSpan } from \"../../../components/transcript/timeline\";\n\n// =============================================================================\n// Sorting\n// =============================================================================\n\n/** Compare spans by start time, with end time as tiebreaker. */\nexport function compareByTime(\n  a: { startTime: Date; endTime: Date },\n  b: { startTime: Date; endTime: Date }\n): number {\n  return (\n    a.startTime.getTime() - b.startTime.getTime() ||\n    a.endTime.getTime() - b.endTime.getTime()\n  );\n}\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface SingleSpan {\n  agent: TimelineSpan;\n}\n\nexport interface ParallelSpan {\n  agents: TimelineSpan[];\n}\n\nexport type RowSpan = SingleSpan | ParallelSpan;\n\nexport interface SwimlaneRow {\n  name: string;\n  spans: RowSpan[];\n  totalTokens: number;\n  startTime: Date;\n  endTime: Date;\n}\n\n// =============================================================================\n// Type Guards\n// =============================================================================\n\nexport function isSingleSpan(span: RowSpan): span is SingleSpan {\n  return \"agent\" in span;\n}\n\nexport function isParallelSpan(span: RowSpan): span is ParallelSpan {\n  return \"agents\" in span;\n}\n\n/** Unwrap a RowSpan to a flat array of TimelineSpan agents. */\nexport function getAgents(span: RowSpan): TimelineSpan[] {\n  return isSingleSpan(span) ? [span.agent] : span.agents;\n}\n\n// =============================================================================\n// Overlap Detection\n// =============================================================================\n\n/** Tolerance in milliseconds for considering two spans as overlapping. */\nconst OVERLAP_TOLERANCE_MS = 100;\n\n/**\n * Returns true if two spans overlap in time, within the tolerance.\n * Two spans overlap if A starts before B ends and B starts before A ends.\n */\nfunction spansOverlap(a: TimelineSpan, b: TimelineSpan): boolean {\n  return (\n    a.startTime.getTime() < b.endTime.getTime() + OVERLAP_TOLERANCE_MS &&\n    b.startTime.getTime() < a.endTime.getTime() + OVERLAP_TOLERANCE_MS\n  );\n}\n\n/**\n * Returns true if any pair of spans in the group overlap.\n */\nfunction groupHasOverlap(spans: TimelineSpan[]): boolean {\n  for (let i = 0; i < spans.length; i++) {\n    for (let j = i + 1; j < spans.length; j++) {\n      const a = spans[i];\n      const b = spans[j];\n      if (a && b && spansOverlap(a, b)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// =============================================================================\n// Main Computation\n// =============================================================================\n\n/**\n * Computes swimlane rows from a TimelineSpan's children.\n *\n * @returns Array of SwimlaneRow, with the parent row always first,\n *          followed by child rows ordered by earliest start time.\n */\nexport function computeSwimlaneRows(node: TimelineSpan): SwimlaneRow[] {\n  // Parent row is always first\n  const parentRow = buildParentRow(node);\n\n  // Collect non-utility child spans\n  const children = node.content.filter(\n    (item): item is TimelineSpan => item.type === \"span\" && !item.utility\n  );\n\n  if (children.length === 0) {\n    return [parentRow];\n  }\n\n  // Group by name (case-insensitive)\n  const groups = groupByName(children);\n\n  // Build rows from groups\n  const childRows: SwimlaneRow[] = [];\n  for (const [displayName, spans] of groups) {\n    const row = buildRowFromGroup(displayName, spans);\n    if (row) {\n      childRows.push(row);\n    }\n  }\n\n  // Sort child rows by earliest start time\n  childRows.sort(compareByTime);\n\n  return [parentRow, ...childRows];\n}\n\n// =============================================================================\n// Internal Helpers\n// =============================================================================\n\nfunction buildParentRow(node: TimelineSpan): SwimlaneRow {\n  return {\n    name: node.name,\n    spans: [{ agent: node }],\n    totalTokens: node.totalTokens,\n    startTime: node.startTime,\n    endTime: node.endTime,\n  };\n}\n\n/**\n * Groups spans by name (case-insensitive), preserving the display name\n * from the first span encountered in each group.\n *\n * Returns entries in insertion order (first-seen order).\n */\nfunction groupByName(spans: TimelineSpan[]): [string, TimelineSpan[]][] {\n  const map = new Map<string, { displayName: string; spans: TimelineSpan[] }>();\n\n  for (const span of spans) {\n    const key = span.name.toLowerCase();\n    const existing = map.get(key);\n    if (existing) {\n      existing.spans.push(span);\n    } else {\n      map.set(key, { displayName: span.name, spans: [span] });\n    }\n  }\n\n  return Array.from(map.values()).map((g) => [g.displayName, g.spans]);\n}\n\nfunction buildRowFromGroup(\n  displayName: string,\n  spans: TimelineSpan[]\n): SwimlaneRow | null {\n  // Sort spans by start time, end time as tiebreaker\n  const sorted = [...spans].sort(compareByTime);\n\n  const first = sorted[0];\n  if (!first) {\n    return null;\n  }\n\n  // Determine row spans based on overlap\n  let rowSpans: RowSpan[];\n  if (sorted.length === 1) {\n    rowSpans = [{ agent: first }];\n  } else if (groupHasOverlap(sorted)) {\n    // Any overlap → entire group is one ParallelSpan\n    rowSpans = [{ agents: sorted }];\n  } else {\n    // No overlap → each span is a separate SingleSpan (iterative)\n    rowSpans = sorted.map((span) => ({ agent: span }));\n  }\n\n  // Compute aggregated time range and tokens\n  const startTime = first.startTime;\n  const endTime = sorted.reduce(\n    (latest, span) =>\n      span.endTime.getTime() > latest.getTime() ? span.endTime : latest,\n    first.endTime\n  );\n  const totalTokens = sorted.reduce((sum, span) => sum + span.totalTokens, 0);\n\n  return {\n    name: displayName,\n    spans: rowSpans,\n    totalTokens,\n    startTime,\n    endTime,\n  };\n}\n","/**\n * Timeline navigation hook and pure helper functions.\n *\n * Provides URL-driven drill-down navigation through the timeline span tree.\n * Pure functions (parsePathSegment, resolvePath, buildBreadcrumbs) are exported\n * for unit testing without DOM dependencies.\n */\n\nimport { useCallback, useMemo } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\nimport type {\n  Timeline,\n  TimelineBranch,\n  TimelineSpan,\n} from \"../../../components/transcript/timeline\";\nimport {\n  type SwimlaneRow,\n  compareByTime,\n  computeSwimlaneRows,\n} from \"../utils/swimlaneRows\";\n\n// =============================================================================\n// Query Parameter Constants\n// =============================================================================\n\nconst kPathParam = \"path\";\nconst kSelectedParam = \"selected\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface BreadcrumbSegment {\n  label: string;\n  path: string;\n}\n\nexport interface TimelineState {\n  /** The resolved TimelineSpan for the current path. */\n  node: TimelineSpan;\n  /** Swimlane rows computed from the resolved node. */\n  rows: SwimlaneRow[];\n  /** Breadcrumb trail from root to the current path. */\n  breadcrumbs: BreadcrumbSegment[];\n  /** Currently selected span identifier, or null. Encoded as \"name\" or \"name-N\". */\n  selected: string | null;\n  /** Navigate into a child span by name and optional span index. */\n  drillDown: (name: string, spanIndex?: number) => void;\n  /** Navigate up one level. */\n  goUp: () => void;\n  /** Navigate directly to a specific path (for breadcrumb jumps). */\n  navigateTo: (path: string) => void;\n  /** Set or clear the selected span. Use spanIndex for multi-span rows. */\n  select: (name: string | null, spanIndex?: number) => void;\n}\n\n// =============================================================================\n// Pure Functions\n// =============================================================================\n\n/**\n * Parses a single path segment into a name and optional span index.\n *\n * The span index suffix is `-N` where N is a positive integer (1-indexed).\n * Only the last `-N` suffix is considered; earlier hyphens are part of the name.\n *\n * Examples:\n *   \"explore\"       → { name: \"explore\", spanIndex: null }\n *   \"explore-2\"     → { name: \"explore\", spanIndex: 2 }\n *   \"my-agent\"      → { name: \"my-agent\", spanIndex: null }\n *   \"my-agent-3\"    → { name: \"my-agent\", spanIndex: 3 }\n *   \"explore-0\"     → { name: \"explore-0\", spanIndex: null }  (0 is not valid)\n */\nexport function parsePathSegment(segment: string): {\n  name: string;\n  spanIndex: number | null;\n} {\n  const match = /^(.+)-(\\d+)$/.exec(segment);\n  if (match) {\n    const name = match[1]!;\n    const index = parseInt(match[2]!, 10);\n    if (index >= 1) {\n      return { name, spanIndex: index };\n    }\n  }\n  return { name: segment, spanIndex: null };\n}\n\n/**\n * Resolves a path string to a span in the timeline tree.\n *\n * Path format: slash-separated segments, e.g. \"build/code/test\".\n * Empty or missing path resolves to the root span.\n *\n * Span names are matched case-insensitively. The `-N` suffix selects the\n * Nth occurrence (1-indexed) among same-named children; without a suffix,\n * the first match is returned.\n *\n * Returns null if the path is invalid.\n */\nexport function resolvePath(\n  timeline: Timeline,\n  pathString: string\n): TimelineSpan | null {\n  if (!pathString) return timeline.root;\n\n  const segments = pathString.split(\"/\").filter((s) => s.length > 0);\n  if (segments.length === 0) return timeline.root;\n\n  // Walk the tree from root\n  let current: TimelineSpan = timeline.root;\n\n  for (const segment of segments) {\n    const branchSpan = resolveBranchSegment(current, segment);\n    if (branchSpan) {\n      current = branchSpan;\n      continue;\n    }\n    const { name, spanIndex } = parsePathSegment(segment);\n    const child = findChildSpan(current, name, spanIndex);\n    if (!child) return null;\n    current = child;\n  }\n\n  return current;\n}\n\n/**\n * Builds a breadcrumb trail for the given path.\n *\n * Always starts with a \"Root\" breadcrumb at path \"\". Each subsequent segment\n * appends to the path. Labels use the resolved span's display name when\n * available, otherwise the raw segment.\n */\nexport function buildBreadcrumbs(\n  pathString: string,\n  timeline: Timeline\n): BreadcrumbSegment[] {\n  const crumbs: BreadcrumbSegment[] = [{ label: timeline.root.name, path: \"\" }];\n\n  if (!pathString) return crumbs;\n\n  const segments = pathString.split(\"/\").filter((s) => s.length > 0);\n  let current: TimelineSpan | null = timeline.root;\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]!;\n    const path = segments.slice(0, i + 1).join(\"/\");\n\n    if (current) {\n      // Try branch segment first (e.g. \"@branch-1\")\n      const branchSpan = resolveBranchSegment(current, segment);\n      if (branchSpan) {\n        crumbs.push({ label: branchSpan.name, path });\n        current = branchSpan;\n      } else {\n        const { name, spanIndex } = parsePathSegment(segment);\n        const child = findChildSpan(current, name, spanIndex);\n        if (child) {\n          crumbs.push({ label: child.name, path });\n          current = child;\n        } else {\n          crumbs.push({ label: segment, path });\n          current = null;\n        }\n      }\n    } else {\n      crumbs.push({ label: segment, path });\n    }\n  }\n\n  return crumbs;\n}\n\n// =============================================================================\n// Internal Helpers\n// =============================================================================\n\n/**\n * Finds a child span by name (case-insensitive) and optional span index.\n *\n * When spanIndex is null and there's exactly one match, returns it directly.\n * When spanIndex is null and there are multiple matches (parallel group),\n * returns a synthetic container span wrapping all matches as numbered children.\n * When spanIndex is N, returns the Nth same-named child (1-indexed).\n */\nfunction findChildSpan(\n  parent: TimelineSpan,\n  name: string,\n  spanIndex: number | null\n): TimelineSpan | null {\n  const lowerName = name.toLowerCase();\n  const matches: TimelineSpan[] = [];\n\n  for (const item of parent.content) {\n    if (item.type === \"span\" && item.name.toLowerCase() === lowerName) {\n      matches.push(item);\n    }\n  }\n\n  if (matches.length === 0) return null;\n\n  // Specific index requested → return that occurrence\n  if (spanIndex !== null) {\n    return matches[spanIndex - 1] ?? null;\n  }\n\n  // Single match → return it directly\n  if (matches.length === 1) {\n    return matches[0]!;\n  }\n\n  // Multiple matches (parallel group) → create a synthetic container\n  // with numbered children (e.g., \"Explore 1\", \"Explore 2\", \"Explore 3\")\n  return createParallelContainer(matches);\n}\n\n/**\n * Creates a synthetic TimelineSpan that wraps parallel agents as children.\n * Each child is renamed with a 1-based index suffix (e.g., \"Explore 1\").\n * The container's time range is the envelope of all agents, and tokens are summed.\n */\nfunction createParallelContainer(agents: TimelineSpan[]): TimelineSpan {\n  const displayName = agents[0]!.name;\n  const startTime = agents.reduce(\n    (min, a) => (a.startTime.getTime() < min.getTime() ? a.startTime : min),\n    agents[0]!.startTime\n  );\n  const endTime = agents.reduce(\n    (max, a) => (a.endTime.getTime() > max.getTime() ? a.endTime : max),\n    agents[0]!.endTime\n  );\n  const totalTokens = agents.reduce((sum, a) => sum + a.totalTokens, 0);\n\n  // Sort by start time (end time as tiebreaker), then number sequentially\n  const sorted = [...agents].sort(compareByTime);\n  const numberedAgents: TimelineSpan[] = sorted.map((agent, i) => ({\n    ...agent,\n    name: `${displayName} ${i + 1}`,\n  }));\n\n  return {\n    type: \"span\",\n    id: `parallel-${displayName.toLowerCase()}`,\n    name: displayName,\n    spanType: \"agent\",\n    content: numberedAgents,\n    branches: [],\n    utility: false,\n    startTime,\n    endTime,\n    totalTokens,\n  };\n}\n\n// =============================================================================\n// Branch Resolution\n// =============================================================================\n\nconst BRANCH_PREFIX = \"@branch-\";\n\n/**\n * Parses a `@branch-N` path segment and resolves it to a synthetic span.\n *\n * Returns null if the segment is not a branch segment or the index is invalid.\n * N is 1-indexed into the parent's branches array.\n */\nfunction resolveBranchSegment(\n  parent: TimelineSpan,\n  segment: string\n): TimelineSpan | null {\n  if (!segment.startsWith(BRANCH_PREFIX)) return null;\n\n  const indexStr = segment.slice(BRANCH_PREFIX.length);\n  const index = parseInt(indexStr, 10);\n  if (isNaN(index) || index < 1) return null;\n\n  const branch = parent.branches[index - 1];\n  if (!branch) return null;\n\n  return createBranchSpan(branch, index);\n}\n\n/**\n * Creates a TimelineSpan for a branch's content.\n *\n * If the branch has exactly one child span, returns that span directly\n * (with a ↳ prefix on its name) to avoid a redundant wrapper level.\n * Otherwise creates a synthetic container wrapping all branch content.\n */\nexport function createBranchSpan(\n  branch: TimelineBranch,\n  index: number\n): TimelineSpan {\n  const label = deriveBranchLabel(branch, index);\n\n  // If exactly one child span, return it directly with ↳ prefix\n  const childSpans = branch.content.filter(\n    (item): item is TimelineSpan => item.type === \"span\"\n  );\n  if (childSpans.length === 1) {\n    return {\n      ...childSpans[0]!,\n      name: `\\u21B3 ${childSpans[0]!.name}`,\n    };\n  }\n\n  return {\n    type: \"span\",\n    id: `branch-${branch.forkedAt}-${index}`,\n    name: `\\u21B3 ${label}`,\n    spanType: \"branch\",\n    content: branch.content,\n    branches: [],\n    utility: false,\n    startTime: branch.startTime,\n    endTime: branch.endTime,\n    totalTokens: branch.totalTokens,\n  };\n}\n\n/**\n * Derives a display label for a branch.\n *\n * Uses the name of the first child span if one exists, otherwise \"Branch N\".\n */\nfunction deriveBranchLabel(branch: TimelineBranch, index: number): string {\n  for (const item of branch.content) {\n    if (item.type === \"span\") return item.name;\n  }\n  return `Branch ${index}`;\n}\n\n// =============================================================================\n// Branch Lookup\n// =============================================================================\n\nexport interface BranchLookupResult {\n  /** The span that owns the branches. */\n  owner: TimelineSpan;\n  /** Path segments from the search root to the owner (empty if owner is root). */\n  ownerPath: string[];\n  /** Matching branches with their 1-indexed position. */\n  branches: Array<{ branch: TimelineBranch; index: number }>;\n}\n\n/**\n * Finds all branches matching a forkedAt UUID anywhere in the span tree.\n * Returns the owning span, its path from root, and matching branches.\n */\nexport function findBranchesByForkedAt(\n  node: TimelineSpan,\n  forkedAt: string,\n  pathSoFar: string[] = []\n): BranchLookupResult | null {\n  // Check this node's branches\n  const matches: Array<{ branch: TimelineBranch; index: number }> = [];\n  for (let i = 0; i < node.branches.length; i++) {\n    const branch = node.branches[i]!;\n    if (branch.forkedAt === forkedAt) {\n      matches.push({ branch, index: i + 1 });\n    }\n  }\n  if (matches.length > 0) {\n    return { owner: node, ownerPath: pathSoFar, branches: matches };\n  }\n\n  // Recurse into child spans\n  for (const item of node.content) {\n    if (item.type === \"span\") {\n      const found = findBranchesByForkedAt(item, forkedAt, [\n        ...pathSoFar,\n        item.name.toLowerCase(),\n      ]);\n      if (found) return found;\n    }\n  }\n\n  return null;\n}\n\n// =============================================================================\n// Hook\n// =============================================================================\n\n/**\n * Timeline navigation hook.\n *\n * Reads `path` and `selected` from URL search params. Returns the resolved\n * node, computed swimlane rows, breadcrumbs, and navigation functions.\n *\n * All navigation updates the URL via search param replacement, preserving\n * other search params.\n */\nexport function useTimeline(timeline: Timeline): TimelineState {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  const pathString = searchParams.get(kPathParam) ?? \"\";\n  const selectedParam = searchParams.get(kSelectedParam) ?? null;\n\n  // Resolve the current path to a span\n  const resolved = useMemo(\n    () => resolvePath(timeline, pathString),\n    [timeline, pathString]\n  );\n\n  // Fall back to root if path resolution fails\n  const node = useMemo(() => resolved ?? timeline.root, [timeline, resolved]);\n\n  // Compute swimlane rows\n  const rows = useMemo(() => computeSwimlaneRows(node), [node]);\n\n  // Default selection: explicit param > first child for parallel containers > root\n  const selected = useMemo(() => {\n    if (selectedParam !== null) return selectedParam;\n    if (node.id.startsWith(\"parallel-\") && rows.length > 1) {\n      return rows[1]!.name;\n    }\n    return rows[0]?.name ?? null;\n  }, [selectedParam, node.id, rows]);\n\n  // Build breadcrumbs\n  const breadcrumbs = useMemo(\n    () => buildBreadcrumbs(pathString, timeline),\n    [pathString, timeline]\n  );\n\n  // Navigation functions\n  const drillDown = useCallback(\n    (name: string, spanIndex?: number) => {\n      const segment = spanIndex ? `${name}-${spanIndex}` : name;\n      const newPath = pathString ? `${pathString}/${segment}` : segment;\n      setSearchParams(\n        (prev) => {\n          const next = new URLSearchParams(prev);\n          next.set(kPathParam, newPath);\n          next.delete(kSelectedParam);\n          return next;\n        },\n        { replace: true }\n      );\n    },\n    [pathString, setSearchParams]\n  );\n\n  const goUp = useCallback(() => {\n    setSearchParams(\n      (prev) => {\n        const next = new URLSearchParams(prev);\n        if (pathString) {\n          const segments = pathString.split(\"/\");\n          segments.pop();\n          const newPath = segments.join(\"/\");\n          if (newPath) {\n            next.set(kPathParam, newPath);\n          } else {\n            next.delete(kPathParam);\n          }\n        }\n        next.delete(kSelectedParam);\n        return next;\n      },\n      { replace: true }\n    );\n  }, [pathString, setSearchParams]);\n\n  const navigateTo = useCallback(\n    (path: string) => {\n      setSearchParams(\n        (prev) => {\n          const next = new URLSearchParams(prev);\n          if (path) {\n            next.set(kPathParam, path);\n          } else {\n            next.delete(kPathParam);\n          }\n          next.delete(kSelectedParam);\n          return next;\n        },\n        { replace: true }\n      );\n    },\n    [setSearchParams]\n  );\n\n  const select = useCallback(\n    (name: string | null, spanIndex?: number) => {\n      setSearchParams(\n        (prev) => {\n          const next = new URLSearchParams(prev);\n          if (name) {\n            const value = spanIndex ? `${name}-${spanIndex}` : name;\n            next.set(kSelectedParam, value);\n          } else {\n            next.delete(kSelectedParam);\n          }\n          return next;\n        },\n        { replace: true }\n      );\n    },\n    [setSearchParams]\n  );\n\n  return {\n    node,\n    rows,\n    breadcrumbs,\n    selected,\n    drillDown,\n    goUp,\n    navigateTo,\n    select,\n  };\n}\n","/**\n * Marker computation for the timeline UI.\n *\n * Collects error, compaction, and branch markers from a TimelineSpan's\n * content at configurable depth levels (direct, children, recursive).\n */\n\nimport type {\n  TimelineBranch,\n  TimelineEvent,\n  TimelineSpan,\n} from \"../../../components/transcript/timeline\";\nimport type { CompactionEvent, Event } from \"../../../types/api-types\";\nimport { formatDuration, formatPrettyDecimal } from \"../../../utils/format\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport type MarkerKind = \"error\" | \"compaction\" | \"branch\";\n\nexport interface TimelineMarker {\n  kind: MarkerKind;\n  timestamp: Date;\n  reference: string;\n  /** Human-readable detail for tooltip display. */\n  tooltip: string;\n}\n\nexport type MarkerDepth = \"direct\" | \"children\" | \"recursive\";\n\n// =============================================================================\n// Event Classification\n// =============================================================================\n\n/**\n * Returns true if the event is an error event.\n *\n * An event is an error if:\n * - It's a ToolEvent with `.error !== null`\n * - It's a ModelEvent with `.error !== null` or `.output.error !== null`\n */\nexport function isErrorEvent(event: Event): boolean {\n  if (event.event === \"tool\") {\n    return event.error !== null;\n  }\n  if (event.event === \"model\") {\n    return event.error !== null || event.output.error !== null;\n  }\n  return false;\n}\n\n/**\n * Returns true if the event is a compaction event.\n */\nexport function isCompactionEvent(event: Event): boolean {\n  return event.event === \"compaction\";\n}\n\n/**\n * Builds a tooltip string for an error event.\n */\nfunction errorTooltip(event: Event): string {\n  if (event.event === \"tool\") {\n    const msg = event.error?.message ?? \"Unknown error\";\n    return `Error (${event.function}): ${msg}`;\n  }\n  if (event.event === \"model\") {\n    const msg =\n      (typeof event.error === \"string\" ? event.error : null) ??\n      (typeof event.output.error === \"string\" ? event.output.error : null) ??\n      \"Unknown error\";\n    return `Error (${event.model}): ${msg}`;\n  }\n  return \"Error\";\n}\n\n// =============================================================================\n// Main Function\n// =============================================================================\n\n/**\n * Collects timeline markers from a TimelineSpan at the specified depth.\n *\n * - `\"direct\"`: Only markers from the span's own TimelineEvent content.\n * - `\"children\"`: Own events + events from direct child spans.\n * - `\"recursive\"`: Full subtree traversal.\n *\n * Branch markers are always collected from the span's own branches\n * (not from child spans), regardless of depth.\n *\n * Results are sorted by timestamp.\n */\nexport function collectMarkers(\n  node: TimelineSpan,\n  depth: MarkerDepth\n): TimelineMarker[] {\n  const markers: TimelineMarker[] = [];\n\n  // Collect event markers at the specified depth\n  collectEventMarkers(node, depth, 0, markers);\n\n  // Collect branch markers from this span's branches only\n  collectBranchMarkers(node, markers);\n\n  // Sort by timestamp\n  markers.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n  return markers;\n}\n\n// =============================================================================\n// Internal Helpers\n// =============================================================================\n\n/**\n * Collects error and compaction markers from event nodes.\n *\n * @param node The span to scan\n * @param depth The depth mode\n * @param currentLevel 0 = the root node itself, 1 = direct children, etc.\n * @param markers Accumulator array\n */\nfunction collectEventMarkers(\n  node: TimelineSpan,\n  depth: MarkerDepth,\n  currentLevel: number,\n  markers: TimelineMarker[]\n): void {\n  for (const item of node.content) {\n    if (item.type === \"event\") {\n      addEventMarker(item, markers);\n    } else if (item.type === \"span\" && shouldDescend(depth, currentLevel)) {\n      collectEventMarkers(item, depth, currentLevel + 1, markers);\n    }\n  }\n}\n\n/**\n * Determines whether to descend into a child span based on depth mode.\n */\nfunction shouldDescend(depth: MarkerDepth, currentLevel: number): boolean {\n  if (depth === \"direct\") return false;\n  if (depth === \"children\") return currentLevel === 0;\n  // \"recursive\"\n  return true;\n}\n\n/**\n * Adds a marker for a timeline event if it's an error or compaction event.\n */\nfunction addEventMarker(\n  eventNode: TimelineEvent,\n  markers: TimelineMarker[]\n): void {\n  const event = eventNode.event;\n  const uuid = event.uuid;\n\n  if (isErrorEvent(event)) {\n    markers.push({\n      kind: \"error\",\n      timestamp: eventNode.startTime,\n      reference: uuid ?? \"\",\n      tooltip: errorTooltip(event),\n    });\n  } else if (isCompactionEvent(event)) {\n    const ce = event as CompactionEvent;\n    const before = ce.tokens_before?.toLocaleString() ?? \"?\";\n    const after = ce.tokens_after?.toLocaleString() ?? \"?\";\n    markers.push({\n      kind: \"compaction\",\n      timestamp: eventNode.startTime,\n      reference: uuid ?? \"\",\n      tooltip: `Context compaction: ${before} → ${after} tokens`,\n    });\n  }\n}\n\n/**\n * Collects branch markers from a span's branches.\n *\n * Groups branches by forkedAt UUID so a single marker represents all branches\n * at a fork point. Resolves each forkedAt to a timestamp by searching the\n * span's content. Fork points with unresolvable forkedAt are silently dropped.\n */\nfunction collectBranchMarkers(\n  node: TimelineSpan,\n  markers: TimelineMarker[]\n): void {\n  // Group branches by forkedAt UUID\n  const groups = new Map<string, TimelineBranch[]>();\n  for (const branch of node.branches) {\n    const existing = groups.get(branch.forkedAt);\n    if (existing) {\n      existing.push(branch);\n    } else {\n      groups.set(branch.forkedAt, [branch]);\n    }\n  }\n\n  for (const [forkedAt, branches] of groups) {\n    const timestamp = resolveForkedAtTimestamp(node, forkedAt);\n    if (timestamp) {\n      markers.push({\n        kind: \"branch\",\n        timestamp,\n        reference: forkedAt,\n        tooltip: branchTooltip(branches),\n      });\n    }\n  }\n}\n\n/**\n * Builds a tooltip string summarizing branches at a fork point.\n */\nfunction branchTooltip(branches: TimelineBranch[]): string {\n  const count = branches.length;\n  const totalTokens = branches.reduce((sum, b) => sum + b.totalTokens, 0);\n  const tokenStr = formatCompactTokens(totalTokens);\n\n  // Compute combined duration: earliest start to latest end\n  const earliest = branches.reduce(\n    (min, b) => (b.startTime < min ? b.startTime : min),\n    branches[0]!.startTime\n  );\n  const latest = branches.reduce(\n    (max, b) => (b.endTime > max ? b.endTime : max),\n    branches[0]!.endTime\n  );\n  const duration = formatDuration(earliest, latest);\n\n  const label = count === 1 ? \"1 branch\" : `${count} branches`;\n  return `${label} (${tokenStr}, ${duration})`;\n}\n\n/**\n * Formats a token count compactly: \"48.5k\", \"1.2M\", etc.\n */\nfunction formatCompactTokens(tokens: number): string {\n  if (tokens >= 1_000_000) {\n    return `${formatPrettyDecimal(tokens / 1_000_000)}M tokens`;\n  }\n  if (tokens >= 1_000) {\n    return `${formatPrettyDecimal(tokens / 1_000)}k tokens`;\n  }\n  return `${tokens} tokens`;\n}\n\n/**\n * Resolves a forkedAt UUID to a timestamp by searching for the matching\n * event in the span's content.\n */\nfunction resolveForkedAtTimestamp(\n  node: TimelineSpan,\n  forkedAt: string\n): Date | null {\n  if (!forkedAt) return null;\n\n  for (const item of node.content) {\n    if (item.type === \"event\" && item.event.uuid === forkedAt) {\n      return item.startTime;\n    }\n  }\n  return null;\n}\n","/**\n * Swimlane layout computation for the timeline UI.\n *\n * Maps swimlane rows + a time range to percentage-based positions for CSS\n * rendering. All functions are pure with no DOM or React dependencies.\n */\n\nimport type { TimelineSpan } from \"../../../components/transcript/timeline\";\nimport { formatPrettyDecimal } from \"../../../utils/format\";\n\nimport { type MarkerDepth, type MarkerKind, collectMarkers } from \"./markers\";\nimport {\n  type RowSpan,\n  type SwimlaneRow,\n  getAgents,\n  isParallelSpan,\n  isSingleSpan,\n} from \"./swimlaneRows\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/** Position of a single bar fill within the bar area, in percentages (0-100). */\nexport interface BarPosition {\n  left: number;\n  width: number;\n}\n\n/** Positioned span with bar position and metadata for rendering. */\nexport interface PositionedSpan {\n  /** Bar position as percentage within the view range. */\n  bar: BarPosition;\n  /** Whether this span can be drilled into. */\n  drillable: boolean;\n  /** For ParallelSpan, the number of agents. Null for SingleSpan. */\n  parallelCount: number | null;\n  /** Task description for tooltip, if available. */\n  description: string | null;\n}\n\n/** Positioned marker within the bar area. */\nexport interface PositionedMarker {\n  /** Percentage offset from left edge (0-100). */\n  left: number;\n  /** The marker kind for rendering the correct glyph. */\n  kind: MarkerKind;\n  /** Reference identifier (forkedAt UUID for branches, event UUID for others). */\n  reference: string;\n  /** Human-readable detail for tooltip display. */\n  tooltip: string;\n}\n\n/** Complete layout data for a single swimlane row. */\nexport interface RowLayout {\n  /** Row name (for label column). */\n  name: string;\n  /** Whether this is the parent row (index 0). */\n  isParent: boolean;\n  /** Positioned spans (fills + chevrons). */\n  spans: PositionedSpan[];\n  /** Positioned markers. */\n  markers: PositionedMarker[];\n  /** Total tokens for the token column. */\n  totalTokens: number;\n  /** Parallel agent count for label display, or null if not parallel. */\n  parallelCount: number | null;\n}\n\n// =============================================================================\n// Percentage Computation\n// =============================================================================\n\n/**\n * Computes a single percentage position for a timestamp within a view range.\n * Result is clamped to [0, 100]. Returns 0 for zero-duration view ranges.\n */\nexport function timestampToPercent(\n  timestamp: Date,\n  viewStart: Date,\n  viewEnd: Date\n): number {\n  const range = viewEnd.getTime() - viewStart.getTime();\n  if (range <= 0) return 0;\n\n  const offset = timestamp.getTime() - viewStart.getTime();\n  return Math.max(0, Math.min(100, (offset / range) * 100));\n}\n\n/**\n * Computes the bar position (left + width) for a time range within a view range.\n * Both left and width are clamped so the bar stays within [0, 100].\n */\nexport function computeBarPosition(\n  spanStart: Date,\n  spanEnd: Date,\n  viewStart: Date,\n  viewEnd: Date\n): BarPosition {\n  const left = timestampToPercent(spanStart, viewStart, viewEnd);\n  const right = timestampToPercent(spanEnd, viewStart, viewEnd);\n  return { left, width: Math.max(0, right - left) };\n}\n\n// =============================================================================\n// Drillability\n// =============================================================================\n\n/**\n * Determines whether a RowSpan is drillable.\n *\n * A SingleSpan is drillable if its agent has non-utility child spans.\n * A ParallelSpan is always drillable (drill reveals individual instances).\n */\nexport function isDrillable(span: RowSpan): boolean {\n  if (isParallelSpan(span)) return true;\n\n  if (isSingleSpan(span)) {\n    return span.agent.content.some(\n      (item): item is TimelineSpan => item.type === \"span\" && !item.utility\n    );\n  }\n\n  return false;\n}\n\n// =============================================================================\n// Token Formatting\n// =============================================================================\n\n/**\n * Formats a token count for compact display: \"48.5k\", \"1.2M\", etc.\n */\nexport function formatTokenCount(tokens: number): string {\n  if (tokens >= 1_000_000) {\n    return `${formatPrettyDecimal(tokens / 1_000_000)}M`;\n  }\n  if (tokens >= 1_000) {\n    return `${formatPrettyDecimal(tokens / 1_000)}k`;\n  }\n  return String(tokens);\n}\n\n// =============================================================================\n// Row Layout Computation\n// =============================================================================\n\n/**\n * Computes the full layout for all swimlane rows.\n *\n * viewStart and viewEnd define the visible time range (from the current\n * drill-down node's startTime/endTime). Markers are collected at the\n * specified depth for each row's spans.\n */\nexport function computeRowLayouts(\n  rows: SwimlaneRow[],\n  viewStart: Date,\n  viewEnd: Date,\n  markerDepth: MarkerDepth\n): RowLayout[] {\n  return rows.map((row, index) => {\n    const isParent = index === 0;\n\n    // Position each RowSpan\n    const spans = row.spans.map((rowSpan): PositionedSpan => {\n      if (isSingleSpan(rowSpan)) {\n        const bar = computeBarPosition(\n          rowSpan.agent.startTime,\n          rowSpan.agent.endTime,\n          viewStart,\n          viewEnd\n        );\n        return {\n          bar,\n          drillable: !isParent && isDrillable(rowSpan),\n          parallelCount: null,\n          description: rowSpan.agent.description ?? null,\n        };\n      }\n\n      // ParallelSpan: envelope from earliest start to latest end\n      const agents = rowSpan.agents;\n      const earliest = agents.reduce(\n        (min, a) => (a.startTime.getTime() < min.getTime() ? a.startTime : min),\n        agents[0]!.startTime\n      );\n      const latest = agents.reduce(\n        (max, a) => (a.endTime.getTime() > max.getTime() ? a.endTime : max),\n        agents[0]!.endTime\n      );\n      const bar = computeBarPosition(earliest, latest, viewStart, viewEnd);\n      return {\n        bar,\n        drillable: !isParent,\n        parallelCount: agents.length,\n        description: null,\n      };\n    });\n\n    // Collect markers for this row\n    const markers = collectRowMarkers(\n      row,\n      isParent,\n      markerDepth,\n      viewStart,\n      viewEnd\n    );\n\n    // Derive row-level parallel count from spans\n    const rowParallelCount =\n      spans.length === 1 && spans[0]!.parallelCount !== null\n        ? spans[0]!.parallelCount\n        : null;\n\n    return {\n      name: row.name,\n      isParent,\n      spans,\n      markers,\n      totalTokens: row.totalTokens,\n      parallelCount: rowParallelCount,\n    };\n  });\n}\n\n// =============================================================================\n// Internal Helpers\n// =============================================================================\n\n/**\n * Collects and positions markers for a single row.\n *\n * For the parent row, markers come from the parent span itself.\n * For child rows, markers are collected from each span's agent and merged.\n */\nfunction collectRowMarkers(\n  row: SwimlaneRow,\n  isParent: boolean,\n  depth: MarkerDepth,\n  viewStart: Date,\n  viewEnd: Date\n): PositionedMarker[] {\n  const allMarkers: PositionedMarker[] = [];\n\n  for (const rowSpan of row.spans) {\n    const agents = getAgents(rowSpan);\n\n    for (const agent of agents) {\n      // For parent row, use the depth as-is.\n      // For child rows, use \"direct\" to avoid double-counting from grandchildren\n      // (the parent row already aggregates via depth).\n      const effectiveDepth = isParent ? depth : \"direct\";\n      const markers = collectMarkers(agent, effectiveDepth);\n\n      for (const m of markers) {\n        allMarkers.push({\n          left: timestampToPercent(m.timestamp, viewStart, viewEnd),\n          kind: m.kind,\n          reference: m.reference,\n          tooltip: m.tooltip,\n        });\n      }\n    }\n  }\n\n  // Sort by position\n  allMarkers.sort((a, b) => a.left - b.left);\n  return allMarkers;\n}\n","import clsx from \"clsx\";\nimport { FC, useCallback } from \"react\";\n\nimport type { TimelineSpan } from \"../../../components/transcript/timeline\";\nimport { useProperty } from \"../../../state/hooks/useProperty\";\nimport { formatDuration, formatDurationShort } from \"../../../utils/format\";\nimport { computeBarPosition, formatTokenCount } from \"../utils/swimlaneLayout\";\n\nimport styles from \"./TimelineMinimap.module.css\";\n\nexport interface MinimapSelection {\n  startTime: Date;\n  endTime: Date;\n  totalTokens: number;\n}\n\nexport interface TimelineMinimapProps {\n  /** Root timeline span (always the full timeline). */\n  root: TimelineSpan;\n  /** Currently selected swimlane row, if any. */\n  selection?: MinimapSelection;\n}\n\n/**\n * Compact minimap showing the selected row's position within the full timeline.\n *\n * Renders as a self-contained flex row: mode label + bar area.\n * Designed to sit inside the breadcrumb row, right-aligned.\n */\nexport const TimelineMinimap: FC<TimelineMinimapProps> = ({\n  root,\n  selection,\n}) => {\n  const [showTokens, setShowTokens] = useProperty<boolean>(\n    \"timeline\",\n    \"minimapShowTokens\",\n    { defaultValue: false, cleanup: false }\n  );\n  const isTokenMode = !!showTokens;\n  const toggle = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      setShowTokens(!isTokenMode);\n    },\n    [isTokenMode, setShowTokens]\n  );\n\n  const bar = selection\n    ? computeBarPosition(\n        selection.startTime,\n        selection.endTime,\n        root.startTime,\n        root.endTime\n      )\n    : null;\n\n  const showRegion = bar !== null;\n  const useShortFormat = bar !== null && bar.width <= 15;\n\n  // Compute both labels so the container can size to the wider one\n  const timeRightLabel = formatDuration(root.startTime, root.endTime);\n  const tokenRightLabel = formatTokenCount(root.totalTokens);\n  const sectionLabel =\n    selection && isTokenMode\n      ? formatTokenCount(selection.totalTokens)\n      : selection\n        ? useShortFormat\n          ? formatDurationShort(selection.startTime, selection.endTime)\n          : formatDuration(selection.startTime, selection.endTime)\n        : \"\";\n\n  return (\n    <div className={styles.container}>\n      {/* Mode label — click to toggle time/tokens.\n          Both values are rendered so the cell sizes to the wider one. */}\n      <div\n        className={clsx(styles.stableLabel, styles.alignRight)}\n        onClick={toggle}\n      >\n        <span className={isTokenMode ? styles.hidden : undefined}>time</span>\n        <span className={isTokenMode ? undefined : styles.hidden}>tokens</span>\n      </div>\n\n      {/* Bar area */}\n      <div className={styles.minimap}>\n        <div className={styles.track} />\n\n        {/* Selection region fill between markers */}\n        {showRegion && (\n          <div\n            className={styles.regionFill}\n            style={{ left: `${bar.left}%`, width: `${bar.width}%` }}\n          />\n        )}\n\n        {/* Vertical tick markers at selection boundaries */}\n        {showRegion && (\n          <>\n            <div className={styles.marker} style={{ left: `${bar.left}%` }} />\n            <div\n              className={styles.marker}\n              style={{ left: `${bar.left + bar.width}%` }}\n            />\n          </>\n        )}\n\n        {/* Section label pill between markers */}\n        {showRegion && (\n          <div\n            className={styles.sectionTime}\n            style={{ left: `${bar.left}%`, width: `${bar.width}%` }}\n          >\n            <span className={styles.sectionTimePill} onClick={toggle}>\n              {sectionLabel}\n            </span>\n          </div>\n        )}\n      </div>\n\n      {/* Right edge label — both values rendered for stable width */}\n      <div\n        className={clsx(styles.stableLabel, styles.alignLeft)}\n        onClick={toggle}\n      >\n        <span className={isTokenMode ? styles.hidden : undefined}>\n          {timeRightLabel}\n        </span>\n        <span className={isTokenMode ? undefined : styles.hidden}>\n          {tokenRightLabel}\n        </span>\n      </div>\n    </div>\n  );\n};\n","import clsx from \"clsx\";\nimport { FC, useCallback, useMemo, useState } from \"react\";\n\nimport { ApplicationIcons } from \"../../../components/icons\";\nimport { PopOver } from \"../../../components/PopOver\";\nimport type {\n  TimelineBranch,\n  TimelineSpan,\n} from \"../../../components/transcript/timeline\";\nimport { useProperty } from \"../../../state/hooks/useProperty\";\nimport { formatTime } from \"../../../utils/format\";\nimport {\n  type BreadcrumbSegment,\n  createBranchSpan,\n  findBranchesByForkedAt,\n  parsePathSegment,\n} from \"../hooks/useTimeline\";\nimport type {\n  PositionedMarker,\n  PositionedSpan,\n  RowLayout,\n} from \"../utils/swimlaneLayout\";\nimport { formatTokenCount } from \"../utils/swimlaneLayout\";\n\nimport { TimelineMinimap, type TimelineMinimapProps } from \"./TimelineMinimap\";\nimport styles from \"./TimelineSwimLanes.module.css\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\ninterface TimelineSwimLanesProps {\n  /** Row layouts computed by computeRowLayouts. */\n  layouts: RowLayout[];\n  /** Currently selected span identifier (e.g. \"explore\" or \"explore-2\"), or null. */\n  selected: string | null;\n  /** The current drill-down node (for branch lookup). */\n  node: TimelineSpan;\n  /** Called when a span is clicked (selection). */\n  onSelect: (name: string, spanIndex?: number) => void;\n  /** Called when a span's drill-down chevron is clicked. */\n  onDrillDown: (name: string, spanIndex?: number) => void;\n  /** Called when a branch popover entry is clicked. Segment is e.g. \"@branch-1\". */\n  onBranchDrillDown: (branchSegment: string) => void;\n  /** Called on Escape key (go up). */\n  onGoUp: () => void;\n  /** Minimap props for the zoom indicator row. */\n  minimap?: TimelineMinimapProps;\n  /** Breadcrumb props for the navigation row. */\n  breadcrumb?: BreadcrumbRowProps;\n}\n\ninterface BreadcrumbRowProps {\n  breadcrumbs: BreadcrumbSegment[];\n  atRoot: boolean;\n  onGoUp: () => void;\n  onNavigate: (path: string) => void;\n  minimap?: TimelineMinimapProps;\n  /** Currently selected row name, shown as a read-only tail segment. */\n  selected?: string | null;\n}\n\n// =============================================================================\n// Selection helpers\n// =============================================================================\n\ninterface ParsedSelection {\n  name: string;\n  spanIndex: number | null;\n}\n\nfunction parseSelected(selected: string | null): ParsedSelection | null {\n  if (!selected) return null;\n  return parsePathSegment(selected);\n}\n\n/**\n * Check if a specific span within a row is the selected one.\n * For single-span rows, any selection of that row name matches.\n * For multi-span rows, the span index must match.\n */\nfunction isSpanSelected(\n  layout: RowLayout,\n  spanIndex: number,\n  parsed: ParsedSelection | null\n): boolean {\n  if (!parsed) return false;\n  if (layout.name.toLowerCase() !== parsed.name.toLowerCase()) return false;\n\n  if (layout.spans.length === 1) {\n    // Single-span row: any selection of this name matches\n    return true;\n  }\n\n  // Multi-span row: match by span index (1-indexed)\n  // No suffix (spanIndex === null) → first span\n  const selectedIdx = parsed.spanIndex ?? 1;\n  return selectedIdx === spanIndex + 1;\n}\n\n// =============================================================================\n// Marker glyphs\n// =============================================================================\n\nconst MARKER_ICONS: Record<string, { icon: string; tooltip: string }> = {\n  error: { icon: ApplicationIcons.error, tooltip: \"Error event\" },\n  compaction: {\n    icon: ApplicationIcons.compactionMarker,\n    tooltip: \"Context compaction\",\n  },\n  branch: { icon: ApplicationIcons.fork, tooltip: \"View branches\" },\n};\n\n// =============================================================================\n// TimelineSwimLanes\n// =============================================================================\n\nexport const TimelineSwimLanes: FC<TimelineSwimLanesProps> = ({\n  layouts,\n  selected,\n  node,\n  onSelect,\n  onDrillDown,\n  onBranchDrillDown,\n  onGoUp,\n  minimap,\n  breadcrumb,\n}) => {\n  const parsedSelection = useMemo(() => parseSelected(selected), [selected]);\n\n  // Collapse state — persisted across sessions\n  const [collapsed, setCollapsed] = useProperty<boolean>(\n    \"timeline\",\n    \"swimlanesCollapsed\",\n    { defaultValue: false, cleanup: false }\n  );\n  const isCollapsed = !!collapsed;\n  const toggleCollapsed = useCallback(() => {\n    setCollapsed(!isCollapsed);\n  }, [isCollapsed, setCollapsed]);\n\n  // Branch popover state\n  const [branchPopover, setBranchPopover] = useState<{\n    forkedAt: string;\n    element: HTMLElement;\n  } | null>(null);\n\n  const handleBranchClick = useCallback(\n    (forkedAt: string, element: HTMLElement) => {\n      setBranchPopover((prev) =>\n        prev?.forkedAt === forkedAt ? null : { forkedAt, element }\n      );\n    },\n    []\n  );\n\n  const handleBranchSelect = useCallback(\n    (branchSegment: string) => {\n      // Compute the owner path at select time to avoid stale closure issues\n      const lookup = findBranchesByForkedAt(\n        node,\n        branchPopover?.forkedAt ?? \"\"\n      );\n      setBranchPopover(null);\n      // Build the full drill-down path: owner path segments + branch segment\n      if (lookup && lookup.ownerPath.length > 0) {\n        const fullSegment = [...lookup.ownerPath, branchSegment].join(\"/\");\n        onBranchDrillDown(fullSegment);\n      } else {\n        onBranchDrillDown(branchSegment);\n      }\n    },\n    [onBranchDrillDown, node, branchPopover?.forkedAt]\n  );\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLDivElement>) => {\n      const rowNames = layouts.map((l) => l.name);\n      const currentRowName = parsedSelection?.name.toLowerCase() ?? null;\n      const currentIndex = currentRowName\n        ? rowNames.findIndex((n) => n.toLowerCase() === currentRowName)\n        : -1;\n\n      switch (e.key) {\n        case \"ArrowDown\": {\n          e.preventDefault();\n          const next =\n            currentIndex < rowNames.length - 1\n              ? currentIndex + 1\n              : currentIndex;\n          const name = rowNames[next];\n          if (name !== undefined) onSelect(name);\n          break;\n        }\n        case \"ArrowUp\": {\n          e.preventDefault();\n          const prev = currentIndex > 0 ? currentIndex - 1 : 0;\n          const name = rowNames[prev];\n          if (name !== undefined) onSelect(name);\n          break;\n        }\n        case \"Enter\": {\n          e.preventDefault();\n          if (parsedSelection) {\n            const layout = layouts.find(\n              (l) => l.name.toLowerCase() === parsedSelection.name.toLowerCase()\n            );\n            if (layout && layout.spans.some((s) => s.drillable)) {\n              onDrillDown(layout.name, parsedSelection.spanIndex ?? undefined);\n            }\n          }\n          break;\n        }\n        case \"Escape\": {\n          e.preventDefault();\n          if (branchPopover) {\n            setBranchPopover(null);\n          } else {\n            onGoUp();\n          }\n          break;\n        }\n      }\n    },\n    [layouts, parsedSelection, onSelect, onDrillDown, onGoUp, branchPopover]\n  );\n\n  // Find branches matching the popover's forkedAt UUID.\n  // Branches may be on the current node or on any child span in the tree,\n  // since markers are collected recursively from the content tree.\n  const branchLookup = useMemo(() => {\n    if (!branchPopover) return null;\n    return findBranchesByForkedAt(node, branchPopover.forkedAt);\n  }, [branchPopover, node]);\n\n  const parentRow = layouts[0];\n  const childRows = layouts.slice(1);\n\n  const renderRow = (layout: RowLayout, rowIndex: number) => (\n    <SwimlaneRow\n      key={`${layout.name}-${rowIndex}`}\n      layout={layout}\n      parsedSelection={parsedSelection}\n      onSelect={(spanIndex) => {\n        if (layout.spans.length > 1) {\n          onSelect(layout.name, spanIndex + 1);\n        } else {\n          onSelect(layout.name);\n        }\n      }}\n      onDrillDown={(spanIndex) =>\n        onDrillDown(\n          layout.name,\n          layout.spans.length > 1 ? spanIndex + 1 : undefined\n        )\n      }\n      onBranchClick={handleBranchClick}\n    />\n  );\n\n  return (\n    <div\n      className={styles.swimlane}\n      tabIndex={0}\n      onKeyDown={handleKeyDown}\n      role=\"grid\"\n      aria-label=\"Timeline swimlane\"\n    >\n      {/* Pinned: breadcrumb (with minimap) + parent row */}\n      <div className={styles.pinnedSection}>\n        {breadcrumb && <BreadcrumbRow {...breadcrumb} minimap={minimap} />}\n      </div>\n\n      {/* Collapsible rows: parent + children */}\n      <div\n        className={clsx(\n          styles.collapsibleSection,\n          isCollapsed && styles.collapsibleCollapsed\n        )}\n      >\n        <div className={styles.collapsibleInner}>\n          <div className={styles.pinnedSection}>\n            {parentRow && renderRow(parentRow, 0)}\n          </div>\n          {childRows.length > 0 && (\n            <div className={styles.scrollSection}>\n              {childRows.map((layout, i) => renderRow(layout, i + 1))}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Collapse toggle on bottom border */}\n      <button\n        className={styles.collapseToggle}\n        onClick={toggleCollapsed}\n        title={isCollapsed ? \"Expand swimlanes\" : \"Collapse swimlanes\"}\n      >\n        <i\n          className={\n            isCollapsed\n              ? ApplicationIcons.expand.down\n              : ApplicationIcons.collapse.up\n          }\n        />\n      </button>\n\n      <BranchPopover\n        isOpen={branchPopover !== null && branchLookup !== null}\n        anchor={branchPopover?.element ?? null}\n        branches={branchLookup?.branches ?? []}\n        onSelect={handleBranchSelect}\n        onClose={() => setBranchPopover(null)}\n      />\n    </div>\n  );\n};\n\n// =============================================================================\n// SwimlaneRow (internal)\n// =============================================================================\n\ninterface SwimlaneRowProps {\n  layout: RowLayout;\n  parsedSelection: ParsedSelection | null;\n  onSelect: (spanIndex: number) => void;\n  onDrillDown: (spanIndex: number) => void;\n  onBranchClick: (forkedAt: string, element: HTMLElement) => void;\n}\n\nconst SwimlaneRow: FC<SwimlaneRowProps> = ({\n  layout,\n  parsedSelection,\n  onSelect,\n  onDrillDown,\n  onBranchClick,\n}) => {\n  const hasSelectedSpan = layout.spans.some((_, i) =>\n    isSpanSelected(layout, i, parsedSelection)\n  );\n\n  return (\n    <div className={styles.row} role=\"row\">\n      {/* Label cell */}\n      <div\n        className={clsx(\n          styles.label,\n          !layout.isParent && styles.labelChild,\n          hasSelectedSpan && styles.labelSelected\n        )}\n      >\n        {layout.name}\n        {layout.parallelCount !== null && (\n          <span className={styles.parallelBadge}>({layout.parallelCount})</span>\n        )}\n      </div>\n\n      {/* Bar area cell */}\n      <div className={styles.barArea}>\n        {/* Fills */}\n        {layout.spans.map((span, spanIndex) => (\n          <BarFill\n            key={spanIndex}\n            span={span}\n            isParent={layout.isParent}\n            isSelected={isSpanSelected(layout, spanIndex, parsedSelection)}\n            onSelect={() => onSelect(spanIndex)}\n            onDrillDown={() => onDrillDown(spanIndex)}\n          />\n        ))}\n\n        {/* Markers */}\n        {layout.markers.map((marker, i) => (\n          <MarkerGlyph key={i} marker={marker} onBranchClick={onBranchClick} />\n        ))}\n      </div>\n\n      {/* Token cell */}\n      <div className={styles.tokens}>\n        {formatTokenCount(layout.totalTokens)}\n      </div>\n    </div>\n  );\n};\n\n// =============================================================================\n// BreadcrumbRow (internal)\n// =============================================================================\n\nconst BreadcrumbRow: FC<BreadcrumbRowProps> = ({\n  breadcrumbs,\n  atRoot,\n  onGoUp,\n  onNavigate,\n  minimap,\n  selected,\n}) => {\n  // Extract display name from selected (strip span index suffix)\n  const selectedLabel = selected ? parsePathSegment(selected).name : null;\n\n  // Suppress selection when it duplicates the last breadcrumb (parent row = current node)\n  const lastBreadcrumb = breadcrumbs[breadcrumbs.length - 1];\n  const showSelection =\n    selectedLabel !== null &&\n    selectedLabel.toLowerCase() !== lastBreadcrumb?.label.toLowerCase();\n\n  return (\n    <div className={styles.breadcrumbRow}>\n      <button\n        className={styles.breadcrumbBack}\n        onClick={onGoUp}\n        disabled={atRoot}\n        title=\"Go up one level (Escape)\"\n      >\n        <i className={ApplicationIcons.navbar.back} />\n      </button>\n      {breadcrumbs.map((segment, i) => {\n        const isLast = i === breadcrumbs.length - 1;\n        return (\n          <span key={segment.path + i} className={styles.breadcrumbGroup}>\n            {i > 0 && (\n              <span className={styles.breadcrumbDivider}>{\"\\u203A\"}</span>\n            )}\n            {isLast ? (\n              <button\n                className={styles.breadcrumbCurrent}\n                onClick={() => onNavigate(segment.path)}\n              >\n                {segment.label}\n              </button>\n            ) : (\n              <button\n                className={styles.breadcrumbLink}\n                onClick={() => onNavigate(segment.path)}\n              >\n                {segment.label}\n              </button>\n            )}\n          </span>\n        );\n      })}\n      {showSelection && (\n        <span className={styles.breadcrumbGroup}>\n          <span className={styles.breadcrumbDivider}>{\"\\u203A\"}</span>\n          <span className={styles.breadcrumbSelection}>{selectedLabel}</span>\n        </span>\n      )}\n      {minimap && <TimelineMinimap {...minimap} />}\n    </div>\n  );\n};\n\n// =============================================================================\n// BarFill (internal)\n// =============================================================================\n\ninterface BarFillProps {\n  span: PositionedSpan;\n  isParent: boolean;\n  isSelected: boolean;\n  onSelect: () => void;\n  onDrillDown: () => void;\n}\n\nconst BarFill: FC<BarFillProps> = ({\n  span,\n  isParent,\n  isSelected,\n  onSelect,\n  onDrillDown,\n}) => {\n  const handleClick = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      onSelect();\n    },\n    [onSelect]\n  );\n\n  const handleDoubleClick = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (span.drillable) {\n        onDrillDown();\n      }\n    },\n    [span.drillable, onDrillDown]\n  );\n\n  const handleChevronClick = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      onDrillDown();\n    },\n    [onDrillDown]\n  );\n\n  return (\n    <>\n      <div\n        className={clsx(\n          styles.fill,\n          isParent && styles.fillParent,\n          isSelected && styles.fillSelected\n        )}\n        style={{\n          left: `${span.bar.left}%`,\n          width: `${span.bar.width}%`,\n        }}\n        title={span.description ?? undefined}\n        onClick={handleClick}\n        onDoubleClick={handleDoubleClick}\n      />\n      {span.drillable && (\n        <button\n          className={styles.chevron}\n          style={{\n            left: `${span.bar.left + span.bar.width}%`,\n          }}\n          onClick={handleChevronClick}\n          title=\"Drill down\"\n        >\n          {\"\\u203A\"}\n        </button>\n      )}\n    </>\n  );\n};\n\n// =============================================================================\n// MarkerGlyph (internal)\n// =============================================================================\n\ninterface MarkerGlyphProps {\n  marker: PositionedMarker;\n  onBranchClick: (forkedAt: string, element: HTMLElement) => void;\n}\n\nconst MarkerGlyph: FC<MarkerGlyphProps> = ({ marker, onBranchClick }) => {\n  const icon = MARKER_ICONS[marker.kind]?.icon ?? \"bi bi-question-circle\";\n  const kindClass =\n    marker.kind === \"error\"\n      ? styles.markerError\n      : marker.kind === \"compaction\"\n        ? styles.markerCompaction\n        : styles.markerBranch;\n\n  const handleClick = useCallback(\n    (e: React.MouseEvent<HTMLSpanElement>) => {\n      if (marker.kind === \"branch\") {\n        e.stopPropagation();\n        onBranchClick(marker.reference, e.currentTarget);\n      }\n    },\n    [marker.kind, marker.reference, onBranchClick]\n  );\n\n  return (\n    <span\n      className={clsx(styles.marker, kindClass)}\n      style={{ left: `${marker.left}%` }}\n      title={marker.tooltip}\n      onClick={handleClick}\n    >\n      <i className={icon} />\n    </span>\n  );\n};\n\n// =============================================================================\n// BranchPopover (internal)\n// =============================================================================\n\ninterface BranchPopoverProps {\n  isOpen: boolean;\n  anchor: HTMLElement | null;\n  branches: Array<{ branch: TimelineBranch; index: number }>;\n  onSelect: (branchSegment: string) => void;\n  onClose: () => void;\n}\n\nconst BranchPopover: FC<BranchPopoverProps> = ({\n  isOpen,\n  anchor,\n  branches,\n  onSelect,\n  onClose,\n}) => {\n  return (\n    <PopOver\n      id=\"branch-popover\"\n      isOpen={isOpen}\n      setIsOpen={(open) => {\n        if (!open) onClose();\n      }}\n      positionEl={anchor}\n      placement=\"bottom\"\n      showArrow={true}\n      hoverDelay={-1}\n      closeOnMouseLeave={false}\n      styles={{ padding: \"4px 0\" }}\n    >\n      <div className={styles.branchPopover}>\n        {branches.map(({ branch, index }) => {\n          const span = createBranchSpan(branch, index);\n          const durationSec =\n            (branch.endTime.getTime() - branch.startTime.getTime()) / 1000;\n          return (\n            <button\n              key={`branch-${index}`}\n              className={styles.branchEntry}\n              onClick={() => onSelect(`@branch-${index}`)}\n            >\n              <span className={styles.branchLabel}>{span.name}</span>\n              <span className={styles.branchMeta}>\n                {formatTokenCount(branch.totalTokens)}\n                {\" \\u00B7 \"}\n                {formatTime(durationSec)}\n              </span>\n            </button>\n          );\n        })}\n      </div>\n    </PopOver>\n  );\n};\n","import type {\n  TimelineBranch,\n  Timeline,\n  TimelineEvent,\n  TimelineSpan,\n} from \"../../components/transcript/timeline\";\nimport type {\n  CompactionEvent,\n  ModelEvent,\n  ToolEvent,\n} from \"../../types/api-types\";\n\nexport interface TimelineScenario {\n  name: string;\n  description: string;\n  timeline: Timeline;\n}\n\n/** Create a Date offset from a base time by the given number of seconds. */\nfunction ts(baseMs: number, offsetSeconds: number): Date {\n  return new Date(baseMs + offsetSeconds * 1000);\n}\n\nconst BASE = new Date(\"2025-01-15T10:00:00Z\").getTime();\n\n// ---------------------------------------------------------------------------\n// Shared constants\n// ---------------------------------------------------------------------------\n\nconst NULL_CONFIG: ModelEvent[\"config\"] = {\n  attempt_timeout: null,\n  batch: null,\n  best_of: null,\n  cache: null,\n  cache_prompt: null,\n  effort: null,\n  extra_body: null,\n  extra_headers: null,\n  frequency_penalty: null,\n  internal_tools: null,\n  logit_bias: null,\n  logprobs: null,\n  max_connections: null,\n  max_retries: null,\n  max_tokens: null,\n  max_tool_output: null,\n  num_choices: null,\n  parallel_tool_calls: null,\n  presence_penalty: null,\n  reasoning_effort: null,\n  reasoning_history: null,\n  reasoning_summary: null,\n  reasoning_tokens: null,\n  response_schema: null,\n  seed: null,\n  stop_seqs: null,\n  system_message: null,\n  temperature: null,\n  timeout: null,\n  top_k: null,\n  top_logprobs: null,\n  top_p: null,\n  verbosity: null,\n};\n\n// ---------------------------------------------------------------------------\n// Event factory functions\n// ---------------------------------------------------------------------------\n\nfunction makeModelEventNode(\n  content: string,\n  startSec: number,\n  endSec: number,\n  tokens: number,\n  uuid?: string\n): TimelineEvent {\n  const event: ModelEvent = {\n    event: \"model\",\n    model: \"claude-sonnet-4-5-20250929\",\n    input: [],\n    tools: [],\n    tool_choice: \"auto\",\n    config: NULL_CONFIG,\n    output: {\n      choices: [\n        {\n          message: {\n            role: \"assistant\",\n            content,\n            id: null,\n            metadata: null,\n            model: null,\n            source: null,\n            tool_calls: null,\n          },\n          stop_reason: \"stop\",\n          logprobs: null,\n        },\n      ],\n      completion: content,\n      error: null,\n      metadata: null,\n      model: \"claude-sonnet-4-5-20250929\",\n      time: endSec - startSec,\n      usage: {\n        input_tokens: Math.floor(tokens * 0.6),\n        output_tokens: Math.floor(tokens * 0.4),\n        total_tokens: tokens,\n        input_tokens_cache_read: null,\n        input_tokens_cache_write: null,\n        reasoning_tokens: null,\n        total_cost: null,\n      },\n    },\n    timestamp: ts(BASE, startSec).toISOString(),\n    working_start: startSec,\n    working_time: endSec - startSec,\n    cache: null,\n    call: null,\n    completed: null,\n    error: null,\n    metadata: null,\n    pending: null,\n    retries: null,\n    role: null,\n    span_id: null,\n    traceback: null,\n    traceback_ansi: null,\n    uuid: uuid ?? null,\n  };\n  return {\n    type: \"event\",\n    event,\n    startTime: ts(BASE, startSec),\n    endTime: ts(BASE, endSec),\n    totalTokens: tokens,\n  };\n}\n\nfunction makeToolEventNode(\n  fn: string,\n  args: Record<string, string>,\n  result: string,\n  startSec: number,\n  endSec: number,\n  tokens: number\n): TimelineEvent {\n  const event: ToolEvent = {\n    event: \"tool\",\n    type: \"function\",\n    function: fn,\n    id: `call-${fn}-${startSec}`,\n    arguments: args,\n    result,\n    events: [],\n    timestamp: ts(BASE, startSec).toISOString(),\n    working_start: startSec,\n    working_time: endSec - startSec,\n    agent: null,\n    completed: null,\n    error: null,\n    failed: null,\n    message_id: null,\n    metadata: null,\n    pending: null,\n    span_id: null,\n    truncated: null,\n    uuid: null,\n    view: null,\n  };\n  return {\n    type: \"event\",\n    event,\n    startTime: ts(BASE, startSec),\n    endTime: ts(BASE, endSec),\n    totalTokens: tokens,\n  };\n}\n\nfunction makeToolErrorEventNode(\n  fn: string,\n  errorMsg: string,\n  errorType: ToolEvent[\"error\"] extends { type: infer T } | null ? T : never,\n  startSec: number,\n  endSec: number,\n  tokens: number\n): TimelineEvent {\n  const event: ToolEvent = {\n    event: \"tool\",\n    type: \"function\",\n    function: fn,\n    id: `call-${fn}-${startSec}`,\n    arguments: {},\n    result: `Error: ${errorMsg}`,\n    events: [],\n    timestamp: ts(BASE, startSec).toISOString(),\n    working_start: startSec,\n    working_time: endSec - startSec,\n    error: { message: errorMsg, type: errorType },\n    failed: true,\n    agent: null,\n    completed: null,\n    message_id: null,\n    metadata: null,\n    pending: null,\n    span_id: null,\n    truncated: null,\n    uuid: null,\n    view: null,\n  };\n  return {\n    type: \"event\",\n    event,\n    startTime: ts(BASE, startSec),\n    endTime: ts(BASE, endSec),\n    totalTokens: tokens,\n  };\n}\n\nfunction makeModelErrorEventNode(\n  _content: string,\n  errorMsg: string,\n  startSec: number,\n  endSec: number,\n  tokens: number\n): TimelineEvent {\n  const event: ModelEvent = {\n    event: \"model\",\n    model: \"claude-sonnet-4-5-20250929\",\n    input: [],\n    tools: [],\n    tool_choice: \"auto\",\n    config: NULL_CONFIG,\n    output: {\n      choices: [],\n      completion: \"\",\n      error: errorMsg,\n      metadata: null,\n      model: \"claude-sonnet-4-5-20250929\",\n      time: endSec - startSec,\n      usage: {\n        input_tokens: Math.floor(tokens * 0.8),\n        output_tokens: Math.floor(tokens * 0.2),\n        total_tokens: tokens,\n        input_tokens_cache_read: null,\n        input_tokens_cache_write: null,\n        reasoning_tokens: null,\n        total_cost: null,\n      },\n    },\n    timestamp: ts(BASE, startSec).toISOString(),\n    working_start: startSec,\n    working_time: endSec - startSec,\n    cache: null,\n    call: null,\n    completed: null,\n    error: errorMsg,\n    metadata: null,\n    pending: null,\n    retries: null,\n    role: null,\n    span_id: null,\n    traceback: null,\n    traceback_ansi: null,\n    uuid: null,\n  };\n  return {\n    type: \"event\",\n    event,\n    startTime: ts(BASE, startSec),\n    endTime: ts(BASE, endSec),\n    totalTokens: tokens,\n  };\n}\n\nfunction makeCompactionEventNode(\n  tokensBefore: number,\n  tokensAfter: number,\n  startSec: number,\n  endSec: number\n): TimelineEvent {\n  const event: CompactionEvent = {\n    event: \"compaction\",\n    type: \"summary\",\n    tokens_before: tokensBefore,\n    tokens_after: tokensAfter,\n    timestamp: ts(BASE, startSec).toISOString(),\n    working_start: startSec,\n    metadata: null,\n    pending: null,\n    source: null,\n    span_id: null,\n    uuid: null,\n  };\n  return {\n    type: \"event\",\n    event,\n    startTime: ts(BASE, startSec),\n    endTime: ts(BASE, endSec),\n    totalTokens: 0,\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Helper factories\n// ---------------------------------------------------------------------------\n\nfunction makeSpan(\n  id: string,\n  name: string,\n  spanType: string | null,\n  startSec: number,\n  endSec: number,\n  tokens: number,\n  content: TimelineSpan[\"content\"] = [],\n  options?: {\n    branches?: TimelineBranch[];\n    utility?: boolean;\n    description?: string;\n  }\n): TimelineSpan {\n  return {\n    type: \"span\",\n    id,\n    name,\n    spanType,\n    content,\n    branches: options?.branches ?? [],\n    description: options?.description,\n    utility: options?.utility ?? false,\n    startTime: ts(BASE, startSec),\n    endTime: ts(BASE, endSec),\n    totalTokens: tokens,\n  };\n}\n\nfunction makeTimeline(\n  root: TimelineSpan,\n  options?: {\n    scoring?: TimelineSpan;\n  }\n): Timeline {\n  if (options?.scoring) {\n    // Fold scoring into root content and adjust totals\n    const scoring = options.scoring;\n    const newContent = [...root.content, scoring];\n    const endTime =\n      scoring.endTime > root.endTime ? scoring.endTime : root.endTime;\n    return {\n      name: \"Default\",\n      description: \"\",\n      root: {\n        ...root,\n        content: newContent,\n        endTime,\n        totalTokens: root.totalTokens + scoring.totalTokens,\n      },\n    };\n  }\n  return { name: \"Default\", description: \"\", root };\n}\n\n// ---------------------------------------------------------------------------\n// Scenarios\n// ---------------------------------------------------------------------------\n\n// S1: Sequential agents\nfunction sequentialAgents(): TimelineScenario {\n  const explore = makeSpan(\n    \"explore\",\n    \"Explore\",\n    \"agent\",\n    2,\n    14,\n    8100,\n    [\n      makeModelEventNode(\"Let me examine the project structure.\", 2, 5, 2400),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"find . -type f\" },\n        \"src/\\nlib/\\ntests/\",\n        5,\n        7,\n        800\n      ),\n      makeModelEventNode(\n        \"I see a standard project layout. Let me look at the main module.\",\n        7,\n        10,\n        2600\n      ),\n      makeToolEventNode(\n        \"read_file\",\n        { path: \"src/main.py\" },\n        \"def main(): ...\",\n        10,\n        12,\n        1200\n      ),\n      makeModelEventNode(\"The main entry point is clear.\", 12, 14, 1100),\n    ],\n    {\n      description: \"Explore the project structure and understand the codebase\",\n    }\n  );\n  const plan = makeSpan(\n    \"plan\",\n    \"Plan\",\n    \"agent\",\n    15,\n    24,\n    5300,\n    [\n      makeModelEventNode(\n        \"Based on my exploration, I'll plan the implementation.\",\n        15,\n        18,\n        1800\n      ),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"wc -l src/*.py\" },\n        \"142 total\",\n        18,\n        19,\n        400\n      ),\n      makeModelEventNode(\n        \"The plan is: 1) Refactor core module, 2) Add tests, 3) Update docs.\",\n        19,\n        24,\n        3100\n      ),\n    ],\n    {\n      description:\n        \"Create an implementation plan based on exploration findings\",\n    }\n  );\n  const build = makeSpan(\n    \"build\",\n    \"Build\",\n    \"agent\",\n    25,\n    52,\n    31800,\n    [\n      makeModelEventNode(\n        \"Starting implementation of the refactored module.\",\n        25,\n        29,\n        4200\n      ),\n      makeToolEventNode(\n        \"write_file\",\n        { path: \"src/core.py\" },\n        \"File written successfully\",\n        29,\n        32,\n        2800\n      ),\n      makeModelEventNode(\n        \"Core module done. Now adding test coverage.\",\n        32,\n        36,\n        3600\n      ),\n      makeToolEventNode(\n        \"write_file\",\n        { path: \"tests/test_core.py\" },\n        \"File written successfully\",\n        36,\n        40,\n        3200\n      ),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"pytest tests/\" },\n        \"5 passed\",\n        40,\n        44,\n        1000\n      ),\n      makeModelEventNode(\n        \"All tests pass. Updating documentation.\",\n        44,\n        48,\n        3400\n      ),\n      makeToolEventNode(\n        \"write_file\",\n        { path: \"docs/api.md\" },\n        \"File written successfully\",\n        48,\n        50,\n        2600\n      ),\n      makeModelEventNode(\n        \"Implementation complete with full test coverage.\",\n        50,\n        52,\n        11000\n      ),\n    ],\n    {\n      description:\n        \"Implement the refactored module with tests and documentation\",\n    }\n  );\n  const scoring = makeSpan(\"scoring\", \"Scoring\", \"scorers\", 53, 58, 3200);\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    58,\n    48500,\n    [\n      makeModelEventNode(\n        \"I'll work through this task step by step.\",\n        0,\n        2,\n        1500\n      ),\n      explore,\n      plan,\n      build,\n      makeModelEventNode(\"All phases complete. Task finished.\", 52, 53, 700),\n    ]\n  );\n\n  return {\n    name: \"Sequential agents\",\n    description: \"S1 — Explore → Plan → Build → Scoring\",\n    timeline: makeTimeline(transcript, { scoring }),\n  };\n}\n\n// S2: Iterative agents (multiple spans for same agent name)\nfunction iterativeAgents(): TimelineScenario {\n  const explore1 = makeSpan(\"explore-1\", \"Explore\", \"agent\", 2, 10, 7200, [\n    makeModelEventNode(\"Initial exploration of the codebase.\", 2, 5, 2800),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"ls -la src/\" },\n      \"core.py\\nutils.py\\nconfig.py\",\n      5,\n      6,\n      600\n    ),\n    makeModelEventNode(\"Found key files. Checking dependencies.\", 6, 9, 2400),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pip list\" },\n      \"requests==2.31\\nflask==3.0\",\n      9,\n      10,\n      1400\n    ),\n  ]);\n  const plan1 = makeSpan(\"plan-1\", \"Plan\", \"agent\", 11, 18, 4600, [\n    makeModelEventNode(\n      \"First iteration plan: focus on core module.\",\n      11,\n      14,\n      2200\n    ),\n    makeToolEventNode(\n      \"read_file\",\n      { path: \"src/core.py\" },\n      \"class Core: ...\",\n      14,\n      16,\n      1000\n    ),\n    makeModelEventNode(\"Need more info before finalizing plan.\", 16, 18, 1400),\n  ]);\n  const explore2 = makeSpan(\"explore-2\", \"Explore\", \"agent\", 19, 26, 7300, [\n    makeModelEventNode(\n      \"Second exploration pass: checking edge cases.\",\n      19,\n      22,\n      2600\n    ),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"grep -r 'TODO' src/\" },\n      \"core.py:12: TODO fix\",\n      22,\n      23,\n      800\n    ),\n    makeModelEventNode(\"Found TODOs. Reviewing test coverage.\", 23, 26, 3900),\n  ]);\n  const plan2 = makeSpan(\"plan-2\", \"Plan\", \"agent\", 27, 33, 4600, [\n    makeModelEventNode(\"Revised plan with edge case handling.\", 27, 30, 2400),\n    makeModelEventNode(\n      \"Plan finalized: address TODOs and add error handling.\",\n      30,\n      33,\n      2200\n    ),\n  ]);\n  const build = makeSpan(\"build\", \"Build\", \"agent\", 34, 55, 34600, [\n    makeModelEventNode(\"Implementing planned changes.\", 34, 38, 5200),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/core.py\" },\n      \"File written\",\n      38,\n      42,\n      4800\n    ),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/utils.py\" },\n      \"File written\",\n      42,\n      45,\n      3600\n    ),\n    makeModelEventNode(\"Running tests to verify changes.\", 45, 48, 3200),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pytest -v\" },\n      \"8 passed, 0 failed\",\n      48,\n      51,\n      1200\n    ),\n    makeModelEventNode(\"All tests pass. Build complete.\", 51, 55, 16600),\n  ]);\n  const scoring = makeSpan(\"scoring\", \"Scoring\", \"scorers\", 56, 60, 3200);\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    60,\n    61500,\n    [explore1, plan1, explore2, plan2, build]\n  );\n\n  return {\n    name: \"Iterative agents\",\n    description: \"S2 — Explore and Plan with multiple spans\",\n    timeline: makeTimeline(transcript, { scoring }),\n  };\n}\n\n// S3: Deep nesting (3 levels)\nfunction deepNesting(): TimelineScenario {\n  const generate = makeSpan(\"generate\", \"Generate\", \"agent\", 46, 58, 5800, [\n    makeModelEventNode(\"Generating test cases for the module.\", 46, 50, 2400),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"tests/test_gen.py\" },\n      \"File written\",\n      50,\n      54,\n      1800\n    ),\n    makeModelEventNode(\"Test cases generated successfully.\", 54, 58, 1600),\n  ]);\n  const run = makeSpan(\"run\", \"Run\", \"agent\", 59, 64, 400, [\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pytest tests/test_gen.py\" },\n      \"Running...\",\n      59,\n      61,\n      200\n    ),\n    makeToolErrorEventNode(\n      \"bash\",\n      \"Process timed out after 30s\",\n      \"timeout\",\n      61,\n      64,\n      200\n    ),\n  ]);\n  const evaluate = makeSpan(\"evaluate\", \"Evaluate\", \"agent\", 65, 75, 4200, [\n    makeModelEventNode(\n      \"Evaluating test results despite timeout.\",\n      65,\n      69,\n      1800\n    ),\n    makeToolEventNode(\n      \"read_file\",\n      { path: \"tests/test_gen.py\" },\n      \"def test_basic(): ...\",\n      69,\n      71,\n      600\n    ),\n    makeModelEventNode(\n      \"Test needs adjustment for timeout. Evaluation complete.\",\n      71,\n      75,\n      1800\n    ),\n  ]);\n\n  const code = makeSpan(\"code\", \"Code\", \"agent\", 22, 44, 15200, [\n    makeModelEventNode(\"Writing the core implementation.\", 22, 26, 3200),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/module.py\" },\n      \"File written\",\n      26,\n      30,\n      2800\n    ),\n    makeCompactionEventNode(12000, 6500, 30, 31),\n    makeModelEventNode(\"Continuing after context compaction.\", 31, 36, 4400),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/helpers.py\" },\n      \"File written\",\n      36,\n      40,\n      2400\n    ),\n    makeModelEventNode(\"Code implementation phase complete.\", 40, 44, 2400),\n  ]);\n  const test = makeSpan(\"test\", \"Test\", \"agent\", 45, 75, 10400, [\n    makeModelEventNode(\"Setting up test infrastructure.\", 45, 46, 600),\n    generate,\n    run,\n    evaluate,\n  ]);\n  const fix = makeSpan(\"fix\", \"Fix\", \"agent\", 76, 88, 6200, [\n    makeModelEventNode(\"Fixing the timeout issue in tests.\", 76, 80, 2200),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"tests/test_gen.py\" },\n      \"File updated\",\n      80,\n      83,\n      1800\n    ),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pytest tests/\" },\n      \"3 passed\",\n      83,\n      86,\n      800\n    ),\n    makeModelEventNode(\"All tests pass after fixes.\", 86, 88, 1400),\n  ]);\n\n  const explore = makeSpan(\"explore\", \"Explore\", \"agent\", 2, 18, 6400, [\n    makeModelEventNode(\"Examining the project structure.\", 2, 6, 2200),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"find . -type f\" },\n      \"src/\\nlib/\\ntests/\",\n      6,\n      9,\n      800\n    ),\n    makeModelEventNode(\"Project structure understood.\", 9, 14, 2000),\n    makeToolEventNode(\n      \"read_file\",\n      { path: \"src/main.py\" },\n      \"def main(): ...\",\n      14,\n      18,\n      1400\n    ),\n  ]);\n\n  const build = makeSpan(\"build\", \"Build\", \"agent\", 20, 88, 31800, [\n    makeModelEventNode(\"Starting the build process.\", 20, 22, 800),\n    code,\n    test,\n    fix,\n  ]);\n  const scoring = makeSpan(\"scoring\", \"Scoring\", \"scorers\", 90, 95, 3200);\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    95,\n    41400,\n    [explore, build]\n  );\n\n  return {\n    name: \"Deep nesting (3 levels)\",\n    description:\n      \"S3 — Explore → Build → Code/Test/Fix, Test → Generate/Run/Evaluate\",\n    timeline: makeTimeline(transcript, { scoring }),\n  };\n}\n\n// S4: Parallel agents\nfunction parallelAgents(): TimelineScenario {\n  const explore1 = makeSpan(\n    \"explore-1\",\n    \"Explore\",\n    \"agent\",\n    2,\n    14,\n    8100,\n    [\n      makeModelEventNode(\"Exploring API documentation.\", 2, 5, 2800),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"curl api/docs\" },\n        '{\"endpoints\": [...]}',\n        5,\n        8,\n        1400\n      ),\n      makeModelEventNode(\"API structure documented.\", 8, 11, 2200),\n      makeToolEventNode(\n        \"read_file\",\n        { path: \"api/schema.json\" },\n        '{\"type\": \"object\"}',\n        11,\n        14,\n        1700\n      ),\n    ],\n    { description: \"Search for API documentation\" }\n  );\n  const explore2 = makeSpan(\n    \"explore-2\",\n    \"Explore\",\n    \"agent\",\n    3,\n    16,\n    9400,\n    [\n      makeModelEventNode(\"Exploring database schema.\", 3, 7, 3200),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"sqlite3 db.sqlite .schema\" },\n        \"CREATE TABLE users ...\",\n        7,\n        10,\n        1600\n      ),\n      makeModelEventNode(\"Database schema analyzed.\", 10, 13, 2800),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"sqlite3 db.sqlite 'SELECT count(*) FROM users'\" },\n        \"1247\",\n        13,\n        16,\n        1800\n      ),\n    ],\n    { description: \"Analyze existing database schema and data\" }\n  );\n  const explore3 = makeSpan(\n    \"explore-3\",\n    \"Explore\",\n    \"agent\",\n    2,\n    12,\n    6800,\n    [\n      makeModelEventNode(\"Exploring frontend components.\", 2, 5, 2400),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"ls src/components/\" },\n        \"Header.tsx\\nFooter.tsx\",\n        5,\n        7,\n        800\n      ),\n      makeModelEventNode(\"Frontend component inventory complete.\", 7, 10, 2200),\n      makeToolEventNode(\n        \"read_file\",\n        { path: \"src/App.tsx\" },\n        \"function App() { ... }\",\n        10,\n        12,\n        1400\n      ),\n    ],\n    { description: \"Inventory frontend components and architecture\" }\n  );\n  const plan = makeSpan(\"plan\", \"Plan\", \"agent\", 17, 25, 5300, [\n    makeModelEventNode(\n      \"Synthesizing findings from all exploration tracks.\",\n      17,\n      20,\n      2400\n    ),\n    makeModelEventNode(\"Implementation plan ready.\", 20, 25, 2900),\n  ]);\n  const build = makeSpan(\"build\", \"Build\", \"agent\", 26, 52, 27600, [\n    makeModelEventNode(\"Starting full-stack implementation.\", 26, 30, 4200),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/api/routes.py\" },\n      \"File written\",\n      30,\n      34,\n      3800\n    ),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/components/Dashboard.tsx\" },\n      \"File written\",\n      34,\n      38,\n      4200\n    ),\n    makeModelEventNode(\n      \"Core components built. Adding integration.\",\n      38,\n      42,\n      3600\n    ),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"npm run build\" },\n      \"Build successful\",\n      42,\n      46,\n      1200\n    ),\n    makeModelEventNode(\"Build and integration complete.\", 46, 52, 10600),\n  ]);\n  const scoring = makeSpan(\"scoring\", \"Scoring\", \"scorers\", 53, 57, 3200);\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    57,\n    60400,\n    [explore1, explore2, explore3, plan, build]\n  );\n\n  return {\n    name: \"Parallel agents\",\n    description: \"S4 — Explore (3) parallel group + Plan + Build\",\n    timeline: makeTimeline(transcript, { scoring }),\n  };\n}\n\n// S5: Inline markers (error and compaction events)\nfunction inlineMarkers(): TimelineScenario {\n  const agent = makeSpan(\"agent\", \"Agent\", \"agent\", 2, 55, 42000, [\n    makeModelEventNode(\"Starting work on the task.\", 2, 6, 3200),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"npm install\" },\n      \"added 142 packages\",\n      6,\n      10,\n      1200\n    ),\n    makeModelEventNode(\"Dependencies installed. Writing code.\", 10, 16, 4800),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/feature.ts\" },\n      \"File written\",\n      16,\n      20,\n      3600\n    ),\n    makeModelErrorEventNode(\n      \"Attempting to call the API\",\n      \"Rate limit exceeded: 429 Too Many Requests\",\n      20,\n      24,\n      2400\n    ),\n    makeModelEventNode(\n      \"Retrying after rate limit. Adjusting approach.\",\n      24,\n      28,\n      3200\n    ),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"curl -X POST api/endpoint\" },\n      '{\"status\": \"ok\"}',\n      28,\n      31,\n      1400\n    ),\n    makeToolErrorEventNode(\n      \"bash\",\n      \"Command timed out after 60s\",\n      \"timeout\",\n      31,\n      35,\n      800\n    ),\n    makeModelEventNode(\n      \"Tool timed out. Working around the issue.\",\n      35,\n      39,\n      3800\n    ),\n    makeCompactionEventNode(15000, 8000, 39, 40),\n    makeModelEventNode(\n      \"Context compacted. Continuing with reduced history.\",\n      40,\n      45,\n      5200\n    ),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/feature.ts\" },\n      \"File updated\",\n      45,\n      49,\n      4800\n    ),\n    makeModelEventNode(\"Feature implementation complete.\", 49, 55, 7600),\n  ]);\n  const scoring = makeSpan(\"scoring\", \"Scoring\", \"scorers\", 56, 60, 3200);\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    60,\n    45200,\n    [agent]\n  );\n\n  return {\n    name: \"Inline markers\",\n    description: \"S5 — Agent with error and compaction events\",\n    timeline: makeTimeline(transcript, { scoring }),\n  };\n}\n\n// S7: Flat transcript (single agent, no children)\nfunction flatTranscript(): TimelineScenario {\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    40,\n    12400,\n    [\n      makeModelEventNode(\"Analyzing the user request.\", 0, 4, 1800),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"ls -la\" },\n        \"total 42\\ndrwxr-xr-x ...\",\n        4,\n        6,\n        600\n      ),\n      makeModelEventNode(\n        \"I see the project files. Let me read the config.\",\n        6,\n        10,\n        2200\n      ),\n      makeToolEventNode(\n        \"read_file\",\n        { path: \"config.yaml\" },\n        \"port: 8080\\ndb: postgres\",\n        10,\n        12,\n        800\n      ),\n      makeModelEventNode(\n        \"Configuration loaded. Making the requested change.\",\n        12,\n        18,\n        2400\n      ),\n      makeToolEventNode(\n        \"write_file\",\n        { path: \"config.yaml\" },\n        \"port: 9090\\ndb: postgres\",\n        18,\n        20,\n        600\n      ),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"python validate.py\" },\n        \"Config valid\",\n        20,\n        23,\n        400\n      ),\n      makeModelEventNode(\n        \"Change applied and validated successfully.\",\n        23,\n        28,\n        1800\n      ),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"python -m pytest\" },\n        \"12 passed\",\n        28,\n        34,\n        800\n      ),\n      makeModelEventNode(\"All tests pass. Task complete.\", 34, 40, 900),\n    ]\n  );\n\n  return {\n    name: \"Flat transcript\",\n    description: \"S7 — Single agent, no children, just events\",\n    timeline: makeTimeline(transcript),\n  };\n}\n\n// S8: Many rows (8+ agents to test scrolling)\nfunction manyRows(): TimelineScenario {\n  const names = [\n    \"Research\",\n    \"Analyze\",\n    \"Design\",\n    \"Implement\",\n    \"Test\",\n    \"Review\",\n    \"Refactor\",\n    \"Deploy\",\n    \"Monitor\",\n    \"Cleanup\",\n  ];\n\n  const agentEvents: [string, Record<string, string>, string][][] = [\n    // Research\n    [[\"bash\", { cmd: \"search docs\" }, \"Found 5 relevant docs\"]],\n    // Analyze\n    [[\"read_file\", { path: \"src/main.py\" }, \"class Main: ...\"]],\n    // Design\n    [[\"write_file\", { path: \"design.md\" }, \"Written\"]],\n    // Implement\n    [[\"write_file\", { path: \"src/feature.py\" }, \"Written\"]],\n    // Test — model error agent\n    [[\"bash\", { cmd: \"pytest\" }, \"3 passed, 1 failed\"]],\n    // Review\n    [[\"bash\", { cmd: \"ruff check src/\" }, \"All checks passed\"]],\n    // Refactor — compaction agent\n    [[\"write_file\", { path: \"src/refactored.py\" }, \"Written\"]],\n    // Deploy\n    [[\"bash\", { cmd: \"docker build .\" }, \"Successfully built abc123\"]],\n    // Monitor\n    [[\"bash\", { cmd: \"curl health\" }, '{\"status\":\"healthy\"}']],\n    // Cleanup\n    [[\"bash\", { cmd: \"rm -rf tmp/\" }, \"Cleaned\"]],\n  ];\n\n  const agents: TimelineSpan[] = [];\n  let offset = 2;\n  let totalTokens = 0;\n  for (let i = 0; i < names.length; i++) {\n    const duration = 4 + Math.floor(i * 0.5);\n    const tokens = 2000 + i * 1100;\n    const name = names[i] ?? `Agent ${i}`;\n    const evts = agentEvents[i] ?? [];\n    const mid = offset + Math.floor(duration / 2);\n\n    const content: (TimelineEvent | TimelineSpan)[] = [\n      makeModelEventNode(\n        `Starting ${name.toLowerCase()} phase.`,\n        offset,\n        mid,\n        Math.floor(tokens * 0.4)\n      ),\n    ];\n\n    for (const [fn, args, result] of evts) {\n      content.push(\n        makeToolEventNode(\n          fn,\n          args,\n          result,\n          mid,\n          mid + 1,\n          Math.floor(tokens * 0.2)\n        )\n      );\n    }\n\n    // Add model error on Test agent (index 4)\n    if (i === 4) {\n      content.push(\n        makeModelErrorEventNode(\n          \"Attempting test analysis\",\n          \"Context length exceeded\",\n          mid + 1,\n          mid + 2,\n          Math.floor(tokens * 0.1)\n        )\n      );\n    }\n\n    // Add compaction on Refactor agent (index 6)\n    if (i === 6) {\n      content.push(makeCompactionEventNode(9000, 5000, mid + 1, mid + 2));\n    }\n\n    content.push(\n      makeModelEventNode(\n        `${name} phase complete.`,\n        offset + duration - 1,\n        offset + duration,\n        Math.floor(tokens * 0.3)\n      )\n    );\n\n    agents.push(\n      makeSpan(\n        `agent-${i}`,\n        name,\n        \"agent\",\n        offset,\n        offset + duration,\n        tokens,\n        content\n      )\n    );\n    totalTokens += tokens;\n    offset += duration + 1;\n  }\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    offset,\n    totalTokens,\n    agents\n  );\n\n  return {\n    name: \"Many rows (8+)\",\n    description: \"S8 — Tests 6-row cap / scrolling with 10 agents\",\n    timeline: makeTimeline(transcript),\n  };\n}\n\n// S10: Utility agents\nfunction utilityAgents(): TimelineScenario {\n  const util1 = makeSpan(\n    \"util-1\",\n    \"bash_checker\",\n    \"agent\",\n    3,\n    4,\n    300,\n    [\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"shellcheck script.sh\" },\n        \"No issues\",\n        3,\n        4,\n        300\n      ),\n    ],\n    {\n      utility: true,\n    }\n  );\n  const util2 = makeSpan(\n    \"util-2\",\n    \"safety_validator\",\n    \"agent\",\n    8,\n    9,\n    200,\n    [makeToolEventNode(\"validate\", { rule: \"safety\" }, \"Pass\", 8, 9, 200)],\n    {\n      utility: true,\n    }\n  );\n  const util3 = makeSpan(\n    \"util-3\",\n    \"bash_checker\",\n    \"agent\",\n    14,\n    15,\n    300,\n    [\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"shellcheck deploy.sh\" },\n        \"No issues\",\n        14,\n        15,\n        300\n      ),\n    ],\n    {\n      utility: true,\n    }\n  );\n  const util4 = makeSpan(\n    \"util-4\",\n    \"format_checker\",\n    \"agent\",\n    20,\n    21,\n    250,\n    [\n      makeToolEventNode(\n        \"format\",\n        { target: \"src/\" },\n        \"All files formatted\",\n        20,\n        21,\n        250\n      ),\n    ],\n    {\n      utility: true,\n    }\n  );\n  const mainAgent = makeSpan(\"main\", \"Build\", \"agent\", 2, 45, 28000, [\n    makeModelEventNode(\"Starting build with safety checks.\", 2, 3, 1200),\n    util1,\n    makeModelEventNode(\n      \"Bash check passed. Writing implementation.\",\n      4,\n      8,\n      3800\n    ),\n    util2,\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/build.py\" },\n      \"Written\",\n      9,\n      13,\n      4200\n    ),\n    makeModelEventNode(\n      \"Core written. Continuing with more code.\",\n      13,\n      14,\n      2400\n    ),\n    util3,\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/deploy.py\" },\n      \"Written\",\n      15,\n      19,\n      3600\n    ),\n    makeModelEventNode(\n      \"Deploy script ready. Running format check.\",\n      19,\n      20,\n      2200\n    ),\n    util4,\n    makeModelEventNode(\"All checks passed. Build complete.\", 21, 30, 4800),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"python -m build\" },\n      \"Build successful\",\n      30,\n      40,\n      2400\n    ),\n    makeModelEventNode(\"Package built and ready.\", 40, 45, 3400),\n  ]);\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    50,\n    29050,\n    [mainAgent]\n  );\n\n  return {\n    name: \"Utility agents\",\n    description: \"S10 — Agent with multiple utility children\",\n    timeline: makeTimeline(transcript),\n  };\n}\n\n// S11a: Branches (single fork)\nfunction branchesSingleFork(): TimelineScenario {\n  const branch1Refactor = makeSpan(\n    \"branch1-refactor\",\n    \"Refactor\",\n    \"agent\",\n    15,\n    22,\n    5200,\n    [\n      makeModelEventNode(\"Refactoring the module for clarity.\", 15, 18, 2400),\n      makeToolEventNode(\n        \"write_file\",\n        { path: \"src/refactored.py\" },\n        \"Written\",\n        18,\n        20,\n        1600\n      ),\n      makeModelEventNode(\"Refactoring complete.\", 20, 22, 1200),\n    ]\n  );\n  const branch1Validate = makeSpan(\n    \"branch1-validate\",\n    \"Validate\",\n    \"agent\",\n    23,\n    28,\n    3500,\n    [\n      makeModelEventNode(\"Validating the refactored code.\", 23, 25, 1400),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"pytest tests/\" },\n        \"6 passed\",\n        25,\n        27,\n        800\n      ),\n      makeModelEventNode(\"Validation passed.\", 27, 28, 1300),\n    ]\n  );\n\n  const branch1: TimelineBranch = {\n    type: \"branch\",\n    forkedAt: \"model-call-5\",\n    content: [branch1Refactor, branch1Validate],\n    startTime: ts(BASE, 15),\n    endTime: ts(BASE, 28),\n    totalTokens: 8700,\n  };\n\n  const branch2Rewrite = makeSpan(\n    \"branch2-rewrite\",\n    \"Rewrite\",\n    \"agent\",\n    15,\n    25,\n    5100,\n    [\n      makeModelEventNode(\n        \"Taking a different approach: full rewrite.\",\n        15,\n        19,\n        2200\n      ),\n      makeToolEventNode(\n        \"write_file\",\n        { path: \"src/rewritten.py\" },\n        \"Written\",\n        19,\n        22,\n        1800\n      ),\n      makeModelEventNode(\"Rewrite approach complete.\", 22, 25, 1100),\n    ]\n  );\n\n  const branch2: TimelineBranch = {\n    type: \"branch\",\n    forkedAt: \"model-call-5\",\n    content: [branch2Rewrite],\n    startTime: ts(BASE, 15),\n    endTime: ts(BASE, 25),\n    totalTokens: 5100,\n  };\n\n  const code = makeSpan(\"code\", \"Code\", \"agent\", 2, 24, 15200, [\n    makeModelEventNode(\"Writing initial implementation.\", 2, 6, 4200),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/module.py\" },\n      \"Written\",\n      6,\n      10,\n      3200\n    ),\n    makeModelEventNode(\n      \"Initial code written. Iterating on design.\",\n      10,\n      16,\n      4400\n    ),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/module.py\" },\n      \"Updated\",\n      16,\n      20,\n      2000\n    ),\n    makeModelEventNode(\"Code phase finalized.\", 20, 24, 1400),\n  ]);\n  const test = makeSpan(\"test\", \"Test\", \"agent\", 25, 40, 10400, [\n    makeModelEventNode(\"Setting up test suite.\", 25, 28, 2200),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"tests/test_module.py\" },\n      \"Written\",\n      28,\n      32,\n      3400\n    ),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pytest tests/\" },\n      \"7 passed\",\n      32,\n      36,\n      1200\n    ),\n    makeModelEventNode(\"All tests passing.\", 36, 40, 3600),\n  ]);\n\n  const build = makeSpan(\n    \"build\",\n    \"Build\",\n    \"agent\",\n    1,\n    52,\n    31800,\n    [\n      makeModelEventNode(\n        \"Starting build with branching strategy.\",\n        1,\n        2,\n        800,\n        \"model-call-5\"\n      ),\n      code,\n      test,\n      makeModelEventNode(\"Build complete. Best branch selected.\", 40, 52, 5400),\n    ],\n    {\n      branches: [branch1, branch2],\n    }\n  );\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    55,\n    31800,\n    [build]\n  );\n\n  return {\n    name: \"Branches (single fork)\",\n    description: \"S11 — Agent with 2 branches at one fork point\",\n    timeline: makeTimeline(transcript),\n  };\n}\n\n// S11b: Branches (multiple forks)\nfunction branchesMultipleForks(): TimelineScenario {\n  const earlyAttempt = makeSpan(\n    \"early-attempt\",\n    \"Attempt\",\n    \"agent\",\n    8,\n    14,\n    4200,\n    [\n      makeModelEventNode(\"Early attempt at solving the problem.\", 8, 11, 2000),\n      makeToolEventNode(\n        \"bash\",\n        { cmd: \"python solve.py\" },\n        \"Partial result\",\n        11,\n        13,\n        1200\n      ),\n      makeModelEventNode(\"Attempt did not fully succeed.\", 13, 14, 1000),\n    ]\n  );\n\n  const earlyBranch: TimelineBranch = {\n    type: \"branch\",\n    forkedAt: \"model-call-3\",\n    content: [earlyAttempt],\n    startTime: ts(BASE, 8),\n    endTime: ts(BASE, 14),\n    totalTokens: 4200,\n  };\n\n  const lateRetry = makeSpan(\"late-retry\", \"Retry\", \"agent\", 30, 38, 3800, [\n    makeModelEventNode(\"Retrying with modified parameters.\", 30, 33, 1600),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"python solve.py --retry\" },\n      \"Better result\",\n      33,\n      36,\n      1000\n    ),\n    makeModelEventNode(\"Retry showed improvement.\", 36, 38, 1200),\n  ]);\n\n  const lateBranch1: TimelineBranch = {\n    type: \"branch\",\n    forkedAt: \"model-call-10\",\n    content: [lateRetry],\n    startTime: ts(BASE, 30),\n    endTime: ts(BASE, 38),\n    totalTokens: 3800,\n  };\n\n  const lateAlt = makeSpan(\"late-alt\", \"Alternative\", \"agent\", 30, 42, 6100, [\n    makeModelEventNode(\n      \"Trying a completely different algorithm.\",\n      30,\n      34,\n      2400\n    ),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/alt_solver.py\" },\n      \"Written\",\n      34,\n      37,\n      1800\n    ),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"python alt_solver.py\" },\n      \"Success!\",\n      37,\n      40,\n      800\n    ),\n    makeModelEventNode(\"Alternative approach succeeded.\", 40, 42, 1100),\n  ]);\n\n  const lateBranch2: TimelineBranch = {\n    type: \"branch\",\n    forkedAt: \"model-call-10\",\n    content: [lateAlt],\n    startTime: ts(BASE, 30),\n    endTime: ts(BASE, 42),\n    totalTokens: 6100,\n  };\n\n  const code = makeSpan(\"code\", \"Code\", \"agent\", 2, 28, 15200, [\n    makeModelEventNode(\"Beginning code implementation.\", 2, 6, 3600),\n    makeToolEventNode(\n      \"write_file\",\n      { path: \"src/solver.py\" },\n      \"Written\",\n      6,\n      10,\n      2800\n    ),\n    makeModelEventNode(\"Core solver implemented.\", 10, 16, 4200),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"python solver.py\" },\n      \"Initial results\",\n      16,\n      20,\n      1400\n    ),\n    makeModelEventNode(\"Optimizing the solver.\", 20, 28, 3200),\n  ]);\n  const test = makeSpan(\"test\", \"Test\", \"agent\", 29, 48, 10400, [\n    makeModelEventNode(\"Running comprehensive test suite.\", 29, 33, 2800),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pytest tests/ -v\" },\n      \"12 passed\",\n      33,\n      38,\n      1600\n    ),\n    makeModelEventNode(\"Tests validated. Checking edge cases.\", 38, 43, 3200),\n    makeToolEventNode(\n      \"bash\",\n      { cmd: \"pytest tests/edge_cases.py\" },\n      \"4 passed\",\n      43,\n      46,\n      1000\n    ),\n    makeModelEventNode(\"All edge cases handled.\", 46, 48, 1800),\n  ]);\n\n  const build = makeSpan(\n    \"build\",\n    \"Build\",\n    \"agent\",\n    1,\n    55,\n    31800,\n    [\n      makeModelEventNode(\n        \"Starting build with exploration branches.\",\n        1,\n        2,\n        600,\n        \"model-call-3\"\n      ),\n      code,\n      makeModelEventNode(\n        \"Evaluating approaches.\",\n        28,\n        29,\n        400,\n        \"model-call-10\"\n      ),\n      test,\n      makeModelEventNode(\n        \"Build finalized after exploring alternatives.\",\n        48,\n        55,\n        5800\n      ),\n    ],\n    {\n      branches: [earlyBranch, lateBranch1, lateBranch2],\n    }\n  );\n\n  const transcript = makeSpan(\n    \"transcript\",\n    \"Transcript\",\n    \"agent\",\n    0,\n    58,\n    31800,\n    [build]\n  );\n\n  return {\n    name: \"Branches (multiple forks)\",\n    description: \"S11 — Agent with branches at different fork points\",\n    timeline: makeTimeline(transcript),\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Export all scenarios\n// ---------------------------------------------------------------------------\n\nexport const timelineScenarios: TimelineScenario[] = [\n  sequentialAgents(),\n  iterativeAgents(),\n  deepNesting(),\n  parallelAgents(),\n  inlineMarkers(),\n  flatTranscript(),\n  manyRows(),\n  utilityAgents(),\n  branchesSingleFork(),\n  branchesMultipleForks(),\n];\n","/**\n * Bridge from timeline spans to raw Event[] for the transcript display pipeline.\n *\n * Resolves the selected swimlane row to TimelineSpan(s), then walks their\n * content trees to produce a flat Event[] that can be fed through useEventNodes.\n * Child TimelineSpans are re-emitted as synthetic span_begin/span_end events\n * so treeifyEvents can reconstruct the hierarchy.\n */\n\nimport type {\n  TimelineEvent,\n  TimelineSpan,\n} from \"../../components/transcript/timeline\";\nimport type {\n  Event,\n  SpanBeginEvent,\n  SpanEndEvent,\n} from \"../../types/api-types\";\n\nimport type { MinimapSelection } from \"./components/TimelineMinimap\";\nimport { parsePathSegment } from \"./hooks/useTimeline\";\nimport {\n  type SwimlaneRow,\n  getAgents,\n  isParallelSpan,\n  isSingleSpan,\n} from \"./utils/swimlaneRows\";\n\n// =============================================================================\n// Row lookup\n// =============================================================================\n\n/** Find a swimlane row by name (case-insensitive). */\nfunction findRowByName(\n  rows: SwimlaneRow[],\n  name: string\n): SwimlaneRow | undefined {\n  return rows.find((r) => r.name.toLowerCase() === name.toLowerCase());\n}\n\n// =============================================================================\n// Selected spans\n// =============================================================================\n\n/**\n * Resolves the selected swimlane row identifier to TimelineSpan(s).\n *\n * For single-span rows, returns the single agent. For parallel rows with a\n * span index suffix (e.g. \"Explore-2\"), returns the specific agent. For\n * parallel rows without a suffix, returns all agents.\n */\nexport function getSelectedSpans(\n  rows: SwimlaneRow[],\n  selected: string | null\n): TimelineSpan[] {\n  if (!selected) return [];\n\n  const { name, spanIndex } = parsePathSegment(selected);\n  const row = findRowByName(rows, name);\n  if (!row) return [];\n\n  const result: TimelineSpan[] = [];\n  for (const rowSpan of row.spans) {\n    if (isSingleSpan(rowSpan)) {\n      result.push(rowSpan.agent);\n    } else if (isParallelSpan(rowSpan)) {\n      if (spanIndex !== null) {\n        const agent = rowSpan.agents[spanIndex - 1];\n        if (agent) result.push(agent);\n      } else {\n        result.push(...rowSpan.agents);\n      }\n    }\n  }\n  return result;\n}\n\n// =============================================================================\n// Minimap selection\n// =============================================================================\n\n/**\n * Computes the minimap selection for the currently selected swimlane row.\n *\n * Resolves a single visually-highlighted span: for iterative rows, the\n * specific SingleSpan is selected; for parallel rows with a span index,\n * the specific agent. Without an index, the envelope of all parallel agents\n * is returned.\n */\nexport function computeMinimapSelection(\n  rows: SwimlaneRow[],\n  selected: string | null\n): MinimapSelection | undefined {\n  if (!selected) return undefined;\n  const { name, spanIndex } = parsePathSegment(selected);\n  const row = findRowByName(rows, name);\n  if (!row) return undefined;\n\n  const targetIndex = (spanIndex ?? 1) - 1;\n  for (const rowSpan of row.spans) {\n    if (isSingleSpan(rowSpan)) {\n      const singleIndex = row.spans.indexOf(rowSpan);\n      if (singleIndex === targetIndex || row.spans.length === 1) {\n        const agent = rowSpan.agent;\n        return {\n          startTime: agent.startTime,\n          endTime: agent.endTime,\n          totalTokens: agent.totalTokens,\n        };\n      }\n    } else if (isParallelSpan(rowSpan)) {\n      if (spanIndex !== null) {\n        const agent = rowSpan.agents[spanIndex - 1];\n        if (agent) {\n          return {\n            startTime: agent.startTime,\n            endTime: agent.endTime,\n            totalTokens: agent.totalTokens,\n          };\n        }\n      }\n      // No index → envelope of all parallel agents\n      const agents = getAgents(rowSpan);\n      const first = agents[0]!;\n      let start = first.startTime;\n      let end = first.endTime;\n      let tokens = first.totalTokens;\n      for (let i = 1; i < agents.length; i++) {\n        const a = agents[i]!;\n        if (a.startTime < start) start = a.startTime;\n        if (a.endTime > end) end = a.endTime;\n        tokens += a.totalTokens;\n      }\n      return { startTime: start, endTime: end, totalTokens: tokens };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Collects raw Event[] from TimelineSpan content trees.\n *\n * Walks the content recursively. For TimelineEvent items, emits the wrapped\n * raw Event. For child TimelineSpan items, emits synthetic span_begin/span_end\n * events bracketing the recursed content, so treeifyEvents can rebuild the\n * parent-child hierarchy via span_id matching.\n */\nexport function collectRawEvents(spans: TimelineSpan[]): Event[] {\n  const events: Event[] = [];\n  for (const span of spans) {\n    collectFromContent(span.content, events);\n  }\n  return events;\n}\n\nfunction collectFromContent(\n  content: ReadonlyArray<TimelineEvent | TimelineSpan>,\n  out: Event[]\n): void {\n  for (const item of content) {\n    if (item.type === \"event\") {\n      out.push(item.event);\n    } else {\n      // Emit synthetic span_begin\n      const beginEvent: SpanBeginEvent = {\n        event: \"span_begin\",\n        name: item.name,\n        id: item.id,\n        span_id: item.id,\n        type: item.spanType,\n        timestamp: item.startTime.toISOString(),\n        parent_id: null,\n        pending: false,\n        working_start: 0,\n        uuid: null,\n        metadata: null,\n      };\n      out.push(beginEvent);\n\n      // Recurse into child content\n      collectFromContent(item.content, out);\n\n      // Emit synthetic span_end\n      const endEvent: SpanEndEvent = {\n        event: \"span_end\",\n        id: `${item.id}-end`,\n        span_id: item.id,\n        timestamp: item.endTime.toISOString(),\n        pending: false,\n        working_start: 0,\n        uuid: null,\n        metadata: null,\n      };\n      out.push(endEvent);\n    }\n  }\n}\n","import {\n  VscodeOption,\n  VscodeSingleSelect,\n} from \"@vscode-elements/react-elements\";\nimport clsx from \"clsx\";\nimport { FC, useEffect, useMemo, useState } from \"react\";\n\nimport { ApplicationIcons } from \"../../components/icons\";\nimport { useEventNodes } from \"../../components/transcript/hooks/useEventNodes\";\nimport { TranscriptOutline } from \"../../components/transcript/outline/TranscriptOutline\";\nimport { TranscriptViewNodes } from \"../../components/transcript/TranscriptViewNodes\";\nimport { useDocumentTitle } from \"../../hooks/useDocumentTitle\";\nimport { useProperty } from \"../../state/hooks/useProperty\";\n\nimport { TimelinePills } from \"./components/TimelinePills\";\nimport { TimelineSwimLanes } from \"./components/TimelineSwimLanes\";\nimport { useTimeline } from \"./hooks/useTimeline\";\nimport { timelineScenarios } from \"./syntheticNodes\";\nimport {\n  collectRawEvents,\n  computeMinimapSelection,\n  getSelectedSpans,\n} from \"./timelineEventNodes\";\nimport styles from \"./TimelinePanel.module.css\";\nimport type { MarkerDepth } from \"./utils/markers\";\nimport { computeRowLayouts } from \"./utils/swimlaneLayout\";\n\nexport const TimelinePanel: FC = () => {\n  useDocumentTitle(\"Timeline\");\n\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const [markerDepth, setMarkerDepth] = useState<MarkerDepth>(\"children\");\n  const [outlineCollapsed, setOutlineCollapsed] = useProperty<boolean>(\n    \"timeline\",\n    \"outlineCollapsed\",\n    { defaultValue: true, cleanup: false }\n  );\n  const isOutlineCollapsed = !!outlineCollapsed;\n  const scenario = timelineScenarios[selectedIndex];\n\n  const timeline = scenario?.timeline;\n  const state = useTimeline(timeline!);\n\n  // Clear drill-down path on mount so reloads start at root\n  useEffect(() => {\n    state.navigateTo(\"\");\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const layouts = useMemo(\n    () =>\n      computeRowLayouts(\n        state.rows,\n        state.node.startTime,\n        state.node.endTime,\n        markerDepth\n      ),\n    [state.rows, state.node.startTime, state.node.endTime, markerDepth]\n  );\n\n  const atRoot = state.breadcrumbs.length <= 1;\n\n  // Resolved spans for the selected swimlane row (all spans, for event display)\n  const selectedSpans = useMemo(\n    () => getSelectedSpans(state.rows, state.selected),\n    [state.rows, state.selected]\n  );\n\n  const minimapSelection = useMemo(\n    () => computeMinimapSelection(state.rows, state.selected),\n    [state.rows, state.selected]\n  );\n\n  const rawEvents = useMemo(\n    () => collectRawEvents(selectedSpans),\n    [selectedSpans]\n  );\n  const { eventNodes, defaultCollapsedIds } = useEventNodes(rawEvents, false);\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.headerRow}>\n        <h2 className={styles.title}>Timeline</h2>\n        <VscodeSingleSelect\n          value={String(selectedIndex)}\n          onChange={(e) => {\n            const target = e.target as HTMLSelectElement;\n            setSelectedIndex(Number(target.value));\n            state.navigateTo(\"\");\n          }}\n          className={styles.scenarioSelect}\n        >\n          {timelineScenarios.map((s, i) => (\n            <VscodeOption key={i} value={String(i)}>\n              {s.name}\n            </VscodeOption>\n          ))}\n        </VscodeSingleSelect>\n        <VscodeSingleSelect\n          value={markerDepth}\n          onChange={(e) => {\n            const target = e.target as HTMLSelectElement;\n            setMarkerDepth(target.value as MarkerDepth);\n          }}\n          className={styles.markerDepthSelect}\n        >\n          <VscodeOption value=\"direct\">Markers: direct</VscodeOption>\n          <VscodeOption value=\"children\">Markers: children</VscodeOption>\n          <VscodeOption value=\"recursive\">Markers: recursive</VscodeOption>\n        </VscodeSingleSelect>\n        <span className={styles.scenarioDescription}>\n          {scenario?.description}\n        </span>\n      </div>\n      <div className={styles.content}>\n        <TimelinePills timelines={[]} activeIndex={0} onSelect={() => {}} />\n        <TimelineSwimLanes\n          layouts={layouts}\n          selected={state.selected}\n          node={state.node}\n          onSelect={state.select}\n          onDrillDown={state.drillDown}\n          onBranchDrillDown={state.drillDown}\n          onGoUp={state.goUp}\n          minimap={{\n            root: timeline!.root,\n            selection: minimapSelection,\n          }}\n          breadcrumb={{\n            breadcrumbs: state.breadcrumbs,\n            atRoot,\n            onGoUp: state.goUp,\n            onNavigate: state.navigateTo,\n            selected: state.selected,\n          }}\n        />\n        {eventNodes.length > 0 ? (\n          <div\n            className={clsx(\n              styles.eventsContainer,\n              isOutlineCollapsed && styles.outlineCollapsed\n            )}\n          >\n            <div className={styles.outlinePane}>\n              {!isOutlineCollapsed && (\n                <TranscriptOutline\n                  eventNodes={eventNodes}\n                  defaultCollapsedIds={defaultCollapsedIds}\n                  className={styles.outline}\n                />\n              )}\n              <div\n                className={styles.outlineToggle}\n                onClick={() => setOutlineCollapsed(!isOutlineCollapsed)}\n              >\n                <i className={ApplicationIcons.sidebar} />\n              </div>\n            </div>\n            <div className={styles.eventsSeparator} />\n            <div className={styles.eventList}>\n              <TranscriptViewNodes\n                id=\"timeline-events\"\n                eventNodes={eventNodes}\n                defaultCollapsedIds={defaultCollapsedIds}\n              />\n            </div>\n          </div>\n        ) : (\n          <div className={styles.emptyEvents}>\n            Select a swimlane row to view events\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n"],"names":["jsx","styles","row","label","useMemo","useCallback","tokens","bar","jsxs","Fragment","minimap","branchPopover","useState","marker","content","outlineCollapsed","useEffect"],"mappings":"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"}