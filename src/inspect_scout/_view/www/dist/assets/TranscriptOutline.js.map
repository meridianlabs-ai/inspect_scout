{"version":3,"file":"TranscriptOutline.js","sources":["../../src/utils/python.ts","../../src/components/transcript/outline/OutlineRow.tsx","../../src/components/transcript/outline/tree-visitors.ts","../../src/components/transcript/outline/TranscriptOutline.tsx"],"sourcesContent":["/**\n * Extracts the package and module names from a fully qualified Python module path\n *\n * @param name - A Python import path that may include a package name\n * @returns An object containing the package and module names\n */\nexport const parsePackageName = (name: string): PythonName => {\n  if (name.includes(\"/\")) {\n    const [packageName, moduleName] = name.split(\"/\", 2);\n    return { package: packageName || \"\", module: moduleName || \"\" };\n  }\n  return { package: \"\", module: name };\n};\n\nexport interface PythonName {\n  package: string;\n  module: string;\n}\n","import clsx from \"clsx\";\nimport { FC, ReactNode, useRef } from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport { formatDateTime, formatTime } from \"../../../utils/format\";\nimport { parsePackageName } from \"../../../utils/python\";\nimport { MetaDataGrid } from \"../../content/MetaDataGrid\";\nimport { ApplicationIcons } from \"../../icons\";\nimport { PulsingDots } from \"../../PulsingDots\";\nimport { useCollapseTranscriptEvent } from \"../hooks/useCollapseTranscriptEvent\";\nimport { kSandboxSignalName } from \"../transform/fixups\";\nimport { EventNode } from \"../types\";\n\nimport styles from \"./OutlineRow.module.css\";\n\nexport interface OutlineRowProps {\n  node: EventNode;\n  collapseScope: string;\n  running?: boolean;\n  selected?: boolean;\n  getEventUrl?: (eventId: string) => string | undefined;\n  onSelect?: (nodeId: string) => void;\n}\n\nexport const OutlineRow: FC<OutlineRowProps> = ({\n  node,\n  collapseScope,\n  running,\n  selected,\n  getEventUrl,\n  onSelect,\n}) => {\n  const [collapsed, setCollapsed] = useCollapseTranscriptEvent(\n    collapseScope,\n    node.id\n  );\n  const icon = iconForNode(node);\n  const toggle = toggleIcon(node, collapsed);\n\n  const ref = useRef(null);\n\n  // Generate URL for deep linking to this event\n  const eventUrl = getEventUrl?.(node.id);\n\n  return (\n    <>\n      <div\n        className={clsx(\n          styles.eventRow,\n          \"text-size-smaller\",\n          selected ? styles.selected : \"\"\n        )}\n        style={{ paddingLeft: `${node.depth * 0.4}em` }}\n        data-unsearchable={true}\n        onClick={() => onSelect?.(node.id)}\n      >\n        <div\n          className={clsx(styles.toggle)}\n          onClick={() => {\n            setCollapsed(!collapsed);\n          }}\n        >\n          {toggle ? <i className={clsx(toggle)} /> : undefined}\n        </div>\n        <div className={clsx(styles.label)} data-depth={node.depth}>\n          {icon ? <i className={clsx(icon, styles.icon)} /> : undefined}\n          {eventUrl ? (\n            <Link to={eventUrl} className={clsx(styles.eventLink)} ref={ref}>\n              {parsePackageName(labelForNode(node)).module}\n            </Link>\n          ) : (\n            <span ref={ref}>{parsePackageName(labelForNode(node)).module}</span>\n          )}\n          {running ? (\n            <PulsingDots\n              size=\"small\"\n              className={clsx(styles.progress)}\n              subtle={false}\n            />\n          ) : undefined}\n        </div>\n      </div>\n    </>\n  );\n};\n\nconst toggleIcon = (\n  node: EventNode,\n  collapsed: boolean\n): string | undefined => {\n  if (node.children.length > 0) {\n    return collapsed\n      ? ApplicationIcons.chevron.right\n      : ApplicationIcons.chevron.down;\n  }\n};\n\nconst iconForNode = (node: EventNode): string | undefined => {\n  switch (node.event.event) {\n    case \"sample_limit\":\n      return ApplicationIcons.limits.custom;\n\n    case \"score\":\n      return ApplicationIcons.scorer;\n\n    case \"error\":\n      return ApplicationIcons.error;\n  }\n};\n\nconst labelForNode = (node: EventNode): string => {\n  if (node.event.event === \"span_begin\") {\n    switch (node.event.type) {\n      case \"solver\":\n        return node.event.name;\n      case \"tool\":\n        return node.event.name;\n      default: {\n        if (node.event.name === kSandboxSignalName) {\n          return \"sandbox events\";\n        }\n        return node.event.name;\n      }\n    }\n  } else {\n    switch (node.event.event) {\n      case \"subtask\":\n        return node.event.name;\n      case \"approval\":\n        switch (node.event.decision) {\n          case \"approve\":\n            return \"approved\";\n          case \"reject\":\n            return \"rejected\";\n          case \"escalate\":\n            return \"escalated\";\n          case \"modify\":\n            return \"modified\";\n          case \"terminate\":\n            return \"terminated\";\n          default:\n            return node.event.decision;\n        }\n      case \"model\":\n        return `model${node.event.role ? ` (${node.event.role})` : \"\"}`;\n      case \"score\":\n        return \"scoring\";\n      case \"step\":\n        if (node.event.name === kSandboxSignalName) {\n          return \"sandbox events\";\n        }\n        return node.event.name;\n\n      default:\n        return node.event.event;\n    }\n  }\n};\n\nexport const summarizeNode = (node: EventNode): ReactNode => {\n  let entries: Record<string, unknown> = {};\n  switch (node.event.event) {\n    case \"sample_init\":\n      entries = {\n        sample_id: node.event.sample.id,\n        sandbox: node.event.sample.sandbox?.type,\n        started: node.event.timestamp\n          ? formatDateTime(new Date(node.event.timestamp))\n          : undefined,\n        working_start: node.event.working_start\n          ? formatTime(node.event.working_start)\n          : undefined,\n      };\n      break;\n\n    case \"sample_limit\":\n      entries = {\n        type: node.event.type,\n        message: node.event.message,\n        limit: node.event.limit,\n        started: node.event.timestamp\n          ? formatDateTime(new Date(node.event.timestamp))\n          : undefined,\n        working_start: node.event.working_start\n          ? formatTime(node.event.working_start)\n          : undefined,\n      };\n      break;\n    case \"score\":\n      entries = {\n        answer: node.event.score.answer,\n        score: node.event.score.value,\n        started: node.event.timestamp\n          ? formatDateTime(new Date(node.event.timestamp))\n          : undefined,\n        working_start: node.event.working_start\n          ? formatTime(node.event.working_start)\n          : undefined,\n      };\n      break;\n    case \"span_begin\":\n      entries = {\n        name: node.event.name,\n        started: node.event.timestamp\n          ? formatDateTime(new Date(node.event.timestamp))\n          : undefined,\n        working_start: node.event.working_start\n          ? formatTime(node.event.working_start)\n          : undefined,\n      };\n      break;\n    default:\n      entries = {\n        started: node.event.timestamp\n          ? formatDateTime(new Date(node.event.timestamp))\n          : undefined,\n        working_start: node.event.working_start\n          ? formatTime(node.event.working_start)\n          : undefined,\n      };\n  }\n\n  return (\n    <MetaDataGrid\n      entries={entries}\n      options={{ size: \"mini\" }}\n      className={clsx(styles.popover, \"text-size-smallest\")}\n    />\n  );\n};\n","import { ScoreEvent, SpanBeginEvent } from \"../../../types/api-types\";\nimport { TYPE_SCORER, TYPE_SCORERS } from \"../transform/utils\";\nimport { EventNode } from \"../types\";\n\nconst kTurnType = \"turn\";\nconst kTurnsType = \"turns\";\nconst kCollapsedScoring = \"scorings\";\n\n// Visitors are used to transform the event tree\nexport const removeNodeVisitor = (event: string) => {\n  return {\n    visit: (node: EventNode): EventNode[] => {\n      if (node.event.event === event) {\n        return [];\n      }\n      return [node];\n    },\n  };\n};\n\nexport const removeStepSpanNameVisitor = (name: string) => {\n  return {\n    visit: (node: EventNode): EventNode[] => {\n      if (\n        (node.event.event === \"step\" || node.event.event === \"span_begin\") &&\n        node.event.name === name\n      ) {\n        return [];\n      }\n      return [node];\n    },\n  };\n};\n\nexport const noScorerChildren = () => {\n  let inScorers = false;\n  let inScorer = false;\n  let currentDepth = -1;\n  return {\n    visit: (node: EventNode): EventNode[] => {\n      // Note once we're in the scorers span\n      if (\n        node.event.event === \"span_begin\" &&\n        node.event.type === TYPE_SCORERS\n      ) {\n        inScorers = true;\n        return [node];\n      }\n\n      if (\n        (node.event.event === \"step\" || node.event.event === \"span_begin\") &&\n        node.event.type === TYPE_SCORER\n      ) {\n        inScorer = true;\n        currentDepth = node.depth;\n        return [node];\n      }\n\n      if (inScorers && inScorer && node.depth === currentDepth + 1) {\n        return [];\n      }\n      return [node];\n    },\n  };\n};\n\nexport const makeTurns = (eventNodes: EventNode[]): EventNode[] => {\n  const results: EventNode[] = [];\n  let modelNode: EventNode | null = null;\n  const toolNodes: EventNode[] = [];\n  let turnCount = 1;\n\n  const makeTurn = (force?: boolean) => {\n    if (modelNode !== null && (force || toolNodes.length > 0)) {\n      // Create a new \"turn\" node based on the model event\n      const turnNode = new EventNode(\n        modelNode.id,\n        {\n          id: modelNode.id,\n          event: \"span_begin\",\n          type: kTurnType,\n          name: `turn ${turnCount++}`,\n          pending: false,\n          working_start: modelNode.event.working_start,\n          timestamp: modelNode.event.timestamp,\n          parent_id: null,\n          span_id: modelNode.event.span_id,\n          uuid: null,\n          metadata: null,\n        },\n        modelNode.depth\n      );\n\n      // Add the original model event and tool events as children\n      turnNode.children = [modelNode, ...toolNodes];\n      results.push(turnNode);\n    }\n    modelNode = null;\n    toolNodes.length = 0;\n  };\n\n  for (const node of eventNodes) {\n    if (node.event.event === \"model\") {\n      if (modelNode !== null && toolNodes.length === 0) {\n        // back to back model calls are considered a single turn\n        makeTurn(true);\n      } else {\n        makeTurn();\n        modelNode = node;\n      }\n    } else if (node.event.event === \"tool\") {\n      toolNodes.push(node);\n    } else {\n      makeTurn();\n      results.push(node);\n    }\n  }\n  makeTurn();\n\n  return results;\n};\n\nexport const collapseTurns = (eventNodes: EventNode[]): EventNode[] => {\n  const results: EventNode[] = [];\n  const collecting: EventNode[] = [];\n  const collect = () => {\n    if (collecting.length > 0) {\n      const numberOfTurns = collecting.length;\n      const firstTurn = collecting[0];\n      if (!firstTurn) {\n        return;\n      }\n      const turnNode = new EventNode(\n        firstTurn.id,\n        {\n          ...(firstTurn.event as SpanBeginEvent),\n          name: `${numberOfTurns} ${numberOfTurns === 1 ? \"turn\" : \"turns\"}`,\n          type: kTurnsType,\n        },\n        firstTurn.depth\n      );\n      results.push(turnNode);\n      collecting.length = 0;\n    }\n  };\n\n  for (const node of eventNodes) {\n    if (node.event.event === \"span_begin\" && node.event.type === kTurnType) {\n      // Check depth to ensure we are collecting turns at the same level\n      if (collecting.length > 0 && collecting[0]?.depth !== node.depth) {\n        collect();\n      }\n\n      collecting.push(node);\n    } else {\n      collect();\n      results.push(node);\n    }\n  }\n  // Handle any remaining collected turns\n  collect();\n  return results;\n};\n\nexport const collapseScoring = (eventNodes: EventNode[]): EventNode[] => {\n  const results: EventNode[] = [];\n  const collecting: EventNode[] = [];\n  const collect = () => {\n    if (collecting.length > 0) {\n      const firstScore = collecting[0];\n      if (!firstScore) {\n        return;\n      }\n      const turnNode = new EventNode(\n        firstScore.id,\n        {\n          ...(firstScore.event as ScoreEvent),\n          name: \"scoring\",\n          type: kCollapsedScoring,\n        },\n        firstScore.depth\n      );\n      results.push(turnNode);\n      collecting.length = 0;\n    }\n  };\n\n  for (const node of eventNodes) {\n    if (node.event.event === \"score\") {\n      collecting.push(node);\n    } else {\n      collect();\n      results.push(node);\n    }\n  }\n\n  // Handle any remaining collected turns\n  collect();\n  return results;\n};\n","import clsx from \"clsx\";\nimport {\n  CSSProperties,\n  FC,\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n} from \"react\";\nimport { Virtuoso, VirtuosoHandle } from \"react-virtuoso\";\n\nimport { useTranscriptNavigation } from \"../../../app/transcript/hooks/useTranscriptNavigation\";\nimport { useScrollTrack, useVirtuosoState } from \"../../../state/scrolling\";\nimport { useStore } from \"../../../state/store\";\nimport { kSandboxSignalName } from \"../transform/fixups\";\nimport { flatTree } from \"../transform/flatten\";\nimport { EventNode, kTranscriptOutlineCollapseScope } from \"../types\";\n\nimport { OutlineRow } from \"./OutlineRow\";\nimport styles from \"./TranscriptOutline.module.css\";\nimport {\n  collapseScoring,\n  collapseTurns,\n  makeTurns,\n  noScorerChildren,\n  removeNodeVisitor,\n  removeStepSpanNameVisitor,\n} from \"./tree-visitors\";\n\nconst kFramesToStabilize = 10;\n\ninterface TranscriptOutlineProps {\n  eventNodes: EventNode[];\n  defaultCollapsedIds: Record<string, boolean>;\n  running?: boolean;\n  className?: string | string[];\n  scrollRef?: RefObject<HTMLDivElement | null>;\n  style?: CSSProperties;\n}\n\n// hack: add a padding node to the end of the list so\n// when the tree is positioned at the bottom of the viewport\n// it has some breathing room\nconst EventPaddingNode: EventNode = {\n  id: \"padding\",\n  event: {\n    event: \"info\",\n    source: \"\",\n    data: \"\",\n    timestamp: \"\",\n    pending: false,\n    working_start: 0,\n    span_id: null,\n    uuid: null,\n    metadata: null,\n  },\n  depth: 0,\n  children: [],\n};\n\nexport const TranscriptOutline: FC<TranscriptOutlineProps> = ({\n  eventNodes,\n  defaultCollapsedIds,\n  running,\n  className,\n  scrollRef,\n  style,\n}) => {\n  const id = \"transcript-tree\";\n  // The virtual list handle and state\n  const listHandle = useRef<VirtuosoHandle | null>(null);\n  const { getRestoreState } = useVirtuosoState(listHandle, id);\n\n  // Get URL generator for deep linking to events\n  const { getEventUrl } = useTranscriptNavigation();\n\n  // Collapse state\n  // The list of events that have been collapsed\n  const collapsedEvents = useStore((state) => state.transcriptCollapsedEvents);\n  const setCollapsedEvents = useStore(\n    (state) => state.setTranscriptCollapsedEvents\n  );\n\n  const selectedOutlineId = useStore((state) => state.transcriptOutlineId);\n  const setSelectedOutlineId = useStore(\n    (state) => state.setTranscriptOutlineId\n  );\n  const sampleDetailNavigation = { event: undefined }; // useSampleDetailNavigation();\n\n  // Flag to indicate programmatic scrolling is in progress\n  const isProgrammaticScrolling = useRef(false);\n  // Last position to check for scroll stabilization\n  const lastScrollPosition = useRef<number | null>(null);\n  // Frame count for detecting scroll stabilization\n  const stableFrameCount = useRef(0);\n\n  useEffect(() => {\n    if (sampleDetailNavigation.event) {\n      // Set the flag to indicate we're in programmatic scrolling\n      isProgrammaticScrolling.current = true;\n      lastScrollPosition.current = null;\n      stableFrameCount.current = 0;\n\n      setSelectedOutlineId(sampleDetailNavigation.event);\n\n      // Start monitoring to detect when scrolling has stabilized\n      const checkScrollStabilized = () => {\n        if (!isProgrammaticScrolling.current) return;\n\n        const currentPosition = scrollRef?.current?.scrollTop ?? null;\n\n        if (currentPosition === lastScrollPosition.current) {\n          stableFrameCount.current++;\n\n          // If position has been stable for a few frames, consider scrolling complete\n          if (stableFrameCount.current >= kFramesToStabilize) {\n            isProgrammaticScrolling.current = false;\n            return;\n          }\n        } else {\n          // Reset stability counter if position changed\n          stableFrameCount.current = 0;\n          lastScrollPosition.current = currentPosition;\n        }\n\n        // Continue checking until scrolling stabilizes\n        requestAnimationFrame(checkScrollStabilized);\n      };\n\n      // Start the RAF loop to detect scroll stabilization\n      requestAnimationFrame(checkScrollStabilized);\n    }\n  }, [sampleDetailNavigation.event, setSelectedOutlineId, scrollRef]);\n\n  const outlineNodeList = useMemo(() => {\n    // flattten the event tree\n    const nodeList = flatTree(\n      eventNodes,\n      (collapsedEvents\n        ? collapsedEvents[kTranscriptOutlineCollapseScope]\n        : undefined) || defaultCollapsedIds,\n      [\n        // Strip specific nodes\n        removeNodeVisitor(\"logger\"),\n        removeNodeVisitor(\"info\"),\n        removeNodeVisitor(\"state\"),\n        removeNodeVisitor(\"store\"),\n        removeNodeVisitor(\"approval\"),\n        removeNodeVisitor(\"input\"),\n        removeNodeVisitor(\"sandbox\"),\n\n        // Strip the sandbox wrapper (and children)\n        removeStepSpanNameVisitor(kSandboxSignalName),\n\n        // Remove child events for scorers\n        noScorerChildren(),\n      ]\n    );\n\n    return collapseScoring(collapseTurns(makeTurns(nodeList)));\n  }, [eventNodes, collapsedEvents, defaultCollapsedIds]);\n\n  // Event node, for scroll tracking\n  const allNodesList = useMemo(() => {\n    return flatTree(eventNodes, null);\n  }, [eventNodes]);\n\n  const elementIds = allNodesList.map((node) => node.id);\n  const findNearestOutlineAbove = useCallback(\n    (targetId: string): EventNode | null => {\n      const targetIndex = allNodesList.findIndex(\n        (node) => node.id === targetId\n      );\n      if (targetIndex === -1) return null;\n\n      const outlineIds = new Set(outlineNodeList.map((node) => node.id));\n\n      // Search backwards from target position (inclusive)\n      for (let i = targetIndex; i >= 0; i--) {\n        const node = allNodesList[i];\n        if (node !== undefined && node.id) {\n          if (outlineIds.has(node.id)) {\n            return node;\n          }\n        }\n      }\n\n      return null;\n    },\n    [allNodesList, outlineNodeList]\n  );\n\n  useScrollTrack(\n    elementIds,\n    (id: string) => {\n      if (!isProgrammaticScrolling.current) {\n        // If the ID is not in the list, return\n        const parentNode = findNearestOutlineAbove(id);\n        if (parentNode) {\n          setSelectedOutlineId(parentNode.id);\n        }\n      }\n    },\n    scrollRef\n  );\n\n  // Update the collapsed events when the default collapsed IDs change\n  // This effect only depends on defaultCollapsedIds, not eventNodes\n  useEffect(() => {\n    // Only initialize collapsedEvents if it's empty\n    if (!collapsedEvents && Object.keys(defaultCollapsedIds).length > 0) {\n      setCollapsedEvents(kTranscriptOutlineCollapseScope, defaultCollapsedIds);\n    }\n  }, [defaultCollapsedIds, collapsedEvents, setCollapsedEvents]);\n\n  const renderRow = useCallback(\n    (index: number, node: EventNode) => {\n      if (node === EventPaddingNode) {\n        return (\n          <div\n            className={clsx(styles.eventPadding)}\n            key={node.id}\n            style={{ height: \"2em\" }}\n          ></div>\n        );\n      } else {\n        return (\n          <OutlineRow\n            collapseScope={kTranscriptOutlineCollapseScope}\n            node={node}\n            key={node.id}\n            running={running && index === outlineNodeList.length - 1}\n            selected={\n              selectedOutlineId ? selectedOutlineId === node.id : index === 0\n            }\n            getEventUrl={getEventUrl}\n            onSelect={setSelectedOutlineId}\n          />\n        );\n      }\n    },\n    [\n      outlineNodeList,\n      running,\n      selectedOutlineId,\n      getEventUrl,\n      setSelectedOutlineId,\n    ]\n  );\n\n  return (\n    <Virtuoso\n      ref={listHandle}\n      // eslint-disable-next-line react-hooks/refs -- Virtuoso accepts undefined for customScrollParent and handles dynamic ref population\n      customScrollParent={scrollRef?.current ? scrollRef.current : undefined}\n      id={id}\n      style={{ ...style }}\n      data={[...outlineNodeList, EventPaddingNode]}\n      defaultItemHeight={50}\n      itemContent={renderRow}\n      atBottomThreshold={30}\n      increaseViewportBy={{ top: 300, bottom: 300 }}\n      overscan={{\n        main: 10,\n        reverse: 10,\n      }}\n      className={clsx(className, \"transcript-outline\")}\n      skipAnimationFrameInResizeObserver={true}\n      restoreStateFrom={getRestoreState()}\n      tabIndex={0}\n    />\n  );\n};\n"],"names":["selected","icon","toggle","useRef","jsx","Fragment","jsxs","styles","useEffect","useMemo","useCallback","id","Virtuoso"],"mappings":"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"}