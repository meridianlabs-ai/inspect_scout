{"version":3,"file":"TranscriptsPanel.js","sources":["../../src/app/transcripts/columnSizing/useColumnSizing.ts","../../src/app/transcripts/TranscriptsGrid.tsx","../../src/app/transcripts/TranscriptsPanel.tsx"],"sourcesContent":["import { ColumnSizingState, OnChangeFn } from \"@tanstack/react-table\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\n\nimport { useStore } from \"../../../state/store\";\nimport { TranscriptInfo } from \"../../../types/api-types\";\nimport {\n  clampSize,\n  ColumnSizingStrategyKey,\n  getColumnConstraints,\n  getSizingStrategy,\n  SizingStrategy,\n} from \"../../components/columnSizing\";\nimport { TranscriptColumn } from \"../columns\";\n\ninterface UseColumnSizingOptions {\n  /** Column definitions */\n  columns: TranscriptColumn[];\n  /** Reference to the table element for DOM measurement */\n  tableRef: React.RefObject<HTMLTableElement | null>;\n  /** Current data for content measurement */\n  data: TranscriptInfo[];\n}\n\ninterface UseColumnSizingResult {\n  /** Current column sizing state */\n  columnSizing: ColumnSizingState;\n  /** Handler for column sizing changes with min/max enforcement */\n  handleColumnSizingChange: OnChangeFn<ColumnSizingState>;\n  /** Current sizing strategy key */\n  sizingStrategy: ColumnSizingStrategyKey;\n  /** Set the sizing strategy */\n  setSizingStrategy: (strategy: ColumnSizingStrategyKey) => void;\n  /** Apply auto-sizing based on current strategy (preserves manually resized columns) */\n  applyAutoSizing: () => void;\n  /** Reset a single column to its auto-calculated size */\n  resetColumnSize: (columnId: string) => void;\n  /** Reset all column sizing and clear manual resize tracking */\n  clearColumnSizing: () => void;\n}\n\n/**\n * Hook for managing column sizing with min/max constraints and auto-sizing.\n * Manually resized columns are preserved during auto-sizing operations.\n */\nexport function useColumnSizing({\n  columns,\n  tableRef,\n  data,\n}: UseColumnSizingOptions): UseColumnSizingResult {\n  const columnSizing = useStore(\n    (state) => state.transcriptsTableState.columnSizing\n  );\n  const sizingStrategy = useStore(\n    (state) => state.transcriptsTableState.sizingStrategy\n  );\n  const manuallyResizedColumns = useStore(\n    (state) => state.transcriptsTableState.manuallyResizedColumns\n  );\n  const setTableState = useStore((state) => state.setTranscriptsTableState);\n\n  // Track which columns have been manually resized\n  const manuallyResizedSet = useMemo(\n    () => new Set(manuallyResizedColumns),\n    [manuallyResizedColumns]\n  );\n\n  // Get constraints for all columns\n  const columnConstraints = useMemo(\n    () => getColumnConstraints(columns),\n    [columns]\n  );\n\n  // Track if we're in the middle of an auto-sizing operation\n  const isAutoSizingRef = useRef(false);\n\n  // Store latest values in refs for stable callbacks\n  const latestRef = useRef({\n    sizingStrategy,\n    columns,\n    data,\n    columnConstraints,\n    manuallyResizedSet,\n    columnSizing,\n  });\n\n  // Update refs when values change\n  useEffect(() => {\n    latestRef.current = {\n      sizingStrategy,\n      columns,\n      data,\n      columnConstraints,\n      manuallyResizedSet,\n      columnSizing,\n    };\n  });\n\n  // Handle column sizing changes with min/max enforcement\n  const handleColumnSizingChange: OnChangeFn<ColumnSizingState> = useCallback(\n    (updaterOrValue) => {\n      const newSizing =\n        typeof updaterOrValue === \"function\"\n          ? updaterOrValue(columnSizing)\n          : updaterOrValue;\n\n      // Clamp sizes to min/max constraints\n      const clampedSizing: ColumnSizingState = {};\n      const newManuallyResized = new Set(manuallyResizedSet);\n\n      for (const [columnId, size] of Object.entries(newSizing)) {\n        const constraints = columnConstraints.get(columnId);\n        if (constraints) {\n          clampedSizing[columnId] = clampSize(size, constraints);\n        } else {\n          clampedSizing[columnId] = size;\n        }\n\n        // Mark this column as manually resized (unless we're auto-sizing)\n        if (!isAutoSizingRef.current) {\n          newManuallyResized.add(columnId);\n        }\n      }\n\n      // Include existing sizes that weren't updated\n      for (const [columnId, size] of Object.entries(columnSizing)) {\n        if (!(columnId in clampedSizing)) {\n          clampedSizing[columnId] = size;\n        }\n      }\n\n      setTableState((prev) => ({\n        ...prev,\n        columnSizing: clampedSizing,\n        manuallyResizedColumns: isAutoSizingRef.current\n          ? prev.manuallyResizedColumns\n          : Array.from(newManuallyResized),\n      }));\n    },\n    [columnSizing, columnConstraints, manuallyResizedSet, setTableState]\n  );\n\n  // Set sizing strategy\n  const setSizingStrategy = useCallback(\n    (strategy: ColumnSizingStrategyKey) => {\n      setTableState((prev) => ({\n        ...prev,\n        sizingStrategy: strategy,\n      }));\n    },\n    [setTableState]\n  );\n\n  // Apply auto-sizing based on current strategy\n  // Preserves sizes of manually resized columns\n  const applyAutoSizing = useCallback(() => {\n    isAutoSizingRef.current = true;\n\n    try {\n      const {\n        sizingStrategy: strategyKey,\n        columns: cols,\n        data: rowData,\n        columnConstraints: constraints,\n        manuallyResizedSet: resizedSet,\n        columnSizing: currentSizing,\n      } = latestRef.current;\n\n      const strategy = getSizingStrategy(\n        strategyKey\n      ) as SizingStrategy<TranscriptInfo>;\n      const calculatedSizing = strategy.computeSizes({\n        tableElement: tableRef.current,\n        columns: cols,\n        data: rowData,\n        constraints,\n      });\n\n      // Merge: use calculated sizes for non-manually-resized columns,\n      // preserve existing sizes for manually resized columns\n      const newSizing: ColumnSizingState = {};\n      for (const [columnId, size] of Object.entries(calculatedSizing)) {\n        if (resizedSet.has(columnId) && currentSizing[columnId] !== undefined) {\n          // Preserve manually resized column's current size\n          newSizing[columnId] = currentSizing[columnId];\n        } else {\n          // Use calculated size\n          newSizing[columnId] = size;\n        }\n      }\n\n      setTableState((prev) => ({\n        ...prev,\n        columnSizing: newSizing,\n      }));\n    } finally {\n      isAutoSizingRef.current = false;\n    }\n  }, [tableRef, setTableState]);\n\n  // Reset a single column to its auto-calculated size\n  const resetColumnSize = useCallback(\n    (columnId: string) => {\n      isAutoSizingRef.current = true;\n\n      try {\n        const {\n          sizingStrategy: strategyKey,\n          columns: cols,\n          data: rowData,\n          columnConstraints: constraints,\n        } = latestRef.current;\n\n        const strategy = getSizingStrategy(\n          strategyKey\n        ) as SizingStrategy<TranscriptInfo>;\n        const allSizes = strategy.computeSizes({\n          tableElement: tableRef.current,\n          columns: cols,\n          data: rowData,\n          constraints,\n        });\n\n        const newSize = allSizes[columnId];\n        if (newSize !== undefined) {\n          setTableState((prev) => {\n            // Remove this column from manually resized list\n            const newManuallyResized = prev.manuallyResizedColumns.filter(\n              (id) => id !== columnId\n            );\n\n            return {\n              ...prev,\n              columnSizing: {\n                ...prev.columnSizing,\n                [columnId]: newSize,\n              },\n              manuallyResizedColumns: newManuallyResized,\n            };\n          });\n        }\n      } finally {\n        isAutoSizingRef.current = false;\n      }\n    },\n    [tableRef, setTableState]\n  );\n\n  // Reset all column sizing and clear manual resize tracking\n  const clearColumnSizing = useCallback(() => {\n    setTableState((prev) => ({\n      ...prev,\n      columnSizing: {},\n      manuallyResizedColumns: [],\n    }));\n  }, [setTableState]);\n\n  return {\n    columnSizing,\n    setSizingStrategy,\n    clearColumnSizing,\n    sizingStrategy,\n    handleColumnSizingChange,\n    applyAutoSizing,\n    resetColumnSize,\n  };\n}\n","import { FC, useEffect, useMemo, useRef } from \"react\";\n\nimport { ScalarValue } from \"../../api/api\";\nimport { transcriptRoute } from \"../../router/url\";\nimport { useStore } from \"../../state/store\";\nimport { TranscriptInfo } from \"../../types/api-types\";\nimport { DataGrid } from \"../components/dataGrid\";\n\nimport {\n  TranscriptColumn,\n  getTranscriptColumns,\n  DEFAULT_COLUMN_ORDER,\n} from \"./columns\";\nimport { useColumnSizing } from \"./columnSizing\";\n\n// Default visible columns (stable reference)\nconst DEFAULT_VISIBLE_COLUMNS: Array<keyof TranscriptInfo> = [\n  \"success\",\n  \"date\",\n  \"task_set\",\n  \"task_id\",\n  \"task_repeat\",\n  \"model\",\n  \"score\",\n  \"message_count\",\n  \"total_time\",\n  \"total_tokens\",\n];\n\n// Generate a stable key for a transcript item\nfunction transcriptItemKey(index: number, item?: TranscriptInfo): string {\n  if (!item) {\n    return String(index);\n  }\n  return `${item.source_uri}/${item.transcript_id}`;\n}\n\ninterface TranscriptGridProps {\n  transcripts: TranscriptInfo[];\n  transcriptsDir?: string | null;\n  className?: string | string[];\n  /** Called when scroll position nears end; receives distance from bottom in px. */\n  onScrollNearEnd: (distanceFromBottom: number) => void;\n  /** Whether more data is available to fetch. */\n  hasMore: boolean;\n  /** Distance from bottom (in px) at which to trigger callback. */\n  fetchThreshold: number;\n  loading?: boolean;\n  /** Autocomplete suggestions for the currently editing filter column */\n  filterSuggestions?: ScalarValue[];\n  /** Called when a filter column starts/stops being edited */\n  onFilterColumnChange?: (columnId: string | null) => void;\n}\n\nexport const TranscriptsGrid: FC<TranscriptGridProps> = ({\n  transcripts,\n  transcriptsDir,\n  className,\n  onScrollNearEnd,\n  hasMore,\n  fetchThreshold,\n  loading,\n  filterSuggestions = [],\n  onFilterColumnChange,\n}) => {\n  // Table ref for DOM measurement (used by column sizing)\n  const tableRef = useRef<HTMLTableElement>(null);\n\n  // Table state from store\n  const columnOrder = useStore(\n    (state) => state.transcriptsTableState.columnOrder\n  );\n  const sorting = useStore((state) => state.transcriptsTableState.sorting);\n  const rowSelection = useStore(\n    (state) => state.transcriptsTableState.rowSelection\n  );\n  const columnFilters =\n    useStore((state) => state.transcriptsTableState.columnFilters) ?? {};\n  const focusedRowId = useStore(\n    (state) => state.transcriptsTableState.focusedRowId\n  );\n  const visibleColumns =\n    useStore((state) => state.transcriptsTableState.visibleColumns) ??\n    DEFAULT_VISIBLE_COLUMNS;\n  const setTableState = useStore((state) => state.setTranscriptsTableState);\n\n  // Define table columns based on visible columns from store\n  const columns = useMemo<TranscriptColumn[]>(\n    () => getTranscriptColumns(visibleColumns),\n    [visibleColumns]\n  );\n\n  // Column sizing with min/max constraints and auto-sizing\n  const {\n    columnSizing,\n    handleColumnSizingChange,\n    applyAutoSizing,\n    resetColumnSize,\n  } = useColumnSizing({\n    columns,\n    tableRef,\n    data: transcripts,\n  });\n\n  // Track if we've done initial auto-sizing\n  const hasInitializedRef = useRef(false);\n\n  // Track previous visible columns to detect changes\n  const previousVisibleColumnsRef = useRef<typeof visibleColumns | null>(null);\n\n  // Auto-size columns on initial load when data is available\n  useEffect(() => {\n    if (!hasInitializedRef.current && transcripts.length > 0) {\n      hasInitializedRef.current = true;\n      applyAutoSizing();\n    }\n  }, [transcripts.length, applyAutoSizing]);\n\n  // Auto-size when visible columns change\n  // (applyAutoSizing preserves manually resized columns)\n  useEffect(() => {\n    const previousVisibleColumns = previousVisibleColumnsRef.current;\n    previousVisibleColumnsRef.current = visibleColumns;\n\n    if (previousVisibleColumns && previousVisibleColumns !== visibleColumns) {\n      applyAutoSizing();\n    }\n  }, [visibleColumns, applyAutoSizing]);\n\n  // Compute effective column order: use explicit order if set, otherwise derive from DEFAULT_COLUMN_ORDER\n  const effectiveColumnOrder = useMemo(() => {\n    if (columnOrder && columnOrder.length > 0) {\n      return columnOrder;\n    }\n    // Filter DEFAULT_COLUMN_ORDER to only include visible columns\n    return DEFAULT_COLUMN_ORDER.filter((col) => visibleColumns.includes(col));\n  }, [columnOrder, visibleColumns]);\n\n  // Get row ID\n  const getRowId = (row: TranscriptInfo): string => String(row.transcript_id);\n\n  // Get route for navigation\n  const getRowRoute = (row: TranscriptInfo): string => {\n    if (!transcriptsDir) return \"\";\n    return transcriptRoute(transcriptsDir, String(row.transcript_id));\n  };\n\n  return (\n    <DataGrid\n      data={transcripts}\n      columns={columns}\n      getRowId={getRowId}\n      getRowKey={transcriptItemKey}\n      state={{\n        sorting,\n        columnOrder: effectiveColumnOrder,\n        columnFilters,\n        columnSizing,\n        rowSelection,\n        focusedRowId,\n      }}\n      onStateChange={setTableState}\n      getRowRoute={getRowRoute}\n      onScrollNearEnd={onScrollNearEnd}\n      hasMore={hasMore}\n      fetchThreshold={fetchThreshold}\n      filterSuggestions={filterSuggestions}\n      onFilterColumnChange={onFilterColumnChange}\n      onColumnSizingChange={handleColumnSizingChange}\n      onResetColumnSize={resetColumnSize}\n      className={className}\n      loading={loading}\n      emptyMessage=\"No matching transcripts\"\n      noConfigMessage=\"No transcripts directory configured.\"\n    />\n  );\n};\n","import { skipToken } from \"@tanstack/react-query\";\nimport clsx from \"clsx\";\nimport { FC, useCallback, useEffect, useMemo } from \"react\";\n\nimport { ErrorPanel } from \"../../components/ErrorPanel\";\nimport { LoadingBar } from \"../../components/LoadingBar\";\nimport { useDocumentTitle } from \"../../hooks/useDocumentTitle\";\nimport { useStore } from \"../../state/store\";\nimport { TranscriptInfo } from \"../../types/api-types\";\nimport { Footer } from \"../components/Footer\";\nimport { TranscriptsNavbar } from \"../components/TranscriptsNavbar\";\nimport { useTranscriptsFilterBarProps } from \"../hooks/useTranscriptsFilterBarProps\";\nimport { useAppConfig } from \"../server/useAppConfig\";\nimport { useServerTranscriptsInfinite } from \"../server/useServerTranscriptsInfinite\";\nimport { useTranscriptsDir } from \"../utils/useTranscriptsDir\";\n\nimport { TRANSCRIPTS_INFINITE_SCROLL_CONFIG } from \"./constants\";\nimport { TranscriptFilterBar } from \"./TranscriptFilterBar\";\nimport { TranscriptsGrid } from \"./TranscriptsGrid\";\nimport styles from \"./TranscriptsPanel.module.css\";\n\nexport const TranscriptsPanel: FC = () => {\n  useDocumentTitle(\"Transcripts\");\n\n  // Resolve the active transcripts directory\n  const {\n    displayTranscriptsDir,\n    resolvedTranscriptsDir,\n    resolvedTranscriptsDirSource,\n    setTranscriptsDir,\n  } = useTranscriptsDir();\n  const config = useAppConfig();\n  const filter = Array.isArray(config.filter)\n    ? config.filter.join(\" \")\n    : config.filter;\n\n  const sorting = useStore((state) => state.transcriptsTableState.sorting);\n\n  // Clear detail state\n  const clearTranscriptState = useStore((state) => state.clearTranscriptState);\n  useEffect(() => {\n    clearTranscriptState();\n  }, [clearTranscriptState]);\n\n  const {\n    filterCodeValues,\n    filterSuggestions,\n    onFilterColumnChange,\n    condition,\n  } = useTranscriptsFilterBarProps(resolvedTranscriptsDir);\n  const { data, error, fetchNextPage, hasNextPage, isFetching } =\n    useServerTranscriptsInfinite(\n      resolvedTranscriptsDir\n        ? {\n            location: resolvedTranscriptsDir,\n            pageSize: TRANSCRIPTS_INFINITE_SCROLL_CONFIG.pageSize,\n            filter: condition,\n            sorting,\n          }\n        : skipToken\n    );\n\n  const transcripts: TranscriptInfo[] = useMemo(\n    () => data?.pages.flatMap((page) => page.items) ?? [],\n    [data]\n  );\n\n  const handleScrollNearEnd = useCallback(\n    (distanceFromBottom: number) => {\n      if (distanceFromBottom <= 0) {\n        console.log(\"Hit bottom!\");\n      }\n      fetchNextPage({ cancelRefetch: false }).catch(console.error);\n    },\n    [fetchNextPage]\n  );\n\n  return (\n    <div className={clsx(styles.container)}>\n      <TranscriptsNavbar\n        bordered={true}\n        transcriptsDir={displayTranscriptsDir}\n        transcriptsDirSource={resolvedTranscriptsDirSource}\n        filter={filter}\n        setTranscriptsDir={setTranscriptsDir}\n      />\n      <LoadingBar loading={isFetching} />\n      {error && (\n        <ErrorPanel\n          title=\"Error Loading Transcript\"\n          error={{\n            message: error.message || \"Unknown Error\",\n          }}\n        />\n      )}\n      {!error && (\n        <>\n          <TranscriptFilterBar\n            filterCodeValues={filterCodeValues}\n            filterSuggestions={filterSuggestions}\n            onFilterColumnChange={onFilterColumnChange}\n          />\n          <TranscriptsGrid\n            transcripts={transcripts}\n            transcriptsDir={resolvedTranscriptsDir}\n            loading={isFetching && transcripts.length === 0}\n            onScrollNearEnd={handleScrollNearEnd}\n            hasMore={hasNextPage}\n            fetchThreshold={TRANSCRIPTS_INFINITE_SCROLL_CONFIG.threshold}\n            filterSuggestions={filterSuggestions}\n            onFilterColumnChange={onFilterColumnChange}\n          />\n        </>\n      )}\n      <Footer\n        id={\"transcripts-footer\"}\n        itemCount={data?.pages[0]?.total_count || 0}\n        paginated={false}\n      />\n    </div>\n  );\n};\n"],"names":["useMemo","useRef","useEffect","useCallback","jsx","jsxs","Fragment"],"mappings":"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"}