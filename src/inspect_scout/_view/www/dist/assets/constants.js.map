{"version":3,"file":"constants.js","sources":["../../src/app/server/useServerTranscriptsInfinite.ts","../../src/app/transcripts/constants.ts"],"sourcesContent":["import {\n  UseInfiniteQueryResult,\n  InfiniteData,\n  useInfiniteQuery,\n  QueryKey,\n  keepPreviousData,\n  skipToken,\n} from \"@tanstack/react-query\";\nimport { SortingState } from \"@tanstack/react-table\";\nimport { useMemo } from \"react\";\n\nimport { Condition } from \"../../query\";\nimport { useApi } from \"../../state/store\";\nimport { TranscriptsResponse } from \"../../types/api-types\";\n\nimport { CursorType, sortingStateToOrderBy } from \".\";\n\ntype ServerTranscriptsInfiniteParams = {\n  location: string;\n  pageSize?: number;\n  filter?: Condition;\n  sorting?: SortingState;\n};\n\nexport const useServerTranscriptsInfinite = (\n  params: ServerTranscriptsInfiniteParams | typeof skipToken\n): UseInfiniteQueryResult<\n  InfiniteData<TranscriptsResponse, CursorType | undefined>,\n  Error\n> => {\n  const api = useApi();\n\n  const orderBy = useMemo(\n    () =>\n      params !== skipToken && params.sorting\n        ? sortingStateToOrderBy(params.sorting)\n        : undefined,\n    [params]\n  );\n\n  const pageSize = params !== skipToken ? (params.pageSize ?? 50) : 50;\n\n  return useInfiniteQuery<\n    TranscriptsResponse,\n    Error,\n    InfiniteData<TranscriptsResponse, CursorType | undefined>,\n    QueryKey,\n    CursorType | undefined\n  >({\n    queryKey:\n      params === skipToken\n        ? [skipToken]\n        : [\n            \"transcripts-infinite\",\n            params.location,\n            params.filter,\n            orderBy,\n            pageSize,\n            \"project-config-inv\",\n          ],\n    queryFn:\n      params === skipToken\n        ? skipToken\n        : async ({ pageParam }) => {\n            const pagination = pageParam\n              ? {\n                  limit: pageSize,\n                  cursor: pageParam,\n                  direction: \"forward\" as const,\n                }\n              : {\n                  limit: pageSize,\n                  cursor: null,\n                  direction: \"forward\" as const,\n                };\n\n            return await api.getTranscripts(\n              params.location,\n              params.filter,\n              orderBy,\n              pagination\n            );\n          },\n    initialPageParam: undefined,\n    getNextPageParam: (lastPage) => lastPage.next_cursor ?? undefined,\n    staleTime: 10 * 60 * 1000,\n    refetchInterval: 10 * 60 * 1000,\n    placeholderData: keepPreviousData,\n  });\n};\n","/**\n * Infinite Scroll Tuning\n *\n * Goal: user never hits bottom while waiting for next page.\n *\n * Formula: threshold >= scroll_speed × fetch_duration\n *\n * Assumptions:\n *   row_height = 29px\n *   fetch_duration = 300-1000ms (variable with fixed overhead)\n *   max_scroll_speed = 1500px/s (typical fast scroller)\n *\n * Check at typical speed (1500px/s):\n *   runway_time = 2000px / 1500px/s = 1333ms\n *   worst_case_fetch = 1000ms\n *   margin = 333ms ✓\n *\n * Check at extreme speed (5000px/s):\n *   runway_time = 2000px / 5000px/s = 400ms\n *   median_fetch = ~350ms\n *   margin = 50ms (tight but ok) ✓\n *\n * Why large pageSize? Fetch duration is mostly fixed overhead, so larger\n * pages = fewer fetches = fewer stall opportunities. 500 rows gives ~9.7s\n * of scrolling per page at 1500px/s.\n *\n * Note: If threshold > pageSize_px, the next page is prefetched immediately\n * after the current page loads. This is fine for maximum smoothness.\n */\nexport const TRANSCRIPTS_INFINITE_SCROLL_CONFIG = {\n  /** Number of rows to fetch per page (500 rows = 14,500px at 29px/row) */\n  pageSize: 500,\n  /** Distance from bottom (in px) at which to trigger fetch (~69 rows) */\n  threshold: 2000,\n} as const;\n"],"names":["useMemo"],"mappings":";;AAwBO,MAAM,+BAA+B,CAC1C,WAIG;AACH,QAAM,MAAM,OAAA;AAEZ,QAAM,UAAUA,aAAAA;AAAAA,IACd,MACE,WAAW,aAAa,OAAO,UAC3B,sBAAsB,OAAO,OAAO,IACpC;AAAA,IACN,CAAC,MAAM;AAAA,EAAA;AAGT,QAAM,WAAW,WAAW,YAAa,OAAO,YAAY,KAAM;AAElE,SAAO,iBAML;AAAA,IACA,UACE,WAAW,YACP,CAAC,SAAS,IACV;AAAA,MACE;AAAA,MACA,OAAO;AAAA,MACP,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,IAER,SACE,WAAW,YACP,YACA,OAAO,EAAE,gBAAgB;AACvB,YAAM,aAAa,YACf;AAAA,QACE,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,WAAW;AAAA,MAAA,IAEb;AAAA,QACE,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,WAAW;AAAA,MAAA;AAGjB,aAAO,MAAM,IAAI;AAAA,QACf,OAAO;AAAA,QACP,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MAAA;AAAA,IAEJ;AAAA,IACN,kBAAkB;AAAA,IAClB,kBAAkB,CAAC,aAAa,SAAS,eAAe;AAAA,IACxD,WAAW,KAAK,KAAK;AAAA,IACrB,iBAAiB,KAAK,KAAK;AAAA,IAC3B,iBAAiB;AAAA,EAAA,CAClB;AACH;AC5DO,MAAM,qCAAqC;AAAA;AAAA,EAEhD,UAAU;AAAA;AAAA,EAEV,WAAW;AACb;"}