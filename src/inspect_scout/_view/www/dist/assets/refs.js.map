{"version":3,"file":"refs.js","sources":["../../src/app/server/useScan.ts","../../src/app/hooks/useSelectedScan.ts","../../src/app/utils/scan.ts","../../src/app/utils/results.ts","../../src/components/Card.tsx","../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/utf8.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/compat.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/buffer.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/io/adapters.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/metadata-version.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/union-mode.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/precision.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/date-unit.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/time-unit.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/interval-unit.mjs","../../node_modules/.pnpm/flatbuffers@25.9.23/node_modules/flatbuffers/mjs/constants.js","../../node_modules/.pnpm/flatbuffers@25.9.23/node_modules/flatbuffers/mjs/utils.js","../../node_modules/.pnpm/flatbuffers@25.9.23/node_modules/flatbuffers/mjs/encoding.js","../../node_modules/.pnpm/flatbuffers@25.9.23/node_modules/flatbuffers/mjs/byte-buffer.js","../../node_modules/.pnpm/flatbuffers@25.9.23/node_modules/flatbuffers/mjs/builder.js","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/body-compression-method.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/compression-type.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/body-compression.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/buffer.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/field-node.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/record-batch.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/dictionary-batch.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/endianness.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/dictionary-kind.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/int.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/dictionary-encoding.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/key-value.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/binary.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/bool.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/date.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/decimal.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/duration.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/fixed-size-binary.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/fixed-size-list.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/floating-point.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/interval.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/large-binary.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/large-utf8.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/list.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/map.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/null.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/struct-.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/time.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/timestamp.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/union.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/utf8.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/type.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/field.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/schema.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/message-header.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/enum.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/pretty.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/bigint.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/bn.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/type.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/math.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/set.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/row/struct.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/get.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/row/map.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/vector.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/bit.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/data.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/chunk.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/indexof.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/iterator.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/vector.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/block.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/footer.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/schema.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/metadata/file.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/fb/message.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/typeassembler.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/metadata/json.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/metadata/message.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/io/interfaces.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/io/stream.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/io/file.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/int.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/interval.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/vectorloader.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/typecomparator.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/util/recordbatch.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/table.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/recordbatch.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/message.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/compression/validators.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/compression/registry.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/compression/constants.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/reader.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/visitor/vectorassembler.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/writer.mjs","../../node_modules/.pnpm/apache-arrow@21.1.0/node_modules/apache-arrow/ipc/serialization.mjs","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/BitSet.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/bin.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-date.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-regexp.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-object.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/equal.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/recode.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/sequence.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/null.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-array.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-typed-array.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-array-type.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-string.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-valid.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/array.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/pad.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/format-date.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-iso-date-string.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/parse-iso-date.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/date.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/json.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/random.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/math.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-map.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-set.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-map-or-set.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/object.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/string.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/functions/index.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/to-array.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-bigint.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/to-string.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/op-api.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/error.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/unique-name.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-function.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/repeat.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/bins.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/key-function.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/distinct-map.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/no-op.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/product.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/aggregate-functions.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/window-functions.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/op/index.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/concat.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/unroll.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/ascending.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/max.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/min.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/to-numeric.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/quantile.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/value-list.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/reduce/reducer.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/reduce/field-reducer.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/reduce/util.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/entries.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/ast/constants.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/ast/walk.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/ast/clean.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/ast/util.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/codegen.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/compile.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/rewrite.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/row-object.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/to-function.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/parse-escape.js","../../node_modules/.pnpm/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/constants.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/is-number.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/parse-expression.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/parse.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/helpers/wrap.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/helpers/field.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/assign.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/helpers/selection.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/util/parse.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/groupby.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/ColumnSet.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/rollup.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/select.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/regroup.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/array-type.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/Table.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/assign.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/concat.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/relocate.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/bisector.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/window/window-state.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/window/window.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/derive.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/filter.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/dedupe.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/join/lookup.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/intersect.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/util/parse-key.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/util/join-keys.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/join-filter.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/except.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/unroll.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/fold.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/ungroup.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/impute.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/intersect.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/join.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/lookup.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/expression/compare.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/orderby.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/pivot.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/reduce.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/rename.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/sample.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/shuffle.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/sample.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/helpers/slice.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/slice.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/spread.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/union.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/verbs/unorder.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/constants.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/util/arrays.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/util/objects.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/data-types.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/util/numbers.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/util/strings.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/util/read.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/util/struct.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/batch.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/column.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/table.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/batch-type.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/block.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/record-batch.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/dictionary-batch.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/data-type.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/metadata.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/schema.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/message.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/decode-ipc.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/decode/table-from-ipc.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/builder.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/record-batch.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/dictionary-batch.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/metadata.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/data-type.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/schema.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/footer.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/message.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/sink.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/encode-ipc.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/encode/table-to-ipc.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/buffer.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/batch.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/validity.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/dictionary.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/infer-type.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/binary.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/bool.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/decimal.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/fixed-size-binary.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/fixed-size-list.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/interval.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/list.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/struct.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/map.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/run-end-encoded.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/union.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/utf8.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builders/values.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/builder.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/column-from-values.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/column-from-array.js","../../node_modules/.pnpm/@uwdata+flechette@2.2.6/node_modules/@uwdata/flechette/src/build/table-from-columns.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/util/columns.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/to-arrow.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/to-arrow-ipc.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/identity.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/util/scan.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/to-csv.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/util/map-object.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/util/infer.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/util/formats.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/util/format-value.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/to-html.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/stream/constants.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/to-json.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/to-markdown.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/ColumnTable.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/format/from-arrow.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/helpers/escape.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/columns-from.js","../../node_modules/.pnpm/arquero@8.0.3/node_modules/arquero/src/table/index.js","../../node_modules/.pnpm/lz4js@0.2.0/node_modules/lz4js/util.js","../../node_modules/.pnpm/lz4js@0.2.0/node_modules/lz4js/xxh32.js","../../node_modules/.pnpm/lz4js@0.2.0/node_modules/lz4js/lz4.js","../../src/utils/arrow.ts","../../src/app/utils/arrow.ts","../../src/app/server/useScanDataframe.ts","../../src/app/hooks/useSelectedScanner.ts","../../src/app/hooks/useSelectedScanDataframe.ts","../../src/app/utils/arrowHelpers.ts","../../src/app/types.ts","../../src/app/components/Explanation.tsx","../../src/app/components/ValidationResult.tsx","../../src/app/components/Value.tsx","../../src/components/transcript/TranscriptView.tsx","../../src/app/utils/refs.tsx"],"sourcesContent":["import { skipToken } from \"@tanstack/react-query\";\n\nimport { useApi } from \"../../state/store\";\nimport { Status } from \"../../types/api-types\";\nimport { AsyncData } from \"../../utils/asyncData\";\nimport { useAsyncDataFromQuery } from \"../../utils/asyncDataFromQuery\";\n\ntype ScanParams = {\n  scansDir: string;\n  scanPath: string;\n};\n\n// Fetches scan status from the server by location\nexport const useScan = (\n  params: ScanParams | typeof skipToken\n): AsyncData<Status> => {\n  const api = useApi();\n\n  return useAsyncDataFromQuery({\n    queryKey:\n      params === skipToken\n        ? [skipToken]\n        : [\"scan\", params.scansDir, params.scanPath, \"scans-inv\"],\n    queryFn:\n      params === skipToken\n        ? skipToken\n        : () => api.getScan(params.scansDir, params.scanPath),\n    staleTime: 10000,\n  });\n};\n","import { skipToken } from \"@tanstack/react-query\";\nimport { useEffect } from \"react\";\n\nimport { useStore } from \"../../state/store\";\nimport { Status } from \"../../types/api-types\";\nimport { AsyncData } from \"../../utils/asyncData\";\nimport { useScan } from \"../server/useScan\";\n\nimport { useScanRoute } from \"./useScanRoute\";\n\nexport const useSelectedScan = (): AsyncData<Status> => {\n  const { resolvedScansDir, scanPath } = useScanRoute();\n\n  // Set selectedScanLocation for nav restoration\n  const setSelectedScanLocation = useStore(\n    (state) => state.setSelectedScanLocation\n  );\n  useEffect(() => {\n    if (scanPath) {\n      setSelectedScanLocation(scanPath);\n    }\n  }, [scanPath, setSelectedScanLocation]);\n\n  return useScan(\n    resolvedScansDir && scanPath\n      ? { scansDir: resolvedScansDir, scanPath }\n      : skipToken\n  );\n};\n","import { Status } from \"../../types/api-types\";\nimport { toRelativePath } from \"../../utils/path\";\n\n/**\n * Gets the display name for a scan.\n *\n * Uses the relative path from the scans directory when available,\n * providing a more informative title that includes the directory structure.\n *\n * @param scan - The scan status object, or undefined if loading\n * @param scansDir - The base scans directory for computing relative paths\n * @returns The scan display name, or undefined if scan is undefined\n */\nexport function getScanDisplayName(\n  scan: Status | undefined,\n  scansDir: string | undefined\n): string | undefined {\n  if (!scan) return undefined;\n\n  // Use relative path if we have a scans directory\n  if (scansDir && scan.location) {\n    const relativePath = toRelativePath(scan.location, scansDir);\n    if (relativePath) {\n      return relativePath;\n    }\n  }\n\n  // Fall back to scan name\n  return scan.spec.scan_name === \"job\" ? \"scan\" : scan.spec.scan_name;\n}\n","import { ScanResultSummary } from \"../types\";\n\nexport interface IdentifierInfo {\n  taskSet?: string;\n  id: string | number;\n  secondaryId?: string | number;\n  epoch?: number;\n}\n\nexport const resultIdentifierStr = (\n  summary?: ScanResultSummary\n): string | undefined => {\n  const identifier = resultIdentifier(summary);\n  if (!identifier) {\n    return undefined;\n  }\n  if (identifier.secondaryId || identifier.epoch) {\n    const id: string[] = [];\n    if (identifier.taskSet) {\n      id.push(identifier.taskSet);\n    }\n    id.push(String(identifier.id));\n\n    const result: string[] = [id.join(\"/\")];\n    if (identifier.secondaryId) {\n      result.push(String(identifier.secondaryId));\n    }\n    if (identifier.epoch) {\n      result.push(`(${String(identifier.epoch)})`);\n    }\n    return result.join(\" \");\n  }\n};\n\nexport const resultIdentifier = (\n  summary?: ScanResultSummary\n): IdentifierInfo => {\n  if (!summary) {\n    return {\n      id: \"unknown\",\n    };\n  }\n  if (summary.inputType === \"transcript\") {\n    // Look in the metadata for a sample identifier\n    const sampleIdentifier = getSampleIdentifier(summary);\n    if (sampleIdentifier) {\n      return sampleIdentifier;\n    }\n  } else if (summary.inputType === \"message\") {\n    const sampleIdentifier = getSampleIdentifier(summary);\n    return {\n      id: summary.transcriptSourceId,\n      secondaryId: sampleIdentifier ? sampleIdentifier.id : undefined,\n      epoch: sampleIdentifier ? sampleIdentifier.epoch : undefined,\n    };\n  } else if (summary.inputType === \"event\") {\n    const sampleIdentifier = getSampleIdentifier(summary);\n    return {\n      id: summary.transcriptSourceId,\n      secondaryId: sampleIdentifier ? sampleIdentifier.id : undefined,\n      epoch: sampleIdentifier ? sampleIdentifier.epoch : undefined,\n    };\n  }\n\n  return {\n    id: summary.transcriptSourceId,\n  };\n};\n\nconst getSampleIdentifier = (\n  summary: ScanResultSummary\n): IdentifierInfo | undefined => {\n  const id = summary.transcriptTaskId;\n  const epoch = summary.transcriptTaskRepeat;\n\n  if (id && epoch) {\n    const taskSet = summary.transcriptTaskSet;\n    return {\n      id,\n      epoch,\n      taskSet,\n    };\n  }\n  return undefined;\n};\n\nexport const resultLog = (summary: ScanResultSummary): string | undefined => {\n  if (summary.inputType === \"transcript\") {\n    return summary.transcriptMetadata[\"log\"] as string;\n  }\n  return undefined;\n};\n","import clsx from \"clsx\";\nimport { FC, ReactNode } from \"react\";\n\nimport { ApplicationIcons } from \"./icons\";\nimport \"./Card.css\";\n\ninterface CardHeaderProps {\n  id?: string;\n  icon?: string;\n  label?: string;\n  type?: \"default\" | \"modern\";\n  className?: string;\n  children?: ReactNode;\n}\n\ninterface CardBodyProps {\n  id?: string;\n  children?: ReactNode;\n  className?: string | string[];\n  padded?: boolean;\n}\n\ninterface CardProps {\n  id?: string;\n  children?: ReactNode;\n  className?: string | string[];\n}\n\ninterface CardCollapsingHeaderProps {\n  id: string;\n  icon: string;\n  label: string;\n  cardBodyId: string;\n  children?: ReactNode;\n}\n\nexport const CardHeader: FC<CardHeaderProps> = ({\n  id,\n  icon,\n  type,\n  label,\n  className,\n  children,\n}) => {\n  return (\n    <div\n      className={clsx(\n        \"card-header-container\",\n        \"text-style-label\",\n        className,\n        type === \"modern\" ? \"card-header-modern\" : \"\"\n      )}\n      id={id || \"\"}\n    >\n      {icon ? (\n        <i className={clsx(\"card-header-icon\", icon)}></i>\n      ) : (\n        <span\n          className={clsx(\"card-header-icon\", \"card-header-icon-empty\")}\n        ></span>\n      )}\n      {label ? label : \"\"} {children}\n    </div>\n  );\n};\n\nexport const CardBody: FC<CardBodyProps> = ({\n  id,\n  children,\n  className,\n  padded = true,\n}) => {\n  return (\n    <div\n      className={clsx(\n        \"card-body\",\n        className,\n        !padded ? \"card-no-padding\" : undefined\n      )}\n      id={id || \"\"}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport const Card: FC<CardProps> = ({ id, children, className }) => {\n  return (\n    <div className={clsx(\"card\", className)} id={id}>\n      {children}\n    </div>\n  );\n};\n\nexport const CardCollapsingHeader: FC<CardCollapsingHeaderProps> = ({\n  id,\n  icon,\n  label,\n  cardBodyId,\n  children,\n}) => {\n  return (\n    <CardHeader\n      id={id}\n      className={clsx(\n        \"card-collaping-header\",\n        \"container-fluid\",\n        \"collapse\",\n        \"show\",\n        \"do-not-collapse-self\"\n      )}\n    >\n      <div\n        className={clsx(\"card-collaping-header-container\", \"row\", \"row-cols-3\")}\n        data-bs-toggle=\"collapse\"\n        data-bs-target={`#${cardBodyId}`}\n        aria-expanded=\"false\"\n        aria-controls={cardBodyId}\n      >\n        <div className={\"card-collaping-header-icon\"}>\n          <i className={icon}></i>{\" \"}\n          <span className=\"hide-when-collapsed\">{label}</span>\n        </div>\n        <div className=\"hide-when-expanded card-collapsing-header-content\">\n          {children}\n        </div>\n        <div className={\"card-collapsing-header-toggle\"}>\n          <i\n            className={clsx(ApplicationIcons[\"toggle-right\"], \"toggle-rotated\")}\n          ></i>\n        </div>\n      </div>\n    </CardHeader>\n  );\n};\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nconst decoder = new TextDecoder('utf-8');\n/** @ignore */\nexport const decodeUtf8 = decoder.decode.bind(decoder);\nconst encoder = new TextEncoder();\n/** @ignore */\nexport const encodeUtf8 = (value) => encoder.encode(value);\n\n//# sourceMappingURL=utf8.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */ const isNumber = (x) => typeof x === 'number';\n/** @ignore */ const isBoolean = (x) => typeof x === 'boolean';\n/** @ignore */ const isFunction = (x) => typeof x === 'function';\n/** @ignore */\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport const isObject = (x) => x != null && Object(x) === x;\n/** @ignore */\nexport const isPromise = (x) => {\n    return isObject(x) && isFunction(x.then);\n};\n/** @ignore */\nexport const isObservable = (x) => {\n    return isObject(x) && isFunction(x.subscribe);\n};\n/** @ignore */\nexport const isIterable = (x) => {\n    return isObject(x) && isFunction(x[Symbol.iterator]);\n};\n/** @ignore */\nexport const isAsyncIterable = (x) => {\n    return isObject(x) && isFunction(x[Symbol.asyncIterator]);\n};\n/** @ignore */\nexport const isArrowJSON = (x) => {\n    return isObject(x) && isObject(x['schema']);\n};\n/** @ignore */\nexport const isArrayLike = (x) => {\n    return isObject(x) && isNumber(x['length']);\n};\n/** @ignore */\nexport const isIteratorResult = (x) => {\n    return isObject(x) && ('done' in x) && ('value' in x);\n};\n/** @ignore */\nexport const isUnderlyingSink = (x) => {\n    return isObject(x) &&\n        isFunction(x['abort']) &&\n        isFunction(x['close']) &&\n        isFunction(x['start']) &&\n        isFunction(x['write']);\n};\n/** @ignore */\nexport const isFileHandle = (x) => {\n    return isObject(x) && isFunction(x['stat']) && isNumber(x['fd']);\n};\n/** @ignore */\nexport const isFSReadStream = (x) => {\n    return isReadableNodeStream(x) && isNumber(x['bytesRead']);\n};\n/** @ignore */\nexport const isFetchResponse = (x) => {\n    return isObject(x) && isReadableDOMStream(x['body']);\n};\nconst isReadableInterop = (x) => ('_getDOMStream' in x && '_getNodeStream' in x);\n/** @ignore */\nexport const isWritableDOMStream = (x) => {\n    return isObject(x) &&\n        isFunction(x['abort']) &&\n        isFunction(x['getWriter']) &&\n        !isReadableInterop(x);\n};\n/** @ignore */\nexport const isReadableDOMStream = (x) => {\n    return isObject(x) &&\n        isFunction(x['cancel']) &&\n        isFunction(x['getReader']) &&\n        !isReadableInterop(x);\n};\n/** @ignore */\nexport const isWritableNodeStream = (x) => {\n    return isObject(x) &&\n        isFunction(x['end']) &&\n        isFunction(x['write']) &&\n        isBoolean(x['writable']) &&\n        !isReadableInterop(x);\n};\n/** @ignore */\nexport const isReadableNodeStream = (x) => {\n    return isObject(x) &&\n        isFunction(x['read']) &&\n        isFunction(x['pipe']) &&\n        isBoolean(x['readable']) &&\n        !isReadableInterop(x);\n};\n/** @ignore */\nexport const isFlatbuffersByteBuffer = (x) => {\n    return isObject(x) &&\n        isFunction(x['clear']) &&\n        isFunction(x['bytes']) &&\n        isFunction(x['position']) &&\n        isFunction(x['setPosition']) &&\n        isFunction(x['capacity']) &&\n        isFunction(x['getBufferIdentifier']) &&\n        isFunction(x['createLong']);\n};\n\n//# sourceMappingURL=compat.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { encodeUtf8 } from '../util/utf8.mjs';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isFlatbuffersByteBuffer } from './compat.mjs';\n/** @ignore */\nconst SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);\n/** @ignore */\nfunction collapseContiguousByteRanges(chunks) {\n    const result = chunks[0] ? [chunks[0]] : [];\n    let xOffset, yOffset, xLen, yLen;\n    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n;) {\n        x = result[j];\n        y = chunks[i];\n        // continue if x and y don't share the same underlying ArrayBuffer, or if x isn't before y\n        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {\n            y && (result[++j] = y);\n            continue;\n        }\n        ({ byteOffset: xOffset, byteLength: xLen } = x);\n        ({ byteOffset: yOffset, byteLength: yLen } = y);\n        // continue if the byte ranges of x and y aren't contiguous\n        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {\n            y && (result[++j] = y);\n            continue;\n        }\n        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);\n    }\n    return result;\n}\n/** @ignore */\nexport function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {\n    const targetByteLength = target.byteLength;\n    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));\n    dst.set(src, targetByteOffset);\n    return target;\n}\n/** @ignore */\nexport function joinUint8Arrays(chunks, size) {\n    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,\n    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during\n    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer\n    const result = collapseContiguousByteRanges(chunks);\n    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);\n    let source, sliced, buffer;\n    let offset = 0, index = -1;\n    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);\n    for (const n = result.length; ++index < n;) {\n        source = result[index];\n        sliced = source.subarray(0, Math.min(source.length, length - offset));\n        if (length <= (offset + sliced.length)) {\n            if (sliced.length < source.length) {\n                result[index] = source.subarray(sliced.length);\n            }\n            else if (sliced.length === source.length) {\n                index++;\n            }\n            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);\n            break;\n        }\n        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);\n        offset += sliced.length;\n    }\n    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];\n}\n/** @ignore */\nexport function toArrayBufferView(ArrayBufferViewCtor, input) {\n    let value = isIteratorResult(input) ? input.value : input;\n    if (value instanceof ArrayBufferViewCtor) {\n        if (ArrayBufferViewCtor === Uint8Array) {\n            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need\n            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/\n            return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);\n        }\n        return value;\n    }\n    if (!value) {\n        return new ArrayBufferViewCtor(0);\n    }\n    if (typeof value === 'string') {\n        value = encodeUtf8(value);\n    }\n    if (value instanceof ArrayBuffer) {\n        return new ArrayBufferViewCtor(value);\n    }\n    if (value instanceof SharedArrayBuf) {\n        return new ArrayBufferViewCtor(value);\n    }\n    if (isFlatbuffersByteBuffer(value)) {\n        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());\n    }\n    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : (value.byteLength <= 0 ? new ArrayBufferViewCtor(0)\n        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT));\n}\n/** @ignore */ export const toInt8Array = (input) => toArrayBufferView(Int8Array, input);\n/** @ignore */ export const toInt16Array = (input) => toArrayBufferView(Int16Array, input);\n/** @ignore */ export const toInt32Array = (input) => toArrayBufferView(Int32Array, input);\n/** @ignore */ export const toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);\n/** @ignore */ export const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);\n/** @ignore */ export const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);\n/** @ignore */ export const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);\n/** @ignore */ export const toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);\n/** @ignore */ export const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);\n/** @ignore */ export const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);\n/** @ignore */ export const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);\n/** @ignore */\nconst pump = (iterator) => { iterator.next(); return iterator; };\n/** @ignore */\nexport function* toArrayBufferViewIterator(ArrayCtor, source) {\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    const wrap = function* (x) { yield x; };\n    const buffers = (typeof source === 'string') ? wrap(source)\n        : (ArrayBuffer.isView(source)) ? wrap(source)\n            : (source instanceof ArrayBuffer) ? wrap(source)\n                : (source instanceof SharedArrayBuf) ? wrap(source)\n                    : !isIterable(source) ? wrap(source) : source;\n    yield* pump((function* (it) {\n        let r = null;\n        do {\n            r = it.next(yield toArrayBufferView(ArrayCtor, r));\n        } while (!r.done);\n    })(buffers[Symbol.iterator]()));\n    return new ArrayCtor();\n}\n/** @ignore */ export const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);\n/** @ignore */ export const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);\n/** @ignore */ export const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);\n/** @ignore */ export const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);\n/** @ignore */ export const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);\n/** @ignore */ export const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);\n/** @ignore */ export const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);\n/** @ignore */ export const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);\n/** @ignore */ export const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);\n/** @ignore */\nexport function toArrayBufferViewAsyncIterator(ArrayCtor, source) {\n    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {\n        // if a Promise, unwrap the Promise and iterate the resolved value\n        if (isPromise(source)) {\n            return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));\n        }\n        // eslint-disable-next-line unicorn/consistent-function-scoping\n        const wrap = function (x) { return __asyncGenerator(this, arguments, function* () { yield yield __await(yield __await(x)); }); };\n        const emit = function (source) {\n            return __asyncGenerator(this, arguments, function* () {\n                yield __await(yield* __asyncDelegator(__asyncValues(pump((function* (it) {\n                    let r = null;\n                    do {\n                        r = it.next(yield r === null || r === void 0 ? void 0 : r.value);\n                    } while (!r.done);\n                })(source[Symbol.iterator]())))));\n            });\n        };\n        const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator\n            : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator\n                : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator\n                    : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator\n                        : isIterable(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values\n                            : !isAsyncIterable(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator\n                                : source; // otherwise if AsyncIterable, use it\n        yield __await(// otherwise if AsyncIterable, use it\n        yield* __asyncDelegator(__asyncValues(pump((function (it) {\n            return __asyncGenerator(this, arguments, function* () {\n                let r = null;\n                do {\n                    r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));\n                } while (!r.done);\n            });\n        })(buffers[Symbol.asyncIterator]())))));\n        return yield __await(new ArrayCtor());\n    });\n}\n/** @ignore */ export const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);\n/** @ignore */ export const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);\n/** @ignore */ export const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);\n/** @ignore */ export const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);\n/** @ignore */ export const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);\n/** @ignore */ export const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);\n/** @ignore */ export const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);\n/** @ignore */ export const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);\n/** @ignore */ export const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);\nexport function rebaseValueOffsets(offset, length, valueOffsets) {\n    // If we have a non-zero offset, create a new offsets array with the values\n    // shifted by the start offset, such that the new start offset is 0\n    if (offset !== 0) {\n        valueOffsets = valueOffsets.slice(0, length);\n        for (let i = -1, n = valueOffsets.length; ++i < n;) {\n            valueOffsets[i] += offset;\n        }\n    }\n    return valueOffsets.subarray(0, length);\n}\n/** @ignore */\nexport function compareArrayLike(a, b) {\n    let i = 0;\n    const n = a.length;\n    if (n !== b.length) {\n        return false;\n    }\n    if (n > 0) {\n        do {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        } while (++i < n);\n    }\n    return true;\n}\n\n//# sourceMappingURL=buffer.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncGenerator, __await, __awaiter } from \"tslib\";\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer.mjs';\n/** @ignore */\nexport default {\n    fromIterable(source) {\n        return pump(fromIterable(source));\n    },\n    fromAsyncIterable(source) {\n        return pump(fromAsyncIterable(source));\n    },\n    fromDOMStream(source) {\n        return pump(fromDOMStream(source));\n    },\n    fromNodeStream(stream) {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream(source, options) {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream(source, options) {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n/** @ignore */\nconst pump = (iterator) => { iterator.next(); return iterator; };\n/** @ignore */\nfunction* fromIterable(source) {\n    let done, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = (yield (() => null)()) || { cmd: 'read', size: 0 });\n    // initialize the iterator\n    const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ?\n                it.next() : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    }\n    catch (e) {\n        threw = true;\n        (typeof it.throw === 'function') && (it.throw(e));\n    }\n    finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return(null));\n    }\n    return null;\n}\n/** @ignore */\nfunction fromAsyncIterable(source) {\n    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {\n        let done, threw = false;\n        let buffers = [], buffer;\n        let cmd, size, bufferLength = 0;\n        function byteRange() {\n            if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n            }\n            [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n            return buffer;\n        }\n        // Yield so the caller can inject the read command before creating the source AsyncIterator\n        ({ cmd, size } = (yield yield __await((() => null)())) || { cmd: 'read', size: 0 });\n        // initialize the iterator\n        const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n        try {\n            do {\n                // read the next value\n                ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                    ? yield __await(it.next())\n                    : yield __await(it.next(size - bufferLength)));\n                // if chunk is not null or empty, push it onto the queue\n                if (!done && buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n                // If we have enough bytes in our buffer, yield chunks until we don't\n                if (done || size <= bufferLength) {\n                    do {\n                        ({ cmd, size } = yield yield __await(byteRange()));\n                    } while (size < bufferLength);\n                }\n            } while (!done);\n        }\n        catch (e) {\n            threw = true;\n            (typeof it.throw === 'function') && (yield __await(it.throw(e)));\n        }\n        finally {\n            (threw === false) && (typeof it.return === 'function') && (yield __await(it.return(new Uint8Array(0))));\n        }\n        return yield __await(null);\n    });\n}\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction fromDOMStream(source) {\n    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {\n        let done = false, threw = false;\n        let buffers = [], buffer;\n        let cmd, size, bufferLength = 0;\n        function byteRange() {\n            if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n            }\n            [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n            return buffer;\n        }\n        // Yield so the caller can inject the read command before we establish the ReadableStream lock\n        ({ cmd, size } = (yield yield __await((() => null)())) || { cmd: 'read', size: 0 });\n        // initialize the reader and lock the stream\n        const it = new AdaptiveByteReader(source);\n        try {\n            do {\n                // read the next value\n                ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                    ? yield __await(it['read']())\n                    : yield __await(it['read'](size - bufferLength)));\n                // if chunk is not null or empty, push it onto the queue\n                if (!done && buffer.byteLength > 0) {\n                    buffers.push(toUint8Array(buffer));\n                    bufferLength += buffer.byteLength;\n                }\n                // If we have enough bytes in our buffer, yield chunks until we don't\n                if (done || size <= bufferLength) {\n                    do {\n                        ({ cmd, size } = yield yield __await(byteRange()));\n                    } while (size < bufferLength);\n                }\n            } while (!done);\n        }\n        catch (e) {\n            threw = true;\n            yield __await(it['cancel'](e));\n        }\n        finally {\n            (threw === false) ? (yield __await(it['cancel']()))\n                : source['locked'] && it.releaseLock();\n        }\n        return yield __await(null);\n    });\n}\n/** @ignore */\nclass AdaptiveByteReader {\n    constructor(source) {\n        this.source = source;\n        this.reader = null;\n        this.reader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.reader['closed'].catch(() => { });\n    }\n    get closed() {\n        return this.reader ? this.reader['closed'].catch(() => { }) : Promise.resolve();\n    }\n    releaseLock() {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = null;\n    }\n    cancel(reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { reader, source } = this;\n            reader && (yield reader['cancel'](reason).catch(() => { }));\n            source && (source['locked'] && this.releaseLock());\n        });\n    }\n    read(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (size === 0) {\n                return { done: this.reader == null, value: new Uint8Array(0) };\n            }\n            const result = yield this.reader.read();\n            !result.done && (result.value = toUint8Array(result));\n            return result;\n        });\n    }\n}\n/** @ignore */\nconst onEvent = (stream, event) => {\n    const handler = (_) => resolve([event, _]);\n    let resolve;\n    return [event, handler, new Promise((r) => (resolve = r) && stream['once'](event, handler))];\n};\n/** @ignore */\nfunction fromNodeStream(stream) {\n    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {\n        const events = [];\n        let event = 'error';\n        let done = false, err = null;\n        let cmd, size, bufferLength = 0;\n        let buffers = [], buffer;\n        function byteRange() {\n            if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n            }\n            [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n            return buffer;\n        }\n        // Yield so the caller can inject the read command before we\n        // add the listener for the source stream's 'readable' event.\n        ({ cmd, size } = (yield yield __await((() => null)())) || { cmd: 'read', size: 0 });\n        // ignore stdin if it's a TTY\n        if (stream['isTTY']) {\n            yield yield __await(new Uint8Array(0));\n            return yield __await(null);\n        }\n        try {\n            // initialize the stream event handlers\n            events[0] = onEvent(stream, 'end');\n            events[1] = onEvent(stream, 'error');\n            do {\n                events[2] = onEvent(stream, 'readable');\n                // wait on the first message event from the stream\n                [event, err] = yield __await(Promise.race(events.map((x) => x[2])));\n                // if the stream emitted an Error, rethrow it\n                if (event === 'error') {\n                    break;\n                }\n                if (!(done = event === 'end')) {\n                    // If the size is NaN, request to read everything in the stream's internal buffer\n                    if (!Number.isFinite(size - bufferLength)) {\n                        buffer = toUint8Array(stream['read']());\n                    }\n                    else {\n                        buffer = toUint8Array(stream['read'](size - bufferLength));\n                        // If the byteLength is 0, then the requested amount is more than the stream has\n                        // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                        // continue emitting readable events, so request to read everything the stream\n                        // has in its internal buffer right now.\n                        if (buffer.byteLength < (size - bufferLength)) {\n                            buffer = toUint8Array(stream['read']());\n                        }\n                    }\n                    // if chunk is not null or empty, push it onto the queue\n                    if (buffer.byteLength > 0) {\n                        buffers.push(buffer);\n                        bufferLength += buffer.byteLength;\n                    }\n                }\n                // If we have enough bytes in our buffer, yield chunks until we don't\n                if (done || size <= bufferLength) {\n                    do {\n                        ({ cmd, size } = yield yield __await(byteRange()));\n                    } while (size < bufferLength);\n                }\n            } while (!done);\n        }\n        finally {\n            yield __await(cleanup(events, event === 'error' ? err : null));\n        }\n        return yield __await(null);\n        function cleanup(events, err) {\n            buffer = buffers = null;\n            return new Promise((resolve, reject) => {\n                for (const [evt, fn] of events) {\n                    stream['off'](evt, fn);\n                }\n                try {\n                    // Some stream implementations don't call the destroy callback,\n                    // because it's really a node-internal API. Just calling `destroy`\n                    // here should be enough to conform to the ReadableStream contract\n                    const destroy = stream['destroy'];\n                    destroy && destroy.call(stream, err);\n                    err = undefined;\n                }\n                catch (e) {\n                    err = e || err;\n                }\n                finally {\n                    err != null ? reject(err) : resolve();\n                }\n            });\n        }\n    });\n}\n\n//# sourceMappingURL=adapters.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * Logical types, vector layouts, and schemas\n * Format Version History.\n * Version 1.0 - Forward and backwards compatibility guaranteed.\n * Version 1.1 - Add Decimal256.\n * Version 1.2 - Add Interval MONTH_DAY_NANO.\n * Version 1.3 - Add Run-End Encoded.\n */\nexport var MetadataVersion;\n(function (MetadataVersion) {\n    /**\n     * 0.1.0 (October 2016).\n     */\n    MetadataVersion[MetadataVersion[\"V1\"] = 0] = \"V1\";\n    /**\n     * 0.2.0 (February 2017). Non-backwards compatible with V1.\n     */\n    MetadataVersion[MetadataVersion[\"V2\"] = 1] = \"V2\";\n    /**\n     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.\n     */\n    MetadataVersion[MetadataVersion[\"V3\"] = 2] = \"V3\";\n    /**\n     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.\n     */\n    MetadataVersion[MetadataVersion[\"V4\"] = 3] = \"V4\";\n    /**\n     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4\n     * metadata and IPC messages). Implementations are recommended to provide a\n     * V4 compatibility mode with V5 format changes disabled.\n     *\n     * Incompatible changes between V4 and V5:\n     * - Union buffer layout has changed. In V5, Unions don't have a validity\n     *   bitmap buffer.\n     */\n    MetadataVersion[MetadataVersion[\"V5\"] = 4] = \"V5\";\n})(MetadataVersion || (MetadataVersion = {}));\n\n//# sourceMappingURL=metadata-version.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport var UnionMode;\n(function (UnionMode) {\n    UnionMode[UnionMode[\"Sparse\"] = 0] = \"Sparse\";\n    UnionMode[UnionMode[\"Dense\"] = 1] = \"Dense\";\n})(UnionMode || (UnionMode = {}));\n\n//# sourceMappingURL=union-mode.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport var Precision;\n(function (Precision) {\n    Precision[Precision[\"HALF\"] = 0] = \"HALF\";\n    Precision[Precision[\"SINGLE\"] = 1] = \"SINGLE\";\n    Precision[Precision[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(Precision || (Precision = {}));\n\n//# sourceMappingURL=precision.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport var DateUnit;\n(function (DateUnit) {\n    DateUnit[DateUnit[\"DAY\"] = 0] = \"DAY\";\n    DateUnit[DateUnit[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n})(DateUnit || (DateUnit = {}));\n\n//# sourceMappingURL=date-unit.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport var TimeUnit;\n(function (TimeUnit) {\n    TimeUnit[TimeUnit[\"SECOND\"] = 0] = \"SECOND\";\n    TimeUnit[TimeUnit[\"MILLISECOND\"] = 1] = \"MILLISECOND\";\n    TimeUnit[TimeUnit[\"MICROSECOND\"] = 2] = \"MICROSECOND\";\n    TimeUnit[TimeUnit[\"NANOSECOND\"] = 3] = \"NANOSECOND\";\n})(TimeUnit || (TimeUnit = {}));\n\n//# sourceMappingURL=time-unit.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport var IntervalUnit;\n(function (IntervalUnit) {\n    IntervalUnit[IntervalUnit[\"YEAR_MONTH\"] = 0] = \"YEAR_MONTH\";\n    IntervalUnit[IntervalUnit[\"DAY_TIME\"] = 1] = \"DAY_TIME\";\n    IntervalUnit[IntervalUnit[\"MONTH_DAY_NANO\"] = 2] = \"MONTH_DAY_NANO\";\n})(IntervalUnit || (IntervalUnit = {}));\n\n//# sourceMappingURL=interval-unit.mjs.map\n","export const SIZEOF_SHORT = 2;\nexport const SIZEOF_INT = 4;\nexport const FILE_IDENTIFIER_LENGTH = 4;\nexport const SIZE_PREFIX_LENGTH = 4;\n","export const int32 = new Int32Array(2);\nexport const float32 = new Float32Array(int32.buffer);\nexport const float64 = new Float64Array(int32.buffer);\nexport const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n","export var Encoding;\n(function (Encoding) {\n    Encoding[Encoding[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n    Encoding[Encoding[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n","import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from './constants.js';\nimport { Encoding } from './encoding.js';\nimport { float32, float64, int32, isLittleEndian } from './utils.js';\nexport class ByteBuffer {\n    /**\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n     */\n    constructor(bytes_) {\n        this.bytes_ = bytes_;\n        this.position_ = 0;\n        this.text_decoder_ = new TextDecoder();\n    }\n    /**\n     * Create and allocate a new ByteBuffer with a given size.\n     */\n    static allocate(byte_size) {\n        return new ByteBuffer(new Uint8Array(byte_size));\n    }\n    clear() {\n        this.position_ = 0;\n    }\n    /**\n     * Get the underlying `Uint8Array`.\n     */\n    bytes() {\n        return this.bytes_;\n    }\n    /**\n     * Get the buffer's position.\n     */\n    position() {\n        return this.position_;\n    }\n    /**\n     * Set the buffer's position.\n     */\n    setPosition(position) {\n        this.position_ = position;\n    }\n    /**\n     * Get the buffer's capacity.\n     */\n    capacity() {\n        return this.bytes_.length;\n    }\n    readInt8(offset) {\n        return (this.readUint8(offset) << 24) >> 24;\n    }\n    readUint8(offset) {\n        return this.bytes_[offset];\n    }\n    readInt16(offset) {\n        return (this.readUint16(offset) << 16) >> 16;\n    }\n    readUint16(offset) {\n        return this.bytes_[offset] | (this.bytes_[offset + 1] << 8);\n    }\n    readInt32(offset) {\n        return (this.bytes_[offset] |\n            (this.bytes_[offset + 1] << 8) |\n            (this.bytes_[offset + 2] << 16) |\n            (this.bytes_[offset + 3] << 24));\n    }\n    readUint32(offset) {\n        return this.readInt32(offset) >>> 0;\n    }\n    readInt64(offset) {\n        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) +\n            (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readUint64(offset) {\n        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) +\n            (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readFloat32(offset) {\n        int32[0] = this.readInt32(offset);\n        return float32[0];\n    }\n    readFloat64(offset) {\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n        return float64[0];\n    }\n    writeInt8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeUint8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeInt16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeUint16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeInt32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeUint32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeInt64(offset, value) {\n        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n    }\n    writeUint64(offset, value) {\n        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n    }\n    writeFloat32(offset, value) {\n        float32[0] = value;\n        this.writeInt32(offset, int32[0]);\n    }\n    writeFloat64(offset, value) {\n        float64[0] = value;\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n    }\n    /**\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n     * schema does not include a file_identifier (likely points at padding or the\n     * start of a the root vtable).\n     */\n    getBufferIdentifier() {\n        if (this.bytes_.length <\n            this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n        }\n        let result = '';\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n        }\n        return result;\n    }\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     */\n    __offset(bb_pos, vtable_offset) {\n        const vtable = bb_pos - this.readInt32(bb_pos);\n        return vtable_offset < this.readInt16(vtable)\n            ? this.readInt16(vtable + vtable_offset)\n            : 0;\n    }\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     */\n    __union(t, offset) {\n        t.bb_pos = offset + this.readInt32(offset);\n        t.bb = this;\n        return t;\n    }\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n     * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n     * the data will just be packaged back up in another FlatBuffer later on.\n     *\n     * @param offset\n     * @param opt_encoding Defaults to UTF16_STRING\n     */\n    __string(offset, opt_encoding) {\n        offset += this.readInt32(offset);\n        const length = this.readInt32(offset);\n        offset += SIZEOF_INT;\n        const utf8bytes = this.bytes_.subarray(offset, offset + length);\n        if (opt_encoding === Encoding.UTF8_BYTES)\n            return utf8bytes;\n        else\n            return this.text_decoder_.decode(utf8bytes);\n    }\n    /**\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n     * if a string then return a new one\n     *\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n     * makes the behaviour of __union_with_string different compared to __union\n     */\n    __union_with_string(o, offset) {\n        if (typeof o === 'string') {\n            return this.__string(offset);\n        }\n        return this.__union(o, offset);\n    }\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     */\n    __indirect(offset) {\n        return offset + this.readInt32(offset);\n    }\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector(offset) {\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n    }\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector_len(offset) {\n        return this.readInt32(offset + this.readInt32(offset));\n    }\n    __has_identifier(ident) {\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: file identifier must be length ' + FILE_IDENTIFIER_LENGTH);\n        }\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A helper function for generating list for obj api\n     */\n    createScalarList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    /**\n     * A helper function for generating list for obj api\n     * @param listAccessor function that accepts an index and return data at that index\n     * @param listLength listLength\n     * @param res result list\n     */\n    createObjList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val.unpack());\n            }\n        }\n        return ret;\n    }\n}\n","import { ByteBuffer } from './byte-buffer.js';\nimport { FILE_IDENTIFIER_LENGTH, SIZE_PREFIX_LENGTH, SIZEOF_INT, SIZEOF_SHORT, } from './constants.js';\nexport class Builder {\n    /**\n     * Create a FlatBufferBuilder.\n     */\n    constructor(opt_initial_size) {\n        /** Minimum alignment encountered so far. */\n        this.minalign = 1;\n        /** The vtable for the current table. */\n        this.vtable = null;\n        /** The amount of fields we're actually using. */\n        this.vtable_in_use = 0;\n        /** Whether we are currently serializing a table. */\n        this.isNested = false;\n        /** Starting offset of the current struct/table. */\n        this.object_start = 0;\n        /** List of offsets of all vtables. */\n        this.vtables = [];\n        /** For the current vector being built. */\n        this.vector_num_elems = 0;\n        /** False omits default values from the serialized data */\n        this.force_defaults = false;\n        this.string_maps = null;\n        this.text_encoder = new TextEncoder();\n        let initial_size;\n        if (!opt_initial_size) {\n            initial_size = 1024;\n        }\n        else {\n            initial_size = opt_initial_size;\n        }\n        /**\n         * @type {ByteBuffer}\n         * @private\n         */\n        this.bb = ByteBuffer.allocate(initial_size);\n        this.space = initial_size;\n    }\n    clear() {\n        this.bb.clear();\n        this.space = this.bb.capacity();\n        this.minalign = 1;\n        this.vtable = null;\n        this.vtable_in_use = 0;\n        this.isNested = false;\n        this.object_start = 0;\n        this.vtables = [];\n        this.vector_num_elems = 0;\n        this.force_defaults = false;\n        this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults) {\n        this.force_defaults = forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n    dataBuffer() {\n        return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n    asUint8Array() {\n        return this.bb\n            .bytes()\n            .subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n    prep(size, additional_bytes) {\n        // Track the biggest thing we've ever aligned to.\n        if (size > this.minalign) {\n            this.minalign = size;\n        }\n        // Find the amount of alignment needed such that `size` is properly\n        // aligned after `additional_bytes`\n        const align_size = (~(this.bb.capacity() - this.space + additional_bytes) + 1) & (size - 1);\n        // Reallocate the buffer if needed.\n        while (this.space < align_size + size + additional_bytes) {\n            const old_buf_size = this.bb.capacity();\n            this.bb = Builder.growByteBuffer(this.bb);\n            this.space += this.bb.capacity() - old_buf_size;\n        }\n        this.pad(align_size);\n    }\n    pad(byte_size) {\n        for (let i = 0; i < byte_size; i++) {\n            this.bb.writeInt8(--this.space, 0);\n        }\n    }\n    writeInt8(value) {\n        this.bb.writeInt8((this.space -= 1), value);\n    }\n    writeInt16(value) {\n        this.bb.writeInt16((this.space -= 2), value);\n    }\n    writeInt32(value) {\n        this.bb.writeInt32((this.space -= 4), value);\n    }\n    writeInt64(value) {\n        this.bb.writeInt64((this.space -= 8), value);\n    }\n    writeFloat32(value) {\n        this.bb.writeFloat32((this.space -= 4), value);\n    }\n    writeFloat64(value) {\n        this.bb.writeFloat64((this.space -= 8), value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n    addInt8(value) {\n        this.prep(1, 0);\n        this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n    addInt16(value) {\n        this.prep(2, 0);\n        this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n    addInt32(value) {\n        this.prep(4, 0);\n        this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n    addInt64(value) {\n        this.prep(8, 0);\n        this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n    addFloat32(value) {\n        this.prep(4, 0);\n        this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n    addFloat64(value) {\n        this.prep(8, 0);\n        this.writeFloat64(value);\n    }\n    addFieldInt8(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt8(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt16(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt16(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt64(voffset, value, defaultValue) {\n        if (this.force_defaults || value !== defaultValue) {\n            this.addInt64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat64(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldOffset(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addOffset(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n    addFieldStruct(voffset, value, defaultValue) {\n        if (value != defaultValue) {\n            this.nested(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n    nested(obj) {\n        if (obj != this.offset()) {\n            throw new TypeError('FlatBuffers: struct must be serialized inline.');\n        }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested() {\n        if (this.isNested) {\n            throw new TypeError('FlatBuffers: object serialization must not be nested.');\n        }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n    slot(voffset) {\n        if (this.vtable !== null)\n            this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n    offset() {\n        return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n    static growByteBuffer(bb) {\n        const old_buf_size = bb.capacity();\n        // Ensure we don't grow beyond what fits in an int.\n        if (old_buf_size & 0xc0000000) {\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n        }\n        const new_buf_size = old_buf_size << 1;\n        const nbb = ByteBuffer.allocate(new_buf_size);\n        nbb.setPosition(new_buf_size - old_buf_size);\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n        return nbb;\n    }\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    addOffset(offset) {\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n    startObject(numfields) {\n        this.notNested();\n        if (this.vtable == null) {\n            this.vtable = [];\n        }\n        this.vtable_in_use = numfields;\n        for (let i = 0; i < numfields; i++) {\n            this.vtable[i] = 0; // This will push additional elements as needed\n        }\n        this.isNested = true;\n        this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n    endObject() {\n        if (this.vtable == null || !this.isNested) {\n            throw new Error('FlatBuffers: endObject called without startObject');\n        }\n        this.addInt32(0);\n        const vtableloc = this.offset();\n        // Trim trailing zeroes.\n        let i = this.vtable_in_use - 1;\n        // eslint-disable-next-line no-empty\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\n        const trimmed_size = i + 1;\n        // Write out the current vtable.\n        for (; i >= 0; i--) {\n            // Offset relative to the start of the table.\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n        }\n        const standard_fields = 2; // The fields below:\n        this.addInt16(vtableloc - this.object_start);\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n        this.addInt16(len);\n        // Search for an existing vtable that matches the current one.\n        let existing_vtable = 0;\n        const vt1 = this.space;\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\n            const vt2 = this.bb.capacity() - this.vtables[i];\n            if (len == this.bb.readInt16(vt2)) {\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n                        continue outer_loop;\n                    }\n                }\n                existing_vtable = this.vtables[i];\n                break;\n            }\n        }\n        if (existing_vtable) {\n            // Found a match:\n            // Remove the current vtable.\n            this.space = this.bb.capacity() - vtableloc;\n            // Point table to existing vtable.\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n        }\n        else {\n            // No match:\n            // Add the location of the current vtable to the list of vtables.\n            this.vtables.push(this.offset());\n            // Point table to current vtable.\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n        }\n        this.isNested = false;\n        return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n        if (opt_file_identifier) {\n            const file_identifier = opt_file_identifier;\n            this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n                throw new TypeError('FlatBuffers: file identifier must be length ' +\n                    FILE_IDENTIFIER_LENGTH);\n            }\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n                this.writeInt8(file_identifier.charCodeAt(i));\n            }\n        }\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\n        this.addOffset(root_table);\n        if (size_prefix) {\n            this.addInt32(this.bb.capacity() - this.space);\n        }\n        this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n    finishSizePrefixed(root_table, opt_file_identifier) {\n        this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n    requiredField(table, field) {\n        const table_start = this.bb.capacity() - table;\n        const vtable_start = table_start - this.bb.readInt32(table_start);\n        const ok = field < this.bb.readInt16(vtable_start) &&\n            this.bb.readInt16(vtable_start + field) != 0;\n        // If this fails, the caller will show what field needs to be set.\n        if (!ok) {\n            throw new TypeError('FlatBuffers: field ' + field + ' must be set');\n        }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n    startVector(elem_size, num_elems, alignment) {\n        this.notNested();\n        this.vector_num_elems = num_elems;\n        this.prep(SIZEOF_INT, elem_size * num_elems);\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n    endVector() {\n        this.writeInt32(this.vector_num_elems);\n        return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createSharedString(s) {\n        if (!s) {\n            return 0;\n        }\n        if (!this.string_maps) {\n            this.string_maps = new Map();\n        }\n        if (this.string_maps.has(s)) {\n            return this.string_maps.get(s);\n        }\n        const offset = this.createString(s);\n        this.string_maps.set(s, offset);\n        return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createString(s) {\n        if (s === null || s === undefined) {\n            return 0;\n        }\n        let utf8;\n        if (s instanceof Uint8Array) {\n            utf8 = s;\n        }\n        else {\n            utf8 = this.text_encoder.encode(s);\n        }\n        this.addInt8(0);\n        this.startVector(1, utf8.length, 1);\n        this.bb.setPosition((this.space -= utf8.length));\n        this.bb.bytes().set(utf8, this.space);\n        return this.endVector();\n    }\n    /**\n     * Create a byte vector.\n     *\n     * @param v The bytes to add\n     * @returns The offset in the buffer where the byte vector starts\n     */\n    createByteVector(v) {\n        if (v === null || v === undefined) {\n            return 0;\n        }\n        this.startVector(1, v.length, 1);\n        this.bb.setPosition((this.space -= v.length));\n        this.bb.bytes().set(v, this.space);\n        return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n    createObjectOffset(obj) {\n        if (obj === null) {\n            return 0;\n        }\n        if (typeof obj === 'string') {\n            return this.createString(obj);\n        }\n        else {\n            return obj.pack(this);\n        }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n    createObjectOffsetList(list) {\n        const ret = [];\n        for (let i = 0; i < list.length; ++i) {\n            const val = list[i];\n            if (val !== null) {\n                ret.push(this.createObjectOffset(val));\n            }\n            else {\n                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n            }\n        }\n        return ret;\n    }\n    createStructOffsetList(list, startFunc) {\n        startFunc(this, list.length);\n        this.createObjectOffsetList(list.slice().reverse());\n        return this.endVector();\n    }\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * Provided for forward compatibility in case we need to support different\n * strategies for compressing the IPC message body (like whole-body\n * compression rather than buffer-level) in the future\n */\nexport var BodyCompressionMethod;\n(function (BodyCompressionMethod) {\n    /**\n     * Each constituent buffer is first compressed with the indicated\n     * compressor, and then written with the uncompressed length in the first 8\n     * bytes as a 64-bit little-endian signed integer followed by the compressed\n     * buffer bytes (and then padding as required by the protocol). The\n     * uncompressed length may be set to -1 to indicate that the data that\n     * follows is not compressed, which can be useful for cases where\n     * compression does not yield appreciable savings.\n     */\n    BodyCompressionMethod[BodyCompressionMethod[\"BUFFER\"] = 0] = \"BUFFER\";\n})(BodyCompressionMethod || (BodyCompressionMethod = {}));\n\n//# sourceMappingURL=body-compression-method.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport var CompressionType;\n(function (CompressionType) {\n    CompressionType[CompressionType[\"LZ4_FRAME\"] = 0] = \"LZ4_FRAME\";\n    CompressionType[CompressionType[\"ZSTD\"] = 1] = \"ZSTD\";\n})(CompressionType || (CompressionType = {}));\n\n//# sourceMappingURL=compression-type.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { BodyCompressionMethod } from './body-compression-method.mjs';\nimport { CompressionType } from './compression-type.mjs';\n/**\n * Optional compression for the memory buffers constituting IPC message\n * bodies. Intended for use with RecordBatch but could be used for other\n * message types\n */\nexport class BodyCompression {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsBodyCompression(bb, obj) {\n        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsBodyCompression(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * Compressor library.\n     * For LZ4_FRAME, each compressed buffer must consist of a single frame.\n     */\n    codec() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;\n    }\n    /**\n     * Indicates the way the record batch body was compressed\n     */\n    method() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;\n    }\n    static startBodyCompression(builder) {\n        builder.startObject(2);\n    }\n    static addCodec(builder, codec) {\n        builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);\n    }\n    static addMethod(builder, method) {\n        builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);\n    }\n    static endBodyCompression(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createBodyCompression(builder, codec, method) {\n        BodyCompression.startBodyCompression(builder);\n        BodyCompression.addCodec(builder, codec);\n        BodyCompression.addMethod(builder, method);\n        return BodyCompression.endBodyCompression(builder);\n    }\n}\n\n//# sourceMappingURL=body-compression.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * ----------------------------------------------------------------------\n * A Buffer represents a single contiguous memory segment\n */\nexport class Buffer {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    /**\n     * The relative offset into the shared memory page where the bytes for this\n     * buffer starts\n     */\n    offset() {\n        return this.bb.readInt64(this.bb_pos);\n    }\n    /**\n     * The absolute length (in bytes) of the memory buffer. The memory is found\n     * from offset (inclusive) to offset + length (non-inclusive). When building\n     * messages using the encapsulated IPC message, padding bytes may be written\n     * after a buffer, but such padding bytes do not need to be accounted for in\n     * the size here.\n     */\n    length() {\n        return this.bb.readInt64(this.bb_pos + 8);\n    }\n    static sizeOf() {\n        return 16;\n    }\n    static createBuffer(builder, offset, length) {\n        builder.prep(8, 16);\n        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));\n        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));\n        return builder.offset();\n    }\n}\n\n//# sourceMappingURL=buffer.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * ----------------------------------------------------------------------\n * Data structures for describing a table row batch (a collection of\n * equal-length Arrow arrays)\n * Metadata about a field at some level of a nested type tree (but not\n * its children).\n *\n * For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`\n * would have {length: 5, null_count: 2} for its List node, and {length: 6,\n * null_count: 0} for its Int16 node, as separate FieldNode structs\n */\nexport class FieldNode {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    /**\n     * The number of value slots in the Arrow array at this level of a nested\n     * tree\n     */\n    length() {\n        return this.bb.readInt64(this.bb_pos);\n    }\n    /**\n     * The number of observed nulls. Fields with null_count == 0 may choose not\n     * to write their physical validity bitmap out as a materialized buffer,\n     * instead setting the length of the bitmap buffer to 0.\n     */\n    nullCount() {\n        return this.bb.readInt64(this.bb_pos + 8);\n    }\n    static sizeOf() {\n        return 16;\n    }\n    static createFieldNode(builder, length, null_count) {\n        builder.prep(8, 16);\n        builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));\n        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));\n        return builder.offset();\n    }\n}\n\n//# sourceMappingURL=field-node.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { BodyCompression } from './body-compression.mjs';\nimport { Buffer } from './buffer.mjs';\nimport { FieldNode } from './field-node.mjs';\n/**\n * A data header describing the shared memory layout of a \"record\" or \"row\"\n * batch. Some systems call this a \"row batch\" internally and others a \"record\n * batch\".\n */\nexport class RecordBatch {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsRecordBatch(bb, obj) {\n        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsRecordBatch(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * number of records / rows. The arrays in the batch should all have this\n     * length\n     */\n    length() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');\n    }\n    /**\n     * Nodes correspond to the pre-ordered flattened logical schema\n     */\n    nodes(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;\n    }\n    nodesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    /**\n     * Buffers correspond to the pre-ordered flattened buffer tree\n     *\n     * The number of buffers appended to this list depends on the schema. For\n     * example, most primitive arrays will have 2 buffers, 1 for the validity\n     * bitmap and 1 for the values. For struct arrays, there will only be a\n     * single buffer for the validity (nulls) bitmap\n     */\n    buffers(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? (obj || new Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;\n    }\n    buffersLength() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    /**\n     * Optional compression of the message body\n     */\n    compression(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    static startRecordBatch(builder) {\n        builder.startObject(4);\n    }\n    static addLength(builder, length) {\n        builder.addFieldInt64(0, length, BigInt('0'));\n    }\n    static addNodes(builder, nodesOffset) {\n        builder.addFieldOffset(1, nodesOffset, 0);\n    }\n    static startNodesVector(builder, numElems) {\n        builder.startVector(16, numElems, 8);\n    }\n    static addBuffers(builder, buffersOffset) {\n        builder.addFieldOffset(2, buffersOffset, 0);\n    }\n    static startBuffersVector(builder, numElems) {\n        builder.startVector(16, numElems, 8);\n    }\n    static addCompression(builder, compressionOffset) {\n        builder.addFieldOffset(3, compressionOffset, 0);\n    }\n    static endRecordBatch(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n}\n\n//# sourceMappingURL=record-batch.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { RecordBatch } from './record-batch.mjs';\n/**\n * For sending dictionary encoding information. Any Field can be\n * dictionary-encoded, but in this case none of its children may be\n * dictionary-encoded.\n * There is one vector / column per dictionary, but that vector / column\n * may be spread across multiple dictionary batches by using the isDelta\n * flag\n */\nexport class DictionaryBatch {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsDictionaryBatch(bb, obj) {\n        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    id() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');\n    }\n    data(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    /**\n     * If isDelta is true the values in the dictionary are to be appended to a\n     * dictionary with the indicated id. If isDelta is false this dictionary\n     * should replace the existing dictionary.\n     */\n    isDelta() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    static startDictionaryBatch(builder) {\n        builder.startObject(3);\n    }\n    static addId(builder, id) {\n        builder.addFieldInt64(0, id, BigInt('0'));\n    }\n    static addData(builder, dataOffset) {\n        builder.addFieldOffset(1, dataOffset, 0);\n    }\n    static addIsDelta(builder, isDelta) {\n        builder.addFieldInt8(2, +isDelta, +false);\n    }\n    static endDictionaryBatch(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n}\n\n//# sourceMappingURL=dictionary-batch.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * ----------------------------------------------------------------------\n * Endianness of the platform producing the data\n */\nexport var Endianness;\n(function (Endianness) {\n    Endianness[Endianness[\"Little\"] = 0] = \"Little\";\n    Endianness[Endianness[\"Big\"] = 1] = \"Big\";\n})(Endianness || (Endianness = {}));\n\n//# sourceMappingURL=endianness.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * ----------------------------------------------------------------------\n * Dictionary encoding metadata\n * Maintained for forwards compatibility, in the future\n * Dictionaries might be explicit maps between integers and values\n * allowing for non-contiguous index values\n */\nexport var DictionaryKind;\n(function (DictionaryKind) {\n    DictionaryKind[DictionaryKind[\"DenseArray\"] = 0] = \"DenseArray\";\n})(DictionaryKind || (DictionaryKind = {}));\n\n//# sourceMappingURL=dictionary-kind.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nexport class Int {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsInt(bb, obj) {\n        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsInt(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    bitWidth() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    isSigned() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    static startInt(builder) {\n        builder.startObject(2);\n    }\n    static addBitWidth(builder, bitWidth) {\n        builder.addFieldInt32(0, bitWidth, 0);\n    }\n    static addIsSigned(builder, isSigned) {\n        builder.addFieldInt8(1, +isSigned, +false);\n    }\n    static endInt(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createInt(builder, bitWidth, isSigned) {\n        Int.startInt(builder);\n        Int.addBitWidth(builder, bitWidth);\n        Int.addIsSigned(builder, isSigned);\n        return Int.endInt(builder);\n    }\n}\n\n//# sourceMappingURL=int.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { DictionaryKind } from './dictionary-kind.mjs';\nimport { Int } from './int.mjs';\nexport class DictionaryEncoding {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsDictionaryEncoding(bb, obj) {\n        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * The known dictionary id in the application where this data is used. In\n     * the file or streaming formats, the dictionary ids are found in the\n     * DictionaryBatch messages\n     */\n    id() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');\n    }\n    /**\n     * The dictionary indices are constrained to be non-negative integers. If\n     * this field is null, the indices must be signed int32. To maximize\n     * cross-language compatibility and performance, implementations are\n     * recommended to prefer signed integer types over unsigned integer types\n     * and to avoid uint64 indices unless they are required by an application.\n     */\n    indexType(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    /**\n     * By default, dictionaries are not ordered, or the order does not have\n     * semantic meaning. In some statistical, applications, dictionary-encoding\n     * is used to represent ordered categorical data, and we provide a way to\n     * preserve that metadata here\n     */\n    isOrdered() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    dictionaryKind() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;\n    }\n    static startDictionaryEncoding(builder) {\n        builder.startObject(4);\n    }\n    static addId(builder, id) {\n        builder.addFieldInt64(0, id, BigInt('0'));\n    }\n    static addIndexType(builder, indexTypeOffset) {\n        builder.addFieldOffset(1, indexTypeOffset, 0);\n    }\n    static addIsOrdered(builder, isOrdered) {\n        builder.addFieldInt8(2, +isOrdered, +false);\n    }\n    static addDictionaryKind(builder, dictionaryKind) {\n        builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);\n    }\n    static endDictionaryEncoding(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n}\n\n//# sourceMappingURL=dictionary-encoding.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * ----------------------------------------------------------------------\n * user defined key value pairs to add custom metadata to arrow\n * key namespacing is the responsibility of the user\n */\nexport class KeyValue {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsKeyValue(bb, obj) {\n        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsKeyValue(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    key(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    value(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    static startKeyValue(builder) {\n        builder.startObject(2);\n    }\n    static addKey(builder, keyOffset) {\n        builder.addFieldOffset(0, keyOffset, 0);\n    }\n    static addValue(builder, valueOffset) {\n        builder.addFieldOffset(1, valueOffset, 0);\n    }\n    static endKeyValue(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createKeyValue(builder, keyOffset, valueOffset) {\n        KeyValue.startKeyValue(builder);\n        KeyValue.addKey(builder, keyOffset);\n        KeyValue.addValue(builder, valueOffset);\n        return KeyValue.endKeyValue(builder);\n    }\n}\n\n//# sourceMappingURL=key-value.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * Opaque binary data\n */\nexport class Binary {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsBinary(bb, obj) {\n        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsBinary(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startBinary(builder) {\n        builder.startObject(0);\n    }\n    static endBinary(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createBinary(builder) {\n        Binary.startBinary(builder);\n        return Binary.endBinary(builder);\n    }\n}\n\n//# sourceMappingURL=binary.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nexport class Bool {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsBool(bb, obj) {\n        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsBool(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startBool(builder) {\n        builder.startObject(0);\n    }\n    static endBool(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createBool(builder) {\n        Bool.startBool(builder);\n        return Bool.endBool(builder);\n    }\n}\n\n//# sourceMappingURL=bool.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { DateUnit } from './date-unit.mjs';\n/**\n * Date is either a 32-bit or 64-bit signed integer type representing an\n * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:\n *\n * * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n *   leap seconds), where the values are evenly divisible by 86400000\n * * Days (32 bits) since the UNIX epoch\n */\nexport class Date {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsDate(bb, obj) {\n        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsDate(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    unit() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit.MILLISECOND;\n    }\n    static startDate(builder) {\n        builder.startObject(1);\n    }\n    static addUnit(builder, unit) {\n        builder.addFieldInt16(0, unit, DateUnit.MILLISECOND);\n    }\n    static endDate(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createDate(builder, unit) {\n        Date.startDate(builder);\n        Date.addUnit(builder, unit);\n        return Date.endDate(builder);\n    }\n}\n\n//# sourceMappingURL=date.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * Exact decimal value represented as an integer value in two's\n * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers\n * are used. The representation uses the endianness indicated\n * in the Schema.\n */\nexport class Decimal {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsDecimal(bb, obj) {\n        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsDecimal(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * Total number of decimal digits\n     */\n    precision() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    /**\n     * Number of digits after the decimal point \".\"\n     */\n    scale() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    /**\n     * Number of bits per value. The only accepted widths are 128 and 256.\n     * We use bitWidth for consistency with Int::bitWidth.\n     */\n    bitWidth() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;\n    }\n    static startDecimal(builder) {\n        builder.startObject(3);\n    }\n    static addPrecision(builder, precision) {\n        builder.addFieldInt32(0, precision, 0);\n    }\n    static addScale(builder, scale) {\n        builder.addFieldInt32(1, scale, 0);\n    }\n    static addBitWidth(builder, bitWidth) {\n        builder.addFieldInt32(2, bitWidth, 128);\n    }\n    static endDecimal(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createDecimal(builder, precision, scale, bitWidth) {\n        Decimal.startDecimal(builder);\n        Decimal.addPrecision(builder, precision);\n        Decimal.addScale(builder, scale);\n        Decimal.addBitWidth(builder, bitWidth);\n        return Decimal.endDecimal(builder);\n    }\n}\n\n//# sourceMappingURL=decimal.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { TimeUnit } from './time-unit.mjs';\nexport class Duration {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsDuration(bb, obj) {\n        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsDuration(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    unit() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.MILLISECOND;\n    }\n    static startDuration(builder) {\n        builder.startObject(1);\n    }\n    static addUnit(builder, unit) {\n        builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);\n    }\n    static endDuration(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createDuration(builder, unit) {\n        Duration.startDuration(builder);\n        Duration.addUnit(builder, unit);\n        return Duration.endDuration(builder);\n    }\n}\n\n//# sourceMappingURL=duration.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nexport class FixedSizeBinary {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsFixedSizeBinary(bb, obj) {\n        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * Number of bytes per value\n     */\n    byteWidth() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    static startFixedSizeBinary(builder) {\n        builder.startObject(1);\n    }\n    static addByteWidth(builder, byteWidth) {\n        builder.addFieldInt32(0, byteWidth, 0);\n    }\n    static endFixedSizeBinary(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createFixedSizeBinary(builder, byteWidth) {\n        FixedSizeBinary.startFixedSizeBinary(builder);\n        FixedSizeBinary.addByteWidth(builder, byteWidth);\n        return FixedSizeBinary.endFixedSizeBinary(builder);\n    }\n}\n\n//# sourceMappingURL=fixed-size-binary.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nexport class FixedSizeList {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsFixedSizeList(bb, obj) {\n        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsFixedSizeList(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * Number of list items per value\n     */\n    listSize() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;\n    }\n    static startFixedSizeList(builder) {\n        builder.startObject(1);\n    }\n    static addListSize(builder, listSize) {\n        builder.addFieldInt32(0, listSize, 0);\n    }\n    static endFixedSizeList(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createFixedSizeList(builder, listSize) {\n        FixedSizeList.startFixedSizeList(builder);\n        FixedSizeList.addListSize(builder, listSize);\n        return FixedSizeList.endFixedSizeList(builder);\n    }\n}\n\n//# sourceMappingURL=fixed-size-list.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Precision } from './precision.mjs';\nexport class FloatingPoint {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsFloatingPoint(bb, obj) {\n        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsFloatingPoint(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    precision() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision.HALF;\n    }\n    static startFloatingPoint(builder) {\n        builder.startObject(1);\n    }\n    static addPrecision(builder, precision) {\n        builder.addFieldInt16(0, precision, Precision.HALF);\n    }\n    static endFloatingPoint(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createFloatingPoint(builder, precision) {\n        FloatingPoint.startFloatingPoint(builder);\n        FloatingPoint.addPrecision(builder, precision);\n        return FloatingPoint.endFloatingPoint(builder);\n    }\n}\n\n//# sourceMappingURL=floating-point.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { IntervalUnit } from './interval-unit.mjs';\nexport class Interval {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsInterval(bb, obj) {\n        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsInterval(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    unit() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit.YEAR_MONTH;\n    }\n    static startInterval(builder) {\n        builder.startObject(1);\n    }\n    static addUnit(builder, unit) {\n        builder.addFieldInt16(0, unit, IntervalUnit.YEAR_MONTH);\n    }\n    static endInterval(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createInterval(builder, unit) {\n        Interval.startInterval(builder);\n        Interval.addUnit(builder, unit);\n        return Interval.endInterval(builder);\n    }\n}\n\n//# sourceMappingURL=interval.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * Same as Binary, but with 64-bit offsets, allowing to represent\n * extremely large data values.\n */\nexport class LargeBinary {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsLargeBinary(bb, obj) {\n        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsLargeBinary(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startLargeBinary(builder) {\n        builder.startObject(0);\n    }\n    static endLargeBinary(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createLargeBinary(builder) {\n        LargeBinary.startLargeBinary(builder);\n        return LargeBinary.endLargeBinary(builder);\n    }\n}\n\n//# sourceMappingURL=large-binary.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * Same as Utf8, but with 64-bit offsets, allowing to represent\n * extremely large data values.\n */\nexport class LargeUtf8 {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsLargeUtf8(bb, obj) {\n        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsLargeUtf8(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startLargeUtf8(builder) {\n        builder.startObject(0);\n    }\n    static endLargeUtf8(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createLargeUtf8(builder) {\n        LargeUtf8.startLargeUtf8(builder);\n        return LargeUtf8.endLargeUtf8(builder);\n    }\n}\n\n//# sourceMappingURL=large-utf8.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nexport class List {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsList(bb, obj) {\n        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsList(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startList(builder) {\n        builder.startObject(0);\n    }\n    static endList(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createList(builder) {\n        List.startList(builder);\n        return List.endList(builder);\n    }\n}\n\n//# sourceMappingURL=list.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * A Map is a logical nested type that is represented as\n *\n * List<entries: Struct<key: K, value: V>>\n *\n * In this layout, the keys and values are each respectively contiguous. We do\n * not constrain the key and value types, so the application is responsible\n * for ensuring that the keys are hashable and unique. Whether the keys are sorted\n * may be set in the metadata for this field.\n *\n * In a field with Map type, the field has a child Struct field, which then\n * has two children: key type and the second the value type. The names of the\n * child fields may be respectively \"entries\", \"key\", and \"value\", but this is\n * not enforced.\n *\n * Map\n * ```text\n *   - child[0] entries: Struct\n *     - child[0] key: K\n *     - child[1] value: V\n * ```\n * Neither the \"entries\" field nor the \"key\" field may be nullable.\n *\n * The metadata is structured so that Arrow systems without special handling\n * for Map can make Map an alias for List. The \"layout\" attribute for the Map\n * field must have the same contents as a List.\n */\nexport class Map {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsMap(bb, obj) {\n        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsMap(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * Set to true if the keys within each value are sorted\n     */\n    keysSorted() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    static startMap(builder) {\n        builder.startObject(1);\n    }\n    static addKeysSorted(builder, keysSorted) {\n        builder.addFieldInt8(0, +keysSorted, +false);\n    }\n    static endMap(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createMap(builder, keysSorted) {\n        Map.startMap(builder);\n        Map.addKeysSorted(builder, keysSorted);\n        return Map.endMap(builder);\n    }\n}\n\n//# sourceMappingURL=map.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * These are stored in the flatbuffer in the Type union below\n */\nexport class Null {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsNull(bb, obj) {\n        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsNull(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startNull(builder) {\n        builder.startObject(0);\n    }\n    static endNull(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createNull(builder) {\n        Null.startNull(builder);\n        return Null.endNull(builder);\n    }\n}\n\n//# sourceMappingURL=null.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct\n * (according to the physical memory layout). We used Struct_ here as\n * Struct is a reserved word in Flatbuffers\n */\nexport class Struct_ {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsStruct_(bb, obj) {\n        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsStruct_(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startStruct_(builder) {\n        builder.startObject(0);\n    }\n    static endStruct_(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createStruct_(builder) {\n        Struct_.startStruct_(builder);\n        return Struct_.endStruct_(builder);\n    }\n}\n\n//# sourceMappingURL=struct-.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { TimeUnit } from './time-unit.mjs';\n/**\n * Time is either a 32-bit or 64-bit signed integer type representing an\n * elapsed time since midnight, stored in either of four units: seconds,\n * milliseconds, microseconds or nanoseconds.\n *\n * The integer `bitWidth` depends on the `unit` and must be one of the following:\n * * SECOND and MILLISECOND: 32 bits\n * * MICROSECOND and NANOSECOND: 64 bits\n *\n * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds\n * (exclusive), adjusted for the time unit (for example, up to 86400000\n * exclusive for the MILLISECOND unit).\n * This definition doesn't allow for leap seconds. Time values from\n * measurements with leap seconds will need to be corrected when ingesting\n * into Arrow (for example by replacing the value 86400 with 86399).\n */\nexport class Time {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsTime(bb, obj) {\n        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsTime(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    unit() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.MILLISECOND;\n    }\n    bitWidth() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;\n    }\n    static startTime(builder) {\n        builder.startObject(2);\n    }\n    static addUnit(builder, unit) {\n        builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);\n    }\n    static addBitWidth(builder, bitWidth) {\n        builder.addFieldInt32(1, bitWidth, 32);\n    }\n    static endTime(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createTime(builder, unit, bitWidth) {\n        Time.startTime(builder);\n        Time.addUnit(builder, unit);\n        Time.addBitWidth(builder, bitWidth);\n        return Time.endTime(builder);\n    }\n}\n\n//# sourceMappingURL=time.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { TimeUnit } from './time-unit.mjs';\n/**\n * Timestamp is a 64-bit signed integer representing an elapsed time since a\n * fixed epoch, stored in either of four units: seconds, milliseconds,\n * microseconds or nanoseconds, and is optionally annotated with a timezone.\n *\n * Timestamp values do not include any leap seconds (in other words, all\n * days are considered 86400 seconds long).\n *\n * Timestamps with a non-empty timezone\n * ------------------------------------\n *\n * If a Timestamp column has a non-empty timezone value, its epoch is\n * 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone\n * (the Unix epoch), regardless of the Timestamp's own timezone.\n *\n * Therefore, timestamp values with a non-empty timezone correspond to\n * physical points in time together with some additional information about\n * how the data was obtained and/or how to display it (the timezone).\n *\n *   For example, the timestamp value 0 with the timezone string \"Europe/Paris\"\n *   corresponds to \"January 1st 1970, 00h00\" in the UTC timezone, but the\n *   application may prefer to display it as \"January 1st 1970, 01h00\" in\n *   the Europe/Paris timezone (which is the same physical point in time).\n *\n * One consequence is that timestamp values with a non-empty timezone\n * can be compared and ordered directly, since they all share the same\n * well-known point of reference (the Unix epoch).\n *\n * Timestamps with an unset / empty timezone\n * -----------------------------------------\n *\n * If a Timestamp column has no timezone value, its epoch is\n * 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.\n *\n * Therefore, timestamp values without a timezone cannot be meaningfully\n * interpreted as physical points in time, but only as calendar / clock\n * indications (\"wall clock time\") in an unspecified timezone.\n *\n *   For example, the timestamp value 0 with an empty timezone string\n *   corresponds to \"January 1st 1970, 00h00\" in an unknown timezone: there\n *   is not enough information to interpret it as a well-defined physical\n *   point in time.\n *\n * One consequence is that timestamp values without a timezone cannot\n * be reliably compared or ordered, since they may have different points of\n * reference.  In particular, it is *not* possible to interpret an unset\n * or empty timezone as the same as \"UTC\".\n *\n * Conversion between timezones\n * ----------------------------\n *\n * If a Timestamp column has a non-empty timezone, changing the timezone\n * to a different non-empty value is a metadata-only operation:\n * the timestamp values need not change as their point of reference remains\n * the same (the Unix epoch).\n *\n * However, if a Timestamp column has no timezone value, changing it to a\n * non-empty value requires to think about the desired semantics.\n * One possibility is to assume that the original timestamp values are\n * relative to the epoch of the timezone being set; timestamp values should\n * then adjusted to the Unix epoch (for example, changing the timezone from\n * empty to \"Europe/Paris\" would require converting the timestamp values\n * from \"Europe/Paris\" to \"UTC\", which seems counter-intuitive but is\n * nevertheless correct).\n *\n * Guidelines for encoding data from external libraries\n * ----------------------------------------------------\n *\n * Date & time libraries often have multiple different data types for temporal\n * data. In order to ease interoperability between different implementations the\n * Arrow project has some recommendations for encoding these types into a Timestamp\n * column.\n *\n * An \"instant\" represents a physical point in time that has no relevant timezone\n * (for example, astronomical data). To encode an instant, use a Timestamp with\n * the timezone string set to \"UTC\", and make sure the Timestamp values\n * are relative to the UTC epoch (January 1st 1970, midnight).\n *\n * A \"zoned date-time\" represents a physical point in time annotated with an\n * informative timezone (for example, the timezone in which the data was\n * recorded).  To encode a zoned date-time, use a Timestamp with the timezone\n * string set to the name of the timezone, and make sure the Timestamp values\n * are relative to the UTC epoch (January 1st 1970, midnight).\n *\n *  (There is some ambiguity between an instant and a zoned date-time with the\n *   UTC timezone.  Both of these are stored the same in Arrow.  Typically,\n *   this distinction does not matter.  If it does, then an application should\n *   use custom metadata or an extension type to distinguish between the two cases.)\n *\n * An \"offset date-time\" represents a physical point in time combined with an\n * explicit offset from UTC.  To encode an offset date-time, use a Timestamp\n * with the timezone string set to the numeric timezone offset string\n * (e.g. \"+03:00\"), and make sure the Timestamp values are relative to\n * the UTC epoch (January 1st 1970, midnight).\n *\n * A \"naive date-time\" (also called \"local date-time\" in some libraries)\n * represents a wall clock time combined with a calendar date, but with\n * no indication of how to map this information to a physical point in time.\n * Naive date-times must be handled with care because of this missing\n * information, and also because daylight saving time (DST) may make\n * some values ambiguous or nonexistent. A naive date-time may be\n * stored as a struct with Date and Time fields. However, it may also be\n * encoded into a Timestamp column with an empty timezone. The timestamp\n * values should be computed \"as if\" the timezone of the date-time values\n * was UTC; for example, the naive date-time \"January 1st 1970, 00h00\" would\n * be encoded as timestamp value 0.\n */\nexport class Timestamp {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsTimestamp(bb, obj) {\n        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsTimestamp(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    unit() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.SECOND;\n    }\n    timezone(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    static startTimestamp(builder) {\n        builder.startObject(2);\n    }\n    static addUnit(builder, unit) {\n        builder.addFieldInt16(0, unit, TimeUnit.SECOND);\n    }\n    static addTimezone(builder, timezoneOffset) {\n        builder.addFieldOffset(1, timezoneOffset, 0);\n    }\n    static endTimestamp(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createTimestamp(builder, unit, timezoneOffset) {\n        Timestamp.startTimestamp(builder);\n        Timestamp.addUnit(builder, unit);\n        Timestamp.addTimezone(builder, timezoneOffset);\n        return Timestamp.endTimestamp(builder);\n    }\n}\n\n//# sourceMappingURL=timestamp.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { UnionMode } from './union-mode.mjs';\n/**\n * A union is a complex type with children in Field\n * By default ids in the type vector refer to the offsets in the children\n * optionally typeIds provides an indirection between the child offset and the type id\n * for each child `typeIds[offset]` is the id used in the type vector\n */\nexport class Union {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsUnion(bb, obj) {\n        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsUnion(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    mode() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode.Sparse;\n    }\n    typeIds(index) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n    typeIdsLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    typeIdsArray() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n    }\n    static startUnion(builder) {\n        builder.startObject(2);\n    }\n    static addMode(builder, mode) {\n        builder.addFieldInt16(0, mode, UnionMode.Sparse);\n    }\n    static addTypeIds(builder, typeIdsOffset) {\n        builder.addFieldOffset(1, typeIdsOffset, 0);\n    }\n    static createTypeIdsVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addInt32(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startTypeIdsVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endUnion(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createUnion(builder, mode, typeIdsOffset) {\n        Union.startUnion(builder);\n        Union.addMode(builder, mode);\n        Union.addTypeIds(builder, typeIdsOffset);\n        return Union.endUnion(builder);\n    }\n}\n\n//# sourceMappingURL=union.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * Unicode with UTF-8 encoding\n */\nexport class Utf8 {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsUtf8(bb, obj) {\n        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsUtf8(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static startUtf8(builder) {\n        builder.startObject(0);\n    }\n    static endUtf8(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createUtf8(builder) {\n        Utf8.startUtf8(builder);\n        return Utf8.endUtf8(builder);\n    }\n}\n\n//# sourceMappingURL=utf8.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport { Binary } from './binary.mjs';\nimport { Bool } from './bool.mjs';\nimport { Date } from './date.mjs';\nimport { Decimal } from './decimal.mjs';\nimport { Duration } from './duration.mjs';\nimport { FixedSizeBinary } from './fixed-size-binary.mjs';\nimport { FixedSizeList } from './fixed-size-list.mjs';\nimport { FloatingPoint } from './floating-point.mjs';\nimport { Int } from './int.mjs';\nimport { Interval } from './interval.mjs';\nimport { LargeBinary } from './large-binary.mjs';\nimport { LargeList } from './large-list.mjs';\nimport { LargeUtf8 } from './large-utf8.mjs';\nimport { List } from './list.mjs';\nimport { Map } from './map.mjs';\nimport { Null } from './null.mjs';\nimport { RunEndEncoded } from './run-end-encoded.mjs';\nimport { Struct_ } from './struct-.mjs';\nimport { Time } from './time.mjs';\nimport { Timestamp } from './timestamp.mjs';\nimport { Union } from './union.mjs';\nimport { Utf8 } from './utf8.mjs';\n/**\n * ----------------------------------------------------------------------\n * Top-level Type value, enabling extensible type-specific metadata. We can\n * add new logical types to Type without breaking backwards compatibility\n */\nexport var Type;\n(function (Type) {\n    Type[Type[\"NONE\"] = 0] = \"NONE\";\n    Type[Type[\"Null\"] = 1] = \"Null\";\n    Type[Type[\"Int\"] = 2] = \"Int\";\n    Type[Type[\"FloatingPoint\"] = 3] = \"FloatingPoint\";\n    Type[Type[\"Binary\"] = 4] = \"Binary\";\n    Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n    Type[Type[\"Bool\"] = 6] = \"Bool\";\n    Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n    Type[Type[\"Date\"] = 8] = \"Date\";\n    Type[Type[\"Time\"] = 9] = \"Time\";\n    Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n    Type[Type[\"Interval\"] = 11] = \"Interval\";\n    Type[Type[\"List\"] = 12] = \"List\";\n    Type[Type[\"Struct_\"] = 13] = \"Struct_\";\n    Type[Type[\"Union\"] = 14] = \"Union\";\n    Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n    Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n    Type[Type[\"Map\"] = 17] = \"Map\";\n    Type[Type[\"Duration\"] = 18] = \"Duration\";\n    Type[Type[\"LargeBinary\"] = 19] = \"LargeBinary\";\n    Type[Type[\"LargeUtf8\"] = 20] = \"LargeUtf8\";\n    Type[Type[\"LargeList\"] = 21] = \"LargeList\";\n    Type[Type[\"RunEndEncoded\"] = 22] = \"RunEndEncoded\";\n})(Type || (Type = {}));\nexport function unionToType(type, accessor) {\n    switch (Type[type]) {\n        case 'NONE': return null;\n        case 'Null': return accessor(new Null());\n        case 'Int': return accessor(new Int());\n        case 'FloatingPoint': return accessor(new FloatingPoint());\n        case 'Binary': return accessor(new Binary());\n        case 'Utf8': return accessor(new Utf8());\n        case 'Bool': return accessor(new Bool());\n        case 'Decimal': return accessor(new Decimal());\n        case 'Date': return accessor(new Date());\n        case 'Time': return accessor(new Time());\n        case 'Timestamp': return accessor(new Timestamp());\n        case 'Interval': return accessor(new Interval());\n        case 'List': return accessor(new List());\n        case 'Struct_': return accessor(new Struct_());\n        case 'Union': return accessor(new Union());\n        case 'FixedSizeBinary': return accessor(new FixedSizeBinary());\n        case 'FixedSizeList': return accessor(new FixedSizeList());\n        case 'Map': return accessor(new Map());\n        case 'Duration': return accessor(new Duration());\n        case 'LargeBinary': return accessor(new LargeBinary());\n        case 'LargeUtf8': return accessor(new LargeUtf8());\n        case 'LargeList': return accessor(new LargeList());\n        case 'RunEndEncoded': return accessor(new RunEndEncoded());\n        default: return null;\n    }\n}\nexport function unionListToType(type, accessor, index) {\n    switch (Type[type]) {\n        case 'NONE': return null;\n        case 'Null': return accessor(index, new Null());\n        case 'Int': return accessor(index, new Int());\n        case 'FloatingPoint': return accessor(index, new FloatingPoint());\n        case 'Binary': return accessor(index, new Binary());\n        case 'Utf8': return accessor(index, new Utf8());\n        case 'Bool': return accessor(index, new Bool());\n        case 'Decimal': return accessor(index, new Decimal());\n        case 'Date': return accessor(index, new Date());\n        case 'Time': return accessor(index, new Time());\n        case 'Timestamp': return accessor(index, new Timestamp());\n        case 'Interval': return accessor(index, new Interval());\n        case 'List': return accessor(index, new List());\n        case 'Struct_': return accessor(index, new Struct_());\n        case 'Union': return accessor(index, new Union());\n        case 'FixedSizeBinary': return accessor(index, new FixedSizeBinary());\n        case 'FixedSizeList': return accessor(index, new FixedSizeList());\n        case 'Map': return accessor(index, new Map());\n        case 'Duration': return accessor(index, new Duration());\n        case 'LargeBinary': return accessor(index, new LargeBinary());\n        case 'LargeUtf8': return accessor(index, new LargeUtf8());\n        case 'LargeList': return accessor(index, new LargeList());\n        case 'RunEndEncoded': return accessor(index, new RunEndEncoded());\n        default: return null;\n    }\n}\n\n//# sourceMappingURL=type.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { DictionaryEncoding } from './dictionary-encoding.mjs';\nimport { KeyValue } from './key-value.mjs';\nimport { Type } from './type.mjs';\n/**\n * ----------------------------------------------------------------------\n * A field represents a named column in a record / row batch or child of a\n * nested type.\n */\nexport class Field {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsField(bb, obj) {\n        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsField(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    name(optionalEncoding) {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n    /**\n     * Whether or not this field can contain nulls. Should be true in general.\n     */\n    nullable() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    typeType() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.readUint8(this.bb_pos + offset) : Type.NONE;\n    }\n    /**\n     * This is the type of the decoded value if the field is dictionary encoded.\n     */\n    type(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;\n    }\n    /**\n     * Present only if the field is dictionary encoded.\n     */\n    dictionary(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    /**\n     * children apply only to nested data types like Struct, List and Union. For\n     * primitive types children will have length 0.\n     */\n    children(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    childrenLength() {\n        const offset = this.bb.__offset(this.bb_pos, 14);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    /**\n     * User-defined metadata\n     */\n    customMetadata(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    customMetadataLength() {\n        const offset = this.bb.__offset(this.bb_pos, 16);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static startField(builder) {\n        builder.startObject(7);\n    }\n    static addName(builder, nameOffset) {\n        builder.addFieldOffset(0, nameOffset, 0);\n    }\n    static addNullable(builder, nullable) {\n        builder.addFieldInt8(1, +nullable, +false);\n    }\n    static addTypeType(builder, typeType) {\n        builder.addFieldInt8(2, typeType, Type.NONE);\n    }\n    static addType(builder, typeOffset) {\n        builder.addFieldOffset(3, typeOffset, 0);\n    }\n    static addDictionary(builder, dictionaryOffset) {\n        builder.addFieldOffset(4, dictionaryOffset, 0);\n    }\n    static addChildren(builder, childrenOffset) {\n        builder.addFieldOffset(5, childrenOffset, 0);\n    }\n    static createChildrenVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startChildrenVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addCustomMetadata(builder, customMetadataOffset) {\n        builder.addFieldOffset(6, customMetadataOffset, 0);\n    }\n    static createCustomMetadataVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startCustomMetadataVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endField(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n}\n\n//# sourceMappingURL=field.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Endianness } from './endianness.mjs';\nimport { Field } from './field.mjs';\nimport { KeyValue } from './key-value.mjs';\n/**\n * ----------------------------------------------------------------------\n * A Schema describes the columns in a row batch\n */\nexport class Schema {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsSchema(bb, obj) {\n        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsSchema(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * endianness of the buffer\n     * it is Little Endian by default\n     * if endianness doesn't match the underlying system then the vectors need to be converted\n     */\n    endianness() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;\n    }\n    fields(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    fieldsLength() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    customMetadata(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    customMetadataLength() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    /**\n     * Features used in the stream/file.\n     */\n    features(index) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);\n    }\n    featuresLength() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static startSchema(builder) {\n        builder.startObject(4);\n    }\n    static addEndianness(builder, endianness) {\n        builder.addFieldInt16(0, endianness, Endianness.Little);\n    }\n    static addFields(builder, fieldsOffset) {\n        builder.addFieldOffset(1, fieldsOffset, 0);\n    }\n    static createFieldsVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startFieldsVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addCustomMetadata(builder, customMetadataOffset) {\n        builder.addFieldOffset(2, customMetadataOffset, 0);\n    }\n    static createCustomMetadataVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startCustomMetadataVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static addFeatures(builder, featuresOffset) {\n        builder.addFieldOffset(3, featuresOffset, 0);\n    }\n    static createFeaturesVector(builder, data) {\n        builder.startVector(8, data.length, 8);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addInt64(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startFeaturesVector(builder, numElems) {\n        builder.startVector(8, numElems, 8);\n    }\n    static endSchema(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static finishSchemaBuffer(builder, offset) {\n        builder.finish(offset);\n    }\n    static finishSizePrefixedSchemaBuffer(builder, offset) {\n        builder.finish(offset, undefined, true);\n    }\n    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {\n        Schema.startSchema(builder);\n        Schema.addEndianness(builder, endianness);\n        Schema.addFields(builder, fieldsOffset);\n        Schema.addCustomMetadata(builder, customMetadataOffset);\n        Schema.addFeatures(builder, featuresOffset);\n        return Schema.endSchema(builder);\n    }\n}\n\n//# sourceMappingURL=schema.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport { DictionaryBatch } from './dictionary-batch.mjs';\nimport { RecordBatch } from './record-batch.mjs';\nimport { Schema } from './schema.mjs';\nimport { SparseTensor } from './sparse-tensor.mjs';\nimport { Tensor } from './tensor.mjs';\n/**\n * ----------------------------------------------------------------------\n * The root Message type\n * This union enables us to easily send different message types without\n * redundant storage, and in the future we can easily add new message types.\n *\n * Arrow implementations do not need to implement all of the message types,\n * which may include experimental metadata types. For maximum compatibility,\n * it is best to send data using RecordBatch\n */\nexport var MessageHeader;\n(function (MessageHeader) {\n    MessageHeader[MessageHeader[\"NONE\"] = 0] = \"NONE\";\n    MessageHeader[MessageHeader[\"Schema\"] = 1] = \"Schema\";\n    MessageHeader[MessageHeader[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n    MessageHeader[MessageHeader[\"RecordBatch\"] = 3] = \"RecordBatch\";\n    MessageHeader[MessageHeader[\"Tensor\"] = 4] = \"Tensor\";\n    MessageHeader[MessageHeader[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader || (MessageHeader = {}));\nexport function unionToMessageHeader(type, accessor) {\n    switch (MessageHeader[type]) {\n        case 'NONE': return null;\n        case 'Schema': return accessor(new Schema());\n        case 'DictionaryBatch': return accessor(new DictionaryBatch());\n        case 'RecordBatch': return accessor(new RecordBatch());\n        case 'Tensor': return accessor(new Tensor());\n        case 'SparseTensor': return accessor(new SparseTensor());\n        default: return null;\n    }\n}\nexport function unionListToMessageHeader(type, accessor, index) {\n    switch (MessageHeader[type]) {\n        case 'NONE': return null;\n        case 'Schema': return accessor(index, new Schema());\n        case 'DictionaryBatch': return accessor(index, new DictionaryBatch());\n        case 'RecordBatch': return accessor(index, new RecordBatch());\n        case 'Tensor': return accessor(index, new Tensor());\n        case 'SparseTensor': return accessor(index, new SparseTensor());\n        default: return null;\n    }\n}\n\n//# sourceMappingURL=message-header.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nexport { MetadataVersion } from './fb/metadata-version.mjs';\nexport { UnionMode } from './fb/union-mode.mjs';\nexport { Precision } from './fb/precision.mjs';\nexport { DateUnit } from './fb/date-unit.mjs';\nexport { TimeUnit } from './fb/time-unit.mjs';\nexport { IntervalUnit } from './fb/interval-unit.mjs';\nexport { MessageHeader } from './fb/message-header.mjs';\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only non-negative enum values are written to an Arrow IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport var Type;\n(function (Type) {\n    Type[Type[\"NONE\"] = 0] = \"NONE\";\n    Type[Type[\"Null\"] = 1] = \"Null\";\n    Type[Type[\"Int\"] = 2] = \"Int\";\n    Type[Type[\"Float\"] = 3] = \"Float\";\n    Type[Type[\"Binary\"] = 4] = \"Binary\";\n    Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n    Type[Type[\"Bool\"] = 6] = \"Bool\";\n    Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n    Type[Type[\"Date\"] = 8] = \"Date\";\n    Type[Type[\"Time\"] = 9] = \"Time\";\n    Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n    Type[Type[\"Interval\"] = 11] = \"Interval\";\n    Type[Type[\"List\"] = 12] = \"List\";\n    Type[Type[\"Struct\"] = 13] = \"Struct\";\n    Type[Type[\"Union\"] = 14] = \"Union\";\n    Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n    Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n    Type[Type[\"Map\"] = 17] = \"Map\";\n    Type[Type[\"Duration\"] = 18] = \"Duration\";\n    Type[Type[\"LargeBinary\"] = 19] = \"LargeBinary\";\n    Type[Type[\"LargeUtf8\"] = 20] = \"LargeUtf8\";\n    Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n    Type[Type[\"Int8\"] = -2] = \"Int8\";\n    Type[Type[\"Int16\"] = -3] = \"Int16\";\n    Type[Type[\"Int32\"] = -4] = \"Int32\";\n    Type[Type[\"Int64\"] = -5] = \"Int64\";\n    Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n    Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n    Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n    Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n    Type[Type[\"Float16\"] = -10] = \"Float16\";\n    Type[Type[\"Float32\"] = -11] = \"Float32\";\n    Type[Type[\"Float64\"] = -12] = \"Float64\";\n    Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n    Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n    Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n    Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n    Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n    Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n    Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n    Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n    Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n    Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n    Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n    Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n    Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n    Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n    Type[Type[\"DurationSecond\"] = -27] = \"DurationSecond\";\n    Type[Type[\"DurationMillisecond\"] = -28] = \"DurationMillisecond\";\n    Type[Type[\"DurationMicrosecond\"] = -29] = \"DurationMicrosecond\";\n    Type[Type[\"DurationNanosecond\"] = -30] = \"DurationNanosecond\";\n    Type[Type[\"IntervalMonthDayNano\"] = -31] = \"IntervalMonthDayNano\";\n})(Type || (Type = {}));\nexport var BufferType;\n(function (BufferType) {\n    /**\n     * used in List type, Dense Union and variable length primitive types (String, Binary)\n     */\n    BufferType[BufferType[\"OFFSET\"] = 0] = \"OFFSET\";\n    /**\n     * actual data, either fixed width primitive types in slots or variable width delimited by an OFFSET vector\n     */\n    BufferType[BufferType[\"DATA\"] = 1] = \"DATA\";\n    /**\n     * Bit vector indicating if each value is null\n     */\n    BufferType[BufferType[\"VALIDITY\"] = 2] = \"VALIDITY\";\n    /**\n     * Type vector used in Union type\n     */\n    BufferType[BufferType[\"TYPE\"] = 3] = \"TYPE\";\n})(BufferType || (BufferType = {}));\n\n//# sourceMappingURL=enum.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */ const undf = void (0);\n/** @ignore */\nexport function valueToString(x) {\n    if (x === null) {\n        return 'null';\n    }\n    if (x === undf) {\n        return 'undefined';\n    }\n    switch (typeof x) {\n        case 'number': return `${x}`;\n        case 'bigint': return `${x}`;\n        case 'string': return `\"${x}\"`;\n    }\n    // If [Symbol.toPrimitive] is implemented (like in BN)\n    // use it instead of JSON.stringify(). This ensures we\n    // print BigInts, Decimals, and Binary in their native\n    // representation\n    if (typeof x[Symbol.toPrimitive] === 'function') {\n        return x[Symbol.toPrimitive]('string');\n    }\n    if (ArrayBuffer.isView(x)) {\n        if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n            return `[${[...x].map(x => valueToString(x))}]`;\n        }\n        return `[${x}]`;\n    }\n    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === 'bigint' ? `${y}` : y);\n}\n\n//# sourceMappingURL=pretty.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/**\n * Converts an integer as a number or bigint to a number, throwing an error if the input cannot safely be represented as a number.\n */\nexport function bigIntToNumber(number) {\n    if (typeof number === 'bigint' && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {\n        throw new TypeError(`${number} is not safe to convert to a number.`);\n    }\n    return Number(number);\n}\n/**\n * Duivides the bigint number by the divisor and returns the result as a number.\n * Dividing bigints always results in bigints so we don't get the remainder.\n * This function gives us the remainder but assumes that the result fits into a number.\n *\n * @param number The number to divide.\n * @param divisor The divisor.\n * @returns The result of the division as a number.\n */\nexport function divideBigInts(number, divisor) {\n    return bigIntToNumber(number / divisor) + bigIntToNumber(number % divisor) / bigIntToNumber(divisor);\n}\n\n//# sourceMappingURL=bigint.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toArrayBufferView } from './buffer.mjs';\nimport { bigIntToNumber } from './bigint.mjs';\n/** @ignore */\nexport const isArrowBigNumSymbol = Symbol.for('isArrowBigNum');\n/** @ignore */\nfunction BigNum(x, ...xs) {\n    if (xs.length === 0) {\n        return Object.setPrototypeOf(toArrayBufferView(this['TypedArray'], x), this.constructor.prototype);\n    }\n    return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);\n}\nBigNum.prototype[isArrowBigNumSymbol] = true;\nBigNum.prototype.toJSON = function () { return `\"${bigNumToString(this)}\"`; };\nBigNum.prototype.valueOf = function (scale) { return bigNumToNumber(this, scale); };\nBigNum.prototype.toString = function () { return bigNumToString(this); };\nBigNum.prototype[Symbol.toPrimitive] = function (hint = 'default') {\n    switch (hint) {\n        case 'number': return bigNumToNumber(this);\n        case 'string': return bigNumToString(this);\n        case 'default': return bigNumToBigInt(this);\n    }\n    // @ts-ignore\n    return bigNumToString(this);\n};\n/** @ignore */\nfunction SignedBigNum(...args) { return BigNum.apply(this, args); }\n/** @ignore */\nfunction UnsignedBigNum(...args) { return BigNum.apply(this, args); }\n/** @ignore */\nfunction DecimalBigNum(...args) { return BigNum.apply(this, args); }\nObject.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));\nObject.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));\nObject.assign(SignedBigNum.prototype, BigNum.prototype, { 'constructor': SignedBigNum, 'signed': true, 'TypedArray': Int32Array, 'BigIntArray': BigInt64Array });\nObject.assign(UnsignedBigNum.prototype, BigNum.prototype, { 'constructor': UnsignedBigNum, 'signed': false, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });\nObject.assign(DecimalBigNum.prototype, BigNum.prototype, { 'constructor': DecimalBigNum, 'signed': true, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });\n//FOR ES2020 COMPATIBILITY\nconst TWO_TO_THE_64 = BigInt(4294967296) * BigInt(4294967296); // 2^64 = 0x10000000000000000n\nconst TWO_TO_THE_64_MINUS_1 = TWO_TO_THE_64 - BigInt(1); // (2^32 * 2^32) - 1 = 0xFFFFFFFFFFFFFFFFn\n/** @ignore */\nexport function bigNumToNumber(bn, scale) {\n    const { buffer, byteOffset, byteLength, 'signed': signed } = bn;\n    const words = new BigUint64Array(buffer, byteOffset, byteLength / 8);\n    const negative = signed && words.at(-1) & (BigInt(1) << BigInt(63));\n    let number = BigInt(0);\n    let i = 0;\n    if (negative) {\n        for (const word of words) {\n            number |= (word ^ TWO_TO_THE_64_MINUS_1) * (BigInt(1) << BigInt(64 * i++));\n        }\n        number *= BigInt(-1);\n        number -= BigInt(1);\n    }\n    else {\n        for (const word of words) {\n            number |= word * (BigInt(1) << BigInt(64 * i++));\n        }\n    }\n    if (typeof scale === 'number' && scale > 0) {\n        const denominator = BigInt('1'.padEnd(scale + 1, '0'));\n        const quotient = number / denominator;\n        const remainder = negative ? -(number % denominator) : number % denominator;\n        const integerPart = bigIntToNumber(quotient);\n        const fractionPart = `${remainder}`.padStart(scale, '0');\n        const sign = negative && integerPart === 0 ? '-' : '';\n        return +`${sign}${integerPart}.${fractionPart}`;\n    }\n    return bigIntToNumber(number);\n}\n/** @ignore */\nexport function bigNumToString(a) {\n    // use BigInt native implementation\n    if (a.byteLength === 8) {\n        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);\n        return `${bigIntArray[0]}`;\n    }\n    // unsigned numbers\n    if (!a['signed']) {\n        return unsignedBigNumToString(a);\n    }\n    let array = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);\n    // detect positive numbers\n    const highOrderWord = new Int16Array([array.at(-1)])[0];\n    if (highOrderWord >= 0) {\n        return unsignedBigNumToString(a);\n    }\n    // flip the negative value\n    array = array.slice();\n    let carry = 1;\n    for (let i = 0; i < array.length; i++) {\n        const elem = array[i];\n        const updated = ~elem + carry;\n        array[i] = updated;\n        carry &= elem === 0 ? 1 : 0;\n    }\n    const negated = unsignedBigNumToString(array);\n    return `-${negated}`;\n}\n/** @ignore */\nexport function bigNumToBigInt(a) {\n    if (a.byteLength === 8) {\n        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);\n        return bigIntArray[0];\n    }\n    else {\n        return bigNumToString(a);\n    }\n}\n/** @ignore */\nfunction unsignedBigNumToString(a) {\n    let digits = '';\n    const base64 = new Uint32Array(2);\n    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);\n    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);\n    let i = -1;\n    const n = base32.length - 1;\n    do {\n        for (base64[0] = base32[i = 0]; i < n;) {\n            base32[i++] = base64[1] = base64[0] / 10;\n            base64[0] = ((base64[0] - base64[1] * 10) << 16) + base32[i];\n        }\n        base32[i] = base64[1] = base64[0] / 10;\n        base64[0] = base64[0] - base64[1] * 10;\n        digits = `${base64[0]}${digits}`;\n    } while (checks[0] || checks[1] || checks[2] || checks[3]);\n    return digits !== null && digits !== void 0 ? digits : `0`;\n}\n/** @ignore */\nexport class BN {\n    /** @nocollapse */\n    static new(num, isSigned) {\n        switch (isSigned) {\n            case true: return new SignedBigNum(num);\n            case false: return new UnsignedBigNum(num);\n        }\n        switch (num.constructor) {\n            case Int8Array:\n            case Int16Array:\n            case Int32Array:\n            case BigInt64Array:\n                return new SignedBigNum(num);\n        }\n        if (num.byteLength === 16) {\n            return new DecimalBigNum(num);\n        }\n        return new UnsignedBigNum(num);\n    }\n    /** @nocollapse */\n    static signed(num) {\n        return new SignedBigNum(num);\n    }\n    /** @nocollapse */\n    static unsigned(num) {\n        return new UnsignedBigNum(num);\n    }\n    /** @nocollapse */\n    static decimal(num) {\n        return new DecimalBigNum(num);\n    }\n    constructor(num, isSigned) {\n        return BN.new(num, isSigned);\n    }\n}\n\n//# sourceMappingURL=bn.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\nimport { bigIntToNumber } from './util/bigint.mjs';\nimport { Type, Precision, UnionMode, DateUnit, TimeUnit, IntervalUnit } from './enum.mjs';\n/**\n * An abstract base class for classes that encapsulate metadata about each of\n * the logical types that Arrow can represent.\n */\nexport class DataType {\n    /** @nocollapse */ static isNull(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Null; }\n    /** @nocollapse */ static isInt(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Int; }\n    /** @nocollapse */ static isFloat(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Float; }\n    /** @nocollapse */ static isBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Binary; }\n    /** @nocollapse */ static isLargeBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.LargeBinary; }\n    /** @nocollapse */ static isUtf8(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Utf8; }\n    /** @nocollapse */ static isLargeUtf8(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.LargeUtf8; }\n    /** @nocollapse */ static isBool(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Bool; }\n    /** @nocollapse */ static isDecimal(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Decimal; }\n    /** @nocollapse */ static isDate(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Date; }\n    /** @nocollapse */ static isTime(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Time; }\n    /** @nocollapse */ static isTimestamp(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Timestamp; }\n    /** @nocollapse */ static isInterval(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Interval; }\n    /** @nocollapse */ static isDuration(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Duration; }\n    /** @nocollapse */ static isList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.List; }\n    /** @nocollapse */ static isStruct(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Struct; }\n    /** @nocollapse */ static isUnion(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Union; }\n    /** @nocollapse */ static isFixedSizeBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeBinary; }\n    /** @nocollapse */ static isFixedSizeList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeList; }\n    /** @nocollapse */ static isMap(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Map; }\n    /** @nocollapse */ static isDictionary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Dictionary; }\n    /** @nocollapse */ static isDenseUnion(x) { return DataType.isUnion(x) && x.mode === UnionMode.Dense; }\n    /** @nocollapse */ static isSparseUnion(x) { return DataType.isUnion(x) && x.mode === UnionMode.Sparse; }\n    constructor(typeId) {\n        this.typeId = typeId;\n    }\n}\n_a = Symbol.toStringTag;\nDataType[_a] = ((proto) => {\n    proto.children = null;\n    proto.ArrayType = Array;\n    proto.OffsetArrayType = Int32Array;\n    return proto[Symbol.toStringTag] = 'DataType';\n})(DataType.prototype);\n/** @ignore */\nexport class Null extends DataType {\n    constructor() {\n        super(Type.Null);\n    }\n    toString() { return `Null`; }\n}\n_b = Symbol.toStringTag;\nNull[_b] = ((proto) => proto[Symbol.toStringTag] = 'Null')(Null.prototype);\n/** @ignore */\nclass Int_ extends DataType {\n    constructor(isSigned, bitWidth) {\n        super(Type.Int);\n        this.isSigned = isSigned;\n        this.bitWidth = bitWidth;\n    }\n    get ArrayType() {\n        switch (this.bitWidth) {\n            case 8: return this.isSigned ? Int8Array : Uint8Array;\n            case 16: return this.isSigned ? Int16Array : Uint16Array;\n            case 32: return this.isSigned ? Int32Array : Uint32Array;\n            case 64: return this.isSigned ? BigInt64Array : BigUint64Array;\n        }\n        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n    }\n    toString() { return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`; }\n}\n_c = Symbol.toStringTag;\nInt_[_c] = ((proto) => {\n    proto.isSigned = null;\n    proto.bitWidth = null;\n    return proto[Symbol.toStringTag] = 'Int';\n})(Int_.prototype);\nexport { Int_ as Int };\n/** @ignore */\nexport class Int8 extends Int_ {\n    constructor() { super(true, 8); }\n    get ArrayType() { return Int8Array; }\n}\n/** @ignore */\nexport class Int16 extends Int_ {\n    constructor() { super(true, 16); }\n    get ArrayType() { return Int16Array; }\n}\n/** @ignore */\nexport class Int32 extends Int_ {\n    constructor() { super(true, 32); }\n    get ArrayType() { return Int32Array; }\n}\n/** @ignore */\nexport class Int64 extends Int_ {\n    constructor() { super(true, 64); }\n    get ArrayType() { return BigInt64Array; }\n}\n/** @ignore */\nexport class Uint8 extends Int_ {\n    constructor() { super(false, 8); }\n    get ArrayType() { return Uint8Array; }\n}\n/** @ignore */\nexport class Uint16 extends Int_ {\n    constructor() { super(false, 16); }\n    get ArrayType() { return Uint16Array; }\n}\n/** @ignore */\nexport class Uint32 extends Int_ {\n    constructor() { super(false, 32); }\n    get ArrayType() { return Uint32Array; }\n}\n/** @ignore */\nexport class Uint64 extends Int_ {\n    constructor() { super(false, 64); }\n    get ArrayType() { return BigUint64Array; }\n}\nObject.defineProperty(Int8.prototype, 'ArrayType', { value: Int8Array });\nObject.defineProperty(Int16.prototype, 'ArrayType', { value: Int16Array });\nObject.defineProperty(Int32.prototype, 'ArrayType', { value: Int32Array });\nObject.defineProperty(Int64.prototype, 'ArrayType', { value: BigInt64Array });\nObject.defineProperty(Uint8.prototype, 'ArrayType', { value: Uint8Array });\nObject.defineProperty(Uint16.prototype, 'ArrayType', { value: Uint16Array });\nObject.defineProperty(Uint32.prototype, 'ArrayType', { value: Uint32Array });\nObject.defineProperty(Uint64.prototype, 'ArrayType', { value: BigUint64Array });\n/** @ignore */\nexport class Float extends DataType {\n    constructor(precision) {\n        super(Type.Float);\n        this.precision = precision;\n    }\n    get ArrayType() {\n        switch (this.precision) {\n            case Precision.HALF: return Uint16Array;\n            case Precision.SINGLE: return Float32Array;\n            case Precision.DOUBLE: return Float64Array;\n        }\n        // @ts-ignore\n        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n    }\n    toString() { return `Float${(this.precision << 5) || 16}`; }\n}\n_d = Symbol.toStringTag;\nFloat[_d] = ((proto) => {\n    proto.precision = null;\n    return proto[Symbol.toStringTag] = 'Float';\n})(Float.prototype);\n/** @ignore */\nexport class Float16 extends Float {\n    constructor() { super(Precision.HALF); }\n}\n/** @ignore */\nexport class Float32 extends Float {\n    constructor() { super(Precision.SINGLE); }\n}\n/** @ignore */\nexport class Float64 extends Float {\n    constructor() { super(Precision.DOUBLE); }\n}\nObject.defineProperty(Float16.prototype, 'ArrayType', { value: Uint16Array });\nObject.defineProperty(Float32.prototype, 'ArrayType', { value: Float32Array });\nObject.defineProperty(Float64.prototype, 'ArrayType', { value: Float64Array });\n/** @ignore */\nexport class Binary extends DataType {\n    constructor() {\n        super(Type.Binary);\n    }\n    toString() { return `Binary`; }\n}\n_e = Symbol.toStringTag;\nBinary[_e] = ((proto) => {\n    proto.ArrayType = Uint8Array;\n    return proto[Symbol.toStringTag] = 'Binary';\n})(Binary.prototype);\n/** @ignore */\nexport class LargeBinary extends DataType {\n    constructor() {\n        super(Type.LargeBinary);\n    }\n    toString() { return `LargeBinary`; }\n}\n_f = Symbol.toStringTag;\nLargeBinary[_f] = ((proto) => {\n    proto.ArrayType = Uint8Array;\n    proto.OffsetArrayType = BigInt64Array;\n    return proto[Symbol.toStringTag] = 'LargeBinary';\n})(LargeBinary.prototype);\n/** @ignore */\nexport class Utf8 extends DataType {\n    constructor() {\n        super(Type.Utf8);\n    }\n    toString() { return `Utf8`; }\n}\n_g = Symbol.toStringTag;\nUtf8[_g] = ((proto) => {\n    proto.ArrayType = Uint8Array;\n    return proto[Symbol.toStringTag] = 'Utf8';\n})(Utf8.prototype);\n/** @ignore */\nexport class LargeUtf8 extends DataType {\n    constructor() {\n        super(Type.LargeUtf8);\n    }\n    toString() { return `LargeUtf8`; }\n}\n_h = Symbol.toStringTag;\nLargeUtf8[_h] = ((proto) => {\n    proto.ArrayType = Uint8Array;\n    proto.OffsetArrayType = BigInt64Array;\n    return proto[Symbol.toStringTag] = 'LargeUtf8';\n})(LargeUtf8.prototype);\n/** @ignore */\nexport class Bool extends DataType {\n    constructor() {\n        super(Type.Bool);\n    }\n    toString() { return `Bool`; }\n}\n_j = Symbol.toStringTag;\nBool[_j] = ((proto) => {\n    proto.ArrayType = Uint8Array;\n    return proto[Symbol.toStringTag] = 'Bool';\n})(Bool.prototype);\n/** @ignore */\nexport class Decimal extends DataType {\n    constructor(scale, precision, bitWidth = 128) {\n        super(Type.Decimal);\n        this.scale = scale;\n        this.precision = precision;\n        this.bitWidth = bitWidth;\n    }\n    toString() { return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`; }\n}\n_k = Symbol.toStringTag;\nDecimal[_k] = ((proto) => {\n    proto.scale = null;\n    proto.precision = null;\n    proto.ArrayType = Uint32Array;\n    return proto[Symbol.toStringTag] = 'Decimal';\n})(Decimal.prototype);\n/** @ignore */\nexport class Date_ extends DataType {\n    constructor(unit) {\n        super(Type.Date);\n        this.unit = unit;\n    }\n    toString() { return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`; }\n    get ArrayType() {\n        return this.unit === DateUnit.DAY ? Int32Array : BigInt64Array;\n    }\n}\n_l = Symbol.toStringTag;\nDate_[_l] = ((proto) => {\n    proto.unit = null;\n    return proto[Symbol.toStringTag] = 'Date';\n})(Date_.prototype);\n/** @ignore */\nexport class DateDay extends Date_ {\n    constructor() { super(DateUnit.DAY); }\n}\n/**\n * A signed 64-bit date representing the elapsed time since UNIX epoch (1970-01-01) in milliseconds.\n * According to the specification, this should be treated as the number of days, in milliseconds,  since the UNIX epoch.\n * Therefore, values must be evenly divisible by `86_400_000` (the number of milliseconds in a standard day).\n *\n * Practically, validation that values of this type are evenly divisible by `86_400_000` is not enforced by this library\n * for performance and usability reasons.\n *\n * Users should prefer to use {@link DateDay} to cleanly represent the number of days. For JS dates,\n * {@link TimestampMillisecond} is the preferred type.\n *\n * @ignore\n */\nexport class DateMillisecond extends Date_ {\n    constructor() { super(DateUnit.MILLISECOND); }\n}\n/** @ignore */\nclass Time_ extends DataType {\n    constructor(unit, bitWidth) {\n        super(Type.Time);\n        this.unit = unit;\n        this.bitWidth = bitWidth;\n    }\n    toString() { return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`; }\n    get ArrayType() {\n        switch (this.bitWidth) {\n            case 32: return Int32Array;\n            case 64: return BigInt64Array;\n        }\n        // @ts-ignore\n        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n    }\n}\n_m = Symbol.toStringTag;\nTime_[_m] = ((proto) => {\n    proto.unit = null;\n    proto.bitWidth = null;\n    return proto[Symbol.toStringTag] = 'Time';\n})(Time_.prototype);\nexport { Time_ as Time };\n/** @ignore */\nexport class TimeSecond extends Time_ {\n    constructor() { super(TimeUnit.SECOND, 32); }\n}\n/** @ignore */\nexport class TimeMillisecond extends Time_ {\n    constructor() { super(TimeUnit.MILLISECOND, 32); }\n}\n/** @ignore */\nexport class TimeMicrosecond extends Time_ {\n    constructor() { super(TimeUnit.MICROSECOND, 64); }\n}\n/** @ignore */\nexport class TimeNanosecond extends Time_ {\n    constructor() { super(TimeUnit.NANOSECOND, 64); }\n}\n/** @ignore */\nclass Timestamp_ extends DataType {\n    constructor(unit, timezone) {\n        super(Type.Timestamp);\n        this.unit = unit;\n        this.timezone = timezone;\n    }\n    toString() { return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`; }\n}\n_o = Symbol.toStringTag;\nTimestamp_[_o] = ((proto) => {\n    proto.unit = null;\n    proto.timezone = null;\n    proto.ArrayType = BigInt64Array;\n    return proto[Symbol.toStringTag] = 'Timestamp';\n})(Timestamp_.prototype);\nexport { Timestamp_ as Timestamp };\n/** @ignore */\nexport class TimestampSecond extends Timestamp_ {\n    constructor(timezone) { super(TimeUnit.SECOND, timezone); }\n}\n/** @ignore */\nexport class TimestampMillisecond extends Timestamp_ {\n    constructor(timezone) { super(TimeUnit.MILLISECOND, timezone); }\n}\n/** @ignore */\nexport class TimestampMicrosecond extends Timestamp_ {\n    constructor(timezone) { super(TimeUnit.MICROSECOND, timezone); }\n}\n/** @ignore */\nexport class TimestampNanosecond extends Timestamp_ {\n    constructor(timezone) { super(TimeUnit.NANOSECOND, timezone); }\n}\n/** @ignore */\nclass Interval_ extends DataType {\n    constructor(unit) {\n        super(Type.Interval);\n        this.unit = unit;\n    }\n    toString() { return `Interval<${IntervalUnit[this.unit]}>`; }\n}\n_p = Symbol.toStringTag;\nInterval_[_p] = ((proto) => {\n    proto.unit = null;\n    proto.ArrayType = Int32Array;\n    return proto[Symbol.toStringTag] = 'Interval';\n})(Interval_.prototype);\nexport { Interval_ as Interval };\n/** @ignore */\nexport class IntervalDayTime extends Interval_ {\n    constructor() { super(IntervalUnit.DAY_TIME); }\n}\n/** @ignore */\nexport class IntervalYearMonth extends Interval_ {\n    constructor() { super(IntervalUnit.YEAR_MONTH); }\n}\n/** @ignore */\nexport class IntervalMonthDayNano extends Interval_ {\n    constructor() { super(IntervalUnit.MONTH_DAY_NANO); }\n}\n/** @ignore */\nexport class Duration extends DataType {\n    constructor(unit) {\n        super(Type.Duration);\n        this.unit = unit;\n    }\n    toString() { return `Duration<${TimeUnit[this.unit]}>`; }\n}\n_q = Symbol.toStringTag;\nDuration[_q] = ((proto) => {\n    proto.unit = null;\n    proto.ArrayType = BigInt64Array;\n    return proto[Symbol.toStringTag] = 'Duration';\n})(Duration.prototype);\n/** @ignore */\nexport class DurationSecond extends Duration {\n    constructor() { super(TimeUnit.SECOND); }\n}\n/** @ignore */\nexport class DurationMillisecond extends Duration {\n    constructor() { super(TimeUnit.MILLISECOND); }\n}\n/** @ignore */\nexport class DurationMicrosecond extends Duration {\n    constructor() { super(TimeUnit.MICROSECOND); }\n}\n/** @ignore */\nexport class DurationNanosecond extends Duration {\n    constructor() { super(TimeUnit.NANOSECOND); }\n}\n/** @ignore */\nexport class List extends DataType {\n    constructor(child) {\n        super(Type.List);\n        this.children = [child];\n    }\n    toString() { return `List<${this.valueType}>`; }\n    get valueType() { return this.children[0].type; }\n    get valueField() { return this.children[0]; }\n    get ArrayType() { return this.valueType.ArrayType; }\n}\n_r = Symbol.toStringTag;\nList[_r] = ((proto) => {\n    proto.children = null;\n    return proto[Symbol.toStringTag] = 'List';\n})(List.prototype);\n/** @ignore */\nexport class Struct extends DataType {\n    constructor(children) {\n        super(Type.Struct);\n        this.children = children;\n    }\n    toString() { return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }\n}\n_s = Symbol.toStringTag;\nStruct[_s] = ((proto) => {\n    proto.children = null;\n    return proto[Symbol.toStringTag] = 'Struct';\n})(Struct.prototype);\n/** @ignore */\nclass Union_ extends DataType {\n    constructor(mode, typeIds, children) {\n        super(Type.Union);\n        this.mode = mode;\n        this.children = children;\n        this.typeIds = typeIds = Int32Array.from(typeIds);\n        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));\n    }\n    toString() {\n        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;\n    }\n}\n_t = Symbol.toStringTag;\nUnion_[_t] = ((proto) => {\n    proto.mode = null;\n    proto.typeIds = null;\n    proto.children = null;\n    proto.typeIdToChildIndex = null;\n    proto.ArrayType = Int8Array;\n    return proto[Symbol.toStringTag] = 'Union';\n})(Union_.prototype);\nexport { Union_ as Union };\n/** @ignore */\nexport class DenseUnion extends Union_ {\n    constructor(typeIds, children) {\n        super(UnionMode.Dense, typeIds, children);\n    }\n}\n/** @ignore */\nexport class SparseUnion extends Union_ {\n    constructor(typeIds, children) {\n        super(UnionMode.Sparse, typeIds, children);\n    }\n}\n/** @ignore */\nexport class FixedSizeBinary extends DataType {\n    constructor(byteWidth) {\n        super(Type.FixedSizeBinary);\n        this.byteWidth = byteWidth;\n    }\n    toString() { return `FixedSizeBinary[${this.byteWidth}]`; }\n}\n_u = Symbol.toStringTag;\nFixedSizeBinary[_u] = ((proto) => {\n    proto.byteWidth = null;\n    proto.ArrayType = Uint8Array;\n    return proto[Symbol.toStringTag] = 'FixedSizeBinary';\n})(FixedSizeBinary.prototype);\n/** @ignore */\nexport class FixedSizeList extends DataType {\n    constructor(listSize, child) {\n        super(Type.FixedSizeList);\n        this.listSize = listSize;\n        this.children = [child];\n    }\n    get valueType() { return this.children[0].type; }\n    get valueField() { return this.children[0]; }\n    get ArrayType() { return this.valueType.ArrayType; }\n    toString() { return `FixedSizeList[${this.listSize}]<${this.valueType}>`; }\n}\n_v = Symbol.toStringTag;\nFixedSizeList[_v] = ((proto) => {\n    proto.children = null;\n    proto.listSize = null;\n    return proto[Symbol.toStringTag] = 'FixedSizeList';\n})(FixedSizeList.prototype);\n/** @ignore */\nexport class Map_ extends DataType {\n    constructor(entries, keysSorted = false) {\n        var _y, _z, _0;\n        super(Type.Map);\n        this.children = [entries];\n        this.keysSorted = keysSorted;\n        // ARROW-8716\n        // https://github.com/apache/arrow/issues/17168\n        if (entries) {\n            entries['name'] = 'entries';\n            if ((_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children) {\n                const key = (_z = entries === null || entries === void 0 ? void 0 : entries.type) === null || _z === void 0 ? void 0 : _z.children[0];\n                if (key) {\n                    key['name'] = 'key';\n                }\n                const val = (_0 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _0 === void 0 ? void 0 : _0.children[1];\n                if (val) {\n                    val['name'] = 'value';\n                }\n            }\n        }\n    }\n    get keyType() { return this.children[0].type.children[0].type; }\n    get valueType() { return this.children[0].type.children[1].type; }\n    get childType() { return this.children[0].type; }\n    toString() { return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }\n}\n_w = Symbol.toStringTag;\nMap_[_w] = ((proto) => {\n    proto.children = null;\n    proto.keysSorted = null;\n    return proto[Symbol.toStringTag] = 'Map_';\n})(Map_.prototype);\n/** @ignore */\nconst getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);\n/** @ignore */\nexport class Dictionary extends DataType {\n    constructor(dictionary, indices, id, isOrdered) {\n        super(Type.Dictionary);\n        this.indices = indices;\n        this.dictionary = dictionary;\n        this.isOrdered = isOrdered || false;\n        this.id = id == null ? getId() : bigIntToNumber(id);\n    }\n    get children() { return this.dictionary.children; }\n    get valueType() { return this.dictionary; }\n    get ArrayType() { return this.dictionary.ArrayType; }\n    toString() { return `Dictionary<${this.indices}, ${this.dictionary}>`; }\n}\n_x = Symbol.toStringTag;\nDictionary[_x] = ((proto) => {\n    proto.id = null;\n    proto.indices = null;\n    proto.isOrdered = null;\n    proto.dictionary = null;\n    return proto[Symbol.toStringTag] = 'Dictionary';\n})(Dictionary.prototype);\n/** @ignore */\nexport function strideForType(type) {\n    const t = type;\n    switch (type.typeId) {\n        case Type.Decimal: return type.bitWidth / 32;\n        case Type.Interval: {\n            if (t.unit === IntervalUnit.MONTH_DAY_NANO) {\n                return 4;\n            }\n            return 1 + t.unit;\n        }\n        // case Type.Int: return 1 + +((t as Int_).bitWidth > 32);\n        // case Type.Time: return 1 + +((t as Time_).bitWidth > 32);\n        case Type.FixedSizeList: return t.listSize;\n        case Type.FixedSizeBinary: return t.byteWidth;\n        default: return 1;\n    }\n}\n\n//# sourceMappingURL=type.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Type, Precision, DateUnit, TimeUnit, IntervalUnit, UnionMode } from './enum.mjs';\nimport { DataType } from './type.mjs';\nexport class Visitor {\n    visitMany(nodes, ...args) {\n        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));\n    }\n    visit(...args) {\n        return this.getVisitFn(args[0], false).apply(this, args);\n    }\n    getVisitFn(node, throwIfNotFound = true) {\n        return getVisitFn(this, node, throwIfNotFound);\n    }\n    getVisitFnByTypeId(typeId, throwIfNotFound = true) {\n        return getVisitFnByTypeId(this, typeId, throwIfNotFound);\n    }\n    visitNull(_node, ..._args) { return null; }\n    visitBool(_node, ..._args) { return null; }\n    visitInt(_node, ..._args) { return null; }\n    visitFloat(_node, ..._args) { return null; }\n    visitUtf8(_node, ..._args) { return null; }\n    visitLargeUtf8(_node, ..._args) { return null; }\n    visitBinary(_node, ..._args) { return null; }\n    visitLargeBinary(_node, ..._args) { return null; }\n    visitFixedSizeBinary(_node, ..._args) { return null; }\n    visitDate(_node, ..._args) { return null; }\n    visitTimestamp(_node, ..._args) { return null; }\n    visitTime(_node, ..._args) { return null; }\n    visitDecimal(_node, ..._args) { return null; }\n    visitList(_node, ..._args) { return null; }\n    visitStruct(_node, ..._args) { return null; }\n    visitUnion(_node, ..._args) { return null; }\n    visitDictionary(_node, ..._args) { return null; }\n    visitInterval(_node, ..._args) { return null; }\n    visitDuration(_node, ..._args) { return null; }\n    visitFixedSizeList(_node, ..._args) { return null; }\n    visitMap(_node, ..._args) { return null; }\n}\n/** @ignore */\nfunction getVisitFn(visitor, node, throwIfNotFound = true) {\n    if (typeof node === 'number') {\n        return getVisitFnByTypeId(visitor, node, throwIfNotFound);\n    }\n    if (typeof node === 'string' && (node in Type)) {\n        return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);\n    }\n    if (node && (node instanceof DataType)) {\n        return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);\n    }\n    if ((node === null || node === void 0 ? void 0 : node.type) && (node.type instanceof DataType)) {\n        return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);\n    }\n    return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);\n}\n/** @ignore */\nfunction getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {\n    let fn = null;\n    switch (dtype) {\n        case Type.Null:\n            fn = visitor.visitNull;\n            break;\n        case Type.Bool:\n            fn = visitor.visitBool;\n            break;\n        case Type.Int:\n            fn = visitor.visitInt;\n            break;\n        case Type.Int8:\n            fn = visitor.visitInt8 || visitor.visitInt;\n            break;\n        case Type.Int16:\n            fn = visitor.visitInt16 || visitor.visitInt;\n            break;\n        case Type.Int32:\n            fn = visitor.visitInt32 || visitor.visitInt;\n            break;\n        case Type.Int64:\n            fn = visitor.visitInt64 || visitor.visitInt;\n            break;\n        case Type.Uint8:\n            fn = visitor.visitUint8 || visitor.visitInt;\n            break;\n        case Type.Uint16:\n            fn = visitor.visitUint16 || visitor.visitInt;\n            break;\n        case Type.Uint32:\n            fn = visitor.visitUint32 || visitor.visitInt;\n            break;\n        case Type.Uint64:\n            fn = visitor.visitUint64 || visitor.visitInt;\n            break;\n        case Type.Float:\n            fn = visitor.visitFloat;\n            break;\n        case Type.Float16:\n            fn = visitor.visitFloat16 || visitor.visitFloat;\n            break;\n        case Type.Float32:\n            fn = visitor.visitFloat32 || visitor.visitFloat;\n            break;\n        case Type.Float64:\n            fn = visitor.visitFloat64 || visitor.visitFloat;\n            break;\n        case Type.Utf8:\n            fn = visitor.visitUtf8;\n            break;\n        case Type.LargeUtf8:\n            fn = visitor.visitLargeUtf8;\n            break;\n        case Type.Binary:\n            fn = visitor.visitBinary;\n            break;\n        case Type.LargeBinary:\n            fn = visitor.visitLargeBinary;\n            break;\n        case Type.FixedSizeBinary:\n            fn = visitor.visitFixedSizeBinary;\n            break;\n        case Type.Date:\n            fn = visitor.visitDate;\n            break;\n        case Type.DateDay:\n            fn = visitor.visitDateDay || visitor.visitDate;\n            break;\n        case Type.DateMillisecond:\n            fn = visitor.visitDateMillisecond || visitor.visitDate;\n            break;\n        case Type.Timestamp:\n            fn = visitor.visitTimestamp;\n            break;\n        case Type.TimestampSecond:\n            fn = visitor.visitTimestampSecond || visitor.visitTimestamp;\n            break;\n        case Type.TimestampMillisecond:\n            fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;\n            break;\n        case Type.TimestampMicrosecond:\n            fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;\n            break;\n        case Type.TimestampNanosecond:\n            fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;\n            break;\n        case Type.Time:\n            fn = visitor.visitTime;\n            break;\n        case Type.TimeSecond:\n            fn = visitor.visitTimeSecond || visitor.visitTime;\n            break;\n        case Type.TimeMillisecond:\n            fn = visitor.visitTimeMillisecond || visitor.visitTime;\n            break;\n        case Type.TimeMicrosecond:\n            fn = visitor.visitTimeMicrosecond || visitor.visitTime;\n            break;\n        case Type.TimeNanosecond:\n            fn = visitor.visitTimeNanosecond || visitor.visitTime;\n            break;\n        case Type.Decimal:\n            fn = visitor.visitDecimal;\n            break;\n        case Type.List:\n            fn = visitor.visitList;\n            break;\n        case Type.Struct:\n            fn = visitor.visitStruct;\n            break;\n        case Type.Union:\n            fn = visitor.visitUnion;\n            break;\n        case Type.DenseUnion:\n            fn = visitor.visitDenseUnion || visitor.visitUnion;\n            break;\n        case Type.SparseUnion:\n            fn = visitor.visitSparseUnion || visitor.visitUnion;\n            break;\n        case Type.Dictionary:\n            fn = visitor.visitDictionary;\n            break;\n        case Type.Interval:\n            fn = visitor.visitInterval;\n            break;\n        case Type.IntervalDayTime:\n            fn = visitor.visitIntervalDayTime || visitor.visitInterval;\n            break;\n        case Type.IntervalYearMonth:\n            fn = visitor.visitIntervalYearMonth || visitor.visitInterval;\n            break;\n        case Type.IntervalMonthDayNano:\n            fn = visitor.visitIntervalMonthDayNano || visitor.visitInterval;\n            break;\n        case Type.Duration:\n            fn = visitor.visitDuration;\n            break;\n        case Type.DurationSecond:\n            fn = visitor.visitDurationSecond || visitor.visitDuration;\n            break;\n        case Type.DurationMillisecond:\n            fn = visitor.visitDurationMillisecond || visitor.visitDuration;\n            break;\n        case Type.DurationMicrosecond:\n            fn = visitor.visitDurationMicrosecond || visitor.visitDuration;\n            break;\n        case Type.DurationNanosecond:\n            fn = visitor.visitDurationNanosecond || visitor.visitDuration;\n            break;\n        case Type.FixedSizeList:\n            fn = visitor.visitFixedSizeList;\n            break;\n        case Type.Map:\n            fn = visitor.visitMap;\n            break;\n    }\n    if (typeof fn === 'function')\n        return fn;\n    if (!throwIfNotFound)\n        return () => null;\n    throw new Error(`Unrecognized type '${Type[dtype]}'`);\n}\n/** @ignore */\nfunction inferDType(type) {\n    switch (type.typeId) {\n        case Type.Null: return Type.Null;\n        case Type.Int: {\n            const { bitWidth, isSigned } = type;\n            switch (bitWidth) {\n                case 8: return isSigned ? Type.Int8 : Type.Uint8;\n                case 16: return isSigned ? Type.Int16 : Type.Uint16;\n                case 32: return isSigned ? Type.Int32 : Type.Uint32;\n                case 64: return isSigned ? Type.Int64 : Type.Uint64;\n            }\n            // @ts-ignore\n            return Type.Int;\n        }\n        case Type.Float:\n            switch (type.precision) {\n                case Precision.HALF: return Type.Float16;\n                case Precision.SINGLE: return Type.Float32;\n                case Precision.DOUBLE: return Type.Float64;\n            }\n            // @ts-ignore\n            return Type.Float;\n        case Type.Binary: return Type.Binary;\n        case Type.LargeBinary: return Type.LargeBinary;\n        case Type.Utf8: return Type.Utf8;\n        case Type.LargeUtf8: return Type.LargeUtf8;\n        case Type.Bool: return Type.Bool;\n        case Type.Decimal: return Type.Decimal;\n        case Type.Time:\n            switch (type.unit) {\n                case TimeUnit.SECOND: return Type.TimeSecond;\n                case TimeUnit.MILLISECOND: return Type.TimeMillisecond;\n                case TimeUnit.MICROSECOND: return Type.TimeMicrosecond;\n                case TimeUnit.NANOSECOND: return Type.TimeNanosecond;\n            }\n            // @ts-ignore\n            return Type.Time;\n        case Type.Timestamp:\n            switch (type.unit) {\n                case TimeUnit.SECOND: return Type.TimestampSecond;\n                case TimeUnit.MILLISECOND: return Type.TimestampMillisecond;\n                case TimeUnit.MICROSECOND: return Type.TimestampMicrosecond;\n                case TimeUnit.NANOSECOND: return Type.TimestampNanosecond;\n            }\n            // @ts-ignore\n            return Type.Timestamp;\n        case Type.Date:\n            switch (type.unit) {\n                case DateUnit.DAY: return Type.DateDay;\n                case DateUnit.MILLISECOND: return Type.DateMillisecond;\n            }\n            // @ts-ignore\n            return Type.Date;\n        case Type.Interval:\n            switch (type.unit) {\n                case IntervalUnit.DAY_TIME: return Type.IntervalDayTime;\n                case IntervalUnit.YEAR_MONTH: return Type.IntervalYearMonth;\n                case IntervalUnit.MONTH_DAY_NANO: return Type.IntervalMonthDayNano;\n            }\n            // @ts-ignore\n            return Type.Interval;\n        case Type.Duration:\n            switch (type.unit) {\n                case TimeUnit.SECOND: return Type.DurationSecond;\n                case TimeUnit.MILLISECOND: return Type.DurationMillisecond;\n                case TimeUnit.MICROSECOND: return Type.DurationMicrosecond;\n                case TimeUnit.NANOSECOND: return Type.DurationNanosecond;\n            }\n            // @ts-ignore\n            return Type.Duration;\n        case Type.Map: return Type.Map;\n        case Type.List: return Type.List;\n        case Type.Struct: return Type.Struct;\n        case Type.Union:\n            switch (type.mode) {\n                case UnionMode.Dense: return Type.DenseUnion;\n                case UnionMode.Sparse: return Type.SparseUnion;\n            }\n            // @ts-ignore\n            return Type.Union;\n        case Type.FixedSizeBinary: return Type.FixedSizeBinary;\n        case Type.FixedSizeList: return Type.FixedSizeList;\n        case Type.Dictionary: return Type.Dictionary;\n    }\n    throw new Error(`Unrecognized type '${Type[type.typeId]}'`);\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nVisitor.prototype.visitInt8 = null;\nVisitor.prototype.visitInt16 = null;\nVisitor.prototype.visitInt32 = null;\nVisitor.prototype.visitInt64 = null;\nVisitor.prototype.visitUint8 = null;\nVisitor.prototype.visitUint16 = null;\nVisitor.prototype.visitUint32 = null;\nVisitor.prototype.visitUint64 = null;\nVisitor.prototype.visitFloat16 = null;\nVisitor.prototype.visitFloat32 = null;\nVisitor.prototype.visitFloat64 = null;\nVisitor.prototype.visitDateDay = null;\nVisitor.prototype.visitDateMillisecond = null;\nVisitor.prototype.visitTimestampSecond = null;\nVisitor.prototype.visitTimestampMillisecond = null;\nVisitor.prototype.visitTimestampMicrosecond = null;\nVisitor.prototype.visitTimestampNanosecond = null;\nVisitor.prototype.visitTimeSecond = null;\nVisitor.prototype.visitTimeMillisecond = null;\nVisitor.prototype.visitTimeMicrosecond = null;\nVisitor.prototype.visitTimeNanosecond = null;\nVisitor.prototype.visitDenseUnion = null;\nVisitor.prototype.visitSparseUnion = null;\nVisitor.prototype.visitIntervalDayTime = null;\nVisitor.prototype.visitIntervalYearMonth = null;\nVisitor.prototype.visitIntervalMonthDayNano = null;\nVisitor.prototype.visitDuration = null;\nVisitor.prototype.visitDurationSecond = null;\nVisitor.prototype.visitDurationMillisecond = null;\nVisitor.prototype.visitDurationMicrosecond = null;\nVisitor.prototype.visitDurationNanosecond = null;\n\n//# sourceMappingURL=visitor.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nconst f64 = new Float64Array(1);\nconst u32 = new Uint32Array(f64.buffer);\n/**\n * Convert uint16 (logically a float16) to a JS float64. Inspired by numpy's `npy_half_to_double`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L29\n * @param h {number} the uint16 to convert\n * @private\n * @ignore\n */\nexport function uint16ToFloat64(h) {\n    const expo = (h & 0x7C00) >> 10;\n    const sigf = (h & 0x03FF) / 1024;\n    const sign = Math.pow((-1), ((h & 0x8000) >> 15));\n    switch (expo) {\n        case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n        case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n    }\n    return sign * (Math.pow(2, (expo - 15))) * (1 + sigf);\n}\n/**\n * Convert a float64 to uint16 (assuming the float64 is logically a float16). Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * @param d {number} The float64 to convert\n * @private\n * @ignore\n */\nexport function float64ToUint16(d) {\n    if (d !== d) {\n        return 0x7E00;\n    } // NaN\n    f64[0] = d;\n    // Magic numbers:\n    // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n    // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n    // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n    const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n    let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;\n    if (expo >= 0x40F00000) {\n        //\n        // If exponent overflowed, the float16 is either NaN or Infinity.\n        // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n        //\n        // Magic numbers:\n        // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n        // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n        //\n        // returns:\n        // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n        // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n        // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n        // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n        //\n        // If mantissa is greater than 23 bits, set to +Infinity like numpy\n        if (u32[0] > 0) {\n            expo = 0x7C00;\n        }\n        else {\n            expo = (expo & 0x7C000000) >> 16;\n            sigf = (u32[1] & 0x000FFFFF) >> 10;\n        }\n    }\n    else if (expo <= 0x3F000000) {\n        //\n        // If exponent underflowed, the float is either signed zero or subnormal.\n        //\n        // Magic numbers:\n        // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n        //\n        sigf = 0x100000 + (u32[1] & 0x000FFFFF);\n        sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;\n        expo = 0;\n    }\n    else {\n        //\n        // No overflow or underflow, rebase the exponent and round the mantissa\n        // Magic numbers:\n        // 0x200 = 00000010 00000000 -- masks off the 10th bit\n        //\n        // Ensure the first mantissa bit (the 10th one) is 1 and round\n        expo = (expo - 0x3F000000) >> 10;\n        sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;\n    }\n    return sign | expo | sigf & 0xFFFF;\n}\n\n//# sourceMappingURL=math.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { bigIntToNumber } from '../util/bigint.mjs';\nimport { encodeUtf8 } from '../util/utf8.mjs';\nimport { float64ToUint16 } from '../util/math.mjs';\nimport { UnionMode, Precision, DateUnit, TimeUnit, IntervalUnit } from '../enum.mjs';\n/** @ignore */\nexport class SetVisitor extends Visitor {\n}\n/** @ignore */\nfunction wrapSet(fn) {\n    return (data, _1, _2) => {\n        if (data.setValid(_1, _2 != null)) {\n            return fn(data, _1, _2);\n        }\n    };\n}\n/** @ignore */\nexport const setEpochMsToDays = (data, index, epochMs) => { data[index] = Math.floor(epochMs / 86400000); };\n/** @ignore */\nexport const setVariableWidthBytes = (values, valueOffsets, index, value) => {\n    if (index + 1 < valueOffsets.length) {\n        const x = bigIntToNumber(valueOffsets[index]);\n        const y = bigIntToNumber(valueOffsets[index + 1]);\n        values.set(value.subarray(0, y - x), x);\n    }\n};\n/** @ignore */\nconst setBool = ({ offset, values }, index, val) => {\n    const idx = offset + index;\n    val ? (values[idx >> 3] |= (1 << (idx % 8))) // true\n        : (values[idx >> 3] &= ~(1 << (idx % 8))); // false\n};\n/** @ignore */\nexport const setInt = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setFloat = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setFloat16 = ({ values }, index, value) => { values[index] = float64ToUint16(value); };\n/* istanbul ignore next */\n/** @ignore */\nexport const setAnyFloat = (data, index, value) => {\n    switch (data.type.precision) {\n        case Precision.HALF:\n            return setFloat16(data, index, value);\n        case Precision.SINGLE:\n        case Precision.DOUBLE:\n            return setFloat(data, index, value);\n    }\n};\n/** @ignore */\nexport const setDateDay = ({ values }, index, value) => { setEpochMsToDays(values, index, value.valueOf()); };\n/** @ignore */\nexport const setDateMillisecond = ({ values }, index, value) => { values[index] = BigInt(value); };\n/** @ignore */\nexport const setFixedSizeBinary = ({ stride, values }, index, value) => { values.set(value.subarray(0, stride), stride * index); };\n/** @ignore */\nconst setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);\n/** @ignore */\nconst setUtf8 = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, encodeUtf8(value));\n/* istanbul ignore next */\nexport const setDate = (data, index, value) => {\n    data.type.unit === DateUnit.DAY\n        ? setDateDay(data, index, value)\n        : setDateMillisecond(data, index, value);\n};\n/** @ignore */\nexport const setTimestampSecond = ({ values }, index, value) => { values[index] = BigInt(value / 1000); };\n/** @ignore */\nexport const setTimestampMillisecond = ({ values }, index, value) => { values[index] = BigInt(value); };\n/** @ignore */\nexport const setTimestampMicrosecond = ({ values }, index, value) => { values[index] = BigInt(value * 1000); };\n/** @ignore */\nexport const setTimestampNanosecond = ({ values }, index, value) => { values[index] = BigInt(value * 1000000); };\n/* istanbul ignore next */\n/** @ignore */\nexport const setTimestamp = (data, index, value) => {\n    switch (data.type.unit) {\n        case TimeUnit.SECOND: return setTimestampSecond(data, index, value);\n        case TimeUnit.MILLISECOND: return setTimestampMillisecond(data, index, value);\n        case TimeUnit.MICROSECOND: return setTimestampMicrosecond(data, index, value);\n        case TimeUnit.NANOSECOND: return setTimestampNanosecond(data, index, value);\n    }\n};\n/** @ignore */\nexport const setTimeSecond = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setTimeMillisecond = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setTimeMicrosecond = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setTimeNanosecond = ({ values }, index, value) => { values[index] = value; };\n/* istanbul ignore next */\n/** @ignore */\nexport const setTime = (data, index, value) => {\n    switch (data.type.unit) {\n        case TimeUnit.SECOND: return setTimeSecond(data, index, value);\n        case TimeUnit.MILLISECOND: return setTimeMillisecond(data, index, value);\n        case TimeUnit.MICROSECOND: return setTimeMicrosecond(data, index, value);\n        case TimeUnit.NANOSECOND: return setTimeNanosecond(data, index, value);\n    }\n};\n/** @ignore */\nexport const setDecimal = ({ values, stride }, index, value) => { values.set(value.subarray(0, stride), stride * index); };\n/** @ignore */\nconst setList = (data, index, value) => {\n    const values = data.children[0];\n    const valueOffsets = data.valueOffsets;\n    const set = instance.getVisitFn(values);\n    if (Array.isArray(value)) {\n        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {\n            set(values, itr++, value[++idx]);\n        }\n    }\n    else {\n        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {\n            set(values, itr++, value.get(++idx));\n        }\n    }\n};\n/** @ignore */\nconst setMap = (data, index, value) => {\n    const values = data.children[0];\n    const { valueOffsets } = data;\n    const set = instance.getVisitFn(values);\n    let { [index]: idx, [index + 1]: end } = valueOffsets;\n    const entries = value instanceof Map ? value.entries() : Object.entries(value);\n    for (const val of entries) {\n        set(values, idx, val);\n        if (++idx >= end)\n            break;\n    }\n};\n/** @ignore */ const _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);\n/** @ignore */ const _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));\n/** @ignore */ const _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));\n/** @ignore */ const _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);\n/** @ignore */\nconst setStruct = (data, index, value) => {\n    const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));\n    const set = value instanceof Map ? _setStructMapValue(index, value) :\n        value instanceof Vector ? _setStructVectorValue(index, value) :\n            Array.isArray(value) ? _setStructArrayValue(index, value) :\n                _setStructObjectValue(index, value);\n    // eslint-disable-next-line unicorn/no-array-for-each\n    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));\n};\n/* istanbul ignore next */\n/** @ignore */\nconst setUnion = (data, index, value) => {\n    data.type.mode === UnionMode.Dense ?\n        setDenseUnion(data, index, value) :\n        setSparseUnion(data, index, value);\n};\n/** @ignore */\nconst setDenseUnion = (data, index, value) => {\n    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];\n    const child = data.children[childIndex];\n    instance.visit(child, data.valueOffsets[index], value);\n};\n/** @ignore */\nconst setSparseUnion = (data, index, value) => {\n    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];\n    const child = data.children[childIndex];\n    instance.visit(child, index, value);\n};\n/** @ignore */\nconst setDictionary = (data, index, value) => {\n    var _a;\n    (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.set(data.values[index], value);\n};\n/* istanbul ignore next */\n/** @ignore */\nexport const setIntervalValue = (data, index, value) => {\n    switch (data.type.unit) {\n        case IntervalUnit.YEAR_MONTH: return setIntervalYearMonth(data, index, value);\n        case IntervalUnit.DAY_TIME: return setIntervalDayTime(data, index, value);\n        case IntervalUnit.MONTH_DAY_NANO: return setIntervalMonthDayNano(data, index, value);\n    }\n};\n/** @ignore */\nexport const setIntervalDayTime = ({ values }, index, value) => { values.set(value.subarray(0, 2), 2 * index); };\n/** @ignore */\nexport const setIntervalYearMonth = ({ values }, index, value) => { values[index] = (value[0] * 12) + (value[1] % 12); };\n/** @ignore */\nexport const setIntervalMonthDayNano = ({ values, stride }, index, value) => { values.set(value.subarray(0, stride), stride * index); };\n/** @ignore */\nexport const setDurationSecond = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setDurationMillisecond = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setDurationMicrosecond = ({ values }, index, value) => { values[index] = value; };\n/** @ignore */\nexport const setDurationNanosecond = ({ values }, index, value) => { values[index] = value; };\n/* istanbul ignore next */\n/** @ignore */\nexport const setDuration = (data, index, value) => {\n    switch (data.type.unit) {\n        case TimeUnit.SECOND: return setDurationSecond(data, index, value);\n        case TimeUnit.MILLISECOND: return setDurationMillisecond(data, index, value);\n        case TimeUnit.MICROSECOND: return setDurationMicrosecond(data, index, value);\n        case TimeUnit.NANOSECOND: return setDurationNanosecond(data, index, value);\n    }\n};\n/** @ignore */\nconst setFixedSizeList = (data, index, value) => {\n    const { stride } = data;\n    const child = data.children[0];\n    const set = instance.getVisitFn(child);\n    if (Array.isArray(value)) {\n        for (let idx = -1, offset = index * stride; ++idx < stride;) {\n            set(child, offset + idx, value[idx]);\n        }\n    }\n    else {\n        for (let idx = -1, offset = index * stride; ++idx < stride;) {\n            set(child, offset + idx, value.get(idx));\n        }\n    }\n};\nSetVisitor.prototype.visitBool = wrapSet(setBool);\nSetVisitor.prototype.visitInt = wrapSet(setInt);\nSetVisitor.prototype.visitInt8 = wrapSet(setInt);\nSetVisitor.prototype.visitInt16 = wrapSet(setInt);\nSetVisitor.prototype.visitInt32 = wrapSet(setInt);\nSetVisitor.prototype.visitInt64 = wrapSet(setInt);\nSetVisitor.prototype.visitUint8 = wrapSet(setInt);\nSetVisitor.prototype.visitUint16 = wrapSet(setInt);\nSetVisitor.prototype.visitUint32 = wrapSet(setInt);\nSetVisitor.prototype.visitUint64 = wrapSet(setInt);\nSetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);\nSetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);\nSetVisitor.prototype.visitFloat32 = wrapSet(setFloat);\nSetVisitor.prototype.visitFloat64 = wrapSet(setFloat);\nSetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);\nSetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);\nSetVisitor.prototype.visitBinary = wrapSet(setBinary);\nSetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);\nSetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);\nSetVisitor.prototype.visitDate = wrapSet(setDate);\nSetVisitor.prototype.visitDateDay = wrapSet(setDateDay);\nSetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);\nSetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);\nSetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);\nSetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);\nSetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);\nSetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);\nSetVisitor.prototype.visitTime = wrapSet(setTime);\nSetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);\nSetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);\nSetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);\nSetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);\nSetVisitor.prototype.visitDecimal = wrapSet(setDecimal);\nSetVisitor.prototype.visitList = wrapSet(setList);\nSetVisitor.prototype.visitStruct = wrapSet(setStruct);\nSetVisitor.prototype.visitUnion = wrapSet(setUnion);\nSetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);\nSetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);\nSetVisitor.prototype.visitDictionary = wrapSet(setDictionary);\nSetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);\nSetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);\nSetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);\nSetVisitor.prototype.visitIntervalMonthDayNano = wrapSet(setIntervalMonthDayNano);\nSetVisitor.prototype.visitDuration = wrapSet(setDuration);\nSetVisitor.prototype.visitDurationSecond = wrapSet(setDurationSecond);\nSetVisitor.prototype.visitDurationMillisecond = wrapSet(setDurationMillisecond);\nSetVisitor.prototype.visitDurationMicrosecond = wrapSet(setDurationMicrosecond);\nSetVisitor.prototype.visitDurationNanosecond = wrapSet(setDurationNanosecond);\nSetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);\nSetVisitor.prototype.visitMap = wrapSet(setMap);\n/** @ignore */\nexport const instance = new SetVisitor();\n\n//# sourceMappingURL=set.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { valueToString } from '../util/pretty.mjs';\nimport { instance as getVisitor } from '../visitor/get.mjs';\nimport { instance as setVisitor } from '../visitor/set.mjs';\n/** @ignore */ const kParent = Symbol.for('parent');\n/** @ignore */ const kRowIndex = Symbol.for('rowIndex');\nexport class StructRow {\n    constructor(parent, rowIndex) {\n        this[kParent] = parent;\n        this[kRowIndex] = rowIndex;\n        return new Proxy(this, structRowProxyHandler);\n    }\n    toArray() { return Object.values(this.toJSON()); }\n    toJSON() {\n        const i = this[kRowIndex];\n        const parent = this[kParent];\n        const keys = parent.type.children;\n        const json = {};\n        for (let j = -1, n = keys.length; ++j < n;) {\n            json[keys[j].name] = getVisitor.visit(parent.children[j], i);\n        }\n        return json;\n    }\n    toString() {\n        return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(', ')}}`;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.toString();\n    }\n    [Symbol.iterator]() {\n        return new StructRowIterator(this[kParent], this[kRowIndex]);\n    }\n}\nclass StructRowIterator {\n    constructor(data, rowIndex) {\n        this.childIndex = 0;\n        this.children = data.children;\n        this.rowIndex = rowIndex;\n        this.childFields = data.type.children;\n        this.numChildren = this.childFields.length;\n    }\n    [Symbol.iterator]() { return this; }\n    next() {\n        const i = this.childIndex;\n        if (i < this.numChildren) {\n            this.childIndex = i + 1;\n            return {\n                done: false,\n                value: [\n                    this.childFields[i].name,\n                    getVisitor.visit(this.children[i], this.rowIndex)\n                ]\n            };\n        }\n        return { done: true, value: null };\n    }\n}\nObject.defineProperties(StructRow.prototype, {\n    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },\n    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },\n    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 },\n});\nclass StructRowProxyHandler {\n    isExtensible() { return false; }\n    deleteProperty() { return false; }\n    preventExtensions() { return true; }\n    ownKeys(row) {\n        return row[kParent].type.children.map((f) => f.name);\n    }\n    has(row, key) {\n        return row[kParent].type.children.some((f) => f.name === key);\n    }\n    getOwnPropertyDescriptor(row, key) {\n        if (row[kParent].type.children.some((f) => f.name === key)) {\n            return { writable: true, enumerable: true, configurable: true };\n        }\n        return;\n    }\n    get(row, key) {\n        // Look up key in row first\n        if (Reflect.has(row, key)) {\n            return row[key];\n        }\n        const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n        if (idx !== -1) {\n            const val = getVisitor.visit(row[kParent].children[idx], row[kRowIndex]);\n            // Cache key/val lookups\n            Reflect.set(row, key, val);\n            return val;\n        }\n    }\n    set(row, key, val) {\n        const idx = row[kParent].type.children.findIndex((f) => f.name === key);\n        if (idx !== -1) {\n            setVisitor.visit(row[kParent].children[idx], row[kRowIndex], val);\n            // Cache key/val lookups\n            return Reflect.set(row, key, val);\n        }\n        else if (Reflect.has(row, key) || typeof key === 'symbol') {\n            return Reflect.set(row, key, val);\n        }\n        return false;\n    }\n}\nconst structRowProxyHandler = new StructRowProxyHandler();\n\n//# sourceMappingURL=struct.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { BN } from '../util/bn.mjs';\nimport { Vector } from '../vector.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { MapRow } from '../row/map.mjs';\nimport { StructRow } from '../row/struct.mjs';\nimport { bigIntToNumber, divideBigInts } from '../util/bigint.mjs';\nimport { decodeUtf8 } from '../util/utf8.mjs';\nimport { uint16ToFloat64 } from '../util/math.mjs';\nimport { UnionMode, Precision, DateUnit, TimeUnit, IntervalUnit } from '../enum.mjs';\n/** @ignore */\nexport class GetVisitor extends Visitor {\n}\n/** @ignore */\nfunction wrapGet(fn) {\n    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;\n}\n/** @ignore */ const epochDaysToMs = (data, index) => 86400000 * data[index];\n/** @ignore */\nconst getNull = (_data, _index) => null;\n/** @ignore */\nconst getVariableWidthBytes = (values, valueOffsets, index) => {\n    if (index + 1 >= valueOffsets.length) {\n        return null;\n    }\n    const x = bigIntToNumber(valueOffsets[index]);\n    const y = bigIntToNumber(valueOffsets[index + 1]);\n    return values.subarray(x, y);\n};\n/** @ignore */\nconst getBool = ({ offset, values }, index) => {\n    const idx = offset + index;\n    const byte = values[idx >> 3];\n    return (byte & 1 << (idx % 8)) !== 0;\n};\n/** @ignore */\nconst getDateDay = ({ values }, index) => epochDaysToMs(values, index);\n/** @ignore */\nconst getDateMillisecond = ({ values }, index) => bigIntToNumber(values[index]);\n/** @ignore */\nconst getNumeric = ({ stride, values }, index) => values[stride * index];\n/** @ignore */\nconst getFloat16 = ({ stride, values }, index) => uint16ToFloat64(values[stride * index]);\n/** @ignore */\nconst getBigInts = ({ values }, index) => values[index];\n/** @ignore */\nconst getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));\n/** @ignore */\nconst getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);\n/** @ignore */\nconst getUtf8 = ({ values, valueOffsets }, index) => {\n    const bytes = getVariableWidthBytes(values, valueOffsets, index);\n    return bytes !== null ? decodeUtf8(bytes) : null;\n};\n/* istanbul ignore next */\n/** @ignore */\nconst getInt = ({ values }, index) => values[index];\n/* istanbul ignore next */\n/** @ignore */\nconst getFloat = ({ type, values }, index) => (type.precision !== Precision.HALF ? values[index] : uint16ToFloat64(values[index]));\n/* istanbul ignore next */\n/** @ignore */\nconst getDate = (data, index) => (data.type.unit === DateUnit.DAY\n    ? getDateDay(data, index)\n    : getDateMillisecond(data, index));\n/** @ignore */\nconst getTimestampSecond = ({ values }, index) => 1000 * bigIntToNumber(values[index]);\n/** @ignore */\nconst getTimestampMillisecond = ({ values }, index) => bigIntToNumber(values[index]);\n/** @ignore */\nconst getTimestampMicrosecond = ({ values }, index) => divideBigInts(values[index], BigInt(1000));\n/** @ignore */\nconst getTimestampNanosecond = ({ values }, index) => divideBigInts(values[index], BigInt(1000000));\n/* istanbul ignore next */\n/** @ignore */\nconst getTimestamp = (data, index) => {\n    switch (data.type.unit) {\n        case TimeUnit.SECOND: return getTimestampSecond(data, index);\n        case TimeUnit.MILLISECOND: return getTimestampMillisecond(data, index);\n        case TimeUnit.MICROSECOND: return getTimestampMicrosecond(data, index);\n        case TimeUnit.NANOSECOND: return getTimestampNanosecond(data, index);\n    }\n};\n/** @ignore */\nconst getTimeSecond = ({ values }, index) => values[index];\n/** @ignore */\nconst getTimeMillisecond = ({ values }, index) => values[index];\n/** @ignore */\nconst getTimeMicrosecond = ({ values }, index) => values[index];\n/** @ignore */\nconst getTimeNanosecond = ({ values }, index) => values[index];\n/* istanbul ignore next */\n/** @ignore */\nconst getTime = (data, index) => {\n    switch (data.type.unit) {\n        case TimeUnit.SECOND: return getTimeSecond(data, index);\n        case TimeUnit.MILLISECOND: return getTimeMillisecond(data, index);\n        case TimeUnit.MICROSECOND: return getTimeMicrosecond(data, index);\n        case TimeUnit.NANOSECOND: return getTimeNanosecond(data, index);\n    }\n};\n/** @ignore */\nconst getDecimal = ({ values, stride }, index) => BN.decimal(values.subarray(stride * index, stride * (index + 1)));\n/** @ignore */\nconst getList = (data, index) => {\n    const { valueOffsets, stride, children } = data;\n    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;\n    const child = children[0];\n    const slice = child.slice(begin, end - begin);\n    return new Vector([slice]);\n};\n/** @ignore */\nconst getMap = (data, index) => {\n    const { valueOffsets, children } = data;\n    const { [index]: begin, [index + 1]: end } = valueOffsets;\n    const child = children[0];\n    return new MapRow(child.slice(begin, end - begin));\n};\n/** @ignore */\nconst getStruct = (data, index) => {\n    return new StructRow(data, index);\n};\n/* istanbul ignore next */\n/** @ignore */\nconst getUnion = (data, index) => {\n    return data.type.mode === UnionMode.Dense ?\n        getDenseUnion(data, index) :\n        getSparseUnion(data, index);\n};\n/** @ignore */\nconst getDenseUnion = (data, index) => {\n    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];\n    const child = data.children[childIndex];\n    return instance.visit(child, data.valueOffsets[index]);\n};\n/** @ignore */\nconst getSparseUnion = (data, index) => {\n    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];\n    const child = data.children[childIndex];\n    return instance.visit(child, index);\n};\n/** @ignore */\nconst getDictionary = (data, index) => {\n    var _a;\n    return (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.get(data.values[index]);\n};\n/* istanbul ignore next */\n/** @ignore */\nconst getInterval = (data, index) => (data.type.unit === IntervalUnit.MONTH_DAY_NANO)\n    ? getIntervalMonthDayNano(data, index)\n    : (data.type.unit === IntervalUnit.DAY_TIME)\n        ? getIntervalDayTime(data, index)\n        : getIntervalYearMonth(data, index);\n/** @ignore */\nconst getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));\n/** @ignore */\nconst getIntervalYearMonth = ({ values }, index) => {\n    const interval = values[index];\n    const int32s = new Int32Array(2);\n    int32s[0] = Math.trunc(interval / 12); /* years */\n    int32s[1] = Math.trunc(interval % 12); /* months */\n    return int32s;\n};\n/** @ignore */\nconst getIntervalMonthDayNano = ({ values }, index) => values.subarray(4 * index, 4 * (index + 1));\n/** @ignore */\nconst getDurationSecond = ({ values }, index) => values[index];\n/** @ignore */\nconst getDurationMillisecond = ({ values }, index) => values[index];\n/** @ignore */\nconst getDurationMicrosecond = ({ values }, index) => values[index];\n/** @ignore */\nconst getDurationNanosecond = ({ values }, index) => values[index];\n/* istanbul ignore next */\n/** @ignore */\nconst getDuration = (data, index) => {\n    switch (data.type.unit) {\n        case TimeUnit.SECOND: return getDurationSecond(data, index);\n        case TimeUnit.MILLISECOND: return getDurationMillisecond(data, index);\n        case TimeUnit.MICROSECOND: return getDurationMicrosecond(data, index);\n        case TimeUnit.NANOSECOND: return getDurationNanosecond(data, index);\n    }\n};\n/** @ignore */\nconst getFixedSizeList = (data, index) => {\n    const { stride, children } = data;\n    const child = children[0];\n    const slice = child.slice(index * stride, stride);\n    return new Vector([slice]);\n};\nGetVisitor.prototype.visitNull = wrapGet(getNull);\nGetVisitor.prototype.visitBool = wrapGet(getBool);\nGetVisitor.prototype.visitInt = wrapGet(getInt);\nGetVisitor.prototype.visitInt8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitInt64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitUint8 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint16 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUint64 = wrapGet(getBigInts);\nGetVisitor.prototype.visitFloat = wrapGet(getFloat);\nGetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);\nGetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);\nGetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);\nGetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);\nGetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);\nGetVisitor.prototype.visitBinary = wrapGet(getBinary);\nGetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);\nGetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);\nGetVisitor.prototype.visitDate = wrapGet(getDate);\nGetVisitor.prototype.visitDateDay = wrapGet(getDateDay);\nGetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);\nGetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);\nGetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);\nGetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);\nGetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);\nGetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);\nGetVisitor.prototype.visitTime = wrapGet(getTime);\nGetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);\nGetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);\nGetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);\nGetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);\nGetVisitor.prototype.visitDecimal = wrapGet(getDecimal);\nGetVisitor.prototype.visitList = wrapGet(getList);\nGetVisitor.prototype.visitStruct = wrapGet(getStruct);\nGetVisitor.prototype.visitUnion = wrapGet(getUnion);\nGetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);\nGetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);\nGetVisitor.prototype.visitDictionary = wrapGet(getDictionary);\nGetVisitor.prototype.visitInterval = wrapGet(getInterval);\nGetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);\nGetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);\nGetVisitor.prototype.visitIntervalMonthDayNano = wrapGet(getIntervalMonthDayNano);\nGetVisitor.prototype.visitDuration = wrapGet(getDuration);\nGetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);\nGetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);\nGetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);\nGetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);\nGetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);\nGetVisitor.prototype.visitMap = wrapGet(getMap);\n/** @ignore */\nexport const instance = new GetVisitor();\n\n//# sourceMappingURL=get.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { valueToString } from '../util/pretty.mjs';\nimport { instance as getVisitor } from '../visitor/get.mjs';\nimport { instance as setVisitor } from '../visitor/set.mjs';\n/** @ignore */ export const kKeys = Symbol.for('keys');\n/** @ignore */ export const kVals = Symbol.for('vals');\n/** @ignore */ export const kKeysAsStrings = Symbol.for('kKeysAsStrings');\n/** @ignore */ export const _kKeysAsStrings = Symbol.for('_kKeysAsStrings');\nexport class MapRow {\n    constructor(slice) {\n        this[kKeys] = new Vector([slice.children[0]]).memoize();\n        this[kVals] = slice.children[1];\n        return new Proxy(this, new MapRowProxyHandler());\n    }\n    /** @ignore */\n    get [kKeysAsStrings]() {\n        return this[_kKeysAsStrings] || (this[_kKeysAsStrings] = Array.from(this[kKeys].toArray(), String));\n    }\n    [Symbol.iterator]() {\n        return new MapRowIterator(this[kKeys], this[kVals]);\n    }\n    get size() { return this[kKeys].length; }\n    toArray() { return Object.values(this.toJSON()); }\n    toJSON() {\n        const keys = this[kKeys];\n        const vals = this[kVals];\n        const json = {};\n        for (let i = -1, n = keys.length; ++i < n;) {\n            json[keys.get(i)] = getVisitor.visit(vals, i);\n        }\n        return json;\n    }\n    toString() {\n        return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(', ')}}`;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.toString();\n    }\n}\nclass MapRowIterator {\n    constructor(keys, vals) {\n        this.keys = keys;\n        this.vals = vals;\n        this.keyIndex = 0;\n        this.numKeys = keys.length;\n    }\n    [Symbol.iterator]() { return this; }\n    next() {\n        const i = this.keyIndex;\n        if (i === this.numKeys) {\n            return { done: true, value: null };\n        }\n        this.keyIndex++;\n        return {\n            done: false,\n            value: [\n                this.keys.get(i),\n                getVisitor.visit(this.vals, i),\n            ]\n        };\n    }\n}\n/** @ignore */\nclass MapRowProxyHandler {\n    isExtensible() { return false; }\n    deleteProperty() { return false; }\n    preventExtensions() { return true; }\n    ownKeys(row) {\n        return row[kKeysAsStrings];\n    }\n    has(row, key) {\n        return row[kKeysAsStrings].includes(key);\n    }\n    getOwnPropertyDescriptor(row, key) {\n        const idx = row[kKeysAsStrings].indexOf(key);\n        if (idx !== -1) {\n            return { writable: true, enumerable: true, configurable: true };\n        }\n        return;\n    }\n    get(row, key) {\n        // Look up key in row first\n        if (Reflect.has(row, key)) {\n            return row[key];\n        }\n        const idx = row[kKeysAsStrings].indexOf(key);\n        if (idx !== -1) {\n            const val = getVisitor.visit(Reflect.get(row, kVals), idx);\n            // Cache key/val lookups\n            Reflect.set(row, key, val);\n            return val;\n        }\n    }\n    set(row, key, val) {\n        const idx = row[kKeysAsStrings].indexOf(key);\n        if (idx !== -1) {\n            setVisitor.visit(Reflect.get(row, kVals), idx, val);\n            // Cache key/val lookups\n            return Reflect.set(row, key, val);\n        }\n        else if (Reflect.has(row, key)) {\n            return Reflect.set(row, key, val);\n        }\n        return false;\n    }\n}\nObject.defineProperties(MapRow.prototype, {\n    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },\n    [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },\n    [kVals]: { writable: true, enumerable: false, configurable: false, value: null },\n    [_kKeysAsStrings]: { writable: true, enumerable: false, configurable: false, value: null },\n});\n\n//# sourceMappingURL=map.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { MapRow } from '../row/map.mjs';\nimport { StructRow } from '../row/struct.mjs';\nimport { compareArrayLike } from '../util/buffer.mjs';\n/** @ignore */\nlet tmp;\n/** @ignore */\nexport function clampRange(source, begin, end, then) {\n    // Adjust args similar to Array.prototype.slice. Normalize begin/end to\n    // clamp between 0 and length, and wrap around on negative indices, e.g.\n    // slice(-1, 5) or slice(5, -1)\n    const { length: len = 0 } = source;\n    let lhs = typeof begin !== 'number' ? 0 : begin;\n    let rhs = typeof end !== 'number' ? len : end;\n    // wrap around on negative start/end positions\n    (lhs < 0) && (lhs = ((lhs % len) + len) % len);\n    (rhs < 0) && (rhs = ((rhs % len) + len) % len);\n    // ensure lhs <= rhs\n    (rhs < lhs) && (tmp = lhs, lhs = rhs, rhs = tmp);\n    // ensure rhs <= length\n    (rhs > len) && (rhs = len);\n    return then ? then(source, lhs, rhs) : [lhs, rhs];\n}\n/** @ignore */\nexport const wrapIndex = (index, len) => index < 0 ? (len + index) : index;\nconst isNaNFast = (value) => value !== value;\n/** @ignore */\nexport function createElementComparator(search) {\n    const typeofSearch = typeof search;\n    // Compare primitives\n    if (typeofSearch !== 'object' || search === null) {\n        // Compare NaN\n        if (isNaNFast(search)) {\n            return isNaNFast;\n        }\n        return (value) => value === search;\n    }\n    // Compare Dates\n    if (search instanceof Date) {\n        const valueOfSearch = search.valueOf();\n        return (value) => value instanceof Date ? (value.valueOf() === valueOfSearch) : false;\n    }\n    // Compare TypedArrays\n    if (ArrayBuffer.isView(search)) {\n        return (value) => value ? compareArrayLike(search, value) : false;\n    }\n    // Compare Maps and Rows\n    if (search instanceof Map) {\n        return createMapComparator(search);\n    }\n    // Compare Array-likes\n    if (Array.isArray(search)) {\n        return createArrayLikeComparator(search);\n    }\n    // Compare Vectors\n    if (search instanceof Vector) {\n        return createVectorComparator(search);\n    }\n    return createObjectComparator(search, true);\n    // Compare non-empty Objects\n    // return createObjectComparator(search, search instanceof Proxy);\n}\n/** @ignore */\nfunction createArrayLikeComparator(lhs) {\n    const comparators = [];\n    for (let i = -1, n = lhs.length; ++i < n;) {\n        comparators[i] = createElementComparator(lhs[i]);\n    }\n    return createSubElementsComparator(comparators);\n}\n/** @ignore */\nfunction createMapComparator(lhs) {\n    let i = -1;\n    const comparators = [];\n    for (const v of lhs.values())\n        comparators[++i] = createElementComparator(v);\n    return createSubElementsComparator(comparators);\n}\n/** @ignore */\nfunction createVectorComparator(lhs) {\n    const comparators = [];\n    for (let i = -1, n = lhs.length; ++i < n;) {\n        comparators[i] = createElementComparator(lhs.get(i));\n    }\n    return createSubElementsComparator(comparators);\n}\n/** @ignore */\nfunction createObjectComparator(lhs, allowEmpty = false) {\n    const keys = Object.keys(lhs);\n    // Only compare non-empty Objects\n    if (!allowEmpty && keys.length === 0) {\n        return () => false;\n    }\n    const comparators = [];\n    for (let i = -1, n = keys.length; ++i < n;) {\n        comparators[i] = createElementComparator(lhs[keys[i]]);\n    }\n    return createSubElementsComparator(comparators, keys);\n}\nfunction createSubElementsComparator(comparators, keys) {\n    return (rhs) => {\n        if (!rhs || typeof rhs !== 'object') {\n            return false;\n        }\n        switch (rhs.constructor) {\n            case Array: return compareArray(comparators, rhs);\n            case Map:\n                return compareObject(comparators, rhs, rhs.keys());\n            case MapRow:\n            case StructRow:\n            case Object:\n            case undefined: // support `Object.create(null)` objects\n                return compareObject(comparators, rhs, keys || Object.keys(rhs));\n        }\n        return rhs instanceof Vector ? compareVector(comparators, rhs) : false;\n    };\n}\nfunction compareArray(comparators, arr) {\n    const n = comparators.length;\n    if (arr.length !== n) {\n        return false;\n    }\n    for (let i = -1; ++i < n;) {\n        if (!(comparators[i](arr[i]))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction compareVector(comparators, vec) {\n    const n = comparators.length;\n    if (vec.length !== n) {\n        return false;\n    }\n    for (let i = -1; ++i < n;) {\n        if (!(comparators[i](vec.get(i)))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction compareObject(comparators, obj, keys) {\n    const lKeyItr = keys[Symbol.iterator]();\n    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();\n    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();\n    let i = 0;\n    const n = comparators.length;\n    let rVal = rValItr.next();\n    let lKey = lKeyItr.next();\n    let rKey = rKeyItr.next();\n    for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {\n        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {\n            break;\n        }\n    }\n    if (i === n && lKey.done && rKey.done && rVal.done) {\n        return true;\n    }\n    lKeyItr.return && lKeyItr.return();\n    rKeyItr.return && rKeyItr.return();\n    rValItr.return && rValItr.return();\n    return false;\n}\n\n//# sourceMappingURL=vector.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nexport function getBool(_data, _index, byte, bit) {\n    return (byte & 1 << bit) !== 0;\n}\n/** @ignore */\nexport function getBit(_data, _index, byte, bit) {\n    return (byte & 1 << bit) >> bit;\n}\n/** @ignore */\nexport function setBool(bytes, index, value) {\n    return value ?\n        !!(bytes[index >> 3] |= (1 << (index % 8))) || true :\n        !(bytes[index >> 3] &= ~(1 << (index % 8))) && false;\n}\n/** @ignore */\nexport function truncateBitmap(offset, length, bitmap) {\n    const alignedSize = (bitmap.byteLength + 7) & ~7;\n    if (offset > 0 || bitmap.byteLength < alignedSize) {\n        const bytes = new Uint8Array(alignedSize);\n        // If the offset is a multiple of 8 bits, it's safe to slice the bitmap\n        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) :\n            // Otherwise iterate each bit from the offset and return a new one\n            packBools(new BitIterator(bitmap, offset, length, null, getBool)).subarray(0, alignedSize));\n        return bytes;\n    }\n    return bitmap;\n}\n/** @ignore */\nexport function packBools(values) {\n    const xs = [];\n    let i = 0, bit = 0, byte = 0;\n    for (const value of values) {\n        value && (byte |= 1 << bit);\n        if (++bit === 8) {\n            xs[i++] = byte;\n            byte = bit = 0;\n        }\n    }\n    if (i === 0 || bit > 0) {\n        xs[i++] = byte;\n    }\n    const b = new Uint8Array((xs.length + 7) & ~7);\n    b.set(xs);\n    return b;\n}\n/** @ignore */\nexport class BitIterator {\n    constructor(bytes, begin, length, context, get) {\n        this.bytes = bytes;\n        this.length = length;\n        this.context = context;\n        this.get = get;\n        this.bit = begin % 8;\n        this.byteIndex = begin >> 3;\n        this.byte = bytes[this.byteIndex++];\n        this.index = 0;\n    }\n    next() {\n        if (this.index < this.length) {\n            if (this.bit === 8) {\n                this.bit = 0;\n                this.byte = this.bytes[this.byteIndex++];\n            }\n            return {\n                value: this.get(this.context, this.index++, this.byte, this.bit++)\n            };\n        }\n        return { done: true, value: null };\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n/**\n * Compute the population count (the number of bits set to 1) for a range of bits in a Uint8Array.\n * @param vector The Uint8Array of bits for which to compute the population count.\n * @param lhs The range's left-hand side (or start) bit\n * @param rhs The range's right-hand side (or end) bit\n */\n/** @ignore */\nexport function popcnt_bit_range(data, lhs, rhs) {\n    if (rhs - lhs <= 0) {\n        return 0;\n    }\n    // If the bit range is less than one byte, sum the 1 bits in the bit range\n    if (rhs - lhs < 8) {\n        let sum = 0;\n        for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {\n            sum += bit;\n        }\n        return sum;\n    }\n    // Get the next lowest multiple of 8 from the right hand side\n    const rhsInside = rhs >> 3 << 3;\n    // Get the next highest multiple of 8 from the left hand side\n    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);\n    return (\n    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8\n    popcnt_bit_range(data, lhs, lhsInside) +\n        // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8\n        popcnt_bit_range(data, rhsInside, rhs) +\n        // Get the popcnt of all bits between the left and right hand sides' multiples of 8\n        popcnt_array(data, lhsInside >> 3, (rhsInside - lhsInside) >> 3));\n}\n/** @ignore */\nexport function popcnt_array(arr, byteOffset, byteLength) {\n    let cnt = 0, pos = Math.trunc(byteOffset);\n    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;\n    while (len - pos >= 4) {\n        cnt += popcnt_uint32(view.getUint32(pos));\n        pos += 4;\n    }\n    while (len - pos >= 2) {\n        cnt += popcnt_uint32(view.getUint16(pos));\n        pos += 2;\n    }\n    while (len - pos >= 1) {\n        cnt += popcnt_uint32(view.getUint8(pos));\n        pos += 1;\n    }\n    return cnt;\n}\n/** @ignore */\nexport function popcnt_uint32(uint32) {\n    let i = Math.trunc(uint32);\n    i = i - ((i >>> 1) & 0x55555555);\n    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n    return (((i + (i >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n}\n\n//# sourceMappingURL=bit.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from './vector.mjs';\nimport { BufferType, Type, UnionMode } from './enum.mjs';\nimport { DataType, strideForType } from './type.mjs';\nimport { popcnt_bit_range, truncateBitmap } from './util/bit.mjs';\n/** @ignore */ export const kUnknownNullCount = -1;\n/**\n * Data structure underlying {@link Vector}s. Use the convenience method {@link makeData}.\n */\nexport class Data {\n    get typeId() { return this.type.typeId; }\n    get ArrayType() { return this.type.ArrayType; }\n    get buffers() {\n        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n    }\n    get nullable() {\n        if (this._nullCount !== 0) {\n            const { type } = this;\n            if (DataType.isSparseUnion(type)) {\n                return this.children.some((child) => child.nullable);\n            }\n            else if (DataType.isDenseUnion(type)) {\n                return this.children.some((child) => child.nullable);\n            }\n            return this.nullBitmap && this.nullBitmap.byteLength > 0;\n        }\n        return true;\n    }\n    get byteLength() {\n        let byteLength = 0;\n        const { valueOffsets, values, nullBitmap, typeIds } = this;\n        valueOffsets && (byteLength += valueOffsets.byteLength);\n        values && (byteLength += values.byteLength);\n        nullBitmap && (byteLength += nullBitmap.byteLength);\n        typeIds && (byteLength += typeIds.byteLength);\n        return this.children.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);\n    }\n    get nullCount() {\n        if (DataType.isUnion(this.type)) {\n            return this.children.reduce((nullCount, child) => nullCount + child.nullCount, 0);\n        }\n        let nullCount = this._nullCount;\n        let nullBitmap;\n        if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n            this._nullCount = nullCount = nullBitmap.length === 0 ?\n                // no null bitmap, so all values are valid\n                0 :\n                this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n        }\n        return nullCount;\n    }\n    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {\n        this.type = type;\n        this.children = children;\n        this.dictionary = dictionary;\n        this.offset = Math.floor(Math.max(offset || 0, 0));\n        this.length = Math.floor(Math.max(length || 0, 0));\n        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n        let buffer;\n        if (buffers instanceof Data) {\n            this.stride = buffers.stride;\n            this.values = buffers.values;\n            this.typeIds = buffers.typeIds;\n            this.nullBitmap = buffers.nullBitmap;\n            this.valueOffsets = buffers.valueOffsets;\n        }\n        else {\n            this.stride = strideForType(type);\n            if (buffers) {\n                (buffer = buffers[0]) && (this.valueOffsets = buffer);\n                (buffer = buffers[1]) && (this.values = buffer);\n                (buffer = buffers[2]) && (this.nullBitmap = buffer);\n                (buffer = buffers[3]) && (this.typeIds = buffer);\n            }\n        }\n    }\n    getValid(index) {\n        const { type } = this;\n        if (DataType.isUnion(type)) {\n            const union = type;\n            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];\n            const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index] : index;\n            return child.getValid(indexInChild);\n        }\n        if (this.nullable && this.nullCount > 0) {\n            const pos = this.offset + index;\n            const val = this.nullBitmap[pos >> 3];\n            return (val & (1 << (pos % 8))) !== 0;\n        }\n        return true;\n    }\n    setValid(index, value) {\n        let prev;\n        const { type } = this;\n        if (DataType.isUnion(type)) {\n            const union = type;\n            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];\n            const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index] : index;\n            prev = child.getValid(indexInChild);\n            child.setValid(indexInChild, value);\n        }\n        else {\n            let { nullBitmap } = this;\n            const { offset, length } = this;\n            const idx = offset + index;\n            const mask = 1 << (idx % 8);\n            const byteOffset = idx >> 3;\n            // If no null bitmap, initialize one on the fly\n            if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {\n                nullBitmap = new Uint8Array((((offset + length) + 63) & ~63) >> 3).fill(255);\n                // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n                if (this.nullCount > 0) {\n                    nullBitmap.set(truncateBitmap(offset, length, this.nullBitmap), 0);\n                    Object.assign(this, { nullBitmap });\n                }\n                else {\n                    Object.assign(this, { nullBitmap, _nullCount: 0 });\n                }\n            }\n            const byte = nullBitmap[byteOffset];\n            prev = (byte & mask) !== 0;\n            nullBitmap[byteOffset] = value ? (byte | mask) : (byte & ~mask);\n        }\n        if (prev !== !!value) {\n            // Update `_nullCount` if the new value is different from the old value.\n            this._nullCount = this.nullCount + (value ? -1 : 1);\n        }\n        return value;\n    }\n    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {\n        return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);\n    }\n    slice(offset, length) {\n        const { stride, typeId, children } = this;\n        // +true === 1, +false === 0, so this means\n        // we keep nullCount at 0 if it's already 0,\n        // otherwise set to the invalidated flag -1\n        const nullCount = +(this._nullCount === 0) - 1;\n        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;\n        const buffers = this._sliceBuffers(offset, length, stride, typeId);\n        return this.clone(this.type, this.offset + offset, length, nullCount, buffers, \n        // Don't slice children if we have value offsets (the variable-width types)\n        (children.length === 0 || this.valueOffsets) ? children : this._sliceChildren(children, childStride * offset, childStride * length));\n    }\n    _changeLengthAndBackfillNullBitmap(newLength) {\n        if (this.typeId === Type.Null) {\n            return this.clone(this.type, 0, newLength, 0);\n        }\n        const { length, nullCount } = this;\n        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);\n        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;\n        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n        if (nullCount > 0) {\n            bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n        }\n        const buffers = this.buffers;\n        buffers[BufferType.VALIDITY] = bitmap;\n        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n    _sliceBuffers(offset, length, stride, typeId) {\n        let arr;\n        const { buffers } = this;\n        // If typeIds exist, slice the typeIds buffer\n        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));\n        // If offsets exist, only slice the offsets buffer\n        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||\n            // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n            (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n        return buffers;\n    }\n    _sliceChildren(children, offset, length) {\n        return children.map((child) => child.slice(offset, length));\n    }\n}\nData.prototype.children = Object.freeze([]);\nimport { Visitor } from './visitor.mjs';\nimport { toArrayBufferView, toBigInt64Array, toInt32Array, toUint8Array } from './util/buffer.mjs';\nclass MakeDataVisitor extends Visitor {\n    visit(props) {\n        return this.getVisitFn(props['type']).call(this, props);\n    }\n    visitNull(props) {\n        const { ['type']: type, ['offset']: offset = 0, ['length']: length = 0, } = props;\n        return new Data(type, offset, length, length);\n    }\n    visitBool(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length >> 3, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitInt(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitFloat(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitUtf8(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const data = toUint8Array(props['data']);\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const valueOffsets = toInt32Array(props['valueOffsets']);\n        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);\n    }\n    visitLargeUtf8(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const data = toUint8Array(props['data']);\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const valueOffsets = toBigInt64Array(props['valueOffsets']);\n        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);\n    }\n    visitBinary(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const data = toUint8Array(props['data']);\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const valueOffsets = toInt32Array(props['valueOffsets']);\n        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);\n    }\n    visitLargeBinary(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const data = toUint8Array(props['data']);\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const valueOffsets = toBigInt64Array(props['valueOffsets']);\n        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);\n    }\n    visitFixedSizeBinary(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitDate(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitTimestamp(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitTime(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitDecimal(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitList(props) {\n        const { ['type']: type, ['offset']: offset = 0, ['child']: child } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const valueOffsets = toInt32Array(props['valueOffsets']);\n        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);\n    }\n    visitStruct(props) {\n        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const { length = children.reduce((len, { length }) => Math.max(len, length), 0), nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], children);\n    }\n    visitUnion(props) {\n        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;\n        const typeIds = toArrayBufferView(type.ArrayType, props['typeIds']);\n        const { ['length']: length = typeIds.length, ['nullCount']: nullCount = -1, } = props;\n        if (DataType.isSparseUnion(type)) {\n            return new Data(type, offset, length, nullCount, [undefined, undefined, undefined, typeIds], children);\n        }\n        const valueOffsets = toInt32Array(props['valueOffsets']);\n        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, undefined, typeIds], children);\n    }\n    visitDictionary(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.indices.ArrayType, props['data']);\n        const { ['dictionary']: dictionary = new Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;\n        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap], [], dictionary);\n    }\n    visitInterval(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitDuration(props) {\n        const { ['type']: type, ['offset']: offset = 0 } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const data = toArrayBufferView(type.ArrayType, props['data']);\n        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);\n    }\n    visitFixedSizeList(props) {\n        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const { ['length']: length = child.length / strideForType(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;\n        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], [child]);\n    }\n    visitMap(props) {\n        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;\n        const nullBitmap = toUint8Array(props['nullBitmap']);\n        const valueOffsets = toInt32Array(props['valueOffsets']);\n        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;\n        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);\n    }\n}\nconst makeDataVisitor = new MakeDataVisitor();\nexport function makeData(props) {\n    return makeDataVisitor.visit(props);\n}\n\n//# sourceMappingURL=data.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nexport class ChunkedIterator {\n    constructor(numChunks = 0, getChunkIterator) {\n        this.numChunks = numChunks;\n        this.getChunkIterator = getChunkIterator;\n        this.chunkIndex = 0;\n        this.chunkIterator = this.getChunkIterator(0);\n    }\n    next() {\n        while (this.chunkIndex < this.numChunks) {\n            const next = this.chunkIterator.next();\n            if (!next.done) {\n                return next;\n            }\n            if (++this.chunkIndex < this.numChunks) {\n                this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n            }\n        }\n        return { done: true, value: null };\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n/** @ignore */\nexport function computeChunkNullable(chunks) {\n    return chunks.some(chunk => chunk.nullable);\n}\n/** @ignore */\nexport function computeChunkNullCounts(chunks) {\n    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n/** @ignore */\nexport function computeChunkOffsets(chunks) {\n    return chunks.reduce((offsets, chunk, index) => {\n        offsets[index + 1] = offsets[index] + chunk.length;\n        return offsets;\n    }, new Uint32Array(chunks.length + 1));\n}\n/** @ignore */\nexport function sliceChunks(chunks, offsets, begin, end) {\n    const slices = [];\n    for (let i = -1, n = chunks.length; ++i < n;) {\n        const chunk = chunks[i];\n        const offset = offsets[i];\n        const { length } = chunk;\n        // Stop if the child is to the right of the slice boundary\n        if (offset >= end) {\n            break;\n        }\n        // Exclude children to the left of of the slice boundary\n        if (begin >= offset + length) {\n            continue;\n        }\n        // Include entire child if between both left and right boundaries\n        if (offset >= begin && (offset + length) <= end) {\n            slices.push(chunk);\n            continue;\n        }\n        // Include the child slice that overlaps one of the slice boundaries\n        const from = Math.max(0, begin - offset);\n        const to = Math.min(end - offset, length);\n        slices.push(chunk.slice(from, to - from));\n    }\n    if (slices.length === 0) {\n        slices.push(chunks[0].slice(0, 0));\n    }\n    return slices;\n}\n/** @ignore */\nexport function binarySearch(chunks, offsets, idx, fn) {\n    let lhs = 0, mid = 0, rhs = offsets.length - 1;\n    do {\n        if (lhs >= rhs - 1) {\n            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n        }\n        mid = lhs + (Math.trunc((rhs - lhs) * .5));\n        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);\n    } while (lhs < rhs);\n}\n/** @ignore */\nexport function isChunkedValid(data, index) {\n    return data.getValid(index);\n}\n/** @ignore */\nexport function wrapChunkedCall1(fn) {\n    function chunkedFn(chunks, i, j) { return fn(chunks[i], j); }\n    return function (index) {\n        const data = this.data;\n        return binarySearch(data, this._offsets, index, chunkedFn);\n    };\n}\n/** @ignore */\nexport function wrapChunkedCall2(fn) {\n    let _2;\n    function chunkedFn(chunks, i, j) { return fn(chunks[i], j, _2); }\n    return function (index, value) {\n        const data = this.data;\n        _2 = value;\n        const result = binarySearch(data, this._offsets, index, chunkedFn);\n        _2 = undefined;\n        return result;\n    };\n}\n/** @ignore */\nexport function wrapChunkedIndexOf(indexOf) {\n    let _1;\n    function chunkedIndexOf(data, chunkIndex, fromIndex) {\n        let begin = fromIndex, index = 0, total = 0;\n        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n            const chunk = data[i];\n            if (~(index = indexOf(chunk, _1, begin))) {\n                return total + index;\n            }\n            begin = 0;\n            total += chunk.length;\n        }\n        return -1;\n    }\n    return function (element, offset) {\n        _1 = element;\n        const data = this.data;\n        const result = typeof offset !== 'number'\n            ? chunkedIndexOf(data, 0, 0)\n            : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n        _1 = undefined;\n        return result;\n    };\n}\n\n//# sourceMappingURL=chunk.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Type } from '../enum.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { instance as getVisitor } from './get.mjs';\nimport { getBool, BitIterator } from '../util/bit.mjs';\nimport { createElementComparator } from '../util/vector.mjs';\n/** @ignore */\nexport class IndexOfVisitor extends Visitor {\n}\n/** @ignore */\nfunction nullIndexOf(data, searchElement) {\n    // if you're looking for nulls and the vector isn't empty, we've got 'em!\n    return searchElement === null && data.length > 0 ? 0 : -1;\n}\n/** @ignore */\nfunction indexOfNull(data, fromIndex) {\n    const { nullBitmap } = data;\n    if (!nullBitmap || data.nullCount <= 0) {\n        return -1;\n    }\n    let i = 0;\n    for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool)) {\n        if (!isValid) {\n            return i;\n        }\n        ++i;\n    }\n    return -1;\n}\n/** @ignore */\nfunction indexOfValue(data, searchElement, fromIndex) {\n    if (searchElement === undefined) {\n        return -1;\n    }\n    if (searchElement === null) {\n        switch (data.typeId) {\n            // Unions don't have a nullBitmap of its own, so compare the `searchElement` to `get()`.\n            case Type.Union:\n                break;\n            // Dictionaries do have a nullBitmap, but their dictionary could also have null elements.\n            case Type.Dictionary:\n                break;\n            // All other types can iterate the null bitmap\n            default:\n                return indexOfNull(data, fromIndex);\n        }\n    }\n    const get = getVisitor.getVisitFn(data);\n    const compare = createElementComparator(searchElement);\n    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {\n        if (compare(get(data, i))) {\n            return i;\n        }\n    }\n    return -1;\n}\n/** @ignore */\nfunction indexOfUnion(data, searchElement, fromIndex) {\n    // Unions are special -- they do have a nullBitmap, but so can their children.\n    // If the searchElement is null, we don't know whether it came from the Union's\n    // bitmap or one of its children's. So we don't interrogate the Union's bitmap,\n    // since that will report the wrong index if a child has a null before the Union.\n    const get = getVisitor.getVisitFn(data);\n    const compare = createElementComparator(searchElement);\n    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {\n        if (compare(get(data, i))) {\n            return i;\n        }\n    }\n    return -1;\n}\nIndexOfVisitor.prototype.visitNull = nullIndexOf;\nIndexOfVisitor.prototype.visitBool = indexOfValue;\nIndexOfVisitor.prototype.visitInt = indexOfValue;\nIndexOfVisitor.prototype.visitInt8 = indexOfValue;\nIndexOfVisitor.prototype.visitInt16 = indexOfValue;\nIndexOfVisitor.prototype.visitInt32 = indexOfValue;\nIndexOfVisitor.prototype.visitInt64 = indexOfValue;\nIndexOfVisitor.prototype.visitUint8 = indexOfValue;\nIndexOfVisitor.prototype.visitUint16 = indexOfValue;\nIndexOfVisitor.prototype.visitUint32 = indexOfValue;\nIndexOfVisitor.prototype.visitUint64 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat = indexOfValue;\nIndexOfVisitor.prototype.visitFloat16 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat32 = indexOfValue;\nIndexOfVisitor.prototype.visitFloat64 = indexOfValue;\nIndexOfVisitor.prototype.visitUtf8 = indexOfValue;\nIndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;\nIndexOfVisitor.prototype.visitBinary = indexOfValue;\nIndexOfVisitor.prototype.visitLargeBinary = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;\nIndexOfVisitor.prototype.visitDate = indexOfValue;\nIndexOfVisitor.prototype.visitDateDay = indexOfValue;\nIndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestamp = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTime = indexOfValue;\nIndexOfVisitor.prototype.visitTimeSecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitDecimal = indexOfValue;\nIndexOfVisitor.prototype.visitList = indexOfValue;\nIndexOfVisitor.prototype.visitStruct = indexOfValue;\nIndexOfVisitor.prototype.visitUnion = indexOfValue;\nIndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;\nIndexOfVisitor.prototype.visitDictionary = indexOfValue;\nIndexOfVisitor.prototype.visitInterval = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;\nIndexOfVisitor.prototype.visitIntervalMonthDayNano = indexOfValue;\nIndexOfVisitor.prototype.visitDuration = indexOfValue;\nIndexOfVisitor.prototype.visitDurationSecond = indexOfValue;\nIndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;\nIndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;\nIndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;\nIndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;\nIndexOfVisitor.prototype.visitMap = indexOfValue;\n/** @ignore */\nexport const instance = new IndexOfVisitor();\n\n//# sourceMappingURL=indexof.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Visitor } from '../visitor.mjs';\nimport { Precision } from '../enum.mjs';\nimport { DataType, } from '../type.mjs';\nimport { ChunkedIterator } from '../util/chunk.mjs';\n/** @ignore */\nexport class IteratorVisitor extends Visitor {\n}\n/** @ignore */\nfunction vectorIterator(vector) {\n    const { type } = vector;\n    // Fast case, defer to native iterators if possible\n    if (vector.nullCount === 0 && vector.stride === 1 && (\n    // Don't defer to native iterator for timestamps since Numbers are expected\n    // (DataType.isTimestamp(type)) && type.unit === TimeUnit.MILLISECOND ||\n    (DataType.isInt(type) && type.bitWidth !== 64) ||\n        (DataType.isTime(type) && type.bitWidth !== 64) ||\n        (DataType.isFloat(type) && type.precision !== Precision.HALF))) {\n        return new ChunkedIterator(vector.data.length, (chunkIndex) => {\n            const data = vector.data[chunkIndex];\n            return data.values.subarray(0, data.length)[Symbol.iterator]();\n        });\n    }\n    // Otherwise, iterate manually\n    let offset = 0;\n    return new ChunkedIterator(vector.data.length, (chunkIndex) => {\n        const data = vector.data[chunkIndex];\n        const length = data.length;\n        const inner = vector.slice(offset, offset + length);\n        offset += length;\n        return new VectorIterator(inner);\n    });\n}\n/** @ignore */\nclass VectorIterator {\n    constructor(vector) {\n        this.vector = vector;\n        this.index = 0;\n    }\n    next() {\n        if (this.index < this.vector.length) {\n            return {\n                value: this.vector.get(this.index++)\n            };\n        }\n        return { done: true, value: null };\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nIteratorVisitor.prototype.visitNull = vectorIterator;\nIteratorVisitor.prototype.visitBool = vectorIterator;\nIteratorVisitor.prototype.visitInt = vectorIterator;\nIteratorVisitor.prototype.visitInt8 = vectorIterator;\nIteratorVisitor.prototype.visitInt16 = vectorIterator;\nIteratorVisitor.prototype.visitInt32 = vectorIterator;\nIteratorVisitor.prototype.visitInt64 = vectorIterator;\nIteratorVisitor.prototype.visitUint8 = vectorIterator;\nIteratorVisitor.prototype.visitUint16 = vectorIterator;\nIteratorVisitor.prototype.visitUint32 = vectorIterator;\nIteratorVisitor.prototype.visitUint64 = vectorIterator;\nIteratorVisitor.prototype.visitFloat = vectorIterator;\nIteratorVisitor.prototype.visitFloat16 = vectorIterator;\nIteratorVisitor.prototype.visitFloat32 = vectorIterator;\nIteratorVisitor.prototype.visitFloat64 = vectorIterator;\nIteratorVisitor.prototype.visitUtf8 = vectorIterator;\nIteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;\nIteratorVisitor.prototype.visitBinary = vectorIterator;\nIteratorVisitor.prototype.visitLargeBinary = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;\nIteratorVisitor.prototype.visitDate = vectorIterator;\nIteratorVisitor.prototype.visitDateDay = vectorIterator;\nIteratorVisitor.prototype.visitDateMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestamp = vectorIterator;\nIteratorVisitor.prototype.visitTimestampSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitTime = vectorIterator;\nIteratorVisitor.prototype.visitTimeSecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitDecimal = vectorIterator;\nIteratorVisitor.prototype.visitList = vectorIterator;\nIteratorVisitor.prototype.visitStruct = vectorIterator;\nIteratorVisitor.prototype.visitUnion = vectorIterator;\nIteratorVisitor.prototype.visitDenseUnion = vectorIterator;\nIteratorVisitor.prototype.visitSparseUnion = vectorIterator;\nIteratorVisitor.prototype.visitDictionary = vectorIterator;\nIteratorVisitor.prototype.visitInterval = vectorIterator;\nIteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;\nIteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;\nIteratorVisitor.prototype.visitIntervalMonthDayNano = vectorIterator;\nIteratorVisitor.prototype.visitDuration = vectorIterator;\nIteratorVisitor.prototype.visitDurationSecond = vectorIterator;\nIteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;\nIteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;\nIteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;\nIteratorVisitor.prototype.visitFixedSizeList = vectorIterator;\nIteratorVisitor.prototype.visitMap = vectorIterator;\n/** @ignore */\nexport const instance = new IteratorVisitor();\n\n//# sourceMappingURL=iterator.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Type } from './enum.mjs';\nimport { clampRange, wrapIndex } from './util/vector.mjs';\nimport { DataType, strideForType } from './type.mjs';\nimport { Data, makeData } from './data.mjs';\nimport { isChunkedValid, computeChunkOffsets, computeChunkNullable, computeChunkNullCounts, sliceChunks, wrapChunkedCall1, wrapChunkedCall2, wrapChunkedIndexOf, } from './util/chunk.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nconst visitorsByTypeId = {};\nconst vectorPrototypesByTypeId = {};\n/**\n * Array-like data structure. Use the convenience method {@link makeVector} and {@link vectorFromArray} to create vectors.\n */\nexport class Vector {\n    constructor(input) {\n        var _b, _c, _d;\n        const data = input[0] instanceof Vector\n            ? input.flatMap(x => x.data)\n            : input;\n        if (data.length === 0 || data.some((x) => !(x instanceof Data))) {\n            throw new TypeError('Vector constructor expects an Array of Data instances.');\n        }\n        const type = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.type;\n        switch (data.length) {\n            case 0:\n                this._offsets = [0];\n                break;\n            case 1: {\n                // special case for unchunked vectors\n                const { get, set, indexOf } = visitorsByTypeId[type.typeId];\n                const unchunkedData = data[0];\n                this.isValid = (index) => isChunkedValid(unchunkedData, index);\n                this.get = (index) => get(unchunkedData, index);\n                this.set = (index, value) => set(unchunkedData, index, value);\n                this.indexOf = (index) => indexOf(unchunkedData, index);\n                this._offsets = [0, unchunkedData.length];\n                break;\n            }\n            default:\n                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);\n                this._offsets = computeChunkOffsets(data);\n                break;\n        }\n        this.data = data;\n        this.type = type;\n        this.stride = strideForType(type);\n        this.numChildren = (_d = (_c = type.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;\n        this.length = this._offsets.at(-1);\n    }\n    /**\n     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.\n     */\n    get byteLength() {\n        return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);\n    }\n    /**\n     * Whether this Vector's elements can contain null values.\n     */\n    get nullable() {\n        return computeChunkNullable(this.data);\n    }\n    /**\n     * The number of null elements in this Vector.\n     */\n    get nullCount() {\n        return computeChunkNullCounts(this.data);\n    }\n    /**\n     * The Array or TypedArray constructor used for the JS representation\n     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.\n     */\n    get ArrayType() { return this.type.ArrayType; }\n    /**\n     * The name that should be printed when the Vector is logged in a message.\n     */\n    get [Symbol.toStringTag]() {\n        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;\n    }\n    /**\n     * The name of this Vector.\n     */\n    get VectorName() { return `${Type[this.type.typeId]}Vector`; }\n    /**\n     * Check whether an element is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n    // @ts-ignore\n    isValid(index) { return false; }\n    /**\n     * Get an element value by position.\n     * @param index The index of the element to read.\n     */\n    // @ts-ignore\n    get(index) { return null; }\n    /**\n     * Get an element value by position.\n     * @param index The index of the element to read. A negative index will count back from the last element.\n     */\n    at(index) {\n        return this.get(wrapIndex(index, this.length));\n    }\n    /**\n     * Set an element value by position.\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    // @ts-ignore\n    set(index, value) { return; }\n    /**\n     * Retrieve the index of the first occurrence of a value in an Vector.\n     * @param element The value to locate in the Vector.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    // @ts-ignore\n    indexOf(element, offset) { return -1; }\n    includes(element, offset) {\n        // eslint-disable-next-line unicorn/prefer-includes\n        return this.indexOf(element, offset) > -1;\n    }\n    /**\n     * Iterator for the Vector's elements.\n     */\n    [Symbol.iterator]() {\n        return iteratorVisitor.visit(this);\n    }\n    /**\n     * Combines two or more Vectors of the same type.\n     * @param others Additional Vectors to add to the end of this Vector.\n     */\n    concat(...others) {\n        return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));\n    }\n    /**\n     * Return a zero-copy sub-section of this Vector.\n     * @param start The beginning of the specified portion of the Vector.\n     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.\n     */\n    slice(begin, end) {\n        return new Vector(clampRange(this, begin, end, ({ data, _offsets }, begin, end) => sliceChunks(data, _offsets, begin, end)));\n    }\n    toJSON() { return [...this]; }\n    /**\n     * Return a JavaScript Array or TypedArray of the Vector's elements.\n     *\n     * @note If this Vector contains a single Data chunk and the Vector's type is a\n     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this\n     *  method returns a zero-copy slice of the underlying TypedArray values. If there's\n     *  more than one chunk, the resulting TypedArray will be a copy of the data from each\n     *  chunk's underlying TypedArray values.\n     *\n     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.\n     */\n    toArray() {\n        const { type, data, length, stride, ArrayType } = this;\n        // Fast case, return subarray if possible\n        switch (type.typeId) {\n            case Type.Int:\n            case Type.Float:\n            case Type.Decimal:\n            case Type.Time:\n            case Type.Timestamp:\n                switch (data.length) {\n                    case 0: return new ArrayType();\n                    case 1: return data[0].values.subarray(0, length * stride);\n                    default: return data.reduce((memo, { values, length: chunk_length }) => {\n                        memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);\n                        memo.offset += chunk_length * stride;\n                        return memo;\n                    }, { array: new ArrayType(length * stride), offset: 0 }).array;\n                }\n        }\n        // Otherwise if not primitive, slow copy\n        return [...this];\n    }\n    /**\n     * Returns a string representation of the Vector.\n     *\n     * @returns A string representation of the Vector.\n     */\n    toString() {\n        return `[${[...this].join(',')}]`;\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n    getChild(name) {\n        var _b;\n        return this.getChildAt((_b = this.type.children) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n    getChildAt(index) {\n        if (index > -1 && index < this.numChildren) {\n            return new Vector(this.data.map(({ children }) => children[index]));\n        }\n        return null;\n    }\n    get isMemoized() {\n        if (DataType.isDictionary(this.type)) {\n            return this.data[0].dictionary.isMemoized;\n        }\n        return false;\n    }\n    /**\n     * Adds memoization to the Vector's {@link get} method. For dictionary\n     * vectors, this method return a vector that memoizes only the dictionary\n     * values.\n     *\n     * Memoization is very useful when decoding a value is expensive such as\n     * Utf8. The memoization creates a cache of the size of the Vector and\n     * therefore increases memory usage.\n     *\n     * @returns A new vector that memoizes calls to {@link get}.\n     */\n    memoize() {\n        if (DataType.isDictionary(this.type)) {\n            const dictionary = new MemoizedVector(this.data[0].dictionary);\n            const newData = this.data.map((data) => {\n                const cloned = data.clone();\n                cloned.dictionary = dictionary;\n                return cloned;\n            });\n            return new Vector(newData);\n        }\n        return new MemoizedVector(this);\n    }\n    /**\n     * Returns a vector without memoization of the {@link get} method. If this\n     * vector is not memoized, this method returns this vector.\n     *\n     * @returns A new vector without memoization.\n     */\n    unmemoize() {\n        if (DataType.isDictionary(this.type) && this.isMemoized) {\n            const dictionary = this.data[0].dictionary.unmemoize();\n            const newData = this.data.map((data) => {\n                const newData = data.clone();\n                newData.dictionary = dictionary;\n                return newData;\n            });\n            return new Vector(newData);\n        }\n        return this;\n    }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nVector[_a] = ((proto) => {\n    proto.type = DataType.prototype;\n    proto.data = [];\n    proto.length = 0;\n    proto.stride = 1;\n    proto.numChildren = 0;\n    proto._offsets = new Uint32Array([0]);\n    proto[Symbol.isConcatSpreadable] = true;\n    const typeIds = Object.keys(Type)\n        .map((T) => Type[T])\n        .filter((T) => typeof T === 'number' && T !== Type.NONE);\n    for (const typeId of typeIds) {\n        const get = getVisitor.getVisitFnByTypeId(typeId);\n        const set = setVisitor.getVisitFnByTypeId(typeId);\n        const indexOf = indexOfVisitor.getVisitFnByTypeId(typeId);\n        visitorsByTypeId[typeId] = { get, set, indexOf };\n        vectorPrototypesByTypeId[typeId] = Object.create(proto, {\n            ['isValid']: { value: wrapChunkedCall1(isChunkedValid) },\n            ['get']: { value: wrapChunkedCall1(getVisitor.getVisitFnByTypeId(typeId)) },\n            ['set']: { value: wrapChunkedCall2(setVisitor.getVisitFnByTypeId(typeId)) },\n            ['indexOf']: { value: wrapChunkedIndexOf(indexOfVisitor.getVisitFnByTypeId(typeId)) },\n        });\n    }\n    return 'Vector';\n})(Vector.prototype);\nclass MemoizedVector extends Vector {\n    constructor(vector) {\n        super(vector.data);\n        const get = this.get;\n        const set = this.set;\n        const slice = this.slice;\n        const cache = new Array(this.length);\n        Object.defineProperty(this, 'get', {\n            value(index) {\n                const cachedValue = cache[index];\n                if (cachedValue !== undefined) {\n                    return cachedValue;\n                }\n                const value = get.call(this, index);\n                cache[index] = value;\n                return value;\n            }\n        });\n        Object.defineProperty(this, 'set', {\n            value(index, value) {\n                set.call(this, index, value);\n                cache[index] = value;\n            }\n        });\n        Object.defineProperty(this, 'slice', {\n            value: (begin, end) => new MemoizedVector(slice.call(this, begin, end))\n        });\n        Object.defineProperty(this, 'isMemoized', { value: true });\n        Object.defineProperty(this, 'unmemoize', {\n            value: () => new Vector(this.data)\n        });\n        Object.defineProperty(this, 'memoize', {\n            value: () => this\n        });\n    }\n}\nimport * as dtypes from './type.mjs';\nexport function makeVector(init) {\n    if (init) {\n        if (init instanceof Data) {\n            return new Vector([init]);\n        }\n        if (init instanceof Vector) {\n            return new Vector(init.data);\n        }\n        if (init.type instanceof DataType) {\n            return new Vector([makeData(init)]);\n        }\n        if (Array.isArray(init)) {\n            return new Vector(init.flatMap(v => unwrapInputs(v)));\n        }\n        if (ArrayBuffer.isView(init)) {\n            if (init instanceof DataView) {\n                init = new Uint8Array(init.buffer);\n            }\n            const props = { offset: 0, length: init.length, nullCount: -1, data: init };\n            if (init instanceof Int8Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Int8 }))]);\n            }\n            if (init instanceof Int16Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Int16 }))]);\n            }\n            if (init instanceof Int32Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Int32 }))]);\n            }\n            if (init instanceof BigInt64Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Int64 }))]);\n            }\n            if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Uint8 }))]);\n            }\n            if (init instanceof Uint16Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Uint16 }))]);\n            }\n            if (init instanceof Uint32Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Uint32 }))]);\n            }\n            if (init instanceof BigUint64Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Uint64 }))]);\n            }\n            if (init instanceof Float32Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Float32 }))]);\n            }\n            if (init instanceof Float64Array) {\n                return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new dtypes.Float64 }))]);\n            }\n            throw new Error('Unrecognized input');\n        }\n    }\n    throw new Error('Unrecognized input');\n}\nfunction unwrapInputs(x) {\n    return x instanceof Data ? [x] : (x instanceof Vector ? x.data : makeVector(x).data);\n}\n\n//# sourceMappingURL=vector.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nexport class Block {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    /**\n     * Index to the start of the RecordBlock (note this is past the Message header)\n     */\n    offset() {\n        return this.bb.readInt64(this.bb_pos);\n    }\n    /**\n     * Length of the metadata\n     */\n    metaDataLength() {\n        return this.bb.readInt32(this.bb_pos + 8);\n    }\n    /**\n     * Length of the data (this is aligned so there can be a gap between this and\n     * the metadata).\n     */\n    bodyLength() {\n        return this.bb.readInt64(this.bb_pos + 16);\n    }\n    static sizeOf() {\n        return 24;\n    }\n    static createBlock(builder, offset, metaDataLength, bodyLength) {\n        builder.prep(8, 24);\n        builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));\n        builder.pad(4);\n        builder.writeInt32(metaDataLength);\n        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));\n        return builder.offset();\n    }\n}\n\n//# sourceMappingURL=block.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Block } from './block.mjs';\nimport { KeyValue } from './key-value.mjs';\nimport { MetadataVersion } from './metadata-version.mjs';\nimport { Schema } from './schema.mjs';\n/**\n * ----------------------------------------------------------------------\n * Arrow File metadata\n *\n */\nexport class Footer {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsFooter(bb, obj) {\n        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsFooter(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    version() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion.V1;\n    }\n    schema(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    dictionaries(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;\n    }\n    dictionariesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    recordBatches(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;\n    }\n    recordBatchesLength() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    /**\n     * User-defined metadata\n     */\n    customMetadata(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    customMetadataLength() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static startFooter(builder) {\n        builder.startObject(5);\n    }\n    static addVersion(builder, version) {\n        builder.addFieldInt16(0, version, MetadataVersion.V1);\n    }\n    static addSchema(builder, schemaOffset) {\n        builder.addFieldOffset(1, schemaOffset, 0);\n    }\n    static addDictionaries(builder, dictionariesOffset) {\n        builder.addFieldOffset(2, dictionariesOffset, 0);\n    }\n    static startDictionariesVector(builder, numElems) {\n        builder.startVector(24, numElems, 8);\n    }\n    static addRecordBatches(builder, recordBatchesOffset) {\n        builder.addFieldOffset(3, recordBatchesOffset, 0);\n    }\n    static startRecordBatchesVector(builder, numElems) {\n        builder.startVector(24, numElems, 8);\n    }\n    static addCustomMetadata(builder, customMetadataOffset) {\n        builder.addFieldOffset(4, customMetadataOffset, 0);\n    }\n    static createCustomMetadataVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startCustomMetadataVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endFooter(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static finishFooterBuffer(builder, offset) {\n        builder.finish(offset);\n    }\n    static finishSizePrefixedFooterBuffer(builder, offset) {\n        builder.finish(offset, undefined, true);\n    }\n}\n\n//# sourceMappingURL=footer.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { MetadataVersion } from './enum.mjs';\nimport { DataType } from './type.mjs';\nexport class Schema {\n    constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion.V5) {\n        this.fields = (fields || []);\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(this.fields);\n        }\n        this.dictionaries = dictionaries;\n        this.metadataVersion = metadataVersion;\n    }\n    get [Symbol.toStringTag]() { return 'Schema'; }\n    get names() { return this.fields.map((f) => f.name); }\n    toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n    /**\n     * Construct a new Schema containing only specified fields.\n     *\n     * @param fieldNames Names of fields to keep.\n     * @returns A new Schema of fields matching the specified names.\n     */\n    select(fieldNames) {\n        const names = new Set(fieldNames);\n        const fields = this.fields.filter((f) => names.has(f.name));\n        return new Schema(fields, this.metadata);\n    }\n    /**\n     * Construct a new Schema containing only fields at the specified indices.\n     *\n     * @param fieldIndices Indices of fields to keep.\n     * @returns A new Schema of fields at the specified indices.\n     */\n    selectAt(fieldIndices) {\n        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);\n        return new Schema(fields, this.metadata);\n    }\n    assign(...args) {\n        const other = (args[0] instanceof Schema\n            ? args[0]\n            : Array.isArray(args[0])\n                ? new Schema(args[0])\n                : new Schema(args));\n        const curFields = [...this.fields];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        });\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n        return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n    }\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nSchema.prototype.fields = null;\nSchema.prototype.metadata = null;\nSchema.prototype.dictionaries = null;\nexport class Field {\n    /** @nocollapse */\n    static new(...args) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field(`${name}`, type, nullable, metadata);\n    }\n    constructor(name, type, nullable = false, metadata) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n    get typeId() { return this.type.typeId; }\n    get [Symbol.toStringTag]() { return 'Field'; }\n    toString() { return `${this.name}: ${this.type}`; }\n    clone(...args) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({ name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0]);\n        return Field.new(name, type, nullable, metadata);\n    }\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nField.prototype.type = null;\nField.prototype.name = null;\nField.prototype.nullable = null;\nField.prototype.metadata = null;\n/** @ignore */\nfunction mergeMaps(m1, m2) {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n/** @ignore */\nfunction generateDictionaryMap(fields, dictionaries = new Map()) {\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            }\n            else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n    return dictionaries;\n}\n\n//# sourceMappingURL=schema.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Block as _Block } from '../../fb/block.mjs';\nimport { Footer as _Footer } from '../../fb/footer.mjs';\nimport * as flatbuffers from 'flatbuffers';\nvar Builder = flatbuffers.Builder;\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { Schema } from '../../schema.mjs';\nimport { MetadataVersion } from '../../enum.mjs';\nimport { toUint8Array } from '../../util/buffer.mjs';\nimport { bigIntToNumber } from '../../util/bigint.mjs';\n/** @ignore */\nclass Footer_ {\n    /** @nocollapse */\n    static decode(buf) {\n        buf = new ByteBuffer(toUint8Array(buf));\n        const footer = _Footer.getRootAsFooter(buf);\n        const schema = Schema.decode(footer.schema(), new Map(), footer.version());\n        return new OffHeapFooter(schema, footer);\n    }\n    /** @nocollapse */\n    static encode(footer) {\n        const b = new Builder();\n        const schemaOffset = Schema.encode(b, footer.schema);\n        _Footer.startRecordBatchesVector(b, footer.numRecordBatches);\n        for (const rb of [...footer.recordBatches()].slice().reverse()) {\n            FileBlock.encode(b, rb);\n        }\n        const recordBatchesOffset = b.endVector();\n        _Footer.startDictionariesVector(b, footer.numDictionaries);\n        for (const db of [...footer.dictionaryBatches()].slice().reverse()) {\n            FileBlock.encode(b, db);\n        }\n        const dictionaryBatchesOffset = b.endVector();\n        _Footer.startFooter(b);\n        _Footer.addSchema(b, schemaOffset);\n        _Footer.addVersion(b, MetadataVersion.V5);\n        _Footer.addRecordBatches(b, recordBatchesOffset);\n        _Footer.addDictionaries(b, dictionaryBatchesOffset);\n        _Footer.finishFooterBuffer(b, _Footer.endFooter(b));\n        return b.asUint8Array();\n    }\n    get numRecordBatches() { return this._recordBatches.length; }\n    get numDictionaries() { return this._dictionaryBatches.length; }\n    constructor(schema, version = MetadataVersion.V5, recordBatches, dictionaryBatches) {\n        this.schema = schema;\n        this.version = version;\n        recordBatches && (this._recordBatches = recordBatches);\n        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);\n    }\n    *recordBatches() {\n        for (let block, i = -1, n = this.numRecordBatches; ++i < n;) {\n            if (block = this.getRecordBatch(i)) {\n                yield block;\n            }\n        }\n    }\n    *dictionaryBatches() {\n        for (let block, i = -1, n = this.numDictionaries; ++i < n;) {\n            if (block = this.getDictionaryBatch(i)) {\n                yield block;\n            }\n        }\n    }\n    getRecordBatch(index) {\n        return index >= 0\n            && index < this.numRecordBatches\n            && this._recordBatches[index] || null;\n    }\n    getDictionaryBatch(index) {\n        return index >= 0\n            && index < this.numDictionaries\n            && this._dictionaryBatches[index] || null;\n    }\n}\nexport { Footer_ as Footer };\n/** @ignore */\nclass OffHeapFooter extends Footer_ {\n    get numRecordBatches() { return this._footer.recordBatchesLength(); }\n    get numDictionaries() { return this._footer.dictionariesLength(); }\n    constructor(schema, _footer) {\n        super(schema, _footer.version());\n        this._footer = _footer;\n    }\n    getRecordBatch(index) {\n        if (index >= 0 && index < this.numRecordBatches) {\n            const fileBlock = this._footer.recordBatches(index);\n            if (fileBlock) {\n                return FileBlock.decode(fileBlock);\n            }\n        }\n        return null;\n    }\n    getDictionaryBatch(index) {\n        if (index >= 0 && index < this.numDictionaries) {\n            const fileBlock = this._footer.dictionaries(index);\n            if (fileBlock) {\n                return FileBlock.decode(fileBlock);\n            }\n        }\n        return null;\n    }\n}\n/** @ignore */\nexport class FileBlock {\n    /** @nocollapse */\n    static decode(block) {\n        return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());\n    }\n    /** @nocollapse */\n    static encode(b, fileBlock) {\n        const { metaDataLength } = fileBlock;\n        const offset = BigInt(fileBlock.offset);\n        const bodyLength = BigInt(fileBlock.bodyLength);\n        return _Block.createBlock(b, offset, metaDataLength, bodyLength);\n    }\n    constructor(metaDataLength, bodyLength, offset) {\n        this.metaDataLength = metaDataLength;\n        this.offset = bigIntToNumber(offset);\n        this.bodyLength = bigIntToNumber(bodyLength);\n    }\n}\n\n//# sourceMappingURL=file.mjs.map\n","// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { KeyValue } from './key-value.mjs';\nimport { MessageHeader } from './message-header.mjs';\nimport { MetadataVersion } from './metadata-version.mjs';\nexport class Message {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsMessage(bb, obj) {\n        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsMessage(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    version() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion.V1;\n    }\n    headerType() {\n        const offset = this.bb.__offset(this.bb_pos, 6);\n        return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader.NONE;\n    }\n    header(obj) {\n        const offset = this.bb.__offset(this.bb_pos, 8);\n        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;\n    }\n    bodyLength() {\n        const offset = this.bb.__offset(this.bb_pos, 10);\n        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');\n    }\n    customMetadata(index, obj) {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n    }\n    customMetadataLength() {\n        const offset = this.bb.__offset(this.bb_pos, 12);\n        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    static startMessage(builder) {\n        builder.startObject(5);\n    }\n    static addVersion(builder, version) {\n        builder.addFieldInt16(0, version, MetadataVersion.V1);\n    }\n    static addHeaderType(builder, headerType) {\n        builder.addFieldInt8(1, headerType, MessageHeader.NONE);\n    }\n    static addHeader(builder, headerOffset) {\n        builder.addFieldOffset(2, headerOffset, 0);\n    }\n    static addBodyLength(builder, bodyLength) {\n        builder.addFieldInt64(3, bodyLength, BigInt('0'));\n    }\n    static addCustomMetadata(builder, customMetadataOffset) {\n        builder.addFieldOffset(4, customMetadataOffset, 0);\n    }\n    static createCustomMetadataVector(builder, data) {\n        builder.startVector(4, data.length, 4);\n        for (let i = data.length - 1; i >= 0; i--) {\n            builder.addOffset(data[i]);\n        }\n        return builder.endVector();\n    }\n    static startCustomMetadataVector(builder, numElems) {\n        builder.startVector(4, numElems, 4);\n    }\n    static endMessage(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static finishMessageBuffer(builder, offset) {\n        builder.finish(offset);\n    }\n    static finishSizePrefixedMessageBuffer(builder, offset) {\n        builder.finish(offset, undefined, true);\n    }\n    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {\n        Message.startMessage(builder);\n        Message.addVersion(builder, version);\n        Message.addHeaderType(builder, headerType);\n        Message.addHeader(builder, headerOffset);\n        Message.addBodyLength(builder, bodyLength);\n        Message.addCustomMetadata(builder, customMetadataOffset);\n        return Message.endMessage(builder);\n    }\n}\n\n//# sourceMappingURL=message.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Visitor } from '../visitor.mjs';\nimport { Null } from '../fb/null.mjs';\nimport { Int } from '../fb/int.mjs';\nimport { FloatingPoint } from '../fb/floating-point.mjs';\nimport { Binary } from '../fb/binary.mjs';\nimport { LargeBinary } from '../fb/large-binary.mjs';\nimport { Bool } from '../fb/bool.mjs';\nimport { Utf8 } from '../fb/utf8.mjs';\nimport { LargeUtf8 } from '../fb/large-utf8.mjs';\nimport { Decimal } from '../fb/decimal.mjs';\nimport { Date } from '../fb/date.mjs';\nimport { Time } from '../fb/time.mjs';\nimport { Timestamp } from '../fb/timestamp.mjs';\nimport { Interval } from '../fb/interval.mjs';\nimport { Duration } from '../fb/duration.mjs';\nimport { List } from '../fb/list.mjs';\nimport { Struct_ as Struct } from '../fb/struct-.mjs';\nimport { Union } from '../fb/union.mjs';\nimport { DictionaryEncoding } from '../fb/dictionary-encoding.mjs';\nimport { FixedSizeBinary } from '../fb/fixed-size-binary.mjs';\nimport { FixedSizeList } from '../fb/fixed-size-list.mjs';\nimport { Map as Map_ } from '../fb/map.mjs';\n/** @ignore */\nexport class TypeAssembler extends Visitor {\n    visit(node, builder) {\n        return (node == null || builder == null) ? undefined : super.visit(node, builder);\n    }\n    visitNull(_node, b) {\n        Null.startNull(b);\n        return Null.endNull(b);\n    }\n    visitInt(node, b) {\n        Int.startInt(b);\n        Int.addBitWidth(b, node.bitWidth);\n        Int.addIsSigned(b, node.isSigned);\n        return Int.endInt(b);\n    }\n    visitFloat(node, b) {\n        FloatingPoint.startFloatingPoint(b);\n        FloatingPoint.addPrecision(b, node.precision);\n        return FloatingPoint.endFloatingPoint(b);\n    }\n    visitBinary(_node, b) {\n        Binary.startBinary(b);\n        return Binary.endBinary(b);\n    }\n    visitLargeBinary(_node, b) {\n        LargeBinary.startLargeBinary(b);\n        return LargeBinary.endLargeBinary(b);\n    }\n    visitBool(_node, b) {\n        Bool.startBool(b);\n        return Bool.endBool(b);\n    }\n    visitUtf8(_node, b) {\n        Utf8.startUtf8(b);\n        return Utf8.endUtf8(b);\n    }\n    visitLargeUtf8(_node, b) {\n        LargeUtf8.startLargeUtf8(b);\n        return LargeUtf8.endLargeUtf8(b);\n    }\n    visitDecimal(node, b) {\n        Decimal.startDecimal(b);\n        Decimal.addScale(b, node.scale);\n        Decimal.addPrecision(b, node.precision);\n        Decimal.addBitWidth(b, node.bitWidth);\n        return Decimal.endDecimal(b);\n    }\n    visitDate(node, b) {\n        Date.startDate(b);\n        Date.addUnit(b, node.unit);\n        return Date.endDate(b);\n    }\n    visitTime(node, b) {\n        Time.startTime(b);\n        Time.addUnit(b, node.unit);\n        Time.addBitWidth(b, node.bitWidth);\n        return Time.endTime(b);\n    }\n    visitTimestamp(node, b) {\n        const timezone = (node.timezone && b.createString(node.timezone)) || undefined;\n        Timestamp.startTimestamp(b);\n        Timestamp.addUnit(b, node.unit);\n        if (timezone !== undefined) {\n            Timestamp.addTimezone(b, timezone);\n        }\n        return Timestamp.endTimestamp(b);\n    }\n    visitInterval(node, b) {\n        Interval.startInterval(b);\n        Interval.addUnit(b, node.unit);\n        return Interval.endInterval(b);\n    }\n    visitDuration(node, b) {\n        Duration.startDuration(b);\n        Duration.addUnit(b, node.unit);\n        return Duration.endDuration(b);\n    }\n    visitList(_node, b) {\n        List.startList(b);\n        return List.endList(b);\n    }\n    visitStruct(_node, b) {\n        Struct.startStruct_(b);\n        return Struct.endStruct_(b);\n    }\n    visitUnion(node, b) {\n        Union.startTypeIdsVector(b, node.typeIds.length);\n        const typeIds = Union.createTypeIdsVector(b, node.typeIds);\n        Union.startUnion(b);\n        Union.addMode(b, node.mode);\n        Union.addTypeIds(b, typeIds);\n        return Union.endUnion(b);\n    }\n    visitDictionary(node, b) {\n        const indexType = this.visit(node.indices, b);\n        DictionaryEncoding.startDictionaryEncoding(b);\n        DictionaryEncoding.addId(b, BigInt(node.id));\n        DictionaryEncoding.addIsOrdered(b, node.isOrdered);\n        if (indexType !== undefined) {\n            DictionaryEncoding.addIndexType(b, indexType);\n        }\n        return DictionaryEncoding.endDictionaryEncoding(b);\n    }\n    visitFixedSizeBinary(node, b) {\n        FixedSizeBinary.startFixedSizeBinary(b);\n        FixedSizeBinary.addByteWidth(b, node.byteWidth);\n        return FixedSizeBinary.endFixedSizeBinary(b);\n    }\n    visitFixedSizeList(node, b) {\n        FixedSizeList.startFixedSizeList(b);\n        FixedSizeList.addListSize(b, node.listSize);\n        return FixedSizeList.endFixedSizeList(b);\n    }\n    visitMap(node, b) {\n        Map_.startMap(b);\n        Map_.addKeysSorted(b, node.keysSorted);\n        return Map_.endMap(b);\n    }\n}\n/** @ignore */\nexport const instance = new TypeAssembler();\n\n//# sourceMappingURL=typeassembler.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Schema, Field } from '../../schema.mjs';\nimport { Dictionary, Utf8, LargeUtf8, Binary, LargeBinary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct, Union, Bool, Null, Int, Float, Date_, Time, Interval, Timestamp, Int32, Duration, } from '../../type.mjs';\nimport { DictionaryBatch, RecordBatch, FieldNode, BufferRegion } from './message.mjs';\nimport { TimeUnit, Precision, IntervalUnit, UnionMode, DateUnit } from '../../enum.mjs';\n/** @ignore */\nexport function schemaFromJSON(_schema, dictionaries = new Map()) {\n    return new Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema['metadata']), dictionaries);\n}\n/** @ignore */\nexport function recordBatchFromJSON(b) {\n    return new RecordBatch(b['count'], fieldNodesFromJSON(b['columns']), buffersFromJSON(b['columns']), null);\n}\n/** @ignore */\nexport function dictionaryBatchFromJSON(b) {\n    return new DictionaryBatch(recordBatchFromJSON(b['data']), b['id'], b['isDelta']);\n}\n/** @ignore */\nfunction schemaFieldsFromJSON(_schema, dictionaries) {\n    return (_schema['fields'] || []).filter(Boolean).map((f) => Field.fromJSON(f, dictionaries));\n}\n/** @ignore */\nfunction fieldChildrenFromJSON(_field, dictionaries) {\n    return (_field['children'] || []).filter(Boolean).map((f) => Field.fromJSON(f, dictionaries));\n}\n/** @ignore */\nfunction fieldNodesFromJSON(xs) {\n    return (xs || []).reduce((fieldNodes, column) => [\n        ...fieldNodes,\n        new FieldNode(column['count'], nullCountFromJSON(column['VALIDITY'])),\n        ...fieldNodesFromJSON(column['children'])\n    ], []);\n}\n/** @ignore */\nfunction buffersFromJSON(xs, buffers = []) {\n    for (let i = -1, n = (xs || []).length; ++i < n;) {\n        const column = xs[i];\n        column['VALIDITY'] && buffers.push(new BufferRegion(buffers.length, column['VALIDITY'].length));\n        column['TYPE_ID'] && buffers.push(new BufferRegion(buffers.length, column['TYPE_ID'].length));\n        column['OFFSET'] && buffers.push(new BufferRegion(buffers.length, column['OFFSET'].length));\n        column['DATA'] && buffers.push(new BufferRegion(buffers.length, column['DATA'].length));\n        buffers = buffersFromJSON(column['children'], buffers);\n    }\n    return buffers;\n}\n/** @ignore */\nfunction nullCountFromJSON(validity) {\n    return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);\n}\n/** @ignore */\nexport function fieldFromJSON(_field, dictionaries) {\n    let id;\n    let keys;\n    let field;\n    let dictMeta;\n    let type;\n    let dictType;\n    // If no dictionary encoding\n    if (!dictionaries || !(dictMeta = _field['dictionary'])) {\n        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));\n        field = new Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['metadata']));\n    }\n    // If dictionary encoded and the first time we've seen this dictionary id, decode\n    // the data type and child fields, then wrap in a Dictionary type and insert the\n    // data type into the dictionary types map.\n    else if (!dictionaries.has(id = dictMeta['id'])) {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new Int32();\n        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));\n        dictType = new Dictionary(type, keys, id, dictMeta['isOrdered']);\n        field = new Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));\n    }\n    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the\n    // data type and wrap in a new Dictionary type and field.\n    else {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new Int32();\n        dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta['isOrdered']);\n        field = new Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));\n    }\n    return field || null;\n}\n/** @ignore */\nfunction customMetadataFromJSON(metadata = []) {\n    return new Map(metadata.map(({ key, value }) => [key, value]));\n}\n/** @ignore */\nfunction indexTypeFromJSON(_type) {\n    return new Int(_type['isSigned'], _type['bitWidth']);\n}\n/** @ignore */\nfunction typeFromJSON(f, children) {\n    const typeId = f['type']['name'];\n    switch (typeId) {\n        case 'NONE': return new Null();\n        case 'null': return new Null();\n        case 'binary': return new Binary();\n        case 'largebinary': return new LargeBinary();\n        case 'utf8': return new Utf8();\n        case 'largeutf8': return new LargeUtf8();\n        case 'bool': return new Bool();\n        case 'list': return new List((children || [])[0]);\n        case 'struct': return new Struct(children || []);\n        case 'struct_': return new Struct(children || []);\n    }\n    switch (typeId) {\n        case 'int': {\n            const t = f['type'];\n            return new Int(t['isSigned'], t['bitWidth']);\n        }\n        case 'floatingpoint': {\n            const t = f['type'];\n            return new Float(Precision[t['precision']]);\n        }\n        case 'decimal': {\n            const t = f['type'];\n            return new Decimal(t['scale'], t['precision'], t['bitWidth']);\n        }\n        case 'date': {\n            const t = f['type'];\n            return new Date_(DateUnit[t['unit']]);\n        }\n        case 'time': {\n            const t = f['type'];\n            return new Time(TimeUnit[t['unit']], t['bitWidth']);\n        }\n        case 'timestamp': {\n            const t = f['type'];\n            return new Timestamp(TimeUnit[t['unit']], t['timezone']);\n        }\n        case 'interval': {\n            const t = f['type'];\n            return new Interval(IntervalUnit[t['unit']]);\n        }\n        case 'duration': {\n            const t = f['type'];\n            return new Duration(TimeUnit[t['unit']]);\n        }\n        case 'union': {\n            const t = f['type'];\n            const [m, ...ms] = (t['mode'] + '').toLowerCase();\n            const mode = (m.toUpperCase() + ms.join(''));\n            return new Union(UnionMode[mode], (t['typeIds'] || []), children || []);\n        }\n        case 'fixedsizebinary': {\n            const t = f['type'];\n            return new FixedSizeBinary(t['byteWidth']);\n        }\n        case 'fixedsizelist': {\n            const t = f['type'];\n            return new FixedSizeList(t['listSize'], (children || [])[0]);\n        }\n        case 'map': {\n            const t = f['type'];\n            return new Map_((children || [])[0], t['keysSorted']);\n        }\n    }\n    throw new Error(`Unrecognized type: \"${typeId}\"`);\n}\n\n//# sourceMappingURL=json.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport * as flatbuffers from 'flatbuffers';\nimport { Schema as _Schema } from '../../fb/schema.mjs';\nimport { Int as _Int } from '../../fb/int.mjs';\nimport { RecordBatch as _RecordBatch } from '../../fb/record-batch.mjs';\nimport { DictionaryBatch as _DictionaryBatch } from '../../fb/dictionary-batch.mjs';\nimport { Buffer as _Buffer } from '../../fb/buffer.mjs';\nimport { Field as _Field } from '../../fb/field.mjs';\nimport { FieldNode as _FieldNode } from '../../fb/field-node.mjs';\nimport { Type } from '../../fb/type.mjs';\nimport { KeyValue as _KeyValue } from '../../fb/key-value.mjs';\nimport { Endianness as _Endianness } from '../../fb/endianness.mjs';\nimport { FloatingPoint as _FloatingPoint } from '../../fb/floating-point.mjs';\nimport { Decimal as _Decimal } from '../../fb/decimal.mjs';\nimport { Date as _Date } from '../../fb/date.mjs';\nimport { Time as _Time } from '../../fb/time.mjs';\nimport { Timestamp as _Timestamp } from '../../fb/timestamp.mjs';\nimport { Interval as _Interval } from '../../fb/interval.mjs';\nimport { Duration as _Duration } from '../../fb/duration.mjs';\nimport { Union as _Union } from '../../fb/union.mjs';\nimport { FixedSizeBinary as _FixedSizeBinary } from '../../fb/fixed-size-binary.mjs';\nimport { FixedSizeList as _FixedSizeList } from '../../fb/fixed-size-list.mjs';\nimport { Map as _Map } from '../../fb/map.mjs';\nimport { Message as _Message } from '../../fb/message.mjs';\nimport { BodyCompression as _BodyCompression } from '../../fb/body-compression.mjs';\nimport { BodyCompressionMethod as _BodyCompressionMethod } from '../../fb/body-compression-method.mjs';\nimport { Schema, Field } from '../../schema.mjs';\nimport { toUint8Array } from '../../util/buffer.mjs';\nimport { bigIntToNumber } from '../../util/bigint.mjs';\nimport { MessageHeader, MetadataVersion } from '../../enum.mjs';\nimport { instance as typeAssembler } from '../../visitor/typeassembler.mjs';\nimport { fieldFromJSON, schemaFromJSON, recordBatchFromJSON, dictionaryBatchFromJSON } from './json.mjs';\nvar Builder = flatbuffers.Builder;\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { DataType, Dictionary, Utf8, LargeUtf8, Binary, LargeBinary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct, Union, Bool, Null, Int, Float, Date_, Time, Interval, Timestamp, Int32, Duration, } from '../../type.mjs';\n/**\n * @ignore\n * @private\n **/\nexport class Message {\n    /** @nocollapse */\n    static fromJSON(msg, headerType) {\n        const message = new Message(0, MetadataVersion.V5, headerType);\n        message._createHeader = messageHeaderFromJSON(msg, headerType);\n        return message;\n    }\n    /** @nocollapse */\n    static decode(buf) {\n        buf = new ByteBuffer(toUint8Array(buf));\n        const _message = _Message.getRootAsMessage(buf);\n        const bodyLength = _message.bodyLength();\n        const version = _message.version();\n        const headerType = _message.headerType();\n        const message = new Message(bodyLength, version, headerType);\n        message._createHeader = decodeMessageHeader(_message, headerType);\n        return message;\n    }\n    /** @nocollapse */\n    static encode(message) {\n        const b = new Builder();\n        let headerOffset = -1;\n        if (message.isSchema()) {\n            headerOffset = Schema.encode(b, message.header());\n        }\n        else if (message.isRecordBatch()) {\n            headerOffset = RecordBatch.encode(b, message.header());\n        }\n        else if (message.isDictionaryBatch()) {\n            headerOffset = DictionaryBatch.encode(b, message.header());\n        }\n        _Message.startMessage(b);\n        _Message.addVersion(b, MetadataVersion.V5);\n        _Message.addHeader(b, headerOffset);\n        _Message.addHeaderType(b, message.headerType);\n        _Message.addBodyLength(b, BigInt(message.bodyLength));\n        _Message.finishMessageBuffer(b, _Message.endMessage(b));\n        return b.asUint8Array();\n    }\n    /** @nocollapse */\n    static from(header, bodyLength = 0) {\n        if (header instanceof Schema) {\n            return new Message(0, MetadataVersion.V5, MessageHeader.Schema, header);\n        }\n        if (header instanceof RecordBatch) {\n            return new Message(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);\n        }\n        if (header instanceof DictionaryBatch) {\n            return new Message(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);\n        }\n        throw new Error(`Unrecognized Message header: ${header}`);\n    }\n    get type() { return this.headerType; }\n    get version() { return this._version; }\n    get headerType() { return this._headerType; }\n    get compression() { return this._compression; }\n    get bodyLength() { return this._bodyLength; }\n    header() { return this._createHeader(); }\n    isSchema() { return this.headerType === MessageHeader.Schema; }\n    isRecordBatch() { return this.headerType === MessageHeader.RecordBatch; }\n    isDictionaryBatch() { return this.headerType === MessageHeader.DictionaryBatch; }\n    constructor(bodyLength, version, headerType, header) {\n        this._version = version;\n        this._headerType = headerType;\n        this.body = new Uint8Array(0);\n        this._compression = header === null || header === void 0 ? void 0 : header.compression;\n        header && (this._createHeader = () => header);\n        this._bodyLength = bigIntToNumber(bodyLength);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class RecordBatch {\n    get nodes() { return this._nodes; }\n    get length() { return this._length; }\n    get buffers() { return this._buffers; }\n    get compression() { return this._compression; }\n    constructor(length, nodes, buffers, compression) {\n        this._nodes = nodes;\n        this._buffers = buffers;\n        this._length = bigIntToNumber(length);\n        this._compression = compression;\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class DictionaryBatch {\n    get id() { return this._id; }\n    get data() { return this._data; }\n    get isDelta() { return this._isDelta; }\n    get length() { return this.data.length; }\n    get nodes() { return this.data.nodes; }\n    get buffers() { return this.data.buffers; }\n    constructor(data, id, isDelta = false) {\n        this._data = data;\n        this._isDelta = isDelta;\n        this._id = bigIntToNumber(id);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class BufferRegion {\n    constructor(offset, length) {\n        this.offset = bigIntToNumber(offset);\n        this.length = bigIntToNumber(length);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class FieldNode {\n    constructor(length, nullCount) {\n        this.length = bigIntToNumber(length);\n        this.nullCount = bigIntToNumber(nullCount);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class BodyCompression {\n    constructor(type, method = _BodyCompressionMethod.BUFFER) {\n        this.type = type;\n        this.method = method;\n    }\n}\n/** @ignore */\nfunction messageHeaderFromJSON(message, type) {\n    return (() => {\n        switch (type) {\n            case MessageHeader.Schema: return Schema.fromJSON(message);\n            case MessageHeader.RecordBatch: return RecordBatch.fromJSON(message);\n            case MessageHeader.DictionaryBatch: return DictionaryBatch.fromJSON(message);\n        }\n        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);\n    });\n}\n/** @ignore */\nfunction decodeMessageHeader(message, type) {\n    return (() => {\n        switch (type) {\n            case MessageHeader.Schema: return Schema.decode(message.header(new _Schema()), new Map(), message.version());\n            case MessageHeader.RecordBatch: return RecordBatch.decode(message.header(new _RecordBatch()), message.version());\n            case MessageHeader.DictionaryBatch: return DictionaryBatch.decode(message.header(new _DictionaryBatch()), message.version());\n        }\n        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);\n    });\n}\nField['encode'] = encodeField;\nField['decode'] = decodeField;\nField['fromJSON'] = fieldFromJSON;\nSchema['encode'] = encodeSchema;\nSchema['decode'] = decodeSchema;\nSchema['fromJSON'] = schemaFromJSON;\nRecordBatch['encode'] = encodeRecordBatch;\nRecordBatch['decode'] = decodeRecordBatch;\nRecordBatch['fromJSON'] = recordBatchFromJSON;\nDictionaryBatch['encode'] = encodeDictionaryBatch;\nDictionaryBatch['decode'] = decodeDictionaryBatch;\nDictionaryBatch['fromJSON'] = dictionaryBatchFromJSON;\nFieldNode['encode'] = encodeFieldNode;\nFieldNode['decode'] = decodeFieldNode;\nBufferRegion['encode'] = encodeBufferRegion;\nBufferRegion['decode'] = decodeBufferRegion;\nBodyCompression['encode'] = encodeBodyCompression;\nBodyCompression['decode'] = decodeBodyCompression;\n/** @ignore */\nfunction decodeSchema(_schema, dictionaries = new Map(), version = MetadataVersion.V5) {\n    const fields = decodeSchemaFields(_schema, dictionaries);\n    return new Schema(fields, decodeCustomMetadata(_schema), dictionaries, version);\n}\n/** @ignore */\nfunction decodeRecordBatch(batch, version = MetadataVersion.V5) {\n    const recordBatch = new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version), decodeBodyCompression(batch.compression()));\n    return recordBatch;\n}\n/** @ignore */\nfunction decodeDictionaryBatch(batch, version = MetadataVersion.V5) {\n    return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());\n}\n/** @ignore */\nfunction decodeBufferRegion(b) {\n    return new BufferRegion(b.offset(), b.length());\n}\n/** @ignore */\nfunction decodeFieldNode(f) {\n    return new FieldNode(f.length(), f.nullCount());\n}\n/** @ignore */\nfunction decodeFieldNodes(batch) {\n    const nodes = [];\n    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n;) {\n        if (f = batch.nodes(i)) {\n            nodes[++j] = FieldNode.decode(f);\n        }\n    }\n    return nodes;\n}\n/** @ignore */\nfunction decodeBuffers(batch, version) {\n    const bufferRegions = [];\n    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n;) {\n        if (b = batch.buffers(i)) {\n            // If this Arrow buffer was written before version 4,\n            // advance the buffer's bb_pos 8 bytes to skip past\n            // the now-removed page_id field\n            if (version < MetadataVersion.V4) {\n                b.bb_pos += (8 * (i + 1));\n            }\n            bufferRegions[++j] = BufferRegion.decode(b);\n        }\n    }\n    return bufferRegions;\n}\n/** @ignore */\nfunction decodeSchemaFields(schema, dictionaries) {\n    const fields = [];\n    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n;) {\n        if (f = schema.fields(i)) {\n            fields[++j] = Field.decode(f, dictionaries);\n        }\n    }\n    return fields;\n}\n/** @ignore */\nfunction decodeFieldChildren(field, dictionaries) {\n    const children = [];\n    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n;) {\n        if (f = field.children(i)) {\n            children[++j] = Field.decode(f, dictionaries);\n        }\n    }\n    return children;\n}\n/** @ignore */\nfunction decodeField(f, dictionaries) {\n    let id;\n    let field;\n    let type;\n    let keys;\n    let dictType;\n    let dictMeta;\n    // If no dictionary encoding\n    if (!dictionaries || !(dictMeta = f.dictionary())) {\n        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));\n        field = new Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));\n    }\n    // If dictionary encoded and the first time we've seen this dictionary id, decode\n    // the data type and child fields, then wrap in a Dictionary type and insert the\n    // data type into the dictionary types map.\n    else if (!dictionaries.has(id = bigIntToNumber(dictMeta.id()))) {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));\n        dictType = new Dictionary(type, keys, id, dictMeta.isOrdered());\n        field = new Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n    }\n    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the\n    // data type and wrap in a new Dictionary type and field.\n    else {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n        dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());\n        field = new Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n    }\n    return field || null;\n}\n/** @ignore */\nfunction decodeCustomMetadata(parent) {\n    const data = new Map();\n    if (parent) {\n        for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;) {\n            if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {\n                data.set(key, entry.value());\n            }\n        }\n    }\n    return data;\n}\n/** @ignore */\nfunction decodeIndexType(_type) {\n    return new Int(_type.isSigned(), _type.bitWidth());\n}\n/** @ignore */\nfunction decodeFieldType(f, children) {\n    const typeId = f.typeType();\n    switch (typeId) {\n        case Type['NONE']: return new Null();\n        case Type['Null']: return new Null();\n        case Type['Binary']: return new Binary();\n        case Type['LargeBinary']: return new LargeBinary();\n        case Type['Utf8']: return new Utf8();\n        case Type['LargeUtf8']: return new LargeUtf8();\n        case Type['Bool']: return new Bool();\n        case Type['List']: return new List((children || [])[0]);\n        case Type['Struct_']: return new Struct(children || []);\n    }\n    switch (typeId) {\n        case Type['Int']: {\n            const t = f.type(new _Int());\n            return new Int(t.isSigned(), t.bitWidth());\n        }\n        case Type['FloatingPoint']: {\n            const t = f.type(new _FloatingPoint());\n            return new Float(t.precision());\n        }\n        case Type['Decimal']: {\n            const t = f.type(new _Decimal());\n            return new Decimal(t.scale(), t.precision(), t.bitWidth());\n        }\n        case Type['Date']: {\n            const t = f.type(new _Date());\n            return new Date_(t.unit());\n        }\n        case Type['Time']: {\n            const t = f.type(new _Time());\n            return new Time(t.unit(), t.bitWidth());\n        }\n        case Type['Timestamp']: {\n            const t = f.type(new _Timestamp());\n            return new Timestamp(t.unit(), t.timezone());\n        }\n        case Type['Interval']: {\n            const t = f.type(new _Interval());\n            return new Interval(t.unit());\n        }\n        case Type['Duration']: {\n            const t = f.type(new _Duration());\n            return new Duration(t.unit());\n        }\n        case Type['Union']: {\n            const t = f.type(new _Union());\n            return new Union(t.mode(), t.typeIdsArray() || [], children || []);\n        }\n        case Type['FixedSizeBinary']: {\n            const t = f.type(new _FixedSizeBinary());\n            return new FixedSizeBinary(t.byteWidth());\n        }\n        case Type['FixedSizeList']: {\n            const t = f.type(new _FixedSizeList());\n            return new FixedSizeList(t.listSize(), (children || [])[0]);\n        }\n        case Type['Map']: {\n            const t = f.type(new _Map());\n            return new Map_((children || [])[0], t.keysSorted());\n        }\n    }\n    throw new Error(`Unrecognized type: \"${Type[typeId]}\" (${typeId})`);\n}\n/** @ignore */\nfunction decodeBodyCompression(b) {\n    return b ? new BodyCompression(b.codec(), b.method()) : null;\n}\n/** @ignore */\nfunction encodeSchema(b, schema) {\n    const fieldOffsets = schema.fields.map((f) => Field.encode(b, f));\n    _Schema.startFieldsVector(b, fieldOffsets.length);\n    const fieldsVectorOffset = _Schema.createFieldsVector(b, fieldOffsets);\n    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 :\n        _Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {\n            const key = b.createString(`${k}`);\n            const val = b.createString(`${v}`);\n            _KeyValue.startKeyValue(b);\n            _KeyValue.addKey(b, key);\n            _KeyValue.addValue(b, val);\n            return _KeyValue.endKeyValue(b);\n        }));\n    _Schema.startSchema(b);\n    _Schema.addFields(b, fieldsVectorOffset);\n    _Schema.addEndianness(b, platformIsLittleEndian ? _Endianness.Little : _Endianness.Big);\n    if (metadataOffset !== -1) {\n        _Schema.addCustomMetadata(b, metadataOffset);\n    }\n    return _Schema.endSchema(b);\n}\n/** @ignore */\nfunction encodeField(b, field) {\n    let nameOffset = -1;\n    let typeOffset = -1;\n    let dictionaryOffset = -1;\n    const type = field.type;\n    let typeId = field.typeId;\n    if (!DataType.isDictionary(type)) {\n        typeOffset = typeAssembler.visit(type, b);\n    }\n    else {\n        typeId = type.dictionary.typeId;\n        dictionaryOffset = typeAssembler.visit(type, b);\n        typeOffset = typeAssembler.visit(type.dictionary, b);\n    }\n    const childOffsets = (type.children || []).map((f) => Field.encode(b, f));\n    const childrenVectorOffset = _Field.createChildrenVector(b, childOffsets);\n    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 :\n        _Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {\n            const key = b.createString(`${k}`);\n            const val = b.createString(`${v}`);\n            _KeyValue.startKeyValue(b);\n            _KeyValue.addKey(b, key);\n            _KeyValue.addValue(b, val);\n            return _KeyValue.endKeyValue(b);\n        }));\n    if (field.name) {\n        nameOffset = b.createString(field.name);\n    }\n    _Field.startField(b);\n    _Field.addType(b, typeOffset);\n    _Field.addTypeType(b, typeId);\n    _Field.addChildren(b, childrenVectorOffset);\n    _Field.addNullable(b, !!field.nullable);\n    if (nameOffset !== -1) {\n        _Field.addName(b, nameOffset);\n    }\n    if (dictionaryOffset !== -1) {\n        _Field.addDictionary(b, dictionaryOffset);\n    }\n    if (metadataOffset !== -1) {\n        _Field.addCustomMetadata(b, metadataOffset);\n    }\n    return _Field.endField(b);\n}\n/** @ignore */\nfunction encodeRecordBatch(b, recordBatch) {\n    const nodes = recordBatch.nodes || [];\n    const buffers = recordBatch.buffers || [];\n    _RecordBatch.startNodesVector(b, nodes.length);\n    for (const n of nodes.slice().reverse())\n        FieldNode.encode(b, n);\n    const nodesVectorOffset = b.endVector();\n    _RecordBatch.startBuffersVector(b, buffers.length);\n    for (const b_ of buffers.slice().reverse())\n        BufferRegion.encode(b, b_);\n    const buffersVectorOffset = b.endVector();\n    let bodyCompressionOffset = null;\n    if (recordBatch.compression !== null) {\n        bodyCompressionOffset = encodeBodyCompression(b, recordBatch.compression);\n    }\n    _RecordBatch.startRecordBatch(b);\n    _RecordBatch.addLength(b, BigInt(recordBatch.length));\n    _RecordBatch.addNodes(b, nodesVectorOffset);\n    _RecordBatch.addBuffers(b, buffersVectorOffset);\n    if (recordBatch.compression !== null && bodyCompressionOffset) {\n        _RecordBatch.addCompression(b, bodyCompressionOffset);\n    }\n    return _RecordBatch.endRecordBatch(b);\n}\n/** @ignore */\nfunction encodeBodyCompression(b, node) {\n    _BodyCompression.startBodyCompression(b);\n    _BodyCompression.addCodec(b, node.type);\n    _BodyCompression.addMethod(b, node.method);\n    return _BodyCompression.endBodyCompression(b);\n}\n/** @ignore */\nfunction encodeDictionaryBatch(b, dictionaryBatch) {\n    const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);\n    _DictionaryBatch.startDictionaryBatch(b);\n    _DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));\n    _DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);\n    _DictionaryBatch.addData(b, dataOffset);\n    return _DictionaryBatch.endDictionaryBatch(b);\n}\n/** @ignore */\nfunction encodeFieldNode(b, node) {\n    return _FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));\n}\n/** @ignore */\nfunction encodeBufferRegion(b, node) {\n    return _Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));\n}\n/** @ignore */\nconst platformIsLittleEndian = (() => {\n    const buffer = new ArrayBuffer(2);\n    new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n    // Int16Array uses the platform's endianness.\n    return new Int16Array(buffer)[0] === 256;\n})();\n\n//# sourceMappingURL=message.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __awaiter } from \"tslib\";\nimport streamAdapters from './adapters.mjs';\n/** @ignore */\nexport const ITERATOR_DONE = Object.freeze({ done: true, value: void (0) });\n/** @ignore */\nexport class ArrowJSON {\n    constructor(_json) {\n        this._json = _json;\n    }\n    get schema() { return this._json['schema']; }\n    get batches() { return (this._json['batches'] || []); }\n    get dictionaries() { return (this._json['dictionaries'] || []); }\n}\n/** @ignore */\nexport class ReadableInterop {\n    tee() {\n        return this._getDOMStream().tee();\n    }\n    pipe(writable, options) {\n        return this._getNodeStream().pipe(writable, options);\n    }\n    pipeTo(writable, options) { return this._getDOMStream().pipeTo(writable, options); }\n    pipeThrough(duplex, options) {\n        return this._getDOMStream().pipeThrough(duplex, options);\n    }\n    _getDOMStream() {\n        return this._DOMStream || (this._DOMStream = this.toDOMStream());\n    }\n    _getNodeStream() {\n        return this._nodeStream || (this._nodeStream = this.toNodeStream());\n    }\n}\n/** @ignore */\nexport class AsyncQueue extends ReadableInterop {\n    constructor() {\n        super();\n        this._values = [];\n        this.resolvers = [];\n        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n    }\n    get closed() { return this._closedPromise; }\n    cancel(reason) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.return(reason); });\n    }\n    write(value) {\n        if (this._ensureOpen()) {\n            this.resolvers.length <= 0\n                ? (this._values.push(value))\n                : (this.resolvers.shift().resolve({ done: false, value }));\n        }\n    }\n    abort(value) {\n        if (this._closedPromiseResolve) {\n            this.resolvers.length <= 0\n                ? (this._error = { error: value })\n                : (this.resolvers.shift().reject({ done: true, value }));\n        }\n    }\n    close() {\n        if (this._closedPromiseResolve) {\n            const { resolvers } = this;\n            while (resolvers.length > 0) {\n                resolvers.shift().resolve(ITERATOR_DONE);\n            }\n            this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n        }\n    }\n    [Symbol.asyncIterator]() { return this; }\n    toDOMStream(options) {\n        return streamAdapters.toDOMStream((this._closedPromiseResolve || this._error)\n            ? this\n            : this._values, options);\n    }\n    toNodeStream(options) {\n        return streamAdapters.toNodeStream((this._closedPromiseResolve || this._error)\n            ? this\n            : this._values, options);\n    }\n    throw(_) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.abort(_); return ITERATOR_DONE; });\n    }\n    return(_) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.close(); return ITERATOR_DONE; });\n    }\n    read(size) {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });\n    }\n    peek(size) {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });\n    }\n    next(..._args) {\n        if (this._values.length > 0) {\n            return Promise.resolve({ done: false, value: this._values.shift() });\n        }\n        else if (this._error) {\n            return Promise.reject({ done: true, value: this._error.error });\n        }\n        else if (!this._closedPromiseResolve) {\n            return Promise.resolve(ITERATOR_DONE);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.resolvers.push({ resolve, reject });\n            });\n        }\n    }\n    _ensureOpen() {\n        if (this._closedPromiseResolve) {\n            return true;\n        }\n        throw new Error(`AsyncQueue is closed`);\n    }\n}\n\n//# sourceMappingURL=interfaces.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncValues, __awaiter } from \"tslib\";\nimport streamAdapters from './adapters.mjs';\nimport { decodeUtf8 } from '../util/utf8.mjs';\nimport { ITERATOR_DONE, AsyncQueue } from './interfaces.mjs';\nimport { toUint8Array, joinUint8Arrays } from '../util/buffer.mjs';\nimport { isPromise, isFetchResponse, isIterable, isAsyncIterable, isReadableDOMStream, isReadableNodeStream } from '../util/compat.mjs';\n/** @ignore */\nexport class AsyncByteQueue extends AsyncQueue {\n    write(value) {\n        if ((value = toUint8Array(value)).byteLength > 0) {\n            return super.write(value);\n        }\n    }\n    toString(sync = false) {\n        return sync\n            ? decodeUtf8(this.toUint8Array(true))\n            : this.toUint8Array(false).then(decodeUtf8);\n    }\n    toUint8Array(sync = false) {\n        return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {\n            var _a, e_1, _b, _c;\n            const buffers = [];\n            let byteLength = 0;\n            try {\n                for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffers.push(chunk);\n                    byteLength += chunk.byteLength;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return joinUint8Arrays(buffers, byteLength)[0];\n        }))();\n    }\n}\n/** @ignore */\nexport class ByteStream {\n    constructor(source) {\n        if (source) {\n            this.source = new ByteStreamSource(streamAdapters.fromIterable(source));\n        }\n    }\n    [Symbol.iterator]() { return this; }\n    next(value) { return this.source.next(value); }\n    throw(value) { return this.source.throw(value); }\n    return(value) { return this.source.return(value); }\n    peek(size) { return this.source.peek(size); }\n    read(size) { return this.source.read(size); }\n}\n/** @ignore */\nexport class AsyncByteStream {\n    constructor(source) {\n        if (source instanceof AsyncByteStream) {\n            this.source = source.source;\n        }\n        else if (source instanceof AsyncByteQueue) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromAsyncIterable(source));\n        }\n        else if (isReadableNodeStream(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromNodeStream(source));\n        }\n        else if (isReadableDOMStream(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromDOMStream(source));\n        }\n        else if (isFetchResponse(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromDOMStream(source.body));\n        }\n        else if (isIterable(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromIterable(source));\n        }\n        else if (isPromise(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromAsyncIterable(source));\n        }\n        else if (isAsyncIterable(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromAsyncIterable(source));\n        }\n    }\n    [Symbol.asyncIterator]() { return this; }\n    next(value) { return this.source.next(value); }\n    throw(value) { return this.source.throw(value); }\n    return(value) { return this.source.return(value); }\n    get closed() { return this.source.closed; }\n    cancel(reason) { return this.source.cancel(reason); }\n    peek(size) { return this.source.peek(size); }\n    read(size) { return this.source.read(size); }\n}\n/** @ignore */\nclass ByteStreamSource {\n    constructor(source) {\n        this.source = source;\n    }\n    cancel(reason) { this.return(reason); }\n    peek(size) { return this.next(size, 'peek').value; }\n    read(size) { return this.next(size, 'read').value; }\n    next(size, cmd = 'read') { return this.source.next({ cmd, size }); }\n    throw(value) { return Object.create((this.source.throw && this.source.throw(value)) || ITERATOR_DONE); }\n    return(value) { return Object.create((this.source.return && this.source.return(value)) || ITERATOR_DONE); }\n}\n/** @ignore */\nclass AsyncByteStreamSource {\n    constructor(source) {\n        this.source = source;\n        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n    }\n    cancel(reason) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.return(reason); });\n    }\n    get closed() { return this._closedPromise; }\n    read(size) {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });\n    }\n    peek(size) {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });\n    }\n    next(size_1) {\n        return __awaiter(this, arguments, void 0, function* (size, cmd = 'read') { return (yield this.source.next({ cmd, size })); });\n    }\n    throw(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = (this.source.throw && (yield this.source.throw(value))) || ITERATOR_DONE;\n            this._closedPromiseResolve && this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n            return Object.create(result);\n        });\n    }\n    return(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = (this.source.return && (yield this.source.return(value))) || ITERATOR_DONE;\n            this._closedPromiseResolve && this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n            return Object.create(result);\n        });\n    }\n}\n\n//# sourceMappingURL=stream.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __awaiter } from \"tslib\";\nimport { ByteStream, AsyncByteStream } from './stream.mjs';\nimport { toUint8Array } from '../util/buffer.mjs';\n/** @ignore */\nexport class RandomAccessFile extends ByteStream {\n    constructor(buffer, byteLength) {\n        super();\n        this.position = 0;\n        this.buffer = toUint8Array(buffer);\n        this.size = byteLength === undefined ? this.buffer.byteLength : byteLength;\n    }\n    readInt32(position) {\n        const { buffer, byteOffset } = this.readAt(position, 4);\n        return new DataView(buffer, byteOffset).getInt32(0, true);\n    }\n    seek(position) {\n        this.position = Math.min(position, this.size);\n        return position < this.size;\n    }\n    read(nBytes) {\n        const { buffer, size, position } = this;\n        if (buffer && position < size) {\n            if (typeof nBytes !== 'number') {\n                nBytes = Number.POSITIVE_INFINITY;\n            }\n            this.position = Math.min(size, position + Math.min(size - position, nBytes));\n            return buffer.subarray(position, this.position);\n        }\n        return null;\n    }\n    readAt(position, nBytes) {\n        const buf = this.buffer;\n        const end = Math.min(this.size, position + nBytes);\n        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);\n    }\n    close() { this.buffer && (this.buffer = null); }\n    throw(value) { this.close(); return { done: true, value }; }\n    return(value) { this.close(); return { done: true, value }; }\n}\n/** @ignore */\nexport class AsyncRandomAccessFile extends AsyncByteStream {\n    constructor(file, byteLength) {\n        super();\n        this.position = 0;\n        this._handle = file;\n        if (typeof byteLength === 'number') {\n            this.size = byteLength;\n        }\n        else {\n            this._pending = (() => __awaiter(this, void 0, void 0, function* () {\n                this.size = (yield file.stat()).size;\n                delete this._pending;\n            }))();\n        }\n    }\n    readInt32(position) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { buffer, byteOffset } = yield this.readAt(position, 4);\n            return new DataView(buffer, byteOffset).getInt32(0, true);\n        });\n    }\n    seek(position) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pending && (yield this._pending);\n            this.position = Math.min(position, this.size);\n            return position < this.size;\n        });\n    }\n    read(nBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pending && (yield this._pending);\n            const { _handle: file, size, position } = this;\n            if (file && position < size) {\n                if (typeof nBytes !== 'number') {\n                    nBytes = Number.POSITIVE_INFINITY;\n                }\n                let pos = position, offset = 0, bytesRead = 0;\n                const end = Math.min(size, pos + Math.min(size - pos, nBytes));\n                const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));\n                while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {\n                    ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));\n                }\n                return buffer;\n            }\n            return null;\n        });\n    }\n    readAt(position, nBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pending && (yield this._pending);\n            const { _handle: file, size } = this;\n            if (file && (position + nBytes) < size) {\n                const end = Math.min(size, position + nBytes);\n                const buffer = new Uint8Array(end - position);\n                return (yield file.read(buffer, 0, nBytes, position)).buffer;\n            }\n            return new Uint8Array(nBytes);\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () { const f = this._handle; this._handle = null; f && (yield f.close()); });\n    }\n    throw(value) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });\n    }\n    return(value) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });\n    }\n}\n\n//# sourceMappingURL=file.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nconst carryBit16 = 1 << 16;\n/** @ignore */\nfunction intAsHex(value) {\n    if (value < 0) {\n        value = 0xFFFFFFFF + value + 1;\n    }\n    return `0x${value.toString(16)}`;\n}\n/** @ignore */\nconst kInt32DecimalDigits = 8;\n/** @ignore */\nconst kPowersOfTen = [\n    1,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000\n];\n/** @ignore */\nexport class BaseInt64 {\n    constructor(buffer) {\n        this.buffer = buffer;\n    }\n    high() { return this.buffer[1]; }\n    low() { return this.buffer[0]; }\n    _times(other) {\n        // Break the left and right numbers into 16 bit chunks\n        // so that we can multiply them without overflow.\n        const L = new Uint32Array([\n            this.buffer[1] >>> 16,\n            this.buffer[1] & 0xFFFF,\n            this.buffer[0] >>> 16,\n            this.buffer[0] & 0xFFFF\n        ]);\n        const R = new Uint32Array([\n            other.buffer[1] >>> 16,\n            other.buffer[1] & 0xFFFF,\n            other.buffer[0] >>> 16,\n            other.buffer[0] & 0xFFFF\n        ]);\n        let product = L[3] * R[3];\n        this.buffer[0] = product & 0xFFFF;\n        let sum = product >>> 16;\n        product = L[2] * R[3];\n        sum += product;\n        product = (L[3] * R[2]) >>> 0;\n        sum += product;\n        this.buffer[0] += sum << 16;\n        this.buffer[1] = (sum >>> 0 < product ? carryBit16 : 0);\n        this.buffer[1] += sum >>> 16;\n        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];\n        this.buffer[1] += (L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0]) << 16;\n        return this;\n    }\n    _plus(other) {\n        const sum = (this.buffer[0] + other.buffer[0]) >>> 0;\n        this.buffer[1] += other.buffer[1];\n        if (sum < (this.buffer[0] >>> 0)) {\n            ++this.buffer[1];\n        }\n        this.buffer[0] = sum;\n    }\n    lessThan(other) {\n        return this.buffer[1] < other.buffer[1] ||\n            (this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0]);\n    }\n    equals(other) {\n        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];\n    }\n    greaterThan(other) {\n        return other.lessThan(this);\n    }\n    hex() {\n        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n    }\n}\n/** @ignore */\nexport class Uint64 extends BaseInt64 {\n    times(other) {\n        this._times(other);\n        return this;\n    }\n    plus(other) {\n        this._plus(other);\n        return this;\n    }\n    /** @nocollapse */\n    static from(val, out_buffer = new Uint32Array(2)) {\n        return Uint64.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);\n    }\n    /** @nocollapse */\n    static fromNumber(num, out_buffer = new Uint32Array(2)) {\n        // Always parse numbers as strings - pulling out high and low bits\n        // directly seems to lose precision sometimes\n        // For example:\n        //     > -4613034156400212000 >>> 0\n        //     721782784\n        // The correct lower 32-bits are 721782752\n        return Uint64.fromString(num.toString(), out_buffer);\n    }\n    /** @nocollapse */\n    static fromString(str, out_buffer = new Uint32Array(2)) {\n        const length = str.length;\n        const out = new Uint64(out_buffer);\n        for (let posn = 0; posn < length;) {\n            const group = kInt32DecimalDigits < length - posn ?\n                kInt32DecimalDigits : length - posn;\n            const chunk = new Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));\n            const multiple = new Uint64(new Uint32Array([kPowersOfTen[group], 0]));\n            out.times(multiple);\n            out.plus(chunk);\n            posn += group;\n        }\n        return out;\n    }\n    /** @nocollapse */\n    static convertArray(values) {\n        const data = new Uint32Array(values.length * 2);\n        for (let i = -1, n = values.length; ++i < n;) {\n            Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n        }\n        return data;\n    }\n    /** @nocollapse */\n    static multiply(left, right) {\n        const rtrn = new Uint64(new Uint32Array(left.buffer));\n        return rtrn.times(right);\n    }\n    /** @nocollapse */\n    static add(left, right) {\n        const rtrn = new Uint64(new Uint32Array(left.buffer));\n        return rtrn.plus(right);\n    }\n}\n/** @ignore */\nexport class Int64 extends BaseInt64 {\n    negate() {\n        this.buffer[0] = ~this.buffer[0] + 1;\n        this.buffer[1] = ~this.buffer[1];\n        if (this.buffer[0] == 0) {\n            ++this.buffer[1];\n        }\n        return this;\n    }\n    times(other) {\n        this._times(other);\n        return this;\n    }\n    plus(other) {\n        this._plus(other);\n        return this;\n    }\n    lessThan(other) {\n        // force high bytes to be signed\n        // eslint-disable-next-line unicorn/prefer-math-trunc\n        const this_high = this.buffer[1] << 0;\n        // eslint-disable-next-line unicorn/prefer-math-trunc\n        const other_high = other.buffer[1] << 0;\n        return this_high < other_high ||\n            (this_high === other_high && this.buffer[0] < other.buffer[0]);\n    }\n    /** @nocollapse */\n    static from(val, out_buffer = new Uint32Array(2)) {\n        return Int64.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);\n    }\n    /** @nocollapse */\n    static fromNumber(num, out_buffer = new Uint32Array(2)) {\n        // Always parse numbers as strings - pulling out high and low bits\n        // directly seems to lose precision sometimes\n        // For example:\n        //     > -4613034156400212000 >>> 0\n        //     721782784\n        // The correct lower 32-bits are 721782752\n        return Int64.fromString(num.toString(), out_buffer);\n    }\n    /** @nocollapse */\n    static fromString(str, out_buffer = new Uint32Array(2)) {\n        // TODO: Assert that out_buffer is 0 and length = 2\n        const negate = str.startsWith('-');\n        const length = str.length;\n        const out = new Int64(out_buffer);\n        for (let posn = negate ? 1 : 0; posn < length;) {\n            const group = kInt32DecimalDigits < length - posn ?\n                kInt32DecimalDigits : length - posn;\n            const chunk = new Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));\n            const multiple = new Int64(new Uint32Array([kPowersOfTen[group], 0]));\n            out.times(multiple);\n            out.plus(chunk);\n            posn += group;\n        }\n        return negate ? out.negate() : out;\n    }\n    /** @nocollapse */\n    static convertArray(values) {\n        const data = new Uint32Array(values.length * 2);\n        for (let i = -1, n = values.length; ++i < n;) {\n            Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n        }\n        return data;\n    }\n    /** @nocollapse */\n    static multiply(left, right) {\n        const rtrn = new Int64(new Uint32Array(left.buffer));\n        return rtrn.times(right);\n    }\n    /** @nocollapse */\n    static add(left, right) {\n        const rtrn = new Int64(new Uint32Array(left.buffer));\n        return rtrn.plus(right);\n    }\n}\n/** @ignore */\nexport class Int128 {\n    constructor(buffer) {\n        this.buffer = buffer;\n        // buffer[3] MSB (high)\n        // buffer[2]\n        // buffer[1]\n        // buffer[0] LSB (low)\n    }\n    high() {\n        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n    }\n    low() {\n        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));\n    }\n    negate() {\n        this.buffer[0] = ~this.buffer[0] + 1;\n        this.buffer[1] = ~this.buffer[1];\n        this.buffer[2] = ~this.buffer[2];\n        this.buffer[3] = ~this.buffer[3];\n        if (this.buffer[0] == 0) {\n            ++this.buffer[1];\n        }\n        if (this.buffer[1] == 0) {\n            ++this.buffer[2];\n        }\n        if (this.buffer[2] == 0) {\n            ++this.buffer[3];\n        }\n        return this;\n    }\n    times(other) {\n        // Break the left and right numbers into 32 bit chunks\n        // so that we can multiply them without overflow.\n        const L0 = new Uint64(new Uint32Array([this.buffer[3], 0]));\n        const L1 = new Uint64(new Uint32Array([this.buffer[2], 0]));\n        const L2 = new Uint64(new Uint32Array([this.buffer[1], 0]));\n        const L3 = new Uint64(new Uint32Array([this.buffer[0], 0]));\n        const R0 = new Uint64(new Uint32Array([other.buffer[3], 0]));\n        const R1 = new Uint64(new Uint32Array([other.buffer[2], 0]));\n        const R2 = new Uint64(new Uint32Array([other.buffer[1], 0]));\n        const R3 = new Uint64(new Uint32Array([other.buffer[0], 0]));\n        let product = Uint64.multiply(L3, R3);\n        this.buffer[0] = product.low();\n        const sum = new Uint64(new Uint32Array([product.high(), 0]));\n        product = Uint64.multiply(L2, R3);\n        sum.plus(product);\n        product = Uint64.multiply(L3, R2);\n        sum.plus(product);\n        this.buffer[1] = sum.low();\n        this.buffer[3] = (sum.lessThan(product) ? 1 : 0);\n        this.buffer[2] = sum.high();\n        const high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n        high.plus(Uint64.multiply(L1, R3))\n            .plus(Uint64.multiply(L2, R2))\n            .plus(Uint64.multiply(L3, R1));\n        this.buffer[3] += Uint64.multiply(L0, R3)\n            .plus(Uint64.multiply(L1, R2))\n            .plus(Uint64.multiply(L2, R1))\n            .plus(Uint64.multiply(L3, R0)).low();\n        return this;\n    }\n    plus(other) {\n        const sums = new Uint32Array(4);\n        sums[3] = (this.buffer[3] + other.buffer[3]) >>> 0;\n        sums[2] = (this.buffer[2] + other.buffer[2]) >>> 0;\n        sums[1] = (this.buffer[1] + other.buffer[1]) >>> 0;\n        sums[0] = (this.buffer[0] + other.buffer[0]) >>> 0;\n        if (sums[0] < (this.buffer[0] >>> 0)) {\n            ++sums[1];\n        }\n        if (sums[1] < (this.buffer[1] >>> 0)) {\n            ++sums[2];\n        }\n        if (sums[2] < (this.buffer[2] >>> 0)) {\n            ++sums[3];\n        }\n        this.buffer[3] = sums[3];\n        this.buffer[2] = sums[2];\n        this.buffer[1] = sums[1];\n        this.buffer[0] = sums[0];\n        return this;\n    }\n    hex() {\n        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n    }\n    /** @nocollapse */\n    static multiply(left, right) {\n        const rtrn = new Int128(new Uint32Array(left.buffer));\n        return rtrn.times(right);\n    }\n    /** @nocollapse */\n    static add(left, right) {\n        const rtrn = new Int128(new Uint32Array(left.buffer));\n        return rtrn.plus(right);\n    }\n    /** @nocollapse */\n    static from(val, out_buffer = new Uint32Array(4)) {\n        return Int128.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);\n    }\n    /** @nocollapse */\n    static fromNumber(num, out_buffer = new Uint32Array(4)) {\n        // Always parse numbers as strings - pulling out high and low bits\n        // directly seems to lose precision sometimes\n        // For example:\n        //     > -4613034156400212000 >>> 0\n        //     721782784\n        // The correct lower 32-bits are 721782752\n        return Int128.fromString(num.toString(), out_buffer);\n    }\n    /** @nocollapse */\n    static fromString(str, out_buffer = new Uint32Array(4)) {\n        // TODO: Assert that out_buffer is 0 and length = 4\n        const negate = str.startsWith('-');\n        const length = str.length;\n        const out = new Int128(out_buffer);\n        for (let posn = negate ? 1 : 0; posn < length;) {\n            const group = kInt32DecimalDigits < length - posn ?\n                kInt32DecimalDigits : length - posn;\n            const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));\n            const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));\n            out.times(multiple);\n            out.plus(chunk);\n            posn += group;\n        }\n        return negate ? out.negate() : out;\n    }\n    /** @nocollapse */\n    static convertArray(values) {\n        // TODO: Distinguish between string and number at compile-time\n        const data = new Uint32Array(values.length * 4);\n        for (let i = -1, n = values.length; ++i < n;) {\n            Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));\n        }\n        return data;\n    }\n}\n\n//# sourceMappingURL=int.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nexport function toIntervalDayTimeInt32Array(objects) {\n    var _a, _b;\n    const length = objects.length;\n    const array = new Int32Array(length * 2);\n    for (let oi = 0, ai = 0; oi < length; oi++) {\n        const interval = objects[oi];\n        array[ai++] = (_a = interval['days']) !== null && _a !== void 0 ? _a : 0;\n        array[ai++] = (_b = interval['milliseconds']) !== null && _b !== void 0 ? _b : 0;\n    }\n    return array;\n}\nexport function toIntervalMonthDayNanoInt32Array(objects) {\n    var _a, _b;\n    const length = objects.length;\n    const data = new Int32Array(length * 4);\n    for (let oi = 0, ai = 0; oi < length; oi++) {\n        const interval = objects[oi];\n        data[ai++] = (_a = interval['months']) !== null && _a !== void 0 ? _a : 0;\n        data[ai++] = (_b = interval['days']) !== null && _b !== void 0 ? _b : 0;\n        const nanoseconds = interval['nanoseconds'];\n        if (nanoseconds) {\n            data[ai++] = Number(BigInt(nanoseconds) & BigInt(0xFFFFFFFF));\n            data[ai++] = Number(BigInt(nanoseconds) >> BigInt(32));\n        }\n        else {\n            ai += 2;\n        }\n    }\n    return data;\n}\nexport function toIntervalDayTimeObjects(array) {\n    const length = array.length;\n    const objects = new Array(length / 2);\n    for (let ai = 0, oi = 0; ai < length; ai += 2) {\n        objects[oi++] = {\n            'days': array[ai],\n            'milliseconds': array[ai + 1]\n        };\n    }\n    return objects;\n}\n/** @ignore */\nexport function toIntervalMonthDayNanoObjects(array, stringifyNano) {\n    const length = array.length;\n    const objects = new Array(length / 4);\n    for (let ai = 0, oi = 0; ai < length; ai += 4) {\n        const nanoseconds = (BigInt(array[ai + 3]) << BigInt(32)) | BigInt(array[ai + 2] >>> 0);\n        objects[oi++] = {\n            'months': array[ai],\n            'days': array[ai + 1],\n            'nanoseconds': (stringifyNano ? `${nanoseconds}` : nanoseconds),\n        };\n    }\n    return objects;\n}\n\n//# sourceMappingURL=interval.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { makeData } from '../data.mjs';\nimport { Field } from '../schema.mjs';\nimport { DataType } from '../type.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { packBools } from '../util/bit.mjs';\nimport { encodeUtf8 } from '../util/utf8.mjs';\nimport { Int64, Int128 } from '../util/int.mjs';\nimport { UnionMode, DateUnit, MetadataVersion, IntervalUnit } from '../enum.mjs';\nimport { toArrayBufferView } from '../util/buffer.mjs';\nimport { toIntervalDayTimeInt32Array, toIntervalMonthDayNanoInt32Array } from '../util/interval.mjs';\n/** @ignore */\nexport class VectorLoader extends Visitor {\n    constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion.V5) {\n        super();\n        this.nodesIndex = -1;\n        this.buffersIndex = -1;\n        this.bytes = bytes;\n        this.nodes = nodes;\n        this.buffers = buffers;\n        this.dictionaries = dictionaries;\n        this.metadataVersion = metadataVersion;\n    }\n    visit(node) {\n        return super.visit(node instanceof Field ? node.type : node);\n    }\n    visitNull(type, { length } = this.nextFieldNode()) {\n        return makeData({ type, length });\n    }\n    visitBool(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitInt(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });\n    }\n    visitLargeUtf8(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });\n    }\n    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });\n    }\n    visitLargeBinary(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });\n    }\n    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitDate(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitTime(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitList(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });\n    }\n    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });\n    }\n    visitUnion(type, { length, nullCount } = this.nextFieldNode()) {\n        if (this.metadataVersion < MetadataVersion.V5) {\n            this.readNullBitmap(type, nullCount);\n        }\n        return type.mode === UnionMode.Sparse\n            ? this.visitSparseUnion(type, { length, nullCount })\n            : this.visitDenseUnion(type, { length, nullCount });\n    }\n    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });\n    }\n    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });\n    }\n    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });\n    }\n    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitDuration(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });\n    }\n    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), 'child': this.visit(type.children[0]) });\n    }\n    visitMap(type, { length, nullCount } = this.nextFieldNode()) {\n        return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });\n    }\n    nextFieldNode() { return this.nodes[++this.nodesIndex]; }\n    nextBufferRange() { return this.buffers[++this.buffersIndex]; }\n    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {\n        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);\n    }\n    readOffsets(type, buffer) { return this.readData(type, buffer); }\n    readTypeIds(type, buffer) { return this.readData(type, buffer); }\n    readData(_type, { length, offset } = this.nextBufferRange()) {\n        return this.bytes.subarray(offset, offset + length);\n    }\n    readDictionary(type) {\n        return this.dictionaries.get(type.id);\n    }\n}\n/** @ignore */\nexport class JSONVectorLoader extends VectorLoader {\n    constructor(sources, nodes, buffers, dictionaries, metadataVersion) {\n        super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);\n        this.sources = sources;\n    }\n    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {\n        return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);\n    }\n    readOffsets(_type, { offset } = this.nextBufferRange()) {\n        return toArrayBufferView(Uint8Array, toArrayBufferView(_type.OffsetArrayType, this.sources[offset]));\n    }\n    readTypeIds(type, { offset } = this.nextBufferRange()) {\n        return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));\n    }\n    readData(type, { offset } = this.nextBufferRange()) {\n        const { sources } = this;\n        if (DataType.isTimestamp(type)) {\n            return toArrayBufferView(Uint8Array, Int64.convertArray(sources[offset]));\n        }\n        else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64 || DataType.isDuration(type)) {\n            return toArrayBufferView(Uint8Array, Int64.convertArray(sources[offset]));\n        }\n        else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {\n            return toArrayBufferView(Uint8Array, Int64.convertArray(sources[offset]));\n        }\n        else if (DataType.isDecimal(type)) {\n            return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));\n        }\n        else if (DataType.isBinary(type) || DataType.isLargeBinary(type) || DataType.isFixedSizeBinary(type)) {\n            return binaryDataFromJSON(sources[offset]);\n        }\n        else if (DataType.isBool(type)) {\n            return packBools(sources[offset]);\n        }\n        else if (DataType.isUtf8(type) || DataType.isLargeUtf8(type)) {\n            return encodeUtf8(sources[offset].join(''));\n        }\n        else if (DataType.isInterval(type)) {\n            switch (type.unit) {\n                case IntervalUnit.DAY_TIME:\n                    return toIntervalDayTimeInt32Array(sources[offset]);\n                case IntervalUnit.MONTH_DAY_NANO:\n                    return toIntervalMonthDayNanoInt32Array(sources[offset]);\n                default:\n                    break;\n            }\n        }\n        return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));\n    }\n}\n/** @ignore */\nfunction binaryDataFromJSON(values) {\n    // \"DATA\": [\"49BC7D5B6C47D2\",\"3F5FB6D9322026\"]\n    // There are definitely more efficient ways to do this... but it gets the\n    // job done.\n    const joined = values.join('');\n    const data = new Uint8Array(joined.length / 2);\n    for (let i = 0; i < joined.length; i += 2) {\n        data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);\n    }\n    return data;\n}\nexport class CompressedVectorLoader extends VectorLoader {\n    constructor(bodyChunks, nodes, buffers, dictionaries, metadataVersion) {\n        super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);\n        this.bodyChunks = bodyChunks;\n    }\n    readData(_type, _buffer = this.nextBufferRange()) {\n        return this.bodyChunks[this.buffersIndex];\n    }\n}\n\n//# sourceMappingURL=vectorloader.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Visitor } from '../visitor.mjs';\n/** @ignore */\nexport class TypeComparator extends Visitor {\n    compareSchemas(schema, other) {\n        return (schema === other) || (other instanceof schema.constructor &&\n            this.compareManyFields(schema.fields, other.fields));\n    }\n    compareManyFields(fields, others) {\n        return (fields === others) || (Array.isArray(fields) &&\n            Array.isArray(others) &&\n            fields.length === others.length &&\n            fields.every((f, i) => this.compareFields(f, others[i])));\n    }\n    compareFields(field, other) {\n        return (field === other) || (other instanceof field.constructor &&\n            field.name === other.name &&\n            field.nullable === other.nullable &&\n            this.visit(field.type, other.type));\n    }\n}\nfunction compareConstructor(type, other) {\n    return other instanceof type.constructor;\n}\nfunction compareAny(type, other) {\n    return (type === other) || compareConstructor(type, other);\n}\nfunction compareInt(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.bitWidth === other.bitWidth &&\n        type.isSigned === other.isSigned);\n}\nfunction compareFloat(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.precision === other.precision);\n}\nfunction compareFixedSizeBinary(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.byteWidth === other.byteWidth);\n}\nfunction compareDate(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.unit === other.unit);\n}\nfunction compareTimestamp(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.unit === other.unit &&\n        type.timezone === other.timezone);\n}\nfunction compareTime(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.unit === other.unit &&\n        type.bitWidth === other.bitWidth);\n}\nfunction compareList(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.children.length === other.children.length &&\n        instance.compareManyFields(type.children, other.children));\n}\nfunction compareStruct(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.children.length === other.children.length &&\n        instance.compareManyFields(type.children, other.children));\n}\nfunction compareUnion(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.mode === other.mode &&\n        type.typeIds.every((x, i) => x === other.typeIds[i]) &&\n        instance.compareManyFields(type.children, other.children));\n}\nfunction compareDictionary(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.id === other.id &&\n        type.isOrdered === other.isOrdered &&\n        instance.visit(type.indices, other.indices) &&\n        instance.visit(type.dictionary, other.dictionary));\n}\nfunction compareInterval(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.unit === other.unit);\n}\nfunction compareDuration(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.unit === other.unit);\n}\nfunction compareFixedSizeList(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.listSize === other.listSize &&\n        type.children.length === other.children.length &&\n        instance.compareManyFields(type.children, other.children));\n}\nfunction compareMap(type, other) {\n    return (type === other) || (compareConstructor(type, other) &&\n        type.keysSorted === other.keysSorted &&\n        type.children.length === other.children.length &&\n        instance.compareManyFields(type.children, other.children));\n}\nTypeComparator.prototype.visitNull = compareAny;\nTypeComparator.prototype.visitBool = compareAny;\nTypeComparator.prototype.visitInt = compareInt;\nTypeComparator.prototype.visitInt8 = compareInt;\nTypeComparator.prototype.visitInt16 = compareInt;\nTypeComparator.prototype.visitInt32 = compareInt;\nTypeComparator.prototype.visitInt64 = compareInt;\nTypeComparator.prototype.visitUint8 = compareInt;\nTypeComparator.prototype.visitUint16 = compareInt;\nTypeComparator.prototype.visitUint32 = compareInt;\nTypeComparator.prototype.visitUint64 = compareInt;\nTypeComparator.prototype.visitFloat = compareFloat;\nTypeComparator.prototype.visitFloat16 = compareFloat;\nTypeComparator.prototype.visitFloat32 = compareFloat;\nTypeComparator.prototype.visitFloat64 = compareFloat;\nTypeComparator.prototype.visitUtf8 = compareAny;\nTypeComparator.prototype.visitLargeUtf8 = compareAny;\nTypeComparator.prototype.visitBinary = compareAny;\nTypeComparator.prototype.visitLargeBinary = compareAny;\nTypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;\nTypeComparator.prototype.visitDate = compareDate;\nTypeComparator.prototype.visitDateDay = compareDate;\nTypeComparator.prototype.visitDateMillisecond = compareDate;\nTypeComparator.prototype.visitTimestamp = compareTimestamp;\nTypeComparator.prototype.visitTimestampSecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;\nTypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;\nTypeComparator.prototype.visitTime = compareTime;\nTypeComparator.prototype.visitTimeSecond = compareTime;\nTypeComparator.prototype.visitTimeMillisecond = compareTime;\nTypeComparator.prototype.visitTimeMicrosecond = compareTime;\nTypeComparator.prototype.visitTimeNanosecond = compareTime;\nTypeComparator.prototype.visitDecimal = compareAny;\nTypeComparator.prototype.visitList = compareList;\nTypeComparator.prototype.visitStruct = compareStruct;\nTypeComparator.prototype.visitUnion = compareUnion;\nTypeComparator.prototype.visitDenseUnion = compareUnion;\nTypeComparator.prototype.visitSparseUnion = compareUnion;\nTypeComparator.prototype.visitDictionary = compareDictionary;\nTypeComparator.prototype.visitInterval = compareInterval;\nTypeComparator.prototype.visitIntervalDayTime = compareInterval;\nTypeComparator.prototype.visitIntervalYearMonth = compareInterval;\nTypeComparator.prototype.visitIntervalMonthDayNano = compareInterval;\nTypeComparator.prototype.visitDuration = compareDuration;\nTypeComparator.prototype.visitDurationSecond = compareDuration;\nTypeComparator.prototype.visitDurationMillisecond = compareDuration;\nTypeComparator.prototype.visitDurationMicrosecond = compareDuration;\nTypeComparator.prototype.visitDurationNanosecond = compareDuration;\nTypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;\nTypeComparator.prototype.visitMap = compareMap;\n/** @ignore */\nexport const instance = new TypeComparator();\nexport function compareSchemas(schema, other) {\n    return instance.compareSchemas(schema, other);\n}\nexport function compareFields(field, other) {\n    return instance.compareFields(field, other);\n}\nexport function compareTypes(type, other) {\n    return instance.visit(type, other);\n}\n\n//# sourceMappingURL=typecomparator.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { makeData } from '../data.mjs';\nimport { Struct } from '../type.mjs';\nimport { RecordBatch } from '../recordbatch.mjs';\n/** @ignore */\nexport function distributeVectorsIntoRecordBatches(schema, vecs) {\n    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));\n}\n/** @ignore */\nfunction uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {\n    const fields = [...schema.fields];\n    const batches = [];\n    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };\n    let numBatches = 0, batchLength = 0;\n    let i = -1;\n    const numColumns = cols.length;\n    let child, children = [];\n    while (memo.numBatches-- > 0) {\n        for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns;) {\n            children[i] = child = cols[i].shift();\n            batchLength = Math.min(batchLength, child ? child.length : batchLength);\n        }\n        if (Number.isFinite(batchLength)) {\n            children = distributeChildren(fields, batchLength, children, cols, memo);\n            if (batchLength > 0) {\n                batches[numBatches++] = makeData({\n                    type: new Struct(fields),\n                    length: batchLength,\n                    nullCount: 0,\n                    children: children.slice()\n                });\n            }\n        }\n    }\n    return [\n        schema = schema.assign(fields),\n        batches.map((data) => new RecordBatch(schema, data))\n    ];\n}\n/** @ignore */\nfunction distributeChildren(fields, batchLength, children, columns, memo) {\n    var _a;\n    const nullBitmapSize = ((batchLength + 63) & ~63) >> 3;\n    for (let i = -1, n = columns.length; ++i < n;) {\n        const child = children[i];\n        const length = child === null || child === void 0 ? void 0 : child.length;\n        if (length >= batchLength) {\n            if (length === batchLength) {\n                children[i] = child;\n            }\n            else {\n                children[i] = child.slice(0, batchLength);\n                memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));\n            }\n        }\n        else {\n            const field = fields[i];\n            fields[i] = field.clone({ nullable: true });\n            children[i] = (_a = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a !== void 0 ? _a : makeData({\n                type: field.type,\n                length: batchLength,\n                nullCount: batchLength,\n                nullBitmap: new Uint8Array(nullBitmapSize)\n            });\n        }\n    }\n    return children;\n}\n\n//# sourceMappingURL=recordbatch.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Type } from './enum.mjs';\nimport { Data, makeData } from './data.mjs';\nimport { vectorFromArray } from './factories.mjs';\nimport { makeVector, Vector } from './vector.mjs';\nimport { Field, Schema } from './schema.mjs';\nimport { Null, Struct } from './type.mjs';\nimport { compareSchemas } from './visitor/typecomparator.mjs';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.mjs';\nimport { isChunkedValid, computeChunkOffsets, computeChunkNullCounts, wrapChunkedCall1, wrapChunkedCall2, wrapChunkedIndexOf, sliceChunks, } from './util/chunk.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { clampRange, wrapIndex } from './util/vector.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\n/**\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\n * {@link tableFromIPC}.\n */\nexport class Table {\n    constructor(...args) {\n        var _b, _c;\n        if (args.length === 0) {\n            this.batches = [];\n            this.schema = new Schema([]);\n            this._offsets = [0];\n            return this;\n        }\n        let schema;\n        let offsets;\n        if (args[0] instanceof Schema) {\n            schema = args.shift();\n        }\n        if (args.at(-1) instanceof Uint32Array) {\n            offsets = args.pop();\n        }\n        const unwrap = (x) => {\n            if (x) {\n                if (x instanceof RecordBatch) {\n                    return [x];\n                }\n                else if (x instanceof Table) {\n                    return x.batches;\n                }\n                else if (x instanceof Data) {\n                    if (x.type instanceof Struct) {\n                        return [new RecordBatch(new Schema(x.type.children), x)];\n                    }\n                }\n                else if (Array.isArray(x)) {\n                    return x.flatMap(v => unwrap(v));\n                }\n                else if (typeof x[Symbol.iterator] === 'function') {\n                    return [...x].flatMap(v => unwrap(v));\n                }\n                else if (typeof x === 'object') {\n                    const keys = Object.keys(x);\n                    const vecs = keys.map((k) => new Vector([x[k]]));\n                    const batchSchema = schema !== null && schema !== void 0 ? schema : new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type, vecs[i].nullable)));\n                    const [, batches] = distributeVectorsIntoRecordBatches(batchSchema, vecs);\n                    return batches.length === 0 ? [new RecordBatch(x)] : batches;\n                }\n            }\n            return [];\n        };\n        const batches = args.flatMap(v => unwrap(v));\n        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new Schema([]);\n        if (!(schema instanceof Schema)) {\n            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n        }\n        for (const batch of batches) {\n            if (!(batch instanceof RecordBatch)) {\n                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n            }\n            if (!compareSchemas(schema, batch.schema)) {\n                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n            }\n        }\n        this.schema = schema;\n        this.batches = batches;\n        this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n    }\n    /**\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n     */\n    get data() { return this.batches.map(({ data }) => data); }\n    /**\n     * The number of columns in this Table.\n     */\n    get numCols() { return this.schema.fields.length; }\n    /**\n     * The number of rows in this Table.\n     */\n    get numRows() {\n        return this.data.reduce((numRows, data) => numRows + data.length, 0);\n    }\n    /**\n     * The number of null rows in this Table.\n     */\n    get nullCount() {\n        if (this._nullCount === -1) {\n            this._nullCount = computeChunkNullCounts(this.data);\n        }\n        return this._nullCount;\n    }\n    /**\n     * Check whether an element is null.\n     *\n     * @param index The index at which to read the validity bitmap.\n     */\n    // @ts-ignore\n    isValid(index) { return false; }\n    /**\n     * Get an element value by position.\n     *\n     * @param index The index of the element to read.\n     */\n    // @ts-ignore\n    get(index) { return null; }\n    /**\n      * Get an element value by position.\n      * @param index The index of the element to read. A negative index will count back from the last element.\n      */\n    // @ts-ignore\n    at(index) {\n        return this.get(wrapIndex(index, this.numRows));\n    }\n    /**\n     * Set an element value by position.\n     *\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    // @ts-ignore\n    set(index, value) { return; }\n    /**\n     * Retrieve the index of the first occurrence of a value in an Vector.\n     *\n     * @param element The value to locate in the Vector.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    // @ts-ignore\n    indexOf(element, offset) { return -1; }\n    /**\n     * Iterator for rows in this Table.\n     */\n    [Symbol.iterator]() {\n        if (this.batches.length > 0) {\n            return iteratorVisitor.visit(new Vector(this.data));\n        }\n        return (new Array(0))[Symbol.iterator]();\n    }\n    /**\n     * Return a JavaScript Array of the Table rows.\n     *\n     * @returns An Array of Table rows.\n     */\n    toArray() {\n        return [...this];\n    }\n    /**\n     * Returns a string representation of the Table rows.\n     *\n     * @returns A string representation of the Table rows.\n     */\n    toString() {\n        return `[\\n  ${this.toArray().join(',\\n  ')}\\n]`;\n    }\n    /**\n     * Combines two or more Tables of the same schema.\n     *\n     * @param others Additional Tables to add to the end of this Tables.\n     */\n    concat(...others) {\n        const schema = this.schema;\n        const data = this.data.concat(others.flatMap(({ data }) => data));\n        return new Table(schema, data.map((data) => new RecordBatch(schema, data)));\n    }\n    /**\n     * Return a zero-copy sub-section of this Table.\n     *\n     * @param begin The beginning of the specified portion of the Table.\n     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n     */\n    slice(begin, end) {\n        const schema = this.schema;\n        [begin, end] = clampRange({ length: this.numRows }, begin, end);\n        const data = sliceChunks(this.data, this._offsets, begin, end);\n        return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     *\n     * @param name The name of the child to retrieve.\n     */\n    getChild(name) {\n        return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     *\n     * @param index The index of the child to retrieve.\n     */\n    getChildAt(index) {\n        if (index > -1 && index < this.schema.fields.length) {\n            const data = this.data.map((data) => data.children[index]);\n            if (data.length === 0) {\n                const { type } = this.schema.fields[index];\n                const empty = makeData({ type, length: 0, nullCount: 0 });\n                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n            }\n            return new Vector(data);\n        }\n        return null;\n    }\n    /**\n     * Sets a child Vector by name.\n     *\n     * @param name The name of the child to overwrite.\n     * @returns A new Table with the supplied child for the specified name.\n     */\n    setChild(name, child) {\n        var _b;\n        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);\n    }\n    setChildAt(index, child) {\n        let schema = this.schema;\n        let batches = [...this.batches];\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice();\n            const field = fields[index].clone({ type: child.type });\n            const children = this.schema.fields.map((_, i) => this.getChildAt(i));\n            [fields[index], children[index]] = [field, child];\n            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\n        }\n        return new Table(schema, batches);\n    }\n    /**\n     * Construct a new Table containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new Table of columns matching the specified names.\n     */\n    select(columnNames) {\n        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());\n        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));\n    }\n    /**\n     * Construct a new Table containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new Table of columns at the specified indices.\n     */\n    selectAt(columnIndices) {\n        const schema = this.schema.selectAt(columnIndices);\n        const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n        return new Table(schema, data);\n    }\n    assign(other) {\n        const fields = this.schema.fields;\n        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n            const [indices, oldToNew] = memo;\n            const i = fields.findIndex((f) => f.name === f2.name);\n            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);\n            return memo;\n        }, [[], []]);\n        const schema = this.schema.assign(other.schema);\n        const columns = [\n            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => (j === undefined ? this.getChildAt(i) : other.getChildAt(j))),\n            ...indices.map((i) => other.getChildAt(i))\n        ].filter(Boolean);\n        return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n    }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nTable[_a] = ((proto) => {\n    proto.schema = null;\n    proto.batches = [];\n    proto._offsets = new Uint32Array([0]);\n    proto._nullCount = -1;\n    proto[Symbol.isConcatSpreadable] = true;\n    proto['isValid'] = wrapChunkedCall1(isChunkedValid);\n    proto['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n    proto['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n    proto['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n    return 'Table';\n})(Table.prototype);\n/**\n * Creates a new Table from an object of typed arrays.\n *\n*  @example\n * ```ts\n * const table = makeTable({\n *   a: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays.\n * @returns A new Table.\n */\nexport function makeTable(input) {\n    const vecs = {};\n    const inputs = Object.entries(input);\n    for (const [key, col] of inputs) {\n        vecs[key] = makeVector(col);\n    }\n    return new Table(vecs);\n}\n/**\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\n *\n *  @example\n * ```ts\n * const table = tableFromArrays({\n *   a: [1, 2, 3],\n *   b: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays or JavaScript arrays.\n * @returns A new Table.\n */\nexport function tableFromArrays(input) {\n    const vecs = {};\n    const inputs = Object.entries(input);\n    for (const [key, col] of inputs) {\n        vecs[key] = vectorFromArray(col);\n    }\n    return new Table(vecs);\n}\n\n//# sourceMappingURL=table.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Data, makeData } from './data.mjs';\nimport { Table } from './table.mjs';\nimport { Vector } from './vector.mjs';\nimport { Schema, Field } from './schema.mjs';\nimport { DataType, Struct, Null } from './type.mjs';\nimport { wrapIndex } from './util/vector.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\n/** @ignore */\nexport class RecordBatch {\n    constructor(...args) {\n        switch (args.length) {\n            case 2: {\n                [this.schema] = args;\n                if (!(this.schema instanceof Schema)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [,\n                    this.data = makeData({\n                        nullCount: 0,\n                        type: new Struct(this.schema.fields),\n                        children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n                    })\n                ] = args;\n                if (!(this.data instanceof Data)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n                break;\n            }\n            case 1: {\n                const [obj] = args;\n                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {\n                    memo.children[i] = obj[name];\n                    memo.length = Math.max(memo.length, obj[name].length);\n                    memo.fields[i] = Field.new({ name, type: obj[name].type, nullable: true });\n                    return memo;\n                }, {\n                    length: 0,\n                    fields: new Array(),\n                    children: new Array(),\n                });\n                const schema = new Schema(fields);\n                const data = makeData({ type: new Struct(fields), length, children, nullCount: 0 });\n                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);\n                break;\n            }\n            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n        }\n    }\n    get dictionaries() {\n        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n    }\n    /**\n     * The number of columns in this RecordBatch.\n     */\n    get numCols() { return this.schema.fields.length; }\n    /**\n     * The number of rows in this RecordBatch.\n     */\n    get numRows() { return this.data.length; }\n    /**\n     * The number of null rows in this RecordBatch.\n     */\n    get nullCount() {\n        return this.data.nullCount;\n    }\n    /**\n     * Check whether an row is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n    isValid(index) {\n        return this.data.getValid(index);\n    }\n    /**\n     * Get a row by position.\n     * @param index The index of the row to read.\n     */\n    get(index) {\n        return getVisitor.visit(this.data, index);\n    }\n    /**\n      * Get a row value by position.\n      * @param index The index of the row to read. A negative index will count back from the last row.\n      */\n    at(index) {\n        return this.get(wrapIndex(index, this.numRows));\n    }\n    /**\n     * Set a row by position.\n     * @param index The index of the row to write.\n     * @param value The value to set.\n     */\n    set(index, value) {\n        return setVisitor.visit(this.data, index, value);\n    }\n    /**\n     * Retrieve the index of the first occurrence of a row in an RecordBatch.\n     * @param element The row to locate in the RecordBatch.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    indexOf(element, offset) {\n        return indexOfVisitor.visit(this.data, element, offset);\n    }\n    /**\n     * Iterator for rows in this RecordBatch.\n     */\n    [Symbol.iterator]() {\n        return iteratorVisitor.visit(new Vector([this.data]));\n    }\n    /**\n     * Return a JavaScript Array of the RecordBatch rows.\n     * @returns An Array of RecordBatch rows.\n     */\n    toArray() {\n        return [...this];\n    }\n    /**\n     * Combines two or more RecordBatch of the same schema.\n     * @param others Additional RecordBatch to add to the end of this RecordBatch.\n     */\n    concat(...others) {\n        return new Table(this.schema, [this, ...others]);\n    }\n    /**\n     * Return a zero-copy sub-section of this RecordBatch.\n     * @param start The beginning of the specified portion of the RecordBatch.\n     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the row at the index 'end'.\n     */\n    slice(begin, end) {\n        const [slice] = new Vector([this.data]).slice(begin, end).data;\n        return new RecordBatch(this.schema, slice);\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n    getChild(name) {\n        var _b;\n        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n    getChildAt(index) {\n        if (index > -1 && index < this.schema.fields.length) {\n            return new Vector([this.data.children[index]]);\n        }\n        return null;\n    }\n    /**\n     * Sets a child Vector by name.\n     * @param name The name of the child to overwrite.\n     * @returns A new RecordBatch with the new child for the specified name.\n     */\n    setChild(name, child) {\n        var _b;\n        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);\n    }\n    setChildAt(index, child) {\n        let schema = this.schema;\n        let data = this.data;\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice();\n            const children = data.children.slice();\n            const field = fields[index].clone({ type: child.type });\n            [fields[index], children[index]] = [field, child.data[0]];\n            schema = new Schema(fields, new Map(this.schema.metadata));\n            data = makeData({ type: new Struct(fields), children });\n        }\n        return new RecordBatch(schema, data);\n    }\n    /**\n     * Construct a new RecordBatch containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new RecordBatch of columns matching the specified names.\n     */\n    select(columnNames) {\n        const schema = this.schema.select(columnNames);\n        const type = new Struct(schema.fields);\n        const children = [];\n        for (const name of columnNames) {\n            const index = this.schema.fields.findIndex((f) => f.name === name);\n            if (~index) {\n                children[index] = this.data.children[index];\n            }\n        }\n        return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));\n    }\n    /**\n     * Construct a new RecordBatch containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new RecordBatch of columns matching at the specified indices.\n     */\n    selectAt(columnIndices) {\n        const schema = this.schema.selectAt(columnIndices);\n        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n        const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });\n        return new RecordBatch(schema, subset);\n    }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nRecordBatch[_a] = ((proto) => {\n    proto._nullCount = -1;\n    proto[Symbol.isConcatSpreadable] = true;\n    return 'RecordBatch';\n})(RecordBatch.prototype);\n/** @ignore */\nfunction ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {\n    var _b;\n    const fields = [...schema.fields];\n    const children = [...chunks];\n    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;\n    for (const [idx, field] of schema.fields.entries()) {\n        const chunk = chunks[idx];\n        if (!chunk || chunk.length !== maxLength) {\n            fields[idx] = field.clone({ nullable: true });\n            children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : makeData({\n                type: field.type,\n                length: maxLength,\n                nullCount: maxLength,\n                nullBitmap: new Uint8Array(nullBitmapSize)\n            });\n        }\n    }\n    return [\n        schema.assign(fields),\n        makeData({ type: new Struct(fields), length: maxLength, children })\n    ];\n}\n/** @ignore */\nfunction collectDictionaries(fields, children, dictionaries = new Map()) {\n    var _b, _c;\n    if (((_b = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b !== void 0 ? _b : 0) > 0 && ((fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length))) {\n        for (let i = -1, n = fields.length; ++i < n;) {\n            const { type } = fields[i];\n            const data = children[i];\n            for (const next of [data, ...(((_c = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c === void 0 ? void 0 : _c.data) || [])]) {\n                collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);\n            }\n            if (DataType.isDictionary(type)) {\n                const { id } = type;\n                if (!dictionaries.has(id)) {\n                    if (data === null || data === void 0 ? void 0 : data.dictionary) {\n                        dictionaries.set(id, data.dictionary);\n                    }\n                }\n                else if (dictionaries.get(id) !== data.dictionary) {\n                    throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n                }\n            }\n        }\n    }\n    return dictionaries;\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {\n    constructor(schema) {\n        const children = schema.fields.map((f) => makeData({ type: f.type }));\n        const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children });\n        super(schema, data);\n    }\n}\n\n//# sourceMappingURL=recordbatch.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __awaiter } from \"tslib\";\nimport { MessageHeader } from '../enum.mjs';\nimport { ByteBuffer } from 'flatbuffers';\nimport { Message } from './metadata/message.mjs';\nimport { isFileHandle } from '../util/compat.mjs';\nimport { AsyncRandomAccessFile } from '../io/file.mjs';\nimport { toUint8Array } from '../util/buffer.mjs';\nimport { ByteStream, AsyncByteStream } from '../io/stream.mjs';\nimport { ArrowJSON, ITERATOR_DONE } from '../io/interfaces.mjs';\n/** @ignore */ const invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */ const nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */ const invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */ const invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n/** @ignore */\nexport class MessageReader {\n    constructor(source) {\n        this.source = source instanceof ByteStream ? source : new ByteStream(source);\n    }\n    [Symbol.iterator]() { return this; }\n    next() {\n        let r;\n        if ((r = this.readMetadataLength()).done) {\n            return ITERATOR_DONE;\n        }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = this.readMetadataLength()).done) {\n            return ITERATOR_DONE;\n        }\n        if ((r = this.readMetadata(r.value)).done) {\n            return ITERATOR_DONE;\n        }\n        return r;\n    }\n    throw(value) { return this.source.throw(value); }\n    return(value) { return this.source.return(value); }\n    readMessage(type) {\n        let r;\n        if ((r = this.next()).done) {\n            return null;\n        }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    readMessageBody(bodyLength) {\n        if (bodyLength <= 0) {\n            return new Uint8Array(0);\n        }\n        const buf = toUint8Array(this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n            /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message === null || message === void 0 ? void 0 : message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    readMetadataLength() {\n        const buf = this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;\n        return { done: len === 0, value: len };\n    }\n    readMetadata(metadataLength) {\n        const buf = this.source.read(metadataLength);\n        if (!buf) {\n            return ITERATOR_DONE;\n        }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n/** @ignore */\nexport class AsyncMessageReader {\n    constructor(source, byteLength) {\n        this.source = source instanceof AsyncByteStream ? source\n            : isFileHandle(source)\n                ? new AsyncRandomAccessFile(source, byteLength)\n                : new AsyncByteStream(source);\n    }\n    [Symbol.asyncIterator]() { return this; }\n    next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let r;\n            if ((r = yield this.readMetadataLength()).done) {\n                return ITERATOR_DONE;\n            }\n            // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n            // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n            // pre-v0.15 message, where the first 4 bytes are the metadata length.\n            if ((r.value === -1) &&\n                (r = yield this.readMetadataLength()).done) {\n                return ITERATOR_DONE;\n            }\n            if ((r = yield this.readMetadata(r.value)).done) {\n                return ITERATOR_DONE;\n            }\n            return r;\n        });\n    }\n    throw(value) {\n        return __awaiter(this, void 0, void 0, function* () { return yield this.source.throw(value); });\n    }\n    return(value) {\n        return __awaiter(this, void 0, void 0, function* () { return yield this.source.return(value); });\n    }\n    readMessage(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let r;\n            if ((r = yield this.next()).done) {\n                return null;\n            }\n            if ((type != null) && r.value.headerType !== type) {\n                throw new Error(invalidMessageType(type));\n            }\n            return r.value;\n        });\n    }\n    readMessageBody(bodyLength) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (bodyLength <= 0) {\n                return new Uint8Array(0);\n            }\n            const buf = toUint8Array(yield this.source.read(bodyLength));\n            if (buf.byteLength < bodyLength) {\n                throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n            }\n            // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n            // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n            return /* 1. */ (buf.byteOffset % 8 === 0) &&\n                /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n        });\n    }\n    readSchema() {\n        return __awaiter(this, arguments, void 0, function* (throwIfNull = false) {\n            const type = MessageHeader.Schema;\n            const message = yield this.readMessage(type);\n            const schema = message === null || message === void 0 ? void 0 : message.header();\n            if (throwIfNull && !schema) {\n                throw new Error(nullMessage(type));\n            }\n            return schema;\n        });\n    }\n    readMetadataLength() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buf = yield this.source.read(PADDING);\n            const bb = buf && new ByteBuffer(buf);\n            const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;\n            return { done: len === 0, value: len };\n        });\n    }\n    readMetadata(metadataLength) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buf = yield this.source.read(metadataLength);\n            if (!buf) {\n                return ITERATOR_DONE;\n            }\n            if (buf.byteLength < metadataLength) {\n                throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n            }\n            return { done: false, value: Message.decode(buf) };\n        });\n    }\n}\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n    constructor(source) {\n        super(new Uint8Array(0));\n        this._schema = false;\n        this._body = [];\n        this._batchIndex = 0;\n        this._dictionaryIndex = 0;\n        this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n    }\n    next() {\n        const { _json } = this;\n        if (!this._schema) {\n            this._schema = true;\n            const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n            return { done: false, value: message };\n        }\n        if (this._dictionaryIndex < _json.dictionaries.length) {\n            const batch = _json.dictionaries[this._dictionaryIndex++];\n            this._body = batch['data']['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n            return { done: false, value: message };\n        }\n        if (this._batchIndex < _json.batches.length) {\n            const batch = _json.batches[this._batchIndex++];\n            this._body = batch['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n            return { done: false, value: message };\n        }\n        this._body = [];\n        return ITERATOR_DONE;\n    }\n    readMessageBody(_bodyLength) {\n        return flattenDataSources(this._body);\n        function flattenDataSources(xs) {\n            return (xs || []).reduce((buffers, column) => [\n                ...buffers,\n                ...(column['VALIDITY'] && [column['VALIDITY']] || []),\n                ...(column['TYPE_ID'] && [column['TYPE_ID']] || []),\n                ...(column['OFFSET'] && [column['OFFSET']] || []),\n                ...(column['DATA'] && [column['DATA']] || []),\n                ...flattenDataSources(column['children'])\n            ], []);\n        }\n    }\n    readMessage(type) {\n        let r;\n        if ((r = this.next()).done) {\n            return null;\n        }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    readSchema() {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message === null || message === void 0 ? void 0 : message.header();\n        if (!message || !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n}\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\nfor (let i = 0; i < MAGIC_STR.length; i += 1) {\n    MAGIC[i] = MAGIC_STR.codePointAt(i);\n}\n/** @ignore */\nexport function checkForMagicArrowString(buffer, index = 0) {\n    for (let i = -1, n = MAGIC.length; ++i < n;) {\n        if (MAGIC[i] !== buffer[index + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;\n\n//# sourceMappingURL=message.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { CompressionType } from '../../fb/compression-type.mjs';\nclass Lz4FrameValidator {\n    constructor() {\n        this.LZ4_FRAME_MAGIC = new Uint8Array([4, 34, 77, 24]);\n        this.MIN_HEADER_LENGTH = 7; // 4 (magic) + 2 (FLG + BD) + 1 (header checksum) = 7 min bytes\n    }\n    isValidCodecEncode(codec) {\n        const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\n        const compressed = codec.encode(testData);\n        return this._isValidCompressed(compressed);\n    }\n    _isValidCompressed(buffer) {\n        return (this._hasMinimumLength(buffer) &&\n            this._hasValidMagicNumber(buffer) &&\n            this._hasValidVersion(buffer));\n    }\n    _hasMinimumLength(buffer) {\n        return buffer.length >= this.MIN_HEADER_LENGTH;\n    }\n    _hasValidMagicNumber(buffer) {\n        return this.LZ4_FRAME_MAGIC.every((byte, i) => buffer[i] === byte);\n    }\n    _hasValidVersion(buffer) {\n        const flg = buffer[4];\n        const versionBits = (flg & 0xC0) >> 6;\n        return versionBits === 1;\n    }\n}\nclass ZstdValidator {\n    constructor() {\n        this.ZSTD_MAGIC = new Uint8Array([40, 181, 47, 253]);\n        this.MIN_HEADER_LENGTH = 6; // 4 (magic) + 2 (min Frame_Header) = 6 min bytes\n    }\n    isValidCodecEncode(codec) {\n        const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\n        const compressed = codec.encode(testData);\n        return this._isValidCompressed(compressed);\n    }\n    _isValidCompressed(buffer) {\n        return (this._hasMinimumLength(buffer) &&\n            this._hasValidMagicNumber(buffer));\n    }\n    _hasMinimumLength(buffer) {\n        return buffer.length >= this.MIN_HEADER_LENGTH;\n    }\n    _hasValidMagicNumber(buffer) {\n        return this.ZSTD_MAGIC.every((byte, i) => buffer[i] === byte);\n    }\n}\nexport const compressionValidators = {\n    [CompressionType.LZ4_FRAME]: new Lz4FrameValidator(),\n    [CompressionType.ZSTD]: new ZstdValidator(),\n};\n\n//# sourceMappingURL=validators.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { CompressionType } from '../../fb/compression-type.mjs';\nimport { compressionValidators } from './validators.mjs';\nclass _CompressionRegistry {\n    constructor() {\n        this.registry = {};\n    }\n    set(compression, codec) {\n        if ((codec === null || codec === void 0 ? void 0 : codec.encode) && typeof codec.encode === 'function' && !compressionValidators[compression].isValidCodecEncode(codec)) {\n            throw new Error(`Encoder for ${CompressionType[compression]} is not valid.`);\n        }\n        this.registry[compression] = codec;\n    }\n    get(compression) {\n        var _a;\n        return ((_a = this.registry) === null || _a === void 0 ? void 0 : _a[compression]) || null;\n    }\n}\nexport const compressionRegistry = new _CompressionRegistry();\n\n//# sourceMappingURL=registry.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nexport const LENGTH_NO_COMPRESSED_DATA = -1;\nexport const COMPRESS_LENGTH_PREFIX = 8;\n\n//# sourceMappingURL=constants.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from \"tslib\";\nimport { makeData } from '../data.mjs';\nimport { Vector } from '../vector.mjs';\nimport { Struct } from '../type.mjs';\nimport { MessageHeader } from '../enum.mjs';\nimport { Footer } from './metadata/file.mjs';\nimport streamAdapters from '../io/adapters.mjs';\nimport * as metadata from './metadata/message.mjs';\nimport { ByteStream, AsyncByteStream } from '../io/stream.mjs';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file.mjs';\nimport { VectorLoader, JSONVectorLoader, CompressedVectorLoader } from '../visitor/vectorloader.mjs';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch.mjs';\nimport { ITERATOR_DONE, ReadableInterop, } from '../io/interfaces.mjs';\nimport { MessageReader, AsyncMessageReader, JSONMessageReader, checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding } from './message.mjs';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isArrowJSON, isFileHandle, isFetchResponse, isReadableDOMStream, isReadableNodeStream } from '../util/compat.mjs';\nimport { compressionRegistry } from './compression/registry.mjs';\nimport { bigIntToNumber } from './../util/bigint.mjs';\nimport * as flatbuffers from 'flatbuffers';\nimport { COMPRESS_LENGTH_PREFIX, LENGTH_NO_COMPRESSED_DATA } from './compression/constants.mjs';\nexport class RecordBatchReader extends ReadableInterop {\n    constructor(impl) {\n        super();\n        this._impl = impl;\n    }\n    get closed() { return this._impl.closed; }\n    get schema() { return this._impl.schema; }\n    get autoDestroy() { return this._impl.autoDestroy; }\n    get dictionaries() { return this._impl.dictionaries; }\n    get numDictionaries() { return this._impl.numDictionaries; }\n    get numRecordBatches() { return this._impl.numRecordBatches; }\n    get footer() { return this._impl.isFile() ? this._impl.footer : null; }\n    isSync() { return this._impl.isSync(); }\n    isAsync() { return this._impl.isAsync(); }\n    isFile() { return this._impl.isFile(); }\n    isStream() { return this._impl.isStream(); }\n    next() {\n        return this._impl.next();\n    }\n    throw(value) {\n        return this._impl.throw(value);\n    }\n    return(value) {\n        return this._impl.return(value);\n    }\n    cancel() {\n        return this._impl.cancel();\n    }\n    reset(schema) {\n        this._impl.reset(schema);\n        this._DOMStream = undefined;\n        this._nodeStream = undefined;\n        return this;\n    }\n    open(options) {\n        const opening = this._impl.open(options);\n        return isPromise(opening) ? opening.then(() => this) : this;\n    }\n    readRecordBatch(index) {\n        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n    }\n    [Symbol.iterator]() {\n        return this._impl[Symbol.iterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this._impl[Symbol.asyncIterator]();\n    }\n    toDOMStream() {\n        return streamAdapters.toDOMStream((this.isSync()\n            ? { [Symbol.iterator]: () => this }\n            : { [Symbol.asyncIterator]: () => this }));\n    }\n    toNodeStream() {\n        return streamAdapters.toNodeStream((this.isSync()\n            ? { [Symbol.iterator]: () => this }\n            : { [Symbol.asyncIterator]: () => this }), { objectMode: true });\n    }\n    /** @nocollapse */\n    // @ts-ignore\n    static throughNode(options) {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    static throughDOM(\n    // @ts-ignore\n    writableStrategy, \n    // @ts-ignore\n    readableStrategy) {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n    /** @nocollapse */\n    static from(source) {\n        if (source instanceof RecordBatchReader) {\n            return source;\n        }\n        else if (isArrowJSON(source)) {\n            return fromArrowJSON(source);\n        }\n        else if (isFileHandle(source)) {\n            return fromFileHandle(source);\n        }\n        else if (isPromise(source)) {\n            return (() => __awaiter(this, void 0, void 0, function* () { return yield RecordBatchReader.from(yield source); }))();\n        }\n        else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n            return fromAsyncByteStream(new AsyncByteStream(source));\n        }\n        return fromByteStream(new ByteStream(source));\n    }\n    /** @nocollapse */\n    static readAll(source) {\n        if (source instanceof RecordBatchReader) {\n            return source.isSync() ? readAllSync(source) : readAllAsync(source);\n        }\n        else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {\n            return readAllSync(source);\n        }\n        return readAllAsync(source);\n    }\n}\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n/** @ignore */\nexport class RecordBatchStreamReader extends RecordBatchReader {\n    constructor(_impl) {\n        super(_impl);\n        this._impl = _impl;\n    }\n    readAll() { return [...this]; }\n    [Symbol.iterator]() { return this._impl[Symbol.iterator](); }\n    [Symbol.asyncIterator]() { return __asyncGenerator(this, arguments, function* _a() { yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]()))); }); }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader extends RecordBatchReader {\n    constructor(_impl) {\n        super(_impl);\n        this._impl = _impl;\n    }\n    readAll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, e_1, _b, _c;\n            const batches = new Array();\n            try {\n                for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const batch = _c;\n                    batches.push(batch);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return batches;\n        });\n    }\n    [Symbol.iterator]() { throw new Error(`AsyncRecordBatchStreamReader is not Iterable`); }\n    [Symbol.asyncIterator]() { return this._impl[Symbol.asyncIterator](); }\n}\n/** @ignore */\nexport class RecordBatchFileReader extends RecordBatchStreamReader {\n    constructor(_impl) {\n        super(_impl);\n        this._impl = _impl;\n    }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {\n    constructor(_impl) {\n        super(_impl);\n        this._impl = _impl;\n    }\n}\n/** @ignore */\nclass RecordBatchReaderImpl {\n    get numDictionaries() { return this._dictionaryIndex; }\n    get numRecordBatches() { return this._recordBatchIndex; }\n    constructor(dictionaries = new Map()) {\n        this.closed = false;\n        this.autoDestroy = true;\n        this._dictionaryIndex = 0;\n        this._recordBatchIndex = 0;\n        this.dictionaries = dictionaries;\n    }\n    isSync() { return false; }\n    isAsync() { return false; }\n    isFile() { return false; }\n    isStream() { return false; }\n    reset(schema) {\n        this._dictionaryIndex = 0;\n        this._recordBatchIndex = 0;\n        this.schema = schema;\n        this.dictionaries = new Map();\n        return this;\n    }\n    _loadRecordBatch(header, body) {\n        let children;\n        if (header.compression != null) {\n            const codec = compressionRegistry.get(header.compression.type);\n            if ((codec === null || codec === void 0 ? void 0 : codec.decode) && typeof codec.decode === 'function') {\n                const { decommpressedBody, buffers } = this._decompressBuffers(header, body, codec);\n                children = this._loadCompressedVectors(header, decommpressedBody, this.schema.fields);\n                header = new metadata.RecordBatch(header.length, header.nodes, buffers, null);\n            }\n            else {\n                throw new Error('Record batch is compressed but codec not found');\n            }\n        }\n        else {\n            children = this._loadVectors(header, body, this.schema.fields);\n        }\n        const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children });\n        return new RecordBatch(this.schema, data);\n    }\n    _loadDictionaryBatch(header, body) {\n        const { id, isDelta } = header;\n        const { dictionaries, schema } = this;\n        const dictionary = dictionaries.get(id);\n        const type = schema.dictionaries.get(id);\n        let data;\n        if (header.data.compression != null) {\n            const codec = compressionRegistry.get(header.data.compression.type);\n            if ((codec === null || codec === void 0 ? void 0 : codec.decode) && typeof codec.decode === 'function') {\n                const { decommpressedBody, buffers } = this._decompressBuffers(header.data, body, codec);\n                data = this._loadCompressedVectors(header.data, decommpressedBody, [type]);\n                header = new metadata.DictionaryBatch(new metadata.RecordBatch(header.data.length, header.data.nodes, buffers, null), id, isDelta);\n            }\n            else {\n                throw new Error('Dictionary batch is compressed but codec not found');\n            }\n        }\n        else {\n            data = this._loadVectors(header.data, body, [type]);\n        }\n        // const data = this._loadVectors(header.data, body, [type]);\n        return (dictionary && isDelta ? dictionary.concat(new Vector(data)) :\n            new Vector(data)).memoize();\n    }\n    _loadVectors(header, body, types) {\n        return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);\n    }\n    _loadCompressedVectors(header, body, types) {\n        return new CompressedVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);\n    }\n    _decompressBuffers(header, body, codec) {\n        const decompressedBuffers = [];\n        const newBufferRegions = [];\n        let currentOffset = 0;\n        for (const { offset, length } of header.buffers) {\n            if (length === 0) {\n                decompressedBuffers.push(new Uint8Array(0));\n                newBufferRegions.push(new metadata.BufferRegion(currentOffset, 0));\n                continue;\n            }\n            const byteBuf = new flatbuffers.ByteBuffer(body.subarray(offset, offset + length));\n            const uncompressedLenth = bigIntToNumber(byteBuf.readInt64(0));\n            const bytes = byteBuf.bytes().subarray(COMPRESS_LENGTH_PREFIX);\n            const decompressed = (uncompressedLenth === LENGTH_NO_COMPRESSED_DATA)\n                ? bytes\n                : codec.decode(bytes);\n            decompressedBuffers.push(decompressed);\n            const padding = ((currentOffset + 7) & ~7) - currentOffset;\n            currentOffset += padding;\n            newBufferRegions.push(new metadata.BufferRegion(currentOffset, decompressed.length));\n            currentOffset += decompressed.length;\n        }\n        return {\n            decommpressedBody: decompressedBuffers,\n            buffers: newBufferRegions\n        };\n    }\n}\n/** @ignore */\nclass RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n    constructor(source, dictionaries) {\n        super(dictionaries);\n        this._reader = !isArrowJSON(source)\n            ? new MessageReader(this._handle = source)\n            : new JSONMessageReader(this._handle = source);\n    }\n    isSync() { return true; }\n    isStream() { return true; }\n    [Symbol.iterator]() {\n        return this;\n    }\n    cancel() {\n        if (!this.closed && (this.closed = true)) {\n            this.reset()._reader.return();\n            this._reader = null;\n            this.dictionaries = null;\n        }\n    }\n    open(options) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n                this.cancel();\n            }\n        }\n        return this;\n    }\n    throw(value) {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    return(value) {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    next() {\n        if (this.closed) {\n            return ITERATOR_DONE;\n        }\n        let message;\n        const { _reader: reader } = this;\n        while (message = this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                this.reset(message.header());\n            }\n            else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            }\n            else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n        }\n        return this.return();\n    }\n    _readNextMessageAndValidate(type) {\n        return this._reader.readMessage(type);\n    }\n}\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n    constructor(source, dictionaries) {\n        super(dictionaries);\n        this._reader = new AsyncMessageReader(this._handle = source);\n    }\n    isAsync() { return true; }\n    isStream() { return true; }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    cancel() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.closed && (this.closed = true)) {\n                yield this.reset()._reader.return();\n                this._reader = null;\n                this.dictionaries = null;\n            }\n        });\n    }\n    open(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.closed) {\n                this.autoDestroy = shouldAutoDestroy(this, options);\n                if (!(this.schema || (this.schema = (yield this._reader.readSchema())))) {\n                    yield this.cancel();\n                }\n            }\n            return this;\n        });\n    }\n    throw(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.closed && this.autoDestroy && (this.closed = true)) {\n                return yield this.reset()._reader.throw(value);\n            }\n            return ITERATOR_DONE;\n        });\n    }\n    return(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.closed && this.autoDestroy && (this.closed = true)) {\n                return yield this.reset()._reader.return(value);\n            }\n            return ITERATOR_DONE;\n        });\n    }\n    next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.closed) {\n                return ITERATOR_DONE;\n            }\n            let message;\n            const { _reader: reader } = this;\n            while (message = yield this._readNextMessageAndValidate()) {\n                if (message.isSchema()) {\n                    yield this.reset(message.header());\n                }\n                else if (message.isRecordBatch()) {\n                    this._recordBatchIndex++;\n                    const header = message.header();\n                    const buffer = yield reader.readMessageBody(message.bodyLength);\n                    const recordBatch = this._loadRecordBatch(header, buffer);\n                    return { done: false, value: recordBatch };\n                }\n                else if (message.isDictionaryBatch()) {\n                    this._dictionaryIndex++;\n                    const header = message.header();\n                    const buffer = yield reader.readMessageBody(message.bodyLength);\n                    const vector = this._loadDictionaryBatch(header, buffer);\n                    this.dictionaries.set(header.id, vector);\n                }\n            }\n            if (this.schema && this._recordBatchIndex === 0) {\n                this._recordBatchIndex++;\n                return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };\n            }\n            return yield this.return();\n        });\n    }\n    _readNextMessageAndValidate(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this._reader.readMessage(type);\n        });\n    }\n}\n/** @ignore */\nclass RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {\n    get footer() { return this._footer; }\n    get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n    constructor(source, dictionaries) {\n        super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n    }\n    isSync() { return true; }\n    isFile() { return true; }\n    open(options) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return super.open(options);\n    }\n    readRecordBatch(index) {\n        var _a;\n        if (this.closed) {\n            return null;\n        }\n        if (!this._footer) {\n            this.open();\n        }\n        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    _readDictionaryBatch(index) {\n        var _a;\n        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    _readFooter() {\n        const { _handle } = this;\n        const offset = _handle.size - magicAndPadding;\n        const length = _handle.readInt32(offset);\n        const buffer = _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    _readNextMessageAndValidate(type) {\n        var _a;\n        if (!this._footer) {\n            this.open();\n        }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);\n            if (block && this._handle.seek(block.offset)) {\n                return this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {\n    get footer() { return this._footer; }\n    get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n    constructor(source, ...rest) {\n        const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;\n        const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;\n        super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n    }\n    isFile() { return true; }\n    isAsync() { return true; }\n    open(options) {\n        const _super = Object.create(null, {\n            open: { get: () => super.open }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.closed && !this._footer) {\n                this.schema = (this._footer = yield this._readFooter()).schema;\n                for (const block of this._footer.dictionaryBatches()) {\n                    block && (yield this._readDictionaryBatch(this._dictionaryIndex++));\n                }\n            }\n            return yield _super.open.call(this, options);\n        });\n    }\n    readRecordBatch(index) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (this.closed) {\n                return null;\n            }\n            if (!this._footer) {\n                yield this.open();\n            }\n            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);\n            if (block && (yield this._handle.seek(block.offset))) {\n                const message = yield this._reader.readMessage(MessageHeader.RecordBatch);\n                if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n                    const header = message.header();\n                    const buffer = yield this._reader.readMessageBody(message.bodyLength);\n                    const recordBatch = this._loadRecordBatch(header, buffer);\n                    return recordBatch;\n                }\n            }\n            return null;\n        });\n    }\n    _readDictionaryBatch(index) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);\n            if (block && (yield this._handle.seek(block.offset))) {\n                const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);\n                if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n                    const header = message.header();\n                    const buffer = yield this._reader.readMessageBody(message.bodyLength);\n                    const vector = this._loadDictionaryBatch(header, buffer);\n                    this.dictionaries.set(header.id, vector);\n                }\n            }\n        });\n    }\n    _readFooter() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { _handle } = this;\n            _handle._pending && (yield _handle._pending);\n            const offset = _handle.size - magicAndPadding;\n            const length = yield _handle.readInt32(offset);\n            const buffer = yield _handle.readAt(offset - length, length);\n            return Footer.decode(buffer);\n        });\n    }\n    _readNextMessageAndValidate(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._footer) {\n                yield this.open();\n            }\n            if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n                const block = this._footer.getRecordBatch(this._recordBatchIndex);\n                if (block && (yield this._handle.seek(block.offset))) {\n                    return yield this._reader.readMessage(type);\n                }\n            }\n            return null;\n        });\n    }\n}\n/** @ignore */\nclass RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {\n    constructor(source, dictionaries) {\n        super(source, dictionaries);\n    }\n    _loadVectors(header, body, types) {\n        return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);\n    }\n}\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n/** @ignore */\nfunction shouldAutoDestroy(self, options) {\n    return options && (typeof options['autoDestroy'] === 'boolean') ? options['autoDestroy'] : self['autoDestroy'];\n}\n/** @ignore */\nfunction* readAllSync(source) {\n    const reader = RecordBatchReader.from(source);\n    try {\n        if (!reader.open({ autoDestroy: false }).closed) {\n            do {\n                yield reader;\n            } while (!(reader.reset().open()).closed);\n        }\n    }\n    finally {\n        reader.cancel();\n    }\n}\n/** @ignore */\nfunction readAllAsync(source) {\n    return __asyncGenerator(this, arguments, function* readAllAsync_1() {\n        const reader = yield __await(RecordBatchReader.from(source));\n        try {\n            if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {\n                do {\n                    yield yield __await(reader);\n                } while (!(yield __await(reader.reset().open())).closed);\n            }\n        }\n        finally {\n            yield __await(reader.cancel());\n        }\n    });\n}\n/** @ignore */\nfunction fromArrowJSON(source) {\n    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\n/** @ignore */\nfunction fromByteStream(source) {\n    const bytes = source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read()))\n        : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () { }()));\n}\n/** @ignore */\nfunction fromAsyncByteStream(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const bytes = yield source.peek((magicLength + 7) & ~7);\n        return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n            ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source))\n            : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read()))\n            : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function () { return __asyncGenerator(this, arguments, function* () { }); }()));\n    });\n}\n/** @ignore */\nfunction fromFileHandle(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { size } = yield source.stat();\n        const file = new AsyncRandomAccessFile(source, size);\n        if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, (magicLength + 7) & ~7))) {\n            return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n        }\n        return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n    });\n}\n\n//# sourceMappingURL=reader.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { UnionMode } from '../enum.mjs';\nimport { RecordBatch } from '../recordbatch.mjs';\nimport { rebaseValueOffsets } from '../util/buffer.mjs';\nimport { packBools, truncateBitmap } from '../util/bit.mjs';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message.mjs';\nimport { DataType, } from '../type.mjs';\nimport { bigIntToNumber } from '../util/bigint.mjs';\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n    /** @nocollapse */\n    static assemble(...args) {\n        const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) :\n            (node instanceof RecordBatch) ? node.data.children : node.data);\n        const assembler = new VectorAssembler();\n        assembler.visitMany(unwrap(args));\n        return assembler;\n    }\n    constructor() {\n        super();\n        this._byteLength = 0;\n        this._nodes = [];\n        this._buffers = [];\n        this._bufferRegions = [];\n    }\n    visit(data) {\n        if (data instanceof Vector) {\n            this.visitMany(data.data);\n            return this;\n        }\n        const { type } = data;\n        if (!DataType.isDictionary(type)) {\n            const { length } = data;\n            if (length > 2147483647) {\n                /* istanbul ignore next */\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n            }\n            if (DataType.isUnion(type)) {\n                this.nodes.push(new FieldNode(length, 0));\n            }\n            else {\n                const { nullCount } = data;\n                if (!DataType.isNull(type)) {\n                    addBuffer.call(this, nullCount <= 0\n                        ? new Uint8Array(0) // placeholder validity buffer\n                        : truncateBitmap(data.offset, length, data.nullBitmap));\n                }\n                this.nodes.push(new FieldNode(length, nullCount));\n            }\n        }\n        return super.visit(data);\n    }\n    visitNull(_null) {\n        return this;\n    }\n    visitDictionary(data) {\n        // Assemble the indices here, Dictionary assembled separately.\n        return this.visit(data.clone(data.type.indices));\n    }\n    get nodes() { return this._nodes; }\n    get buffers() { return this._buffers; }\n    get byteLength() { return this._byteLength; }\n    get bufferRegions() { return this._bufferRegions; }\n}\n/** @ignore */\nfunction addBuffer(values) {\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\n    this.buffers.push(values);\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n    this._byteLength += byteLength;\n    return this;\n}\n/** @ignore */\nfunction assembleUnion(data) {\n    var _a;\n    const { type, length, typeIds, valueOffsets } = data;\n    // All Union Vectors have a typeIds buffer\n    addBuffer.call(this, typeIds);\n    // If this is a Sparse Union, treat it like all other Nested types\n    if (type.mode === UnionMode.Sparse) {\n        return assembleNestedVector.call(this, data);\n    }\n    else if (type.mode === UnionMode.Dense) {\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n        if (data.offset <= 0) {\n            // If the Vector hasn't been sliced, write the existing valueOffsets\n            addBuffer.call(this, valueOffsets);\n            // We can treat this like all other Nested types\n            return assembleNestedVector.call(this, data);\n        }\n        else {\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\n            // Union typeIds are not necessary 0-indexed\n            const shiftedOffsets = new Int32Array(length);\n            const childOffsets = Object.create(null);\n            const childLengths = Object.create(null);\n            // If we have a non-zero offset, then the value offsets do not start at\n            // zero. We must a) create a new offsets array with shifted offsets and\n            // b) slice the values array accordingly\n            for (let typeId, shift, index = -1; ++index < length;) {\n                if ((typeId = typeIds[index]) === undefined) {\n                    continue;\n                }\n                if ((shift = childOffsets[typeId]) === undefined) {\n                    shift = childOffsets[typeId] = valueOffsets[index];\n                }\n                shiftedOffsets[index] = valueOffsets[index] - shift;\n                childLengths[typeId] = ((_a = childLengths[typeId]) !== null && _a !== void 0 ? _a : 0) + 1;\n            }\n            addBuffer.call(this, shiftedOffsets);\n            // Slice and visit children accordingly\n            this.visitMany(data.children.map((child, childIndex) => {\n                const typeId = type.typeIds[childIndex];\n                const childOffset = childOffsets[typeId];\n                const childLength = childLengths[typeId];\n                return child.slice(childOffset, Math.min(length, childLength));\n            }));\n        }\n    }\n    return this;\n}\n/** @ignore */\nfunction assembleBoolVector(data) {\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n    let values;\n    if (data.nullCount >= data.length) {\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\n        return addBuffer.call(this, new Uint8Array(0));\n    }\n    else if ((values = data.values) instanceof Uint8Array) {\n        // If values is already a Uint8Array, slice the bitmap (fast path)\n        return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));\n    }\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n    // values as bools and re-pack them into a Uint8Array. This code isn't\n    // reachable unless you're trying to manipulate the Data internals,\n    // we're only doing this for safety.\n    /* istanbul ignore next */\n    return addBuffer.call(this, packBools(data.values));\n}\n/** @ignore */\nfunction assembleFlatVector(data) {\n    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\n/** @ignore */\nfunction assembleFlatListVector(data) {\n    const { length, values, valueOffsets } = data;\n    const begin = bigIntToNumber(valueOffsets[0]);\n    const end = bigIntToNumber(valueOffsets[length]);\n    const byteLength = Math.min(end - begin, values.byteLength - begin);\n    // Push in the order FlatList types read their buffers\n    addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets)); // valueOffsets buffer first\n    addBuffer.call(this, values.subarray(begin, begin + byteLength)); // sliced values buffer second\n    return this;\n}\n/** @ignore */\nfunction assembleListVector(data) {\n    const { length, valueOffsets } = data;\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\n    if (valueOffsets) {\n        const { [0]: begin, [length]: end } = valueOffsets;\n        addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets));\n        // Then insert the List's values child\n        return this.visit(data.children[0].slice(begin, end - begin));\n    }\n    // Then insert the List's values child\n    return this.visit(data.children[0]);\n}\n/** @ignore */\nfunction assembleNestedVector(data) {\n    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitDuration = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;\n\n//# sourceMappingURL=vectorassembler.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncValues, __awaiter } from \"tslib\";\nimport { Table } from '../table.mjs';\nimport { MAGIC } from './message.mjs';\nimport { Vector } from '../vector.mjs';\nimport { DataType } from '../type.mjs';\nimport { Message } from './metadata/message.mjs';\nimport * as metadata from './metadata/message.mjs';\nimport { FileBlock, Footer } from './metadata/file.mjs';\nimport { MessageHeader, MetadataVersion } from '../enum.mjs';\nimport { compareSchemas } from '../visitor/typecomparator.mjs';\nimport { AsyncByteQueue } from '../io/stream.mjs';\nimport { VectorAssembler } from '../visitor/vectorassembler.mjs';\nimport { JSONTypeAssembler } from '../visitor/jsontypeassembler.mjs';\nimport { JSONVectorAssembler } from '../visitor/jsonvectorassembler.mjs';\nimport { toUint8Array } from '../util/buffer.mjs';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch.mjs';\nimport { ReadableInterop } from '../io/interfaces.mjs';\nimport { isPromise, isAsyncIterable, isWritableDOMStream, isWritableNodeStream, isIterable, isObject } from '../util/compat.mjs';\nimport { CompressionType } from '../fb/compression-type.mjs';\nimport { compressionRegistry } from './compression/registry.mjs';\nimport { LENGTH_NO_COMPRESSED_DATA, COMPRESS_LENGTH_PREFIX } from './compression/constants.mjs';\nimport * as flatbuffers from 'flatbuffers';\nexport class RecordBatchWriter extends ReadableInterop {\n    /** @nocollapse */\n    // @ts-ignore\n    static throughNode(options) {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    static throughDOM(\n    // @ts-ignore\n    writableStrategy, \n    // @ts-ignore\n    readableStrategy) {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n    constructor(options) {\n        super();\n        this._position = 0;\n        this._started = false;\n        this._compression = null;\n        // @ts-ignore\n        this._sink = new AsyncByteQueue();\n        this._schema = null;\n        this._dictionaryBlocks = [];\n        this._recordBatchBlocks = [];\n        this._seenDictionaries = new Map();\n        this._dictionaryDeltaOffsets = new Map();\n        isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false, compressionType: null });\n        this._autoDestroy = (typeof options.autoDestroy === 'boolean') ? options.autoDestroy : true;\n        this._writeLegacyIpcFormat = (typeof options.writeLegacyIpcFormat === 'boolean') ? options.writeLegacyIpcFormat : false;\n        if (options.compressionType != null) {\n            if (this._writeLegacyIpcFormat) {\n                throw new Error('Legacy IPC format does not support columnar compression. Use modern IPC format (writeLegacyIpcFormat=false).');\n            }\n            if (Object.values(CompressionType).includes(options.compressionType)) {\n                this._compression = new metadata.BodyCompression(options.compressionType);\n            }\n            else {\n                const validCompressionTypes = Object.values(CompressionType)\n                    .filter((v) => typeof v === 'string');\n                throw new Error(`Unsupported compressionType: ${options.compressionType} Available types: ${validCompressionTypes.join(', ')}`);\n            }\n        }\n        else {\n            this._compression = null;\n        }\n    }\n    toString(sync = false) {\n        return this._sink.toString(sync);\n    }\n    toUint8Array(sync = false) {\n        return this._sink.toUint8Array(sync);\n    }\n    writeAll(input) {\n        if (isPromise(input)) {\n            return input.then((x) => this.writeAll(x));\n        }\n        else if (isAsyncIterable(input)) {\n            return writeAllAsync(this, input);\n        }\n        return writeAll(this, input);\n    }\n    get closed() { return this._sink.closed; }\n    [Symbol.asyncIterator]() { return this._sink[Symbol.asyncIterator](); }\n    toDOMStream(options) { return this._sink.toDOMStream(options); }\n    toNodeStream(options) { return this._sink.toNodeStream(options); }\n    close() {\n        return this.reset()._sink.close();\n    }\n    abort(reason) {\n        return this.reset()._sink.abort(reason);\n    }\n    finish() {\n        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);\n        return this;\n    }\n    reset(sink = this._sink, schema = null) {\n        if ((sink === this._sink) || (sink instanceof AsyncByteQueue)) {\n            this._sink = sink;\n        }\n        else {\n            this._sink = new AsyncByteQueue();\n            if (sink && isWritableDOMStream(sink)) {\n                this.toDOMStream({ type: 'bytes' }).pipeTo(sink);\n            }\n            else if (sink && isWritableNodeStream(sink)) {\n                this.toNodeStream({ objectMode: false }).pipe(sink);\n            }\n        }\n        if (this._started && this._schema) {\n            this._writeFooter(this._schema);\n        }\n        this._started = false;\n        this._dictionaryBlocks = [];\n        this._recordBatchBlocks = [];\n        this._seenDictionaries = new Map();\n        this._dictionaryDeltaOffsets = new Map();\n        if (!schema || !(compareSchemas(schema, this._schema))) {\n            if (schema == null) {\n                this._position = 0;\n                this._schema = null;\n            }\n            else {\n                this._started = true;\n                this._schema = schema;\n                this._writeSchema(schema);\n            }\n        }\n        return this;\n    }\n    write(payload) {\n        let schema = null;\n        if (!this._sink) {\n            throw new Error(`RecordBatchWriter is closed`);\n        }\n        else if (payload == null) {\n            return this.finish() && undefined;\n        }\n        else if (payload instanceof Table && !(schema = payload.schema)) {\n            return this.finish() && undefined;\n        }\n        else if (payload instanceof RecordBatch && !(schema = payload.schema)) {\n            return this.finish() && undefined;\n        }\n        if (schema && !compareSchemas(schema, this._schema)) {\n            if (this._started && this._autoDestroy) {\n                return this.close();\n            }\n            this.reset(this._sink, schema);\n        }\n        if (payload instanceof RecordBatch) {\n            if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {\n                this._writeRecordBatch(payload);\n            }\n        }\n        else if (payload instanceof Table) {\n            this.writeAll(payload.batches);\n        }\n        else if (isIterable(payload)) {\n            this.writeAll(payload);\n        }\n    }\n    _writeMessage(message, alignment = 8) {\n        const a = alignment - 1;\n        const buffer = Message.encode(message);\n        const flatbufferSize = buffer.byteLength;\n        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;\n        const alignedSize = (flatbufferSize + prefixSize + a) & ~a;\n        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;\n        if (message.headerType === MessageHeader.RecordBatch) {\n            this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n        }\n        else if (message.headerType === MessageHeader.DictionaryBatch) {\n            this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));\n        }\n        // If not in legacy pre-0.15.0 mode, write the stream continuation indicator\n        if (!this._writeLegacyIpcFormat) {\n            this._write(Int32Array.of(-1));\n        }\n        // Write the flatbuffer size prefix including padding\n        this._write(Int32Array.of(alignedSize - prefixSize));\n        // Write the flatbuffer\n        if (flatbufferSize > 0) {\n            this._write(buffer);\n        }\n        // Write any padding\n        return this._writePadding(nPaddingBytes);\n    }\n    _write(chunk) {\n        if (this._started) {\n            const buffer = toUint8Array(chunk);\n            if (buffer && buffer.byteLength > 0) {\n                this._sink.write(buffer);\n                this._position += buffer.byteLength;\n            }\n        }\n        return this;\n    }\n    _writeSchema(schema) {\n        return this._writeMessage(Message.from(schema));\n    }\n    // @ts-ignore\n    _writeFooter(schema) {\n        // eos bytes\n        return this._writeLegacyIpcFormat\n            ? this._write(Int32Array.of(0))\n            : this._write(Int32Array.of(-1, 0));\n    }\n    _writeMagic() {\n        return this._write(MAGIC);\n    }\n    _writePadding(nBytes) {\n        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;\n    }\n    _writeRecordBatch(batch) {\n        const { byteLength, nodes, bufferRegions, buffers } = this._assembleRecordBatch(batch);\n        const recordBatch = new metadata.RecordBatch(batch.numRows, nodes, bufferRegions, this._compression);\n        const message = Message.from(recordBatch, byteLength);\n        return this\n            ._writeDictionaries(batch)\n            ._writeMessage(message)\n            ._writeBodyBuffers(buffers);\n    }\n    _assembleRecordBatch(batch) {\n        let { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);\n        if (this._compression != null) {\n            ({ byteLength, bufferRegions, buffers } = this._compressBodyBuffers(buffers));\n        }\n        return { byteLength, nodes, bufferRegions, buffers };\n    }\n    _compressBodyBuffers(buffers) {\n        const codec = compressionRegistry.get(this._compression.type);\n        if (!(codec === null || codec === void 0 ? void 0 : codec.encode) || typeof codec.encode !== 'function') {\n            throw new Error(`Codec for compression type \"${CompressionType[this._compression.type]}\" has invalid encode method`);\n        }\n        let currentOffset = 0;\n        const compressedBuffers = [];\n        const bufferRegions = [];\n        for (const buffer of buffers) {\n            const byteBuf = toUint8Array(buffer);\n            if (byteBuf.length === 0) {\n                compressedBuffers.push(new Uint8Array(0), new Uint8Array(0));\n                bufferRegions.push(new metadata.BufferRegion(currentOffset, 0));\n                continue;\n            }\n            const compressed = codec.encode(byteBuf);\n            const isCompressionEffective = compressed.length < byteBuf.length;\n            const finalBuffer = isCompressionEffective ? compressed : byteBuf;\n            const byteLength = isCompressionEffective ? finalBuffer.length : LENGTH_NO_COMPRESSED_DATA;\n            const lengthPrefix = new flatbuffers.ByteBuffer(new Uint8Array(COMPRESS_LENGTH_PREFIX));\n            lengthPrefix.writeInt64(0, BigInt(byteLength));\n            compressedBuffers.push(lengthPrefix.bytes(), new Uint8Array(finalBuffer));\n            const padding = ((currentOffset + 7) & ~7) - currentOffset;\n            currentOffset += padding;\n            const fullBodyLength = COMPRESS_LENGTH_PREFIX + finalBuffer.length;\n            bufferRegions.push(new metadata.BufferRegion(currentOffset, fullBodyLength));\n            currentOffset += fullBodyLength;\n        }\n        const finalPadding = ((currentOffset + 7) & ~7) - currentOffset;\n        currentOffset += finalPadding;\n        return { byteLength: currentOffset, bufferRegions, buffers: compressedBuffers };\n    }\n    _writeDictionaryBatch(dictionary, id, isDelta = false) {\n        const { byteLength, nodes, bufferRegions, buffers } = this._assembleRecordBatch(new Vector([dictionary]));\n        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions, this._compression);\n        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);\n        const message = Message.from(dictionaryBatch, byteLength);\n        return this\n            ._writeMessage(message)\n            ._writeBodyBuffers(buffers);\n    }\n    _writeBodyBuffers(buffers) {\n        const bufGroupSize = this._compression != null ? 2 : 1;\n        const bufs = new Array(bufGroupSize);\n        for (let i = 0; i < buffers.length; i += bufGroupSize) {\n            let size = 0;\n            for (let j = -1; ++j < bufGroupSize;) {\n                bufs[j] = buffers[i + j];\n                size += bufs[j].byteLength;\n            }\n            if (size === 0) {\n                continue;\n            }\n            for (const buf of bufs)\n                this._write(buf);\n            const padding = ((size + 7) & ~7) - size;\n            if (padding > 0) {\n                this._writePadding(padding);\n            }\n        }\n        return this;\n    }\n    _writeDictionaries(batch) {\n        var _a, _b;\n        for (const [id, dictionary] of batch.dictionaries) {\n            const chunks = (_a = dictionary === null || dictionary === void 0 ? void 0 : dictionary.data) !== null && _a !== void 0 ? _a : [];\n            const prevDictionary = this._seenDictionaries.get(id);\n            const offset = (_b = this._dictionaryDeltaOffsets.get(id)) !== null && _b !== void 0 ? _b : 0;\n            // * If no previous dictionary was written, write an initial DictionaryMessage.\n            // * If the current dictionary does not share chunks with the previous dictionary, write a replacement DictionaryMessage.\n            if (!prevDictionary || prevDictionary.data[0] !== chunks[0]) {\n                // * If `index > 0`, then `isDelta` is true.\n                // * If `index = 0`, then `isDelta` is false, because this is either the initial or a replacement DictionaryMessage.\n                for (const [index, chunk] of chunks.entries())\n                    this._writeDictionaryBatch(chunk, id, index > 0);\n            }\n            else if (offset < chunks.length) {\n                for (const chunk of chunks.slice(offset))\n                    this._writeDictionaryBatch(chunk, id, true);\n            }\n            this._seenDictionaries.set(id, dictionary);\n            this._dictionaryDeltaOffsets.set(id, chunks.length);\n        }\n        return this;\n    }\n}\n/** @ignore */\nexport class RecordBatchStreamWriter extends RecordBatchWriter {\n    /** @nocollapse */\n    static writeAll(input, options) {\n        const writer = new RecordBatchStreamWriter(options);\n        if (isPromise(input)) {\n            return input.then((x) => writer.writeAll(x));\n        }\n        else if (isAsyncIterable(input)) {\n            return writeAllAsync(writer, input);\n        }\n        return writeAll(writer, input);\n    }\n}\n/** @ignore */\nexport class RecordBatchFileWriter extends RecordBatchWriter {\n    /** @nocollapse */\n    static writeAll(input, options) {\n        const writer = new RecordBatchFileWriter(options);\n        if (isPromise(input)) {\n            return input.then((x) => writer.writeAll(x));\n        }\n        else if (isAsyncIterable(input)) {\n            return writeAllAsync(writer, input);\n        }\n        return writeAll(writer, input);\n    }\n    constructor(options) {\n        super(options);\n        this._autoDestroy = true;\n        this._writeLegacyIpcFormat = false;\n    }\n    // @ts-ignore\n    _writeSchema(schema) {\n        return this._writeMagic()._writePadding(2);\n    }\n    _writeDictionaryBatch(dictionary, id, isDelta = false) {\n        if (!isDelta && this._seenDictionaries.has(id)) {\n            throw new Error('The Arrow File format does not support replacement dictionaries. ');\n        }\n        return super._writeDictionaryBatch(dictionary, id, isDelta);\n    }\n    _writeFooter(schema) {\n        const buffer = Footer.encode(new Footer(schema, MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));\n        return super\n            ._writeFooter(schema) // EOS bytes for sequential readers\n            ._write(buffer) // Write the flatbuffer\n            ._write(Int32Array.of(buffer.byteLength)) // then the footer size suffix\n            ._writeMagic(); // then the magic suffix\n    }\n}\n/** @ignore */\nexport class RecordBatchJSONWriter extends RecordBatchWriter {\n    /** @nocollapse */\n    static writeAll(input) {\n        return new RecordBatchJSONWriter().writeAll(input);\n    }\n    constructor() {\n        super();\n        this._autoDestroy = true;\n        this._recordBatches = [];\n        this._recordBatchesWithDictionaries = [];\n    }\n    _writeMessage() { return this; }\n    // @ts-ignore\n    _writeFooter(schema) { return this; }\n    _writeSchema(schema) {\n        return this._write(`{\\n  \"schema\": ${JSON.stringify({ fields: schema.fields.map(field => fieldToJSON(field)) }, null, 2)}`);\n    }\n    _writeDictionaries(batch) {\n        if (batch.dictionaries.size > 0) {\n            this._recordBatchesWithDictionaries.push(batch);\n        }\n        return this;\n    }\n    _writeDictionaryBatch(dictionary, id, isDelta = false) {\n        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,\\n    `);\n        this._write(dictionaryBatchToJSON(dictionary, id, isDelta));\n        this._dictionaryBlocks.push(new FileBlock(0, 0, 0));\n        return this;\n    }\n    _writeRecordBatch(batch) {\n        this._writeDictionaries(batch);\n        this._recordBatches.push(batch);\n        return this;\n    }\n    close() {\n        if (this._recordBatchesWithDictionaries.length > 0) {\n            this._write(`,\\n  \"dictionaries\": [\\n`);\n            for (const batch of this._recordBatchesWithDictionaries) {\n                super._writeDictionaries(batch);\n            }\n            this._write(`\\n  ]`);\n        }\n        if (this._recordBatches.length > 0) {\n            for (let i = -1, n = this._recordBatches.length; ++i < n;) {\n                this._write(i === 0 ? `,\\n  \"batches\": [\\n    ` : `,\\n    `);\n                this._write(recordBatchToJSON(this._recordBatches[i]));\n                this._recordBatchBlocks.push(new FileBlock(0, 0, 0));\n            }\n            this._write(`\\n  ]`);\n        }\n        if (this._schema) {\n            this._write(`\\n}`);\n        }\n        this._recordBatchesWithDictionaries = [];\n        this._recordBatches = [];\n        return super.close();\n    }\n}\n/** @ignore */\nfunction writeAll(writer, input) {\n    let chunks = input;\n    if (input instanceof Table) {\n        chunks = input.batches;\n        writer.reset(undefined, input.schema);\n    }\n    for (const batch of chunks) {\n        writer.write(batch);\n    }\n    return writer.finish();\n}\n/** @ignore */\nfunction writeAllAsync(writer, batches) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, batches_1, batches_1_1;\n        var _b, e_1, _c, _d;\n        try {\n            for (_a = true, batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), _b = batches_1_1.done, !_b; _a = true) {\n                _d = batches_1_1.value;\n                _a = false;\n                const batch = _d;\n                writer.write(batch);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_a && !_b && (_c = batches_1.return)) yield _c.call(batches_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return writer.finish();\n    });\n}\n/** @ignore */\nfunction fieldToJSON({ name, type, nullable }) {\n    const assembler = new JSONTypeAssembler();\n    return {\n        'name': name, 'nullable': nullable,\n        'type': assembler.visit(type),\n        'children': (type.children || []).map((field) => fieldToJSON(field)),\n        'dictionary': !DataType.isDictionary(type) ? undefined : {\n            'id': type.id,\n            'isOrdered': type.isOrdered,\n            'indexType': assembler.visit(type.indices)\n        }\n    };\n}\n/** @ignore */\nfunction dictionaryBatchToJSON(dictionary, id, isDelta = false) {\n    const [columns] = JSONVectorAssembler.assemble(new RecordBatch({ [id]: dictionary }));\n    return JSON.stringify({\n        'id': id,\n        'isDelta': isDelta,\n        'data': {\n            'count': dictionary.length,\n            'columns': columns\n        }\n    }, null, 2);\n}\n/** @ignore */\nfunction recordBatchToJSON(records) {\n    const [columns] = JSONVectorAssembler.assemble(records);\n    return JSON.stringify({\n        'count': records.numRows,\n        'columns': columns\n    }, null, 2);\n}\n\n//# sourceMappingURL=writer.mjs.map\n","// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Table } from '../table.mjs';\nimport { isPromise } from '../util/compat.mjs';\nimport { RecordBatchReader } from './reader.mjs';\nimport { RecordBatchFileWriter, RecordBatchStreamWriter } from './writer.mjs';\nexport function tableFromIPC(input) {\n    const reader = RecordBatchReader.from(input);\n    if (isPromise(reader)) {\n        return reader.then((reader) => tableFromIPC(reader));\n    }\n    if (reader.isAsync()) {\n        return reader.readAll().then((xs) => new Table(xs));\n    }\n    return new Table(reader.readAll());\n}\n/**\n * Serialize a {@link Table} to the IPC format. This function is a convenience\n * wrapper for {@link RecordBatchStreamWriter} and {@link RecordBatchFileWriter}.\n * Opposite of {@link tableFromIPC}.\n *\n * @param table The Table to serialize.\n * @param type Whether to serialize the Table as a file or a stream.\n */\nexport function tableToIPC(table, type = 'stream', compressionType = null) {\n    const writerOptions = { compressionType };\n    return (type === 'stream' ? RecordBatchStreamWriter : RecordBatchFileWriter)\n        .writeAll(table, writerOptions)\n        .toUint8Array(true);\n}\n\n//# sourceMappingURL=serialization.mjs.map\n","const ONE = 0x80000000;\nconst ALL = 0xFFFFFFFF;\n\n/**\n * Represent an indexable set of bits.\n */\nexport class BitSet {\n  /**\n   * Instantiate a new BitSet instance.\n   * @param {number} size The number of bits.\n   */\n  constructor(size) {\n    this._size = size;\n    this._bits = new Uint32Array(Math.ceil(size / 32));\n  }\n\n  /**\n   * The number of bits.\n   * @return {number}\n   */\n  get length() {\n    return this._size;\n  }\n\n  /**\n   * The number of bits set to one.\n   * https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n   * @return {number}\n   */\n  count() {\n    const n = this._bits.length;\n    let count = 0;\n    for (let i = 0; i < n; ++i) {\n      for (let b = this._bits[i]; b; ++count) {\n        b &= b - 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the bit at a given index.\n   * @param {number} i The bit index.\n   */\n  get(i) {\n    return this._bits[i >> 5] & (ONE >>> i);\n  }\n\n  /**\n   * Set the bit at a given index to one.\n   * @param {number} i The bit index.\n   */\n  set(i) {\n    this._bits[i >> 5] |= (ONE >>> i);\n  }\n\n  /**\n   * Clear the bit at a given index to zero.\n   * @param {number} i The bit index.\n   */\n  clear(i) {\n    this._bits[i >> 5] &= ~(ONE >>> i);\n  }\n\n  /**\n   * Scan the bits, invoking a callback function with the index of\n   * each non-zero bit.\n   * @param {(i: number) => void} fn A callback function.\n   */\n  scan(fn) {\n    for (let i = this.next(0); i >= 0; i = this.next(i + 1)) {\n      fn(i);\n    }\n  }\n\n  /**\n   * Get the next non-zero bit starting from a given index.\n   * @param {number} i The bit index.\n   */\n  next(i) {\n    const bits = this._bits;\n    const n = bits.length;\n\n    let index = i >> 5;\n    let curr = bits[index] & (ALL >>> i);\n\n    for (; index < n; curr = bits[++index]) {\n      if (curr !== 0) {\n        return (index << 5) + Math.clz32(curr);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Return the index of the nth non-zero bit.\n   * @param {number} n The number of non-zero bits to advance.\n   * @return {number} The index of the nth non-zero bit.\n   */\n  nth(n) {\n    let i = this.next(0);\n    while (n-- && i >= 0) i = this.next(i + 1);\n    return i;\n  }\n\n  /**\n   * Negate all bits in this bitset.\n   * Modifies this BitSet in place.\n   * @return {this}\n   */\n  not() {\n    const bits = this._bits;\n    const n = bits.length;\n\n    // invert all bits\n    for (let i = 0; i < n; ++i) {\n      bits[i] = ~bits[i];\n    }\n\n    // unset extraneous trailing bits\n    const tail = this._size % 32;\n    if (tail) {\n      bits[n - 1] &= ONE >> (tail - 1);\n    }\n\n    return this;\n  }\n\n  /**\n   * Compute the logical AND of this BitSet and another.\n   * @param {BitSet} bitset The BitSet to combine with.\n   * @return {BitSet} This BitSet updated with the logical AND.\n   */\n  and(bitset) {\n    if (bitset) {\n      const a = this._bits;\n      const b = bitset._bits;\n      const n = a.length;\n\n      for (let i = 0; i < n; ++i) {\n        a[i] &= b[i];\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Compute the logical OR of this BitSet and another.\n   * @param {BitSet} bitset The BitSet to combine with.\n   * @return {BitSet} This BitSet updated with the logical OR.\n   */\n  or(bitset) {\n    if (bitset) {\n      const a = this._bits;\n      const b = bitset._bits;\n      const n = a.length;\n\n      for (let i = 0; i < n; ++i) {\n        a[i] |= b[i];\n      }\n    }\n    return this;\n  }\n}\n","/**\n * Truncate a value to a bin boundary.\n * Useful for creating equal-width histograms.\n * Values outside the [min, max] range will be mapped to\n * -Infinity (< min) or +Infinity (> max).\n * @param {number} value The value to bin.\n * @param {number} min The minimum bin boundary.\n * @param {number} max The maximum bin boundary.\n * @param {number} step The step size between bin boundaries.\n * @param {number} [offset=0] Offset in steps by which to adjust\n *  the bin value. An offset of 1 will return the next boundary.\n */\nexport function bin(value, min, max, step, offset) {\n  return value == null ? null\n    : value < min ? -Infinity\n    : value > max ? +Infinity\n    : (\n        value = Math.max(min, Math.min(value, max)),\n        min + step * Math.floor(1e-14 + (value - min) / step + (offset || 0))\n      );\n}\n","/**\n * @param {*} value\n * @returns {value is Date}\n */\nexport function isDate(value) {\n  return value instanceof Date;\n}\n","/**\n * @param {*} value\n * @returns {value is RegExp}\n */\nexport function isRegExp(value) {\n  return value instanceof RegExp;\n}\n","export function isObject(value) {\n  return value === Object(value);\n}\n","import { isDate } from '../../util/is-date.js';\nimport { isRegExp } from '../../util/is-regexp.js';\nimport { isObject } from '../../util/is-object.js';\n\n/**\n * Compare two values for equality, using join semantics in which null\n * !== null. If the inputs are object-valued, a deep equality check\n * of array entries or object key-value pairs is performed.\n * @param {*} a The first input.\n * @param {*} b The second input.\n * @return {boolean} True if equal, false if not.\n */\nexport function equal(a, b) {\n  return (a == null || b == null || a !== a || b !== b) ? false\n    : a === b ? true\n    : (isDate(a) || isDate(b)) ? +a === +b\n    : (isRegExp(a) && isRegExp(b)) ? a + '' === b + ''\n    : (isObject(a) && isObject(b)) ? deepEqual(a, b)\n    : false;\n}\n\nfunction deepEqual(a, b) {\n  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n    return false;\n  }\n\n  if (a.length || b.length) {\n    return arrayEqual(a, b);\n  }\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  keysA.sort();\n  keysB.sort();\n\n  if (!arrayEqual(keysA, keysB, (a, b) => a === b)) {\n    return false;\n  }\n\n  const n = keysA.length;\n  for (let i = 0; i < n; ++i) {\n    const k = keysA[i];\n    if (!equal(a[k], b[k])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction arrayEqual(a, b, test = equal) {\n  const n = a.length;\n  if (n !== b.length) return false;\n\n  for (let i = 0; i < n; ++i) {\n    if (!test(a[i], b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Recodes an input value to an alternative value, based on a provided\n * value map. If a fallback value is specified, it will be returned when\n * a matching value is not found in the map; otherwise, the input value\n * is returned unchanged.\n * @template T\n * @param {T} value The value to recode. The value must be safely\n *  coercible to a string for lookup against the value map.\n * @param {Map|Record<string,any>} map An object or Map with input values\n *  for keys and output recoded values as values. If a non-Map object, only\n *  the object's own properties will be considered.\n * @param {T} [fallback] A default fallback value to use if the input\n *  value is not found in the value map.\n * @return {T} The recoded value.\n */\nexport function recode(value, map, fallback) {\n  if (map instanceof Map) {\n    if (map.has(value)) return map.get(value);\n  } else {\n    const key = `${value}`;\n    if (Object.hasOwn(map, key)) return map[key];\n  }\n  return fallback !== undefined ? fallback : value;\n}\n","/**\n * Returns an array containing an arithmetic sequence from the start value\n * to the stop value, in step increments. If step is positive, the last\n * element is the largest start + i * step less than stop; if step is\n * negative, the last element is the smallest start + i * step greater\n * than stop. If the returned array would contain an infinite number of\n * values, an empty range is returned.\n * @param {number} [start=0] The starting value of the sequence.\n * @param {number} [stop] The stopping value of the sequence.\n *  The stop value is exclusive; it is not included in the result.\n * @param {number} [step=1] The step increment between sequence values.\n * @return {number[]} The generated sequence.\n */\nexport function sequence(start, stop, step) {\n  let n = arguments.length;\n  start = +start;\n  stop = +stop;\n  step = n < 2\n    ? (stop = start, start = 0, 1)\n    : n < 3 ? 1 : +step;\n\n  n = Math.max(0, Math.ceil((stop - start) / step)) | 0;\n  const seq = new Array(n);\n\n  for (let i = 0; i < n; ++i) {\n    seq[i] = start + i * step;\n  }\n\n  return seq;\n}\n","/**\n * Default NULL (missing) value to use.\n */\nexport const NULL = undefined;\n","/**\n * @param {*} value\n * @returns {value is Array}\n */\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n","const TypedArray = Object.getPrototypeOf(Int8Array);\n\n/**\n * @param {*} value\n * @return {value is import(\"../table/types.js\").TypedArray}\n */\nexport function isTypedArray(value) {\n  return value instanceof TypedArray;\n}\n","import { isArray } from './is-array.js';\nimport { isTypedArray } from './is-typed-array.js';\n\n/**\n * @param {*} value\n * @return {value is (any[] | import('../table/types.js').TypedArray)}\n */\nexport function isArrayType(value) {\n  return isArray(value) || isTypedArray(value);\n}\n","/**\n * @param {*} value\n * @return {value is String}\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n","export function isValid(value) {\n  return value != null && value === value;\n}\n","import { NULL } from '../../util/null.js';\nimport { isArrayType } from '../../util/is-array-type.js';\nimport { isString } from '../../util/is-string.js';\nimport { isValid } from '../../util/is-valid.js';\n\nconst isSeq = (seq) => isArrayType(seq) || isString(seq);\n\n/**\n * Returns a new compacted array with invalid values\n * (`null`, `undefined`, `NaN`) removed.\n * @template T\n * @param {T[]} array The input array.\n * @return {T[]} A compacted array.\n */\nexport function compact(array) {\n  return isArrayType(array)\n    ? array.filter(v => isValid(v))\n    : array;\n}\n\n/**\n * Merges two or more arrays in sequence, returning a new array.\n * @template T\n * @param {...(T|T[])} values The arrays to merge.\n * @return {T[]} The merged array.\n */\nexport function concat(...values) {\n  return [].concat(...values);\n}\n\n/**\n * Determines whether an *array* includes a certain *value* among its\n * entries, returning `true` or `false` as appropriate.\n * @template T\n * @param {T[]} sequence The input array value.\n * @param {T} value The value to search for.\n * @param {number} [index=0] The integer index to start searching\n *  from (default `0`).\n * @return {boolean} True if the value is included, false otherwise.\n */\nexport function includes(sequence, value, index) {\n  return isSeq(sequence)\n    ? sequence.includes(value, index)\n    : false;\n}\n\n/**\n * Returns the first index at which a given *value* can be found in the\n * *sequence* (array or string), or -1 if it is not present.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @param {T} value The value to search for.\n * @return {number} The index of the value, or -1 if not present.\n */\nexport function indexof(sequence, value) {\n  return isSeq(sequence)\n    // @ts-ignore\n    ? sequence.indexOf(value)\n    : -1;\n}\n\n/**\n * Creates and returns a new string by concatenating all of the elements\n * in an *array* (or an array-like object), separated by commas or a\n * specified *delimiter* string. If the *array* has only one item, then\n * that item will be returned without using the delimiter.\n * @template T\n * @param {T[]} array The input array value.\n * @param {string} delim The delimiter string (default `','`).\n * @return {string} The joined string.\n */\nexport function join(array, delim) {\n  return isArrayType(array) ? array.join(delim) : NULL;\n}\n\n/**\n * Returns the last index at which a given *value* can be found in the\n * *sequence* (array or string), or -1 if it is not present.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @param {T} value The value to search for.\n * @return {number} The last index of the value, or -1 if not present.\n */\nexport function lastindexof(sequence, value) {\n  return isSeq(sequence)\n    // @ts-ignore\n    ? sequence.lastIndexOf(value)\n    : -1;\n}\n\n/**\n * Returns the length of the input *sequence* (array or string).\n * @param {Array|string} sequence The input array or string value.\n * @return {number} The length of the sequence.\n */\nexport function length(sequence) {\n  return isSeq(sequence) ? sequence.length : 0;\n}\n\n/**\n * Returns a new array in which the given *property* has been extracted\n * for each element in the input *array*.\n * @param {Array} array The input array value.\n * @param {string} property The property name string to extract. Nested\n *  properties are not supported: the input `\"a.b\"` will indicates a\n *  property with that exact name, *not* a nested property `\"b\"` of\n *  the object `\"a\"`.\n * @return {Array} An array of plucked properties.\n */\nexport function pluck(array, property) {\n  return isArrayType(array)\n    ? array.map(v => isValid(v) ? v[property] : NULL)\n    : NULL;\n}\n\n/**\n * Returns a new array or string with the element order reversed: the first\n * *sequence* element becomes the last, and the last *sequence* element\n * becomes the first. The input *sequence* is unchanged.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @return {T[]|string} The reversed sequence.\n */\nexport function reverse(sequence) {\n  return isArrayType(sequence) ? sequence.slice().reverse()\n    : isString(sequence) ? sequence.split('').reverse().join('')\n    : NULL;\n}\n\n/**\n * Returns a copy of a portion of the input *sequence* (array or string)\n * selected from *start* to *end* (*end* not included) where *start* and\n * *end* represent the index of items in the sequence.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @param {number} [start=0] The starting integer index to copy from\n *  (inclusive, default `0`).\n * @param {number} [end] The ending integer index to copy from (exclusive,\n *  default `sequence.length`).\n * @return {T[]|string} The sliced sequence.\n */\nexport function slice(sequence, start, end) {\n  return isSeq(sequence)\n    ? sequence.slice(start, end)\n    : NULL;\n}\n","export function pad(value, width, char = '0') {\n  const s = value + '';\n  const len = s.length;\n  return len < width ? Array(width - len + 1).join(char) + s : s;\n}\n","import { pad } from './pad.js';\n\nconst pad2 = v => (v < 10 ? '0' : '') + v;\n\nconst formatYear = year => year < 0 ? '-' + pad(-year, 6)\n  : year > 9999 ? '+' + pad(year, 6)\n  : pad(year, 4);\n\nexport function formatISO(year, month, date, hours, min, sec, ms, utc, short) {\n  const suffix = utc ? 'Z' : '';\n  return formatYear(year) + '-' + pad2(month + 1) + '-' + pad2(date) + (\n    !short || ms ? 'T' + pad2(hours) + ':' + pad2(min) + ':' + pad2(sec) + '.' + pad(ms, 3) + suffix\n    : sec ? 'T' + pad2(hours) + ':' + pad2(min) + ':' + pad2(sec) + suffix\n    : min || hours || !utc ? 'T' + pad2(hours) + ':' + pad2(min) + suffix\n    : ''\n  );\n}\n\nexport function formatDate(d, short) {\n  return isNaN(d)\n    ? 'Invalid Date'\n    : formatISO(\n      d.getFullYear(),\n      d.getMonth(),\n      d.getDate(),\n      d.getHours(),\n      d.getMinutes(),\n      d.getSeconds(),\n      d.getMilliseconds(),\n      false, short\n    );\n}\n\nexport function formatUTCDate(d, short) {\n  return isNaN(d)\n    ? 'Invalid Date'\n    : formatISO(\n      d.getUTCFullYear(),\n      d.getUTCMonth(),\n      d.getUTCDate(),\n      d.getUTCHours(),\n      d.getUTCMinutes(),\n      d.getUTCSeconds(),\n      d.getUTCMilliseconds(),\n      true, short\n    );\n}\n","const iso_re = /^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/;\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport function isISODateString(value) {\n  return value.match(iso_re) && !isNaN(Date.parse(value));\n}\n","import { isISODateString } from './is-iso-date-string.js';\n\nexport function parseISODate(value, parse = Date.parse) {\n  return isISODateString(value) ? parse(value) : value;\n}\n","import { formatDate, formatUTCDate } from '../../util/format-date.js';\nimport { parseISODate } from '../../util/parse-iso-date.js';\n\nconst msMinute = 6e4;\nconst msDay = 864e5;\nconst msWeek = 6048e5;\n\nconst t0 = new Date();\nconst t1 = new Date();\nconst t = d => (\n  t0.setTime(typeof d === 'string' ? parseISODate(d) : d),\n  t0\n);\n\n/**\n * Returns an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted\n * string for the given *date* in local timezone. The resulting string is\n * compatible with *parse_date* and JavaScript's built-in *Date.parse*.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {boolean} [shorten=false] A boolean flag (default `false`)\n *  indicating if the formatted string should be shortened if possible.\n *  For example, the local date `2001-01-01` will shorten from\n *  `\"2001-01-01T00:00:00.000\"` to `\"2001-01-01T00:00\"`.\n * @return {string} The formatted date string in local time.\n */\nexport function format_date(date, shorten) {\n  return formatDate(t(date), !shorten);\n}\n\n/**\n * Returns an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted\n * string for the given *date* in Coordinated Universal Time (UTC). The\n * resulting string is compatible with *parse_date* and JavaScript's\n * built-in *Date.parse*.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {boolean} [shorten=false] A boolean flag (default `false`)\n *  indicating if the formatted string should be shortened if possible.\n *  For example, the the UTC date `2001-01-01` will shorten from\n *  `\"2001-01-01T00:00:00.000Z\"` to `\"2001-01-01\"`\n * @return {string} The formatted date string in UTC time.\n */\nexport function format_utcdate(date, shorten){\n  return formatUTCDate(t(date), !shorten);\n}\n\n/**\n * Returns the number of milliseconds elapsed since midnight, January 1,\n * 1970 Universal Coordinated Time (UTC).\n * @return {number} The timestamp for now.\n */\nexport function now() {\n  return Date.now();\n}\n\n/**\n * Returns the timestamp for a *date* as the number of milliseconds elapsed\n * since January 1, 1970 00:00:00 UTC.\n * @param {Date | number} date The input Date value.\n * @return {number} The timestamp value.\n */\nexport function timestamp(date) {\n  return +t(date);\n}\n\n/**\n * Creates and returns a new Date value. If no arguments are provided,\n * the current date and time are used.\n * @param {number} [year] The year.\n * @param {number} [month=0] The (zero-based) month.\n * @param {number} [date=1] The date within the month.\n * @param {number} [hours=0] The hour within the day.\n * @param {number} [minutes=0] The minute within the hour.\n * @param {number} [seconds=0] The second within the minute.\n * @param {number} [milliseconds=0] The milliseconds within the second.\n * @return {Date} The Date value.\n */\nexport function datetime(year, month, date, hours, minutes, seconds, milliseconds) {\n  return !arguments.length\n    ? new Date(Date.now())\n    : new Date(\n        year,\n        month || 0,\n        date == null ? 1 : date,\n        hours || 0,\n        minutes || 0,\n        seconds || 0,\n        milliseconds || 0\n      );\n}\n\n/**\n * Returns the year of the specified *date* according to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The year value in local time.\n */\nexport function year(date) {\n  return t(date).getFullYear();\n}\n\n/**\n * Returns the zero-based quarter of the specified *date* according to\n * local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The quarter value in local time.\n */\nexport function quarter(date) {\n  return Math.floor(t(date).getMonth() / 3);\n}\n\n/**\n * Returns the zero-based month of the specified *date* according to local\n * time. A value of `0` indicates January, `1` indicates February, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The month value in local time.\n */\nexport function month(date) {\n  return t(date).getMonth();\n}\n\n/**\n * Returns the week number of the year (0-53) for the specified *date*\n * according to local time. By default, Sunday is used as the first day\n * of the week. All days in a new year preceding the first Sunday are\n * considered to be in week 0.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {number} firstday The number of first day of the week (default\n *  `0` for Sunday, `1` for Monday and so on).\n * @return {number} The week of the year in local time.\n */\nexport function week(date, firstday) {\n  const i = firstday || 0;\n  t1.setTime(+date);\n  t1.setDate(t1.getDate() - (t1.getDay() + 7 - i) % 7);\n  t1.setHours(0, 0, 0, 0);\n  t0.setTime(+date);\n  t0.setMonth(0);\n  t0.setDate(1);\n  t0.setDate(1 - (t0.getDay() + 7 - i) % 7);\n  t0.setHours(0, 0, 0, 0);\n  const tz = (t1.getTimezoneOffset() - t0.getTimezoneOffset()) * msMinute;\n  return Math.floor((1 + (+t1 - +t0) - tz) / msWeek);\n}\n\n/**\n * Returns the date (day of month) of the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The date (day of month) value.\n */\nexport function date(date) {\n  return t(date).getDate();\n}\n\n/**\n * Returns the day of the year (1-366) of the specified *date* according\n * to local time.\n * @param {Date | number} date A date or timestamp.\n * @return {number} The day of the year in local time.\n */\nexport function dayofyear(date) {\n  t1.setTime(+date);\n  t1.setHours(0, 0, 0, 0);\n  t0.setTime(+t1);\n  t0.setMonth(0);\n  t0.setDate(1);\n  const tz = (t1.getTimezoneOffset() - t0.getTimezoneOffset()) * msMinute;\n  return Math.floor(1 + ((+t1 - +t0) - tz) / msDay);\n}\n\n/**\n * Returns the Sunday-based day of the week (0-6) of the specified *date*\n * according to local time. A value of `0` indicates Sunday, `1` indicates\n * Monday, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The day of the week value in local time.\n */\nexport function dayofweek(date) {\n  return t(date).getDay();\n}\n\n/**\n * Returns the hour of the day for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The hour value in local time.\n */\nexport function hours(date) {\n  return t(date).getHours();\n}\n\n/**\n * Returns the minute of the hour for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The minutes value in local time.\n */\nexport function minutes(date) {\n  return t(date).getMinutes();\n}\n\n/**\n * Returns the seconds of the minute for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The seconds value in local time.\n */\nexport function seconds(date) {\n  return t(date).getSeconds();\n}\n\n/**\n * Returns the milliseconds of the second for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The milliseconds value in local time.\n */\nexport function milliseconds(date) {\n  return t(date).getMilliseconds();\n}\n\n/**\n * Creates and returns a new Date value using Coordinated Universal Time\n * (UTC). If no arguments are provided, the current date and time are used.\n * @param {number} [year] The year.\n * @param {number} [month=0] The (zero-based) month.\n * @param {number} [date=1] The date within the month.\n * @param {number} [hours=0] The hour within the day.\n * @param {number} [minutes=0] The minute within the hour.\n * @param {number} [seconds=0] The second within the minute.\n * @param {number} [milliseconds=0] The milliseconds within the second.\n * @return {Date} The Date value.\n */\nexport function utcdatetime(year, month, date, hours, minutes, seconds, milliseconds) {\n  return !arguments.length\n    ? new Date(Date.now())\n    : new Date(Date.UTC(\n        year,\n        month || 0,\n        date == null ? 1 : date,\n        hours || 0,\n        minutes || 0,\n        seconds || 0,\n        milliseconds || 0\n      ));\n}\n\n/**\n * Returns the year of the specified *date* according to Coordinated\n * Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The year value in UTC time.\n */\nexport function utcyear(date) {\n  return t(date).getUTCFullYear();\n}\n\n/**\n * Returns the zero-based quarter of the specified *date* according to\n * Coordinated Universal Time (UTC)\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The quarter value in UTC time.\n */\nexport function utcquarter(date) {\n  return Math.floor(t(date).getUTCMonth() / 3);\n}\n\n/**\n * Returns the zero-based month of the specified *date* according to\n * Coordinated Universal Time (UTC). A value of `0` indicates January,\n * `1` indicates February, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The month value in UTC time.\n */\nexport function utcmonth(date) {\n  return t(date).getUTCMonth();\n}\n\n/**\n * Returns the week number of the year (0-53) for the specified *date*\n * according to Coordinated Universal Time (UTC). By default, Sunday is\n * used as the first day of the week. All days in a new year preceding the\n * first Sunday are considered to be in week 0.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {number} firstday The number of first day of the week (default\n *  `0` for Sunday, `1` for Monday and so on).\n * @return {number} The week of the year in UTC time.\n */\nexport function utcweek(date, firstday) {\n  const i = firstday || 0;\n  t1.setTime(+date);\n  t1.setUTCDate(t1.getUTCDate() - (t1.getUTCDay() + 7 - i) % 7);\n  t1.setUTCHours(0, 0, 0, 0);\n  t0.setTime(+date);\n  t0.setUTCMonth(0);\n  t0.setUTCDate(1);\n  t0.setUTCDate(1 - (t0.getUTCDay() + 7 - i) % 7);\n  t0.setUTCHours(0, 0, 0, 0);\n  return Math.floor((1 + (+t1 - +t0)) / msWeek);\n}\n\n/**\n * Returns the date (day of month) of the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The date (day of month) value in UTC time.\n */\nexport function utcdate(date) {\n  return t(date).getUTCDate();\n}\n\n/**\n * Returns the day of the year (1-366) of the specified *date* according\n * to Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The day of the year in UTC time.\n */\nexport function utcdayofyear(date) {\n  t1.setTime(+date);\n  t1.setUTCHours(0, 0, 0, 0);\n  const t0 = Date.UTC(t1.getUTCFullYear(), 0, 1);\n  return Math.floor(1 + (+t1 - t0) / msDay);\n}\n\n/**\n * Returns the Sunday-based day of the week (0-6) of the specified *date*\n * according to Coordinated Universal Time (UTC). A value of `0` indicates\n * Sunday, `1` indicates Monday, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The day of the week in UTC time.\n */\nexport function utcdayofweek(date) {\n  return t(date).getUTCDay();\n}\n\n/**\n * Returns the hour of the day for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The hours value in UTC time.\n */\nexport function utchours(date) {\n  return t(date).getUTCHours();\n}\n\n/**\n * Returns the minute of the hour for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The minutes value in UTC time.\n */\nexport function utcminutes(date) {\n  return t(date).getUTCMinutes();\n}\n\n/**\n * Returns the seconds of the minute for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The seconds value in UTC time.\n */\nexport function utcseconds(date) {\n  return t(date).getUTCSeconds();\n}\n\n/**\n * Returns the milliseconds of the second for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The milliseconds value in UTC time.\n */\nexport function utcmilliseconds(date) {\n  return t(date).getUTCMilliseconds();\n}\n","/**\n * Parses a string *value* in JSON format, constructing the JavaScript\n * value or object described by the string.\n * @param {string} value The input string value.\n * @return {any} The parsed JSON.\n */\nexport function parse_json(value) {\n  return JSON.parse(value);\n}\n\n/**\n * Converts a JavaScript object or value to a JSON string.\n * @param {*} value The value to convert to a JSON string.\n * @return {string} The JSON string.\n */\nexport function to_json(value) {\n  return JSON.stringify(value);\n}\n","import { isValid } from './is-valid.js';\n\nlet source = Math.random;\n\nexport function random() {\n  return source();\n}\n\n/**\n * Set a seed value for random number generation.\n * If the seed is a valid number, a 32-bit linear congruential generator\n * with the given seed will be used to generate random values.\n * If the seed is null, undefined, or not a valid number, the random\n * number generator will revert to Math.random.\n * @param {number} seed The random seed value. Should either be an\n *  integer or a fraction between 0 and 1.\n */\nexport function seed(seed) {\n  source = isValid(seed) && isFinite(seed = +seed) ? lcg(seed) : Math.random;\n}\n\nfunction lcg(seed) {\n  const a = 0x19660D;\n  const c = 0x3C6EF35F;\n  const m = 1 / 0x100000000;\n  seed = (0 <= seed && seed < 1 ? seed / m : Math.abs(seed)) | 0;\n\n  // Random numbers using a Linear Congruential Generator with seed value\n  // https://en.wikipedia.org/wiki/Linear_congruential_generator\n  return () => (seed = a * seed + c | 0, m * (seed >>> 0));\n}\n","import { random as _random } from '../../util/random.js';\n\n/**\n * Return a random floating point number between 0 (inclusive) and 1\n * (exclusive). By default uses *Math.random*. Use the *seed* method\n * to instead use a seeded random number generator.\n * @return {number} A pseudorandom number between 0 and 1.\n */\nexport function random() {\n  return _random();\n}\n\n/**\n * Tests if the input *value* is not a number (`NaN`); equivalent\n * to *Number.isNaN*.\n * @param {*} value The value to test.\n * @return {boolean} True if the value is not a number, false otherwise.\n */\nexport function is_nan(value) {\n  return Number.isNaN(value);\n}\n\n/**\n * Tests if the input *value* is finite; equivalent to *Number.isFinite*.\n * @param {*} value The value to test.\n * @return {boolean} True if the value is finite, false otherwise.\n */\nexport function is_finite(value) {\n  return Number.isFinite(value);\n}\n\n/**\n * Returns the absolute value of the input *value*; equivalent to *Math.abs*.\n * @param {number} value The input number value.\n * @return {number} The absolute value.\n */\nexport function abs(value) {\n  return Math.abs(value);\n}\n\n/**\n * Returns the cube root value of the input *value*; equivalent to\n * *Math.cbrt*.\n * @param {number} value The input number value.\n * @return {number} The cube root value.\n */\nexport function cbrt(value) {\n  return Math.cbrt(value);\n}\n\n/**\n * Returns the ceiling of the input *value*, the nearest integer equal to\n * or greater than the input; equivalent to *Math.ceil*.\n * @param {number} value The input number value.\n * @return {number} The ceiling value.\n */\nexport function ceil(value) {\n  return Math.ceil(value);\n}\n\n/**\n * Returns the number of leading zero bits in the 32-bit binary\n * representation of a number *value*; equivalent to *Math.clz32*.\n * @param {number} value The input number value.\n * @return {number} The leading zero bits value.\n */\nexport function clz32(value) {\n  return Math.clz32(value);\n}\n\n/**\n * Returns *e<sup>value</sup>*, where *e* is Euler's number, the base of the\n * natural logarithm; equivalent to *Math.exp*.\n * @param {number} value The input number value.\n * @return {number} The base-e exponentiated value.\n */\nexport function exp(value) {\n  return Math.exp(value);\n}\n\n/**\n * Returns *e<sup>value</sup> - 1*, where *e* is Euler's number, the base of\n * the natural logarithm; equivalent to *Math.expm1*.\n * @param {number} value The input number value.\n * @return {number} The base-e exponentiated value minus 1.\n */\nexport function expm1(value) {\n  return Math.expm1(value);\n}\n\n/**\n * Returns the floor of the input *value*, the nearest integer equal to or\n * less than the input; equivalent to *Math.floor*.\n * @param {number} value The input number value.\n * @return {number} The floor value.\n */\nexport function floor(value) {\n  return Math.floor(value);\n}\n\n/**\n * Returns the nearest 32-bit single precision float representation of the\n * input number *value*; equivalent to *Math.fround*. Useful for translating\n * between 64-bit `Number` values and values from a `Float32Array`.\n * @param {number} value The input number value.\n * @return {number} The rounded value.\n */\nexport function fround(value) {\n  return Math.fround(value);\n}\n\n/**\n * Returns the greatest (maximum) value among the input *values*; equivalent\n * to *Math.max*. This is _not_ an aggregate function, see *op.max* to\n * compute a maximum value across multiple rows.\n * @param {...number} values The input number values.\n * @return {number} The greatest (maximum) value among the inputs.\n */\nexport function greatest(...values) {\n  return Math.max(...values);\n}\n\n/**\n * Returns the least (minimum) value among the input *values*; equivalent\n * to *Math.min*. This is _not_ an aggregate function, see *op.min* to\n * compute a minimum value across multiple rows.\n * @param {...number} values The input number values.\n * @return {number} The least (minimum) value among the inputs.\n */\nexport function least(...values) {\n  return Math.min(...values);\n}\n\n/**\n * Returns the natural logarithm (base *e*) of a number *value*; equivalent\n * to *Math.log*.\n * @param {number} value The input number value.\n * @return {number} The base-e log value.\n */\nexport function log(value) {\n  return Math.log(value);\n}\n\n/**\n * Returns the base 10 logarithm of a number *value*; equivalent\n * to *Math.log10*.\n * @param {number} value The input number value.\n * @return {number} The base-10 log value.\n */\nexport function log10(value) {\n  return Math.log10(value);\n}\n\n/**\n * Returns the natural logarithm (base *e*) of 1 + a number *value*;\n * equivalent to *Math.log1p*.\n * @param {number} value The input number value.\n * @return {number} The base-e log of value + 1.\n */\nexport function log1p(value) {\n  return Math.log1p(value);\n}\n\n/**\n * Returns the base 2 logarithm of a number *value*; equivalent\n * to *Math.log2*.\n * @param {number} value The input number value.\n * @return {number} The base-2 log value.\n */\nexport function log2(value) {\n  return Math.log2(value);\n}\n\n/**\n * Returns the *base* raised to the *exponent* power, that is,\n * *base*<sup>*exponent*</sup>; equivalent to *Math.pow*.\n * @param {number} base The base number value.\n * @param {number} exponent The exponent number value.\n * @return {number} The exponentiated value.\n */\nexport function pow(base, exponent) {\n  return Math.pow(base, exponent);\n}\n\n/**\n * Returns the value of a number rounded to the nearest integer;\n * equivalent to *Math.round*.\n * @param {number} value The input number value.\n * @return {number} The rounded value.\n */\nexport function round(value) {\n  return Math.round(value);\n}\n\n/**\n * Returns either a positive or negative +/- 1, indicating the sign of the\n * input *value*; equivalent to *Math.sign*.\n * @param {number} value The input number value.\n * @return {number} The sign of the value.\n */\nexport function sign(value) {\n  return Math.sign(value);\n}\n\n/**\n * Returns the square root of the input *value*; equivalent to *Math.sqrt*.\n * @param {number} value The input number value.\n * @return {number} The square root value.\n */\nexport function sqrt(value) {\n  return Math.sqrt(value);\n}\n\n/**\n * Returns the integer part of a number by removing any fractional digits;\n * equivalent to *Math.trunc*.\n * @param {number} value The input number value.\n * @return {number} The truncated value.\n */\nexport function trunc(value) {\n  return Math.trunc(value);\n}\n\n/**\n * Converts the input *radians* value to degrees.\n * @param {number} radians The input radians value.\n * @return {number} The value in degrees\n */\nexport function degrees(radians) {\n  return 180 * radians / Math.PI;\n}\n\n/**\n * Converts the input *degrees* value to radians.\n * @param {number} degrees The input degrees value.\n * @return {number} The value in radians.\n */\nexport function radians(degrees) {\n  return Math.PI * degrees / 180;\n}\n\n/**\n * Returns the arc-cosine (in radians) of a number *value*;\n * equivalent to *Math.acos*.\n * @param {number} value The input number value.\n * @return {number} The arc-cosine value.\n */\nexport function acos(value) {\n  return Math.acos(value);\n}\n\n/**\n * Returns the hyperbolic arc-cosine of a number *value*;\n * equivalent to *Math.acosh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic arc-cosine value.\n */\nexport function acosh(value) {\n  return Math.acosh(value);\n}\n\n/**\n * Returns the arc-sine (in radians) of a number *value*;\n * equivalent to *Math.asin*.\n * @param {number} value The input number value.\n * @return {number} The arc-sine value.\n */\nexport function asin(value) {\n  return Math.asin(value);\n}\n\n/**\n * Returns the hyperbolic arc-sine of a number *value*;\n * equivalent to *Math.asinh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic arc-sine value.\n */\nexport function asinh(value) {\n  return Math.asinh(value);\n}\n\n/**\n * Returns the arc-tangent (in radians) of a number *value*;\n * equivalent to *Math.atan*.\n * @param {number} value The input number value.\n * @return {number} The arc-tangent value.\n */\nexport function atan(value) {\n  return Math.atan(value);\n}\n\n/**\n * Returns the angle in the plane (in radians) between the positive x-axis\n * and the ray from (0, 0) to the point (*x*, *y*);\n * equivalent to *Math.atan2*.\n * @param {number} y The y coordinate of the point.\n * @param {number} x The x coordinate of the point.\n * @return {number} The arc-tangent angle.\n */\nexport function atan2(y, x) {\n  return Math.atan2(y, x);\n}\n\n/**\n * Returns the hyperbolic arc-tangent of a number *value*;\n * equivalent to *Math.atanh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic arc-tangent value.\n */\nexport function atanh(value) {\n  return Math.atanh(value);\n}\n\n/**\n * Returns the cosine (in radians) of a number *value*;\n * equivalent to *Math.cos*.\n * @param {number} value The input number value.\n * @return {number} The cosine value.\n */\nexport function cos(value) {\n  return Math.cos(value);\n}\n\n/**\n * Returns the hyperbolic cosine (in radians) of a number *value*;\n * equivalent to *Math.cosh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic cosine value.\n */\nexport function cosh(value) {\n  return Math.cosh(value);\n}\n\n/**\n * Returns the sine (in radians) of a number *value*;\n * equivalent to *Math.sin*.\n * @param {number} value The input number value.\n * @return {number} The sine value.\n */\nexport function sin(value) {\n  return Math.sin(value);\n}\n\n/**\n * Returns the hyperbolic sine (in radians) of a number *value*;\n * equivalent to *Math.sinh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic sine value.\n */\nexport function sinh(value) {\n  return Math.sinh(value);\n}\n\n/**\n * Returns the tangent (in radians) of a number *value*;\n * equivalent to *Math.tan*.\n * @param {number} value The input number value.\n * @return {number} The tangent value.\n */\nexport function tan(value) {\n  return Math.tan(value);\n}\n\n/**\n * Returns the hyperbolic tangent (in radians) of a number *value*;\n * equivalent to *Math.tanh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic tangent value.\n */\nexport function tanh(value) {\n  return Math.tanh(value);\n}\n","/**\n * @param {*} value\n * @return {value is Map}\n */\nexport function isMap(value) {\n  return value instanceof Map;\n}\n","/**\n * @param {*} value\n * @return {value is Set}\n */\nexport function isSet(value) {\n  return value instanceof Set;\n}\n","import { isMap } from './is-map.js';\nimport { isSet } from './is-set.js';\n\n/**\n * @param {*} value\n * @return {value is Map | Set}\n */\nexport function isMapOrSet(value) {\n  return isMap(value) || isSet(value);\n}\n","import { NULL } from '../../util/null.js';\nimport { isMap } from '../../util/is-map.js';\nimport { isMapOrSet } from '../../util/is-map-or-set.js';\n\nfunction array(iter) {\n  return Array.from(iter);\n}\n\n/**\n * Returns a boolean indicating whether the *object* has the specified *key*\n * as its own property (as opposed to inheriting it). If the *object* is a\n * *Map* or *Set* instance, the *has* method will be invoked directly on the\n * object, otherwise *Object.hasOwnProperty* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V>|Set<K>|Record<K, V>} object The object, Map, or Set to\n *  test for property membership.\n * @param {K} key The property key to test for.\n * @return {boolean} True if the object has the given key, false otherwise.\n */\nexport function has(object, key) {\n  return isMapOrSet(object) ? object.has(key)\n    : object != null ? Object.hasOwn(object, `${key}`)\n    : false;\n}\n\n/**\n * Returns an array of a given *object*'s own enumerable property names. If\n * the *object* is a *Map* instance, the *keys* method will be invoked\n * directly on the object, otherwise *Object.keys* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V>|Record<K, V>} object The input object or Map value.\n * @return {K[]} An array of property key name strings.\n */\nexport function keys(object) {\n  return isMap(object) ? array(object.keys())\n    : object != null ? /** @type {K[]} */(Object.keys(object))\n    : [];\n}\n\n/**\n * Returns an array of a given *object*'s own enumerable property values. If\n * the *object* is a *Map* or *Set* instance, the *values* method will be\n * invoked directly on the object, otherwise *Object.values* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V> | Set<V> | Record<K, V>} object The input object, Map,\n *  or Set value.\n * @return {V[]} An array of property values.\n */\nexport function values(object) {\n  return isMapOrSet(object) ? array(object.values())\n    : object != null ? Object.values(object)\n    : [];\n}\n\n/**\n * Returns an array of a given *object*'s own enumerable keyed property\n * `[key, value]` pairs. If the *object* is a *Map* or *Set* instance, the\n * *entries* method will be invoked directly on the object, otherwise\n * *Object.entries* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V> | Set<V> | Record<K, V>} object The input object, Map,\n *  or Set value.\n * @return {[K, V][]} An array of property values.\n */\nexport function entries(object) {\n  return isMapOrSet(object) ? array(object.entries())\n    : object != null ? /** @type {[K, V][]} */(Object.entries(object))\n    : [];\n}\n\n/**\n * Returns a new object given iterable *entries* of `[key, value]` pairs.\n * This method is Arquero's version of the *Object.fromEntries* method.\n * @template {string | number} K\n * @template V\n * @param {Iterable<[K, V]>} entries An iterable collection of `[key, value]`\n *  pairs, such as an array of two-element arrays or a *Map*.\n * @return {Record<K, V>} An object of consolidated key-value pairs.\n */\nexport function object(entries) {\n  return entries\n    ? /** @type {Record<K, V>} */(Object.fromEntries(entries))\n    : NULL;\n}\n","/**\n * Parses a string *value* and returns a Date instance. Beware: this method\n * uses JavaScript's *Date.parse()* functionality, which is inconsistently\n * implemented across browsers. That said,\n * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted strings such\n * as those produced by *op.format_date* and *op.format_utcdate* should be\n * supported across platforms. Note that \"bare\" ISO date strings such as\n * `\"2001-01-01\"` are interpreted by JavaScript as indicating midnight of\n * that day in Coordinated Universal Time (UTC), *not* local time. To\n * indicate the local timezone, an ISO string can include additional time\n * components and no `Z` suffix: `\"2001-01-01T00:00\"`.\n * @param {*} value The input value.\n * @return {Date} The parsed date value.\n */\nexport function parse_date(value) {\n  return value == null ? value : new Date(value);\n}\n\n/**\n * Parses a string *value* and returns a floating point number.\n * @param {*} value The input value.\n * @return {number} The parsed number value.\n */\nexport function parse_float(value) {\n  return value == null ? value : Number.parseFloat(value);\n}\n\n/**\n * Parses a string *value* and returns an integer of the specified radix\n * (the base in mathematical numeral systems).\n * @param {*} value The input value.\n * @param {number} [radix] An integer between 2 and 36 that represents the\n *  radix (the base in mathematical numeral systems) of the string. Be\n *  careful: this does not default to 10! If *radix* is `undefined`, `0`,\n *  or unspecified, JavaScript assumes the following: If the input string\n *  begins with `\"0x\"` or `\"0X\"` (a zero, followed by lowercase or\n *  uppercase X), the radix is assumed to be 16 and the rest of the string\n *  is parsed as a hexidecimal number. If the input string begins with `\"0\"`\n *  (a zero), the radix is assumed to be 8 (octal) or 10 (decimal). Exactly\n *  which radix is chosen is implementation-dependent.  If the input string\n *  begins with any other value, the radix is 10 (decimal).\n * @return {number} The parsed integer value.\n */\nexport function parse_int(value, radix) {\n  return value == null ? value : Number.parseInt(value, radix);\n}\n\n/**\n * Determines whether a string *value* ends with the characters of a\n * specified *search* string, returning `true` or `false` as appropriate.\n * @param {any} value The input string value.\n * @param {string} search The search string to test for.\n * @param {number} [length] If provided, used as the length of *value*\n *  (default `value.length`).\n * @return {boolean} True if the value ends with the search string,\n *  false otherwise.\n */\nexport function endswith(value, search, length) {\n  return value == null ? false : String(value).endsWith(search, length);\n}\n\n/**\n * Retrieves the result of matching a string *value* against a regular\n * expression *regexp*. If no *index* is specified, returns an array\n * whose contents depend on the presence or absence of the regular\n * expression global (`g`) flag, or `null` if no matches are found. If the\n * `g` flag is used, all results matching the complete regular expression\n * will be returned, but capturing groups will not. If the `g` flag is not\n * used, only the first complete match and its related capturing groups are\n * returned.\n *\n * If specified, the *index* looks up a value of the resulting match. If\n * *index* is a number, the corresponding index of the result array is\n * returned. If *index* is a string, the value of the corresponding\n * named capture group is returned, or `null` if there is no such group.\n * @param {*} value The input string value.\n * @param {*} regexp The regular expression to match against.\n * @param {number|string} index The index into the match result array\n *  or capture group.\n * @return {string|string[]} The match result.\n */\nexport function match(value, regexp, index) {\n  const m = value == null ? value : String(value).match(regexp);\n  return index == null || m == null ? m\n    : typeof index === 'number' ? m[index]\n    : m.groups ? m.groups[index]\n    : null;\n}\n\n/**\n * Returns the Unicode normalization form of the string *value*.\n * @param {*} value The input value to normalize.\n * @param {string} form The Unicode normalization form, one of\n *  `'NFC'` (default, canonical decomposition, followed by canonical\n *  composition), `'NFD'` (canonical decomposition), `'NFKC'` (compatibility\n *  decomposition, followed by canonical composition),\n *  or `'NFKD'` (compatibility decomposition).\n * @return {string} The normalized string value.\n */\nexport function normalize(value, form) {\n  return value == null ? value : String(value).normalize(form);\n}\n\n/**\n * Pad a string *value* with a given *fill* string (applied from the end of\n * *value* and repeated, if needed) so that the resulting string reaches a\n * given *length*.\n * @param {*} value The input value to pad.\n * @param {number} length The length of the resulting string once the\n *  *value* string has been padded. If the length is lower than\n *  `value.length`, the *value* string will be returned as-is.\n * @param {string} [fill] The string to pad the *value* string with\n *  (default `''`). If *fill* is too long to stay within the target\n *  *length*, it will be truncated: for left-to-right languages the\n *  left-most part and for right-to-left languages the right-most will\n *  be applied.\n * @return {string} The padded string.\n */\nexport function padend(value, length, fill) {\n  return value == null ? value : String(value).padEnd(length, fill);\n}\n\n/**\n * Pad a string *value* with a given *fill* string (applied from the start\n * of *value* and repeated, if needed) so that the resulting string reaches\n * a given *length*.\n * @param {*} value The input value to pad.\n * @param {number} length The length of the resulting string once the\n *  *value* string has been padded. If the length is lower than\n *  `value.length`, the *value* string will be returned as-is.\n * @param {string} [fill] The string to pad the *value* string with\n *  (default `''`). If *fill* is too long to stay within the target\n *  *length*, it will be truncated: for left-to-right languages the\n *  left-most part and for right-to-left languages the right-most will\n *  be applied.\n * @return {string} The padded string.\n */\nexport function padstart(value, length, fill) {\n  return value == null ? value : String(value).padStart(length, fill);\n}\n\n/**\n * Returns the string *value* converted to upper case.\n * @param {*} value The input string value.\n * @return {string} The upper case string.\n */\nexport function upper(value) {\n  return value == null ? value : String(value).toUpperCase();\n}\n\n/**\n * Returns the string *value* converted to lower case.\n * @param {*} value The input string value.\n * @return {string} The lower case string.\n */\nexport function lower(value) {\n  return value == null ? value : String(value).toLowerCase();\n}\n\n/**\n * Returns a new string which contains the specified *number* of copies of\n * the *value* string concatenated together.\n * @param {*} value The input string to repeat.\n * @param {*} number An integer between `0` and `+Infinity`, indicating the\n *  number of times to repeat the string.\n * @return {string} The repeated string.\n */\nexport function repeat(value, number) {\n  return value == null ? value : String(value).repeat(number);\n}\n\n/**\n * Returns a new string with some or all matches of a *pattern* replaced by\n * a *replacement*. The *pattern* can be a string or a regular expression,\n * and the *replacement* must be a string. If *pattern* is a string, only\n * the first occurrence will be replaced; to make multiple replacements, use\n * a regular expression *pattern* with a `g` (global) flag.\n * @param {*} value The input string value.\n * @param {*} pattern The pattern string or regular expression to replace.\n * @param {*} replacement The replacement string to use.\n * @return {string} The string with patterns replaced.\n */\nexport function replace(value, pattern, replacement) {\n  return value == null\n    ? value\n    : String(value).replace(pattern, String(replacement));\n}\n\n/**\n * Divides a string *value* into an ordered list of substrings based on a\n * *separator* pattern, puts these substrings into an array, and returns the\n * array.\n * @param {*} value The input string value.\n * @param {*} separator A string or regular expression pattern describing\n *  where each split should occur.\n * @param {number} [limit] An integer specifying a limit on the number of\n *  substrings to be included in the array.\n * @return {string[]}\n */\nexport function split(value, separator, limit) {\n  return value == null ? [] : String(value).split(separator, limit);\n}\n\n/**\n * Determines whether a string *value* starts with the characters of a\n * specified *search* string, returning `true` or `false` as appropriate.\n * @param {*} value The input string value.\n * @param {string} search The search string to test for.\n * @param {number} [position=0] The position in the *value* string at which\n *  to begin searching (default `0`).\n * @return {boolean} True if the string starts with the search pattern,\n *  false otherwise.\n */\nexport function startswith(value, search, position) {\n  return value == null ? false : String(value).startsWith(search, position);\n}\n\n/**\n * Returns the part of the string *value* between the *start* and *end*\n * indexes, or to the end of the string.\n * @param {*} value The input string value.\n * @param {number} [start=0] The index of the first character to include in\n *  the returned substring (default `0`).\n * @param {number} [end] The index of the first character to exclude from\n *  the returned substring (default `value.length`).\n * @return {string} The substring.\n */\nexport function substring(value, start, end) {\n  return value == null ? value : String(value).substring(start, end);\n}\n\n/**\n * Returns a new string with whitespace removed from both ends of the input\n * *value* string. Whitespace in this context is all the whitespace\n * characters (space, tab, no-break space, etc.) and all the line terminator\n * characters (LF, CR, etc.).\n * @param {*} value The input string value to trim.\n * @return {string} The trimmed string.\n */\nexport function trim(value) {\n  return value == null ? value : String(value).trim();\n}\n","import { bin } from './bin.js';\nimport { equal } from './equal.js';\nimport { recode } from './recode.js';\nimport { sequence } from './sequence.js';\n\nimport * as array from './array.js';\nimport * as date from './date.js';\nimport * as json from './json.js';\nimport * as math from './math.js';\nimport * as object from './object.js';\nimport * as string from './string.js';\n\nexport const functions = {\n  bin,\n  equal,\n  recode,\n  sequence,\n  ...array,\n  ...date,\n  ...json,\n  ...math,\n  ...object,\n  ...string\n};\n","import { isArray } from './is-array.js';\n\nexport function toArray(value) {\n  return value != null\n    ? (isArray(value) ? value : [value])\n    : [];\n}\n","/**\n * @param {*} value\n * @returns {value is bigint}\n */\nexport function isBigInt(value) {\n  return typeof value === 'bigint';\n}\n","import { isBigInt } from './is-bigint.js';\n\nexport function toString(v) {\n  return v === undefined ? v + ''\n    : isBigInt(v) ? v + 'n'\n    : JSON.stringify(v);\n}\n","import { functions } from './functions/index.js';\nimport { toArray } from '../util/to-array.js';\nimport { toString } from '../util/to-string.js';\n\nexport class Op {\n  constructor(name, fields, params) {\n    this.name = name;\n    this.fields = fields;\n    this.params = params;\n  }\n  toString() {\n    const args = [\n      ...this.fields.map(f => `d[${toString(f)}]`),\n      ...this.params.map(toString)\n    ];\n    return `d => op.${this.name}(${args})`;\n  }\n  toObject() {\n    return { expr: this.toString(), func: true };\n  }\n}\n\n/**\n * @param {string} name\n * @param {any | any[]} [fields]\n * @param {any | any[]} [params]\n */\nexport function op(name, fields = [], params = []) {\n  return new Op(name, toArray(fields), toArray(params));\n}\n\nexport const any = (field) => op('any', field);\nexport const count = () => op('count');\nexport const array_agg = (field) => op('array_agg', field);\nexport const array_agg_distinct = (field) => op('array_agg_distinct', field);\nexport const map_agg = (key, value) => op('map_agg', [key, value]);\nexport const object_agg = (key, value) => op('object_agg', [key, value]);\nexport const entries_agg = (key, value) => op('entries_agg', [key, value]);\n\n/**\n * @typedef {import('../table/types.js').Struct} Struct\n */\n\n/**\n * All table expression operations including normal functions,\n * aggregate functions, and window functions.\n */\nexport const opApi = {\n  ...functions,\n\n  /**\n   * Generate an object representing the current table row.\n   * @param {...string} names The column names to include in the object.\n   *  If unspecified, all columns are included.\n   * @return {Struct} The generated row object.\n   */\n  row_object: (...names) => op('row_object', null, names.flat()),\n\n  /**\n   * Aggregate function to count the number of records (rows).\n   * @returns {number} The count of records.\n   */\n  count,\n\n  /**\n   * Aggregate function returning an arbitrary observed value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} An arbitrary observed value.\n   */\n  any,\n\n  /**\n   * Aggregate function to collect an array of values.\n   * @template T\n   * @param {T} field The data field.\n   * @return {Array<T>} A list of values.\n   */\n  array_agg,\n\n  /**\n   * Aggregate function to collect an array of distinct (unique) values.\n   * @template T\n   * @param {T} field The data field.\n   * @return {Array<T>} An array of unique values.\n   */\n  array_agg_distinct,\n\n  /**\n   * Aggregate function to create an object given input key and value fields.\n   * @template K, V\n   * @param {K} key The object key field.\n   * @param {V} value The object value field.\n   * @return {Record<K, V>} An object of key-value pairs.\n   */\n  object_agg,\n\n  /**\n   * Aggregate function to create a Map given input key and value fields.\n   * @template K, V\n   * @param {K} key The object key field.\n   * @param {V} value The object value field.\n   * @return {Map<K, V>} A Map of key-value pairs.\n   */\n  map_agg,\n\n  /**\n   * Aggregate function to create an array in the style of Object.entries()\n   * given input key and value fields.\n   * @template K, V\n   * @param {K} key The object key field.\n   * @param {V} value The object value field.\n   * @return {[K, V][]} An array of [key, value] arrays.\n   */\n  entries_agg,\n\n  /**\n   * Aggregate function to count the number of valid values.\n   * Invalid values are null, undefined, or NaN.\n   * @param {*} field The data field.\n   * @return {number} The count of valid values.\n   */\n  // @ts-ignore\n  valid: (field) => op('valid', field),\n\n  /**\n   * Aggregate function to count the number of invalid values.\n   * Invalid values are null, undefined, or NaN.\n   * @param {*} field The data field.\n   * @return {number} The count of invalid values.\n   */\n  // @ts-ignore\n  invalid: (field) => op('invalid', field),\n\n  /**\n   * Aggregate function to count the number of distinct values.\n   * @param {*} field The data field.\n   * @return {number} The count of distinct values.\n   */\n  // @ts-ignore\n  distinct: (field) => op('distinct', field),\n\n  /**\n   * Aggregate function to determine the mode (most frequent) value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The mode value.\n   */\n  // @ts-ignore\n  mode: (field) => op('mode', field),\n\n  /**\n   * Aggregate function to sum values.\n   * @param {*} field The data field.\n   * @return {number} The sum of the values.\n   */\n  // @ts-ignore\n  sum: (field) => op('sum', field),\n\n  /**\n   * Aggregate function to multiply values.\n   * @param {*} field The data field.\n   * @return {number} The product of the values.\n   */\n  // @ts-ignore\n  product: (field) => op('product', field),\n\n  /**\n   * Aggregate function for the mean (average) value.\n   * @param {*} field The data field.\n   * @return {number} The mean (average) of the values.\n   */\n  // @ts-ignore\n  mean: (field) => op('mean', field),\n\n  /**\n   * Aggregate function for the average (mean) value.\n   * @param {*} field The data field.\n   * @return {number} The average (mean) of the values.\n   */\n  // @ts-ignore\n  average: (field) => op('average', field),\n\n  /**\n   * Aggregate function for the sample variance.\n   * @param {*} field The data field.\n   * @return {number} The sample variance of the values.\n   */\n  // @ts-ignore\n  variance: (field) => op('variance', field),\n\n  /**\n   * Aggregate function for the population variance.\n   * @param {*} field The data field.\n   * @return {number} The population variance of the values.\n   */\n  // @ts-ignore\n  variancep: (field) => op('variancep', field),\n\n  /**\n   * Aggregate function for the sample standard deviation.\n   * @param {*} field The data field.\n   * @return {number} The sample standard deviation of the values.\n   */\n  // @ts-ignore\n  stdev: (field) => op('stdev', field),\n\n  /**\n   * Aggregate function for the population standard deviation.\n   * @param {*} field The data field.\n   * @return {number} The population standard deviation of the values.\n   */\n  // @ts-ignore\n  stdevp: (field) => op('stdevp', field),\n\n  /**\n   * Aggregate function for the minimum value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The minimum value.\n   */\n  // @ts-ignore\n  min: (field) => op('min', field),\n\n  /**\n   * Aggregate function for the maximum value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The maximum value.\n   */\n  // @ts-ignore\n  max: (field) => op('max', field),\n\n  /**\n   * Aggregate function to compute the quantile boundary\n   * of a data field for a probability threshold.\n   * @param {*} field The data field.\n   * @param {number} p The probability threshold.\n   * @return {number} The quantile value.\n   */\n  // @ts-ignore\n  quantile: (field, p) => op('quantile', field, p),\n\n  /**\n   * Aggregate function for the median value.\n   * This is a shorthand for the 0.5 quantile value.\n   * @param {*} field The data field.\n   * @return {number} The median value.\n   */\n  // @ts-ignore\n  median: (field) => op('median', field),\n\n  /**\n   * Aggregate function for the sample covariance between two variables.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The sample covariance of the values.\n   */\n  // @ts-ignore\n  covariance: (field1, field2) => op('covariance', [field1, field2]),\n\n  /**\n   * Aggregate function for the population covariance between two variables.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The population covariance of the values.\n   */\n  // @ts-ignore\n  covariancep: (field1, field2) => op('covariancep', [field1, field2]),\n\n  /**\n   * Aggregate function for the product-moment correlation between two variables.\n   * To instead compute a rank correlation, compute the average ranks for each\n   * variable and then apply this function to the result.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The correlation between the field values.\n   */\n  // @ts-ignore\n  corr: (field1, field2) => op('corr', [field1, field2]),\n\n  /**\n   * Aggregate function for calculating a binning scheme in terms of\n   * the minimum bin boundary, maximum bin boundary, and step size.\n   * @param {*} field The data field.\n   * @param {number} [maxbins=15] The maximum number of allowed bins.\n   * @param {boolean} [nice=true] Flag indicating if the bin min and max\n   *  should snap to \"nice\" human-friendly values.\n   * @param {number} [minstep] The minimum allowed step size between bins.\n   * @param {number} [step] The exact step size to use between bins.\n   *  If specified, the maxbins and minstep arguments are ignored.\n   * @return {[number, number, number]} The bin [min, max, and step] values.\n   */\n  // @ts-ignore\n  bins: (field, maxbins, nice, minstep, step) => op(\n    'bins',\n    field,\n    [maxbins, nice, minstep, step]\n  ),\n\n  /**\n   * Window function to assign consecutive row numbers, starting from 1.\n   * @return {number} The row number value.\n   */\n  // @ts-ignore\n  row_number: () => op('row_number'),\n\n  /**\n   * Window function to assign a rank to each value in a group, starting\n   * from 1. Peer values are assigned the same rank. Subsequent ranks\n   * reflect the number of prior values: if the first two values tie for\n   * rank 1, the third value is assigned rank 3.\n   * @return {number} The rank value.\n   */\n  // @ts-ignore\n  rank: () => op('rank'),\n\n  /**\n   * Window function to assign a fractional (average) rank to each value in\n   * a group, starting from 1. Peer values are assigned the average of their\n   * indices: if the first two values tie, both will be assigned rank 1.5.\n   * @return {number} The peer-averaged rank value.\n   */\n  // @ts-ignore\n  avg_rank: () => op('avg_rank'),\n\n  /**\n   * Window function to assign a dense rank to each value in a group,\n   * starting from 1. Peer values are assigned the same rank. Subsequent\n   * ranks do not reflect the number of prior values: if the first two\n   * values tie for rank 1, the third value is assigned rank 2.\n   * @return {number} The dense rank value.\n   */\n  // @ts-ignore\n  dense_rank: () => op('dense_rank'),\n\n  /**\n   * Window function to assign a percentage rank to each value in a group.\n   * The percent is calculated as (rank - 1) / (group_size - 1).\n   * @return {number} The percentage rank value.\n   */\n  // @ts-ignore\n  percent_rank: () => op('percent_rank'),\n\n  /**\n   * Window function to assign a cumulative distribution value between 0 and 1\n   * to each value in a group.\n   * @return {number} The cumulative distribution value.\n   */\n  // @ts-ignore\n  cume_dist: () => op('cume_dist'),\n\n  /**\n   * Window function to assign a quantile (e.g., percentile) value to each\n   * value in a group. Accepts an integer parameter indicating the number of\n   * buckets to use (e.g., 100 for percentiles, 5 for quintiles).\n   * @param {number} num The number of buckets for ntile calculation.\n   * @return {number} The quantile value.\n   */\n  // @ts-ignore\n  ntile: (num) => op('ntile', null, num),\n\n  /**\n   * Window function to assign a value that precedes the current value by\n   * a specified number of positions. If no such value exists, returns a\n   * default value instead.\n   * @template T\n   * @param {T} field The data field.\n   * @param {number} [offset=1] The lag offset from the current value.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The lagging value.\n   */\n  // @ts-ignore\n  lag: (field, offset, defaultValue) => op('lag', field, [offset, defaultValue]),\n\n  /**\n   * Window function to assign a value that follows the current value by\n   * a specified number of positions. If no such value exists, returns a\n   * default value instead.\n   * @template T\n   * @param {T} field The data field.\n   * @param {number} [offset=1] The lead offset from the current value.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The leading value.\n   */\n  // @ts-ignore\n  lead: (field, offset, defaultValue) => op('lead', field, [offset, defaultValue]),\n\n  /**\n   * Window function to assign the first value in a sliding window frame.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The first value in the current frame.\n   */\n  // @ts-ignore\n  first_value: (field) => op('first_value', field),\n\n  /**\n   * Window function to assign the last value in a sliding window frame.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The last value in the current frame.\n   */\n  // @ts-ignore\n  last_value: (field) => op('last_value', field),\n\n  /**\n   * Window function to assign the nth value in a sliding window frame\n   * (counting from 1), or undefined if no such value exists.\n   * @template T\n   * @param {T} field The data field.\n   * @param {number} nth The nth position, starting from 1.\n   * @return {T} The nth value in the current frame.\n   */\n  // @ts-ignore\n  nth_value: (field, nth) => op('nth_value', field, nth),\n\n  /**\n   * Window function to fill in missing values with preceding values.\n   * @template T\n   * @param {T} field The data field.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The current value if valid, otherwise the first preceding\n   *  valid value. If no such value exists, returns the default value.\n   */\n  // @ts-ignore\n  fill_down: (field, defaultValue) => op('fill_down', field, defaultValue),\n\n  /**\n   * Window function to fill in missing values with subsequent values.\n   * @template T\n   * @param {T} field The data field.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The current value if valid, otherwise the first subsequent\n   *  valid value. If no such value exists, returns the default value.\n   */\n  // @ts-ignore\n  fill_up: (field, defaultValue) => op('fill_up', field, defaultValue)\n};\n","export function error(message, cause) {\n  // @ts-ignore\n  throw Error(message, { cause });\n}\n","import { isMapOrSet } from './is-map-or-set.js';\n\nexport function uniqueName(names, name) {\n  names = isMapOrSet(names) ? names : new Set(names);\n  let uname = name;\n  let index = 0;\n\n  while (names.has(uname)) {\n    uname = name + ++index;\n  }\n\n  return uname;\n}\n","/**\n * @param {*} value\n * @returns {value is Function}\n */\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n","import { isFunction } from './is-function.js';\n\nexport function repeat(reps, value) {\n  const result = Array(reps);\n  if (isFunction(value)) {\n    for (let i = 0; i < reps; ++i) {\n      result[i] = value(i);\n    }\n  } else {\n    result.fill(value);\n  }\n  return result;\n}\n","export function bins(min, max, maxbins = 15, nice = true, minstep = 0, step) {\n  const base = 10;\n  const logb = Math.LN10;\n\n  if (step == null) {\n    const level = Math.ceil(Math.log(maxbins) / logb);\n    const span = (max - min) || Math.abs(min) || 1;\n    const div = [5, 2];\n\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span / step) > maxbins) {\n      step *= base;\n    }\n\n    // decrease step size if it stays within maxbins\n    const n = div.length;\n    for (let i = 0; i < n; ++i) {\n      const v = step / div[i];\n      if (v >= minstep && span / v <= maxbins) {\n        step = v;\n      }\n    }\n  }\n\n  // snap to \"nice\" boundaries\n  if (nice) {\n    let v = Math.log(step);\n    const precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n    const eps = Math.pow(base, -precision - 1);\n    v = Math.floor(min / step + eps) * step;\n    min = min < v ? v - step : v;\n    max = Math.ceil(max / step) * step;\n  }\n\n  return [\n    min,\n    max === min ? min + step : max,\n    step\n  ];\n}\n","import { isArray } from './is-array.js';\nimport { isDate } from './is-date.js';\nimport { isRegExp } from './is-regexp.js';\nimport { isTypedArray } from './is-typed-array.js';\n\nexport function key(value) {\n  const type = typeof value;\n  return type === 'string' ? `\"${value}\"`\n    : type !== 'object' || !value ? value\n    : isDate(value) ? +value\n    : isArray(value) || isTypedArray(value) ? `[${value.map(key)}]`\n    : isRegExp(value) ? value + ''\n    : objectKey(value);\n}\n\nfunction objectKey(value) {\n  let s = '{';\n  let i = -1;\n  for (const k in value) {\n    if (++i > 0) s += ',';\n    s += `\"${k}\":${key(value[k])}`;\n  }\n  s += '}';\n  return s;\n}\n\nexport function keyFunction(get, nulls) {\n  const n = get.length;\n  return n === 1\n    ? (row, data) => key(get[0](row, data))\n    : (row, data) => {\n        let s = '';\n        for (let i = 0; i < n; ++i) {\n          if (i > 0) s += '|';\n          const v = get[i](row, data);\n          if (nulls && (v == null || v !== v)) return null;\n          s += key(v);\n        }\n        return s;\n      };\n}\n","import { key } from './key-function.js';\n\nexport function distinctMap() {\n  const map = new Map();\n  return {\n    count() {\n      return map.size;\n    },\n    values() {\n      return Array.from(map.values(), _ => _.v);\n    },\n    increment(v) {\n      const k = key(v);\n      const e = map.get(k);\n      e ? ++e.n : map.set(k, { v, n: 1 });\n    },\n    decrement(v) {\n      const k = key(v);\n      const e = map.get(k);\n      e.n === 1 ? map.delete(k) : --e.n;\n    },\n    forEach(fn) {\n      map.forEach(({ v, n }) => fn(v, n));\n    }\n  };\n}\n","export function noop() {}\n","export function product(values, start = 0, stop = values.length) {\n  let prod = values[start++];\n\n  for (let i = start; i < stop; ++i) {\n    prod *= values[i];\n  }\n\n  return prod;\n}\n","import { bins } from '../util/bins.js';\nimport { distinctMap } from '../util/distinct-map.js';\nimport { isBigInt } from '../util/is-bigint.js';\nimport { noop } from '../util/no-op.js';\nimport { NULL } from '../util/null.js';\nimport { product } from '../util/product.js';\n\n/**\n * Initialize an aggregate operator.\n */\nfunction initOp(op) {\n  op.init = op.init || noop;\n  op.add = op.add || noop;\n  op.rem = op.rem || noop;\n  return op;\n}\n\nfunction initProduct(s, value) {\n  s.product_v = false;\n  return s.product = value;\n}\n\n/**\n * Initialize an aggregate operator.\n * @callback AggregateInit\n * @param {object} state The aggregate state object.\n * @return {void}\n */\n\n/**\n * Add a value to an aggregate operator.\n * @callback AggregateAdd\n * @param {object} state The aggregate state object.\n * @param {*} value The value to add.\n * @return {void}\n */\n\n/**\n * Remove a value from an aggregate operator.\n * @callback AggregateRem\n * @param {object} state The aggregate state object.\n * @param {*} value The value to remove.\n * @return {void}\n */\n\n/**\n * Retrive an output value from an aggregate operator.\n * @callback AggregateValue\n * @param {object} state The aggregate state object.\n * @return {*} The output value.\n */\n\n/**\n * An operator instance for an aggregate function.\n * @typedef {object} AggregateOperator\n * @property {AggregateInit} init Initialize the operator.\n * @property {AggregateAdd} [add] Add a value to the operator state.\n * @property {AggregateRem} [rem] Remove a value from the operator state.\n * @property {AggregateValue} value Retrieve an output value.\n */\n\n/**\n * Create a new aggregate operator instance.\n * @callback AggregateCreate\n * @param {...any} params The aggregate operator parameters.\n * @return {AggregateOperator} The instantiated aggregate operator.\n */\n\n/**\n * An operator definition for an aggregate function.\n * @typedef {object} AggregateDef\n * @property {AggregateCreate} create Create a new operator instance.\n * @property {number[]} param Two-element array containing the\n *  counts of input fields and additional parameters.\n * @property {string[]} [req] Names of operators required by this one.\n * @property {string[]} [stream] Names of operators required by this one\n *  for streaming operations (value removes).\n */\n\n/**\n * Aggregate operator definitions.\n */\nexport const aggregateFunctions = {\n  /** @type {AggregateDef} */\n  count: {\n    create: () => initOp({\n      value: s => s.count\n    }),\n    param: []\n  },\n\n  /** @type {AggregateDef} */\n  array_agg: {\n    create: () => initOp({\n      init: s => s.values = true,\n      value: s => s.list.values(s.stream)\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  object_agg: {\n    create: () => initOp({\n      init:  s => s.values = true,\n      value: s => Object.fromEntries(s.list.values())\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  map_agg: {\n    create: () => initOp({\n      init:  s => s.values = true,\n      value: s => new Map(s.list.values())\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  entries_agg: {\n    create: () => initOp({\n      init:  s => s.values = true,\n      value: s => s.list.values(s.stream)\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  any: {\n    create: () => initOp({\n      add: (s, v) => { if (s.any == null) s.any = v; },\n      value: s => s.valid ? s.any : NULL\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  valid: {\n    create: () => initOp({\n      value: s => s.valid\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  invalid: {\n    create: () => initOp({\n      value: s => s.count - s.valid\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  distinct: {\n    create: () => ({\n      init: s => s.distinct = distinctMap(),\n      value: s => s.distinct.count() + (s.valid === s.count ? 0 : 1),\n      add: (s, v) => s.distinct.increment(v),\n      rem: (s, v) => s.distinct.decrement(v)\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  array_agg_distinct: {\n    create: () => initOp({\n      value: s => s.distinct.values()\n    }),\n    param: [1],\n    req: ['distinct']\n  },\n\n  /** @type {AggregateDef} */\n  mode: {\n    create: () => initOp({\n      value: s => {\n        let mode = NULL;\n        let max = 0;\n        s.distinct.forEach((value, count) => {\n          if (count > max) {\n            max = count;\n            mode = value;\n          }\n        });\n        return mode;\n      }\n    }),\n    param: [1],\n    req: ['distinct']\n  },\n\n  /** @type {AggregateDef} */\n  sum: {\n    create: () => ({\n      init:  s => s.sum = 0,\n      value: s => s.valid ? s.sum : NULL,\n      add: (s, v) => isBigInt(v)\n        ? (s.sum === 0 ? s.sum = v : s.sum += v)\n        : s.sum += +v,\n      rem: (s, v) => s.sum -= v\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  product: {\n    create: () => ({\n      init:  s => initProduct(s, 1),\n      value: s => s.valid\n        ? (\n            s.product_v\n              ? initProduct(s, product(s.list.values()))\n              : s.product\n          )\n        : undefined,\n      add: (s, v) => isBigInt(v)\n        ? (s.product === 1 ? s.product = v : s.product *= v)\n        : s.product *= v,\n      rem: (s, v) => (v == 0 || v === Infinity || v === -Infinity)\n        ? s.product_v = true\n        : s.product /= v\n    }),\n    param: [1],\n    stream: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  mean: {\n    create: () => ({\n      init: s => s.mean = 0,\n      value: s => s.valid ? s.mean : NULL,\n      add: (s, v) => {\n        s.mean_d = v - s.mean;\n        s.mean += s.mean_d / s.valid;\n      },\n      rem: (s, v) => {\n        s.mean_d = v - s.mean;\n        s.mean -= s.valid ? s.mean_d / s.valid : s.mean;\n      }\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  average: {\n    create: () => initOp({\n      value: s => s.valid ? s.mean : NULL\n    }),\n    param: [1],\n    req: ['mean']\n  },\n\n  /** @type {AggregateDef} */\n  variance: {\n    create: () => ({\n      init:  s => s.dev = 0,\n      value: s => s.valid > 1 ? s.dev / (s.valid - 1) : NULL,\n      add: (s, v) => s.dev += s.mean_d * (v - s.mean),\n      rem: (s, v) => s.dev -= s.mean_d * (v - s.mean)\n    }),\n    param: [1],\n    req: ['mean']\n  },\n\n  /** @type {AggregateDef} */\n  variancep: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? s.dev / s.valid : NULL\n    }),\n    param: [1],\n    req: ['variance']\n  },\n\n  /** @type {AggregateDef} */\n  stdev: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? Math.sqrt(s.dev / (s.valid - 1)) : NULL\n    }),\n    param: [1],\n    req: ['variance']\n  },\n\n  /** @type {AggregateDef} */\n  stdevp: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? Math.sqrt(s.dev / s.valid) : NULL\n    }),\n    param: [1],\n    req: ['variance']\n  },\n\n  /** @type {AggregateDef} */\n  min: {\n    create: () => ({\n      init:  s => s.min = NULL,\n      value: s => s.min = (Number.isNaN(s.min) ? s.list.min() : s.min),\n      add: (s, v) => { if (v < s.min || s.min === NULL) s.min = v; },\n      rem: (s, v) => { if (v <= s.min) s.min = NaN; }\n    }),\n    param: [1],\n    stream: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  max: {\n    create: () => ({\n      init:  s => s.max = NULL,\n      value: s => s.max = (Number.isNaN(s.max) ? s.list.max() : s.max),\n      add: (s, v) => { if (v > s.max || s.max === NULL) s.max = v; },\n      rem: (s, v) => { if (v >= s.max) s.max = NaN; }\n    }),\n    param: [1],\n    stream: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  quantile: {\n    create: (p) => initOp({\n      value: s => s.list.quantile(p)\n    }),\n    param: [1, 1],\n    req: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  median: {\n    create: () => initOp({\n      value: s => s.list.quantile(0.5)\n    }),\n    param: [1],\n    req: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  covariance: {\n    create: () => ({\n      init:  s => {\n        s.cov = s.mean_x = s.mean_y = s.dev_x = s.dev_y = 0;\n      },\n      value: s => s.valid > 1 ? s.cov / (s.valid - 1) : NULL,\n      add: (s, x, y) => {\n        const dx = x - s.mean_x;\n        const dy = y - s.mean_y;\n        s.mean_x += dx / s.valid;\n        s.mean_y += dy / s.valid;\n        const dy2 = y - s.mean_y;\n        s.dev_x += dx * (x - s.mean_x);\n        s.dev_y += dy * dy2;\n        s.cov += dx * dy2;\n      },\n      rem: (s, x, y) => {\n        const dx = x - s.mean_x;\n        const dy = y - s.mean_y;\n        s.mean_x -= s.valid ? dx / s.valid : s.mean_x;\n        s.mean_y -= s.valid ? dy / s.valid : s.mean_y;\n        const dy2 = y - s.mean_y;\n        s.dev_x -= dx * (x - s.mean_x);\n        s.dev_y -= dy * dy2;\n        s.cov -= dx * dy2;\n      }\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  covariancep: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? s.cov / s.valid : NULL\n    }),\n    param: [2],\n    req: ['covariance']\n  },\n\n  /** @type {AggregateDef} */\n  corr: {\n    create: () => initOp({\n      value: s => s.valid > 1\n        ? s.cov / (Math.sqrt(s.dev_x) * Math.sqrt(s.dev_y))\n        : NULL\n    }),\n    param: [2],\n    req: ['covariance']\n  },\n\n  /** @type {AggregateDef} */\n  bins: {\n    create: (maxbins, nice, minstep, step) => initOp({\n      value: s => bins(s.min, s.max, maxbins, nice, minstep, step)\n    }),\n    param: [1, 4],\n    req: ['min', 'max']\n  }\n};\n","import { error } from '../util/error.js';\nimport { isValid } from '../util/is-valid.js';\nimport { noop } from '../util/no-op.js';\nimport { NULL } from '../util/null.js';\n\n/**\n * Initialize a window operator.\n * @callback WindowInit\n * @return {void}\n */\n\n/**\n * A storage object for the state of the window.\n * @typedef {import('../verbs/window/window-state.js').windowState} WindowState\n */\n\n/**\n * Retrieve an output value from a window operator.\n * @callback WindowValue\n * @param {WindowState} state The window state object.\n * @return {*} The output value.\n */\n\n/**\n * Initialize an aggregate operator.\n * @typedef {import('./aggregate-functions.js').AggregateInit} AggregateInit\n */\n\n/**\n * Retrive an output value from an aggregate operator.\n * @typedef {import('./aggregate-functions.js').AggregateValue} AggregateValue\n */\n\n/**\n * An operator instance for a window function.\n * @typedef {object} WindowOperator\n * @property {AggregateInit} init Initialize the operator.\n * @property {AggregateValue} value Retrieve an output value.\n */\n\n/**\n * Create a new window operator instance.\n * @callback WindowCreate\n * @param {...any} params The aggregate operator parameters.\n * @return {WindowOperator} The instantiated window operator.\n */\n\n/**\n * Create a new aggregate operator instance.\n * @typedef {import('./aggregate-functions.js').AggregateCreate} AggregateCreate\n */\n\n/**\n * An operator definition for a window function.\n * @typedef {object} WindowDef\n * @property {AggregateCreate} create Create a new operator instance.\n * @property {number[]} param Two-element array containing the\n *  counts of input fields and additional parameters.\n */\n\nconst rank = {\n  create() {\n    let rank;\n    return {\n      init: () => rank = 1,\n      value: w => {\n        const i = w.index;\n        return (i && !w.peer(i)) ? (rank = i + 1) : rank;\n      }\n    };\n  },\n  param: []\n};\n\nconst cume_dist = {\n  create() {\n    let cume;\n    return {\n      init: () => cume = 0,\n      value: w => {\n        const { index, peer, size } = w;\n        let i = index;\n        if (cume < i) {\n          while (i + 1 < size && peer(i + 1)) ++i;\n          cume = i;\n        }\n        return (1 + cume) / size;\n      }\n    };\n  },\n  param: []\n};\n\n/**\n * Window operator definitions.\n */\nexport const windowFunctions = {\n  /** @type {WindowDef} */\n  row_number: {\n    create() {\n      return {\n        init: noop,\n        value: w => w.index + 1\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  rank,\n\n  /** @type {WindowDef} */\n  avg_rank: {\n    create() {\n      let j, rank;\n      return {\n        init: () => (j = -1, rank = 1),\n        value: w => {\n          const i = w.index;\n          if (i >= j) {\n            for (rank = j = i + 1; w.peer(j); rank += ++j);\n            rank /= (j - i);\n          }\n          return rank;\n        }\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  dense_rank: {\n    create() {\n      let drank;\n      return {\n        init: () => drank = 1,\n        value: w => {\n          const i = w.index;\n          return (i && !w.peer(i)) ? ++drank : drank;\n        }\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  percent_rank: {\n    create() {\n      const { init, value } = rank.create();\n      return {\n        init,\n        value: w => (value(w) - 1) / (w.size - 1)\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  cume_dist,\n\n  /** @type {WindowDef} */\n  ntile: {\n    create(num) {\n      num = +num;\n      if (!(num > 0)) error('ntile num must be greater than zero.');\n      const { init, value } = cume_dist.create();\n      return {\n        init,\n        value: w => Math.ceil(num * value(w))\n      };\n    },\n    param: [0, 1]\n  },\n\n  /** @type {WindowDef} */\n  lag: {\n    create(offset, defaultValue = NULL) {\n      offset = +offset || 1;\n      return {\n        init: noop,\n        value: (w, f) => {\n          const i = w.index - offset;\n          return i >= 0 ? w.value(i, f) : defaultValue;\n        }\n      };\n    },\n    param: [1, 2]\n  },\n\n  /** @type {WindowDef} */\n  lead: {\n    create(offset, defaultValue = NULL) {\n      offset = +offset || 1;\n      return {\n        init: noop,\n        value: (w, f) => {\n          const i = w.index + offset;\n          return i < w.size ? w.value(i, f) : defaultValue;\n        }\n      };\n    },\n    param: [1, 2]\n  },\n\n  /** @type {WindowDef} */\n  first_value: {\n    create() {\n      return {\n        init: noop,\n        value: (w, f) => w.value(w.i0, f)\n      };\n    },\n    param: [1]\n  },\n\n  /** @type {WindowDef} */\n  last_value: {\n    create() {\n      return {\n        init: noop,\n        value: (w, f) => w.value(w.i1 - 1, f)\n      };\n    },\n    param: [1]\n  },\n\n  /** @type {WindowDef} */\n  nth_value: {\n    create(nth) {\n      nth = +nth;\n      if (!(nth > 0)) error('nth_value nth must be greater than zero.');\n      return {\n        init: noop,\n        value: (w, f) => {\n          const i = w.i0 + (nth - 1);\n          return i < w.i1 ? w.value(i, f) : NULL;\n        }\n      };\n    },\n    param: [1, 1]\n  },\n\n  /** @type {WindowDef} */\n  fill_down: {\n    create(defaultValue = NULL) {\n      let value;\n      return {\n        init: () => value = defaultValue,\n        value: (w, f) => {\n          const v = w.value(w.index, f);\n          return isValid(v) ? (value = v) : value;\n        }\n      };\n    },\n    param: [1, 1]\n  },\n\n  /** @type {WindowDef} */\n  fill_up: {\n    create(defaultValue = NULL) {\n      let value, idx;\n      return {\n        init: () => (value = defaultValue, idx = -1),\n        value: (w, f) => w.index <= idx ? value\n          : (idx = find(w, f, w.index)) >= 0 ? (value = w.value(idx, f))\n          : (idx = w.size, value = defaultValue)\n      };\n    },\n    param: [1, 1]\n  }\n};\n\nfunction find(w, f, i) {\n  for (const n = w.size; i < n; ++i) {\n    if (isValid(w.value(i, f))) return i;\n  }\n  return -1;\n}\n","import { aggregateFunctions } from './aggregate-functions.js';\nimport { windowFunctions } from './window-functions.js';\nimport { functions } from './functions/index.js';\n\nexport { aggregateFunctions } from './aggregate-functions.js';\nexport { windowFunctions } from './window-functions.js';\nexport { functions } from './functions/index.js';\n\n/**\n * Check if an aggregate function with the given name exists.\n * @param {string} name The name of the aggregate function.\n * @return {boolean} True if found, false otherwise.\n */\nexport function hasAggregate(name) {\n  return Object.hasOwn(aggregateFunctions, name);\n}\n\n/**\n * Check if a window function with the given name exists.\n * @param {string} name The name of the window function.\n * @return {boolean} True if found, false otherwise.\n */\nexport function hasWindow(name) {\n  return Object.hasOwn(windowFunctions, name);\n}\n\n/**\n * Check if an expression function with the given name exists.\n * @param {string} name The name of the function.\n * @return {boolean} True if found, false otherwise.\n */\n export function hasFunction(name) {\n  return Object.hasOwn(functions, name) || name === 'row_object';\n}\n\n/**\n * Get an aggregate function definition.\n * @param {string} name The name of the aggregate function.\n * @return {import('./aggregate-functions.js').AggregateDef}\n *  The aggregate function definition, or undefined if not found.\n */\nexport function getAggregate(name) {\n  return hasAggregate(name) && aggregateFunctions[name];\n}\n\n/**\n * Get a window function definition.\n * @param {string} name The name of the window function.\n * @return {import('./window-functions.js').WindowDef}\n *  The window function definition, or undefined if not found.\n */\nexport function getWindow(name) {\n  return hasWindow(name) && windowFunctions[name];\n}\n\n/**\n * Get an expression function definition.\n * @param {string} name The name of the function.\n * @return {Function} The function instance, or undefined if not found.\n */\nexport function getFunction(name) {\n  return hasFunction(name) && functions[name];\n}\n","// eslint-disable-next-line no-unused-vars\nexport function concat(list, fn = ((x, i) => x), delim = '') {\n  const n = list.length;\n  if (!n) return '';\n\n  let s = fn(list[0], 0);\n  for (let i = 1; i < n; ++i) {\n    s += delim + fn(list[i], i);\n  }\n\n  return s;\n}\n","export function unroll(args, code, ...lists) {\n  const v = ['_', '$'];\n  const a = v.slice(0, lists.length);\n  a.push('\"use strict\"; const '\n    + lists\n        .map((l, j) => l.map((_, i) => `${v[j]}${i} = ${v[j]}[${i}]`).join(', '))\n        .join(', ')\n    + `; return (${args}) => ${code};`\n  );\n  return Function(...a)(...lists);\n}\n","export function ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import { NULL } from './null.js';\n\nexport function max(values, start = 0, stop = values.length) {\n  let max = stop ? values[start++] : NULL;\n\n  for (let i = start; i < stop; ++i) {\n    if (max < values[i]) {\n      max = values[i];\n    }\n  }\n\n  return max;\n}\n","import { NULL } from './null.js';\n\nexport function min(values, start = 0, stop = values.length) {\n  let min = stop ? values[start++] : NULL;\n\n  for (let i = start; i < stop; ++i) {\n    if (min > values[i]) {\n      min = values[i];\n    }\n  }\n\n  return min;\n}\n","import { isBigInt } from './is-bigint.js';\n\nexport function toNumeric(value) {\n  return isBigInt(value) ? value : +value;\n}\n","import { isBigInt } from './is-bigint.js';\nimport { NULL } from './null.js';\nimport { toNumeric } from './to-numeric.js';\n\nexport function quantile(values, p) {\n  const n = values.length;\n\n  if (!n) return NULL;\n  if ((p = +p) <= 0 || n < 2) return toNumeric(values[0]);\n  if (p >= 1) return toNumeric(values[n - 1]);\n\n  const i = (n - 1) * p;\n  const i0 = Math.floor(i);\n  const v0 = toNumeric(values[i0]);\n  return isBigInt(v0)\n    ? v0\n    // @ts-ignore\n    : v0 + (toNumeric(values[i0 + 1]) - v0) * (i - i0);\n}\n","import { ascending } from './ascending.js';\nimport { max } from './max.js';\nimport { min } from './min.js';\nimport { quantile } from './quantile.js';\n\nexport class ValueList {\n  constructor(values) {\n    this._values = values || [];\n    this._sorted = null;\n    this._start = 0;\n  }\n\n  values(copy) {\n    if (this._start) {\n      this._values = this._values.slice(this._start);\n      this._start = 0;\n    }\n    return copy\n      ? this._values.slice()\n      : this._values;\n  }\n\n  add(value) {\n    this._values.push(value);\n    this._sorted = null;\n  }\n\n  rem() {\n    this._start += 1;\n    this._sorted = null;\n  }\n\n  min() {\n    return this._sorted && this._sorted.length\n      ? this._sorted[0]\n      : min(this._values, this._start);\n  }\n\n  max() {\n    return this._sorted && this._sorted.length\n      ? this._sorted[this._sorted.length - 1]\n      : max(this._values, this._start);\n  }\n\n  quantile(p) {\n    if (!this._sorted) {\n      this._sorted = this.values(true);\n      this._sorted.sort(ascending);\n    }\n    return quantile(this._sorted, p);\n  }\n}\n","/**\n * Abstract class for custom aggregation operations.\n */\nexport class Reducer {\n  constructor(outputs) {\n    this._outputs = outputs;\n  }\n\n  size() {\n    return this._outputs.length;\n  }\n\n  outputs() {\n    return this._outputs;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  init(columns) {\n    return {};\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  add(state, row, data) {\n    // no-op, subclasses should override\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  rem(state, row, data) {\n    // no-op, subclasses should override\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  write(state, values, index) {\n  }\n}\n","import { getAggregate } from '../../op/index.js';\nimport { concat } from '../../util/concat.js';\nimport { error } from '../../util/error.js';\nimport { isValid } from '../../util/is-valid.js';\nimport { unroll } from '../../util/unroll.js';\nimport { ValueList } from '../../util/value-list.js';\nimport { Reducer } from './reducer.js';\n\nconst update = (ops, args, fn) => unroll(\n  args,\n  '{' + concat(ops, (_, i) => `_${i}.${fn}(${args});`) + '}',\n  ops\n);\n\nexport function fieldReducer(oplist, stream) {\n  const { ops, output } = expand(oplist, stream);\n  const fields = oplist[0].fields;\n  const n = fields.length;\n  const cls = n === 0 ? FieldReducer\n    : n === 1 ? Field1Reducer\n    : n === 2 ? Field2Reducer\n    : error('Unsupported field count: ' + n);\n  // @ts-ignore\n  return new cls(fields, ops, output, stream);\n}\n\nfunction expand(oplist, stream) {\n  const has = {};\n  const ops = [];\n\n  function add(name, params = []) {\n    // check key\n    const key = name + ':' + params;\n    if (has[key]) return has[key];\n\n    // get op instance\n    const def = getAggregate(name);\n    const op = def.create(...params);\n\n    // add required dependencies\n    if (stream < 0 && def.stream) {\n      def.stream.forEach(name => add(name, []));\n    }\n    if (def.req) {\n      def.req.forEach(name => add(name, []));\n    }\n\n    // update state\n    has[key] = op;\n    ops.push(op);\n\n    return op;\n  }\n\n  const output = oplist.map(item => {\n    const op = add(item.name, item.params);\n    op.output = item.id;\n    return op;\n  });\n\n  return { ops, output };\n}\n\nclass FieldReducer extends Reducer {\n  constructor(fields, ops, outputs, stream) {\n    super(outputs);\n    this._op = ops;\n    this._fields = fields;\n    this._stream = !!stream;\n  }\n\n  init() {\n    const state = { count: 0, valid: 0, stream: this._stream };\n    this._op.forEach(op => op.init(state));\n\n    // value list requested\n    if (state.values) {\n      state.list = new ValueList();\n    }\n\n    return state;\n  }\n\n  write(state, values, index) {\n    const op = this._outputs;\n    const n = op.length;\n    for (let i = 0; i < n; ++i) {\n      values[op[i].output][index] = op[i].value(state);\n    }\n    return 1;\n  }\n\n  _add() {\n  }\n\n  _rem() {\n  }\n\n  add(state) {\n    ++state.count;\n  }\n\n  rem(state) {\n    --state.count;\n  }\n}\n\nclass Field1Reducer extends FieldReducer {\n  constructor(fields, ops, outputs, stream) {\n    super(fields, ops, outputs, stream);\n\n    // unroll op invocations for performance\n    const args = ['state', 'v1', 'v2'];\n    this._add = update(ops, args, 'add');\n    this._rem = update(ops, args, 'rem');\n  }\n\n  add(state, row, data) {\n    const value = this._fields[0](row, data);\n    ++state.count;\n    if (isValid(value)) {\n      ++state.valid;\n      if (state.list) state.list.add(value);\n      this._add(state, value);\n    }\n  }\n\n  rem(state, row, data) {\n    const value = this._fields[0](row, data);\n    --state.count;\n    if (isValid(value)) {\n      --state.valid;\n      if (state.list) state.list.rem();\n      this._rem(state, value);\n    }\n  }\n}\n\nclass Field2Reducer extends FieldReducer {\n  constructor(fields, ops, outputs, stream) {\n    super(fields, ops, outputs, stream);\n\n    // unroll op invocations for performance\n    const args = ['state', 'v1', 'v2'];\n    this._add = update(ops, args, 'add');\n    this._rem = update(ops, args, 'rem');\n  }\n\n  add(state, row, data) {\n    const value1 = this._fields[0](row, data);\n    const value2 = this._fields[1](row, data);\n    ++state.count;\n    if (isValid(value1) && isValid(value2)) {\n      ++state.valid;\n      if (state.list) state.list.add([value1, value2]);\n      this._add(state, value1, value2);\n    }\n  }\n\n  rem(state, row, data) {\n    const value1 = this._fields[0](row, data);\n    const value2 = this._fields[1](row, data);\n    --state.count;\n    if (isValid(value1) && isValid(value2)) {\n      --state.valid;\n      if (state.list) state.list.rem();\n      this._rem(state, value1, value2);\n    }\n  }\n}\n","import { repeat } from '../../util/repeat.js';\nimport { fieldReducer } from './field-reducer.js';\n\nexport function aggregateGet(table, ops, get) {\n  if (ops.length) {\n    const data = table.data();\n    const { keys } = table.groups() || {};\n    const result = aggregate(table, ops);\n    const op = keys\n      ? (name, row) => result[name][keys[row]]\n      : name => result[name][0];\n    get = get.map(f => row => f(row, data, op));\n  }\n\n  return get;\n}\n\nexport function aggregate(table, ops, result) {\n  if (!ops.length) return result; // early exit\n\n  // instantiate aggregators and result store\n  const aggrs = reducers(ops);\n  const groups = table.groups();\n  const size = groups ? groups.size : 1;\n  result = result || repeat(ops.length, () => Array(size));\n\n  // compute aggregates, extract results\n  if (size > 1) {\n    aggrs.forEach(aggr => {\n      const cells = reduceGroups(table, aggr, groups);\n      for (let i = 0; i < size; ++i) {\n        aggr.write(cells[i], result, i);\n      }\n    });\n  } else {\n    aggrs.forEach(aggr => {\n      const cell = reduceFlat(table, aggr);\n      aggr.write(cell, result, 0);\n    });\n  }\n\n  return result;\n}\n\nexport function reducers(ops, stream) {\n  const aggrs = [];\n  const fields = {};\n\n  // group operators by field inputs\n  for (const op of ops) {\n    const key = op.fields.map(f => f + '').join(',');\n    (fields[key] || (fields[key] = [])).push(op);\n  }\n\n  // generate a field reducer for each field\n  for (const key in fields) {\n    aggrs.push(fieldReducer(fields[key], stream));\n  }\n\n  return aggrs;\n}\n\nexport function reduceFlat(table, reducer) {\n  // initialize aggregation cell\n  const cell = reducer.init();\n\n  // compute aggregate values\n  // inline the following for performance:\n  // table.scan((row, data) => reducer.add(cell, row, data));\n  const data = table.data();\n  const bits = table.mask();\n\n  if (table.isOrdered()) {\n    const idx = table.indices();\n    const m = idx.length;\n    for (let i = 0; i < m; ++i) {\n      reducer.add(cell, idx[i], data);\n    }\n  } else if (bits) {\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      reducer.add(cell, i, data);\n    }\n  } else {\n    const n = table.totalRows();\n    for (let i = 0; i < n; ++i) {\n      reducer.add(cell, i, data);\n    }\n  }\n\n  return cell;\n}\n\nexport function reduceGroups(table, reducer, groups) {\n  const { keys, size } = groups;\n\n  // initialize aggregation cells\n  const cells = repeat(size, () => reducer.init());\n\n  // compute aggregate values\n  // inline the following for performance:\n  // table.scan((row, data) => reducer.add(cells[keys[row]], row, data));\n  const data = table.data();\n\n  if (table.isOrdered()) {\n    const idx = table.indices();\n    const m = idx.length;\n    for (let i = 0; i < m; ++i) {\n      const row = idx[i];\n      reducer.add(cells[keys[row]], row, data);\n    }\n  } else if (table.isFiltered()) {\n    const bits = table.mask();\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      reducer.add(cells[keys[i]], i, data);\n    }\n  } else {\n    const n = table.totalRows();\n    for (let i = 0; i < n; ++i) {\n      reducer.add(cells[keys[i]], i, data);\n    }\n  }\n\n  return cells;\n}\n\nexport function groupOutput(cols, groups) {\n  const { get, names, rows, size } = groups;\n\n  // write group values to output columns\n  const m = names.length;\n  for (let j = 0; j < m; ++j) {\n    const col = cols.add(names[j], Array(size));\n    const val = get[j];\n    for (let i = 0; i < size; ++i) {\n      col[i] = val(rows[i]);\n    }\n  }\n}\n","import { isArray } from './is-array.js';\nimport { isMap } from './is-map.js';\n\nexport function entries(value) {\n  return isArray(value) ? value\n    : isMap(value) ? value.entries()\n    : value ? Object.entries(value)\n    : [];\n}\n","export const ArrayPattern = 'ArrayPattern';\nexport const ArrowFunctionExpression = 'ArrowFunctionExpression';\nexport const FunctionExpression = 'FunctionExpression';\nexport const Identifier = 'Identifier';\nexport const Literal = 'Literal';\nexport const MemberExpression = 'MemberExpression';\nexport const ObjectExpression = 'ObjectExpression';\nexport const ObjectPattern = 'ObjectPattern';\nexport const Property = 'Property';\n\nexport const Column = 'Column';\nexport const Constant = 'Constant';\nexport const Dictionary = 'Dictionary';\nexport const Function = 'Function';\nexport const Parameter = 'Parameter';\nexport const Op = 'Op';\n","export function walk(node, ctx, visitors, parent) {\n  const visit = visitors[node.type] || visitors['Default'];\n  if (visit && visit(node, ctx, parent) === false) return;\n\n  const walker = walkers[node.type];\n  if (walker) walker(node, ctx, visitors);\n}\n\nconst unary = (node, ctx, visitors) => {\n  walk(node.argument, ctx, visitors, node);\n};\n\nconst binary = (node, ctx, visitors) => {\n  walk(node.left, ctx, visitors, node);\n  walk(node.right, ctx, visitors, node);\n};\n\nconst ternary = (node, ctx, visitors) => {\n  walk(node.test, ctx, visitors, node);\n  walk(node.consequent, ctx, visitors, node);\n  if (node.alternate) walk(node.alternate, ctx, visitors, node);\n};\n\nconst func = (node, ctx, visitors) => {\n  list(node.params, ctx, visitors, node);\n  walk(node.body, ctx, visitors, node);\n};\n\nconst call = (node, ctx, visitors) => {\n  walk(node.callee, ctx, visitors, node);\n  list(node.arguments, ctx, visitors, node);\n};\n\nconst list = (nodes, ctx, visitors, node) => {\n  nodes.forEach(item => walk(item, ctx, visitors, node));\n};\n\nconst walkers = {\n  TemplateLiteral: (node, ctx, visitors) => {\n    list(node.expressions, ctx, visitors, node);\n    list(node.quasis, ctx, visitors, node);\n  },\n  MemberExpression: (node, ctx, visitors) => {\n    walk(node.object, ctx, visitors, node);\n    walk(node.property, ctx, visitors, node);\n  },\n  CallExpression: call,\n  NewExpression: call,\n  ArrayExpression: (node, ctx, visitors) => {\n    list(node.elements, ctx, visitors, node);\n  },\n  AssignmentExpression: binary,\n  AwaitExpression: unary,\n  BinaryExpression: binary,\n  LogicalExpression: binary,\n  UnaryExpression: unary,\n  UpdateExpression: unary,\n  ConditionalExpression: ternary,\n  ObjectExpression: (node, ctx, visitors) => {\n    list(node.properties, ctx, visitors, node);\n  },\n  Property: (node, ctx, visitors) => {\n    walk(node.key, ctx, visitors, node);\n    walk(node.value, ctx, visitors, node);\n  },\n\n  ArrowFunctionExpression: func,\n  FunctionExpression: func,\n  FunctionDeclaration: func,\n\n  VariableDeclaration: (node, ctx, visitors) => {\n    list(node.declarations, ctx, visitors, node);\n  },\n  VariableDeclarator: (node, ctx, visitors) => {\n    walk(node.id, ctx, visitors, node);\n    walk(node.init, ctx, visitors, node);\n  },\n  SpreadElement: (node, ctx, visitors) => {\n    walk(node.argument, ctx, visitors, node);\n  },\n\n  BlockStatement: (node, ctx, visitors) => {\n    list(node.body, ctx, visitors, node);\n  },\n  ExpressionStatement: (node, ctx, visitors) => {\n    walk(node.expression, ctx, visitors, node);\n  },\n  IfStatement: ternary,\n  ForStatement: (node, ctx, visitors) => {\n    walk(node.init, ctx, visitors, node);\n    walk(node.test, ctx, visitors, node);\n    walk(node.update, ctx, visitors, node);\n    walk(node.body, ctx, visitors, node);\n  },\n  WhileStatement: (node, ctx, visitors) => {\n    walk(node.test, ctx, visitors, node);\n    walk(node.body, ctx, visitors, node);\n  },\n  DoWhileStatement: (node, ctx, visitors) => {\n    walk(node.body, ctx, visitors, node);\n    walk(node.test, ctx, visitors, node);\n  },\n  SwitchStatement: (node, ctx, visitors) => {\n    walk(node.discriminant, ctx, visitors, node);\n    list(node.cases, ctx, visitors, node);\n  },\n  SwitchCase: (node, ctx, visitors) => {\n    if (node.test) walk(node.test, ctx, visitors, node);\n    list(node.consequent, ctx, visitors, node);\n  },\n  ReturnStatement: unary,\n\n  Program: (node, ctx, visitors) => {\n    walk(node.body[0], ctx, visitors, node);\n  }\n};\n","import { walk } from './walk.js';\n\nfunction strip(node) {\n  delete node.start;\n  delete node.end;\n  delete node.optional;\n}\n\nfunction stripMember(node) {\n  strip(node);\n  delete node.object;\n  delete node.property;\n  delete node.computed;\n  if (!node.table) delete node.table;\n}\n\nexport function clean(ast) {\n  walk(ast, null, {\n    Column: stripMember,\n    Constant: stripMember,\n    Default: strip\n  });\n  return ast;\n}\n","import { ArrowFunctionExpression, FunctionExpression } from './constants.js';\n\nexport function is(type, node) {\n  return node && node.type === type;\n}\n\nexport function isFunctionExpression(node) {\n  return is(FunctionExpression, node)\n    || is(ArrowFunctionExpression, node);\n}\n","import { error } from '../util/error.js';\nimport { toString } from '../util/to-string.js';\n\nconst visit = (node, opt) => {\n  const f = visitors[node.type];\n  return f\n    ? f(node, opt)\n    : error(`Unsupported expression construct: ${node.type}`);\n};\n\nconst binary = (node, opt) => {\n  return '(' + visit(node.left, opt) + ' ' + node.operator + ' ' + visit(node.right, opt) + ')';\n};\n\nconst func = (node, opt) => {\n  return '(' + list(node.params, opt) + ')=>' + visit(node.body, opt);\n};\n\nconst call = (node, opt) => {\n  return visit(node.callee, opt) + '(' + list(node.arguments, opt) + ')';\n};\n\nconst list = (array, opt, delim = ',') => {\n  return array.map(node => visit(node, opt)).join(delim);\n};\n\nconst name = node => node.computed\n  ? `[${toString(node.name)}]`\n  : `.${node.name}`;\n\nconst ref = (node, opt, method) => {\n  const table = node.table || '';\n  return `data${table}${name(node)}.${method}(${opt.index}${table})`;\n};\n\nconst get = (node, opt) => {\n  const table = node.table || '';\n  return `data${table}${name(node)}[${opt.index}${table}]`;\n};\n\nconst visitors = {\n  Constant: node => node.raw,\n  Column: (node, opt) => node.array ? get(node, opt) : ref(node, opt, 'at'),\n  Dictionary: (node, opt) => ref(node, opt, 'key'),\n  Function: node => `fn.${node.name}`,\n  Parameter: node => `$${name(node)}`,\n  Op: (node, opt) => `op(${toString(node.name)},${opt.op || opt.index})`,\n  Literal: node => node.raw,\n  Identifier: node => node.name,\n  TemplateLiteral: (node, opt) => {\n    const { quasis, expressions } = node;\n    const n = expressions.length;\n    let t = quasis[0].value.raw;\n    for (let i = 0; i < n;) {\n      t += '${' + visit(expressions[i], opt) + '}' + quasis[++i].value.raw;\n    }\n    return '`' + t + '`';\n  },\n  MemberExpression: (node, opt) => {\n    const d = !node.computed;\n    const o = visit(node.object, opt);\n    const p = visit(node.property, opt);\n    return o + (d ? '.' + p : '[' + p + ']');\n  },\n  CallExpression: call,\n  NewExpression: (node, opt) => {\n    return 'new ' + call(node, opt);\n  },\n  ArrayExpression: (node, opt) => {\n    return '[' + list(node.elements, opt) + ']';\n  },\n  AssignmentExpression: binary,\n  BinaryExpression: binary,\n  LogicalExpression: binary,\n  UnaryExpression: (node, opt) => {\n    return '(' + node.operator + visit(node.argument, opt) + ')';\n  },\n  ConditionalExpression: (node, opt) => {\n    return '(' + visit(node.test, opt) +\n      '?' + visit(node.consequent, opt) +\n      ':' + visit(node.alternate, opt) + ')';\n  },\n  ObjectExpression: (node, opt) => {\n    return '({' + list(node.properties, opt) + '})';\n  },\n  Property: (node, opt) => {\n    const key = visit(node.key, opt);\n    return (node.computed ? `[${key}]` : key) + ':' + visit(node.value, opt);\n  },\n\n  ArrowFunctionExpression: func,\n  FunctionExpression: func,\n  FunctionDeclaration: func,\n\n  ArrayPattern: (node, opt) => {\n    return '[' + list(node.elements, opt) + ']';\n  },\n  ObjectPattern: (node, opt) => {\n    return '{' + list(node.properties, opt) + '}';\n  },\n  VariableDeclaration: (node, opt) => {\n    return node.kind + ' ' + list(node.declarations, opt, ',');\n  },\n  VariableDeclarator: (node, opt) => {\n    return visit(node.id, opt) + '=' + visit(node.init, opt);\n  },\n  SpreadElement: (node, opt) => {\n    return '...' + visit(node.argument, opt);\n  },\n\n  BlockStatement: (node, opt) => {\n    return '{' + list(node.body, opt, ';') + ';}';\n  },\n  BreakStatement: () => {\n    return 'break';\n  },\n  ExpressionStatement: (node, opt) => {\n    return visit(node.expression, opt);\n  },\n  IfStatement: (node, opt) => {\n    return 'if (' + visit(node.test, opt) + ')'\n      + visit(node.consequent, opt)\n      + (node.alternate ? ' else ' + visit(node.alternate, opt) : '');\n  },\n  SwitchStatement: (node, opt) => {\n    return 'switch (' + visit(node.discriminant, opt) + ') {'\n     + list(node.cases, opt, '')\n     + '}';\n  },\n  SwitchCase: (node, opt) => {\n    return (node.test ? 'case ' + visit(node.test, opt) : 'default')\n      + ': '\n      + list(node.consequent, opt, ';') + ';';\n  },\n  ReturnStatement: (node, opt) => {\n    return 'return ' + visit(node.argument, opt);\n  },\n  Program: (node, opt) => visit(node.body[0], opt)\n};\n\nexport function codegen(node, opt = { index: 'row' }) {\n  return visit(node, opt);\n}\n","import { functions as fn } from '../op/index.js';\n\nfunction _compile(code, fn, params) {\n  code = `\"use strict\"; return ${code};`;\n  return (Function('fn', '$', code))(fn, params);\n}\n\nexport const compile = {\n  escape: (code, func, params) => _compile(code, func, params),\n  expr:   (code, params) => _compile(`(row,data,op)=>${code}`, fn, params),\n  expr2:  (code, params) => _compile(`(row0,data0,row,data)=>${code}`, fn, params),\n  join:   (code, params) => _compile(`(row1,data1,row2,data2)=>${code}`, fn, params),\n  param:  (code, params) => _compile(code, fn, params)\n};\n","import { Column, Dictionary, Literal } from './ast/constants.js';\nimport { isArrayType } from '../util/is-array-type.js';\nimport { isFunction } from '../util/is-function.js';\n\nconst dictOps = {\n  '==': 1,\n  '!=': 1,\n  '===': 1,\n  '!==': 1\n};\n\n/**\n * Rewrite AST node to be a table column reference.\n * Additionally optimizes dictionary column operations.\n * @param {object} ref AST node to rewrite to a column reference.\n * @param {string} name The name of the column.\n * @param {number} [index] The table index of the column.\n * @param {object} [col] The actual table column instance.\n * @param {object} [op] Parent AST node operating on the column reference.\n */\nexport function rewrite(ref, name, index = 0, col = undefined, op = undefined) {\n  ref.type = Column;\n  ref.name = name;\n  ref.table = index;\n\n  // annotate arrays as such for optimized access\n  if (isArrayType(col)) {\n    ref.array = true;\n  }\n\n  // proceed only if has parent op and is a dictionary column\n  if (op && col && isFunction(col.keyFor)) {\n    // get other arg if op is an optimizeable operation\n    const lit = dictOps[op.operator]\n      ? op.left === ref ? op.right : op.left\n      : op.callee && op.callee.name === 'equal'\n      ? op.arguments[op.arguments[0] === ref ? 1 : 0]\n      : null;\n\n    // rewrite as dictionary lookup if other arg is a literal\n    if (lit && lit.type === Literal) {\n      rewriteDictionary(op, ref, lit, col.keyFor(lit.value));\n    }\n  }\n\n  return ref;\n}\n\nfunction rewriteDictionary(op, ref, lit, key) {\n  if (key < 0) {\n    // value not in dictionary, rewrite op as false literal\n    op.type = Literal;\n    op.value = false;\n    op.raw = 'false';\n  } else {\n    // rewrite ref as dict key access\n    ref.type = Dictionary;\n\n    // rewrite literal as target dict key\n    lit.value = key;\n    lit.raw = key + '';\n  }\n\n  return true;\n}\n","import { Literal, ObjectExpression, Property } from './ast/constants.js';\nimport { codegen } from './codegen.js';\nimport { compile } from './compile.js';\nimport { rewrite } from './rewrite.js';\nimport { entries } from '../util/entries.js';\nimport { isArray } from '../util/is-array.js';\nimport { toString } from '../util/to-string.js';\n\nexport const ROW_OBJECT = 'row_object';\n\nexport function rowObjectExpression(\n  node,\n  table,\n  props = table.columnNames())\n{\n  node.type = ObjectExpression;\n\n  const p = node.properties = [];\n  for (const prop of entries(props)) {\n    const [name, key] = isArray(prop) ? prop : [prop, prop];\n    p.push({\n      type: Property,\n      key: { type: Literal, raw: toString(key) },\n      value: rewrite({ computed: true }, name, 0, table.column(name))\n    });\n  }\n\n  return node;\n}\n\nexport function rowObjectCode(table, props) {\n  return codegen(rowObjectExpression({}, table, props));\n}\n\nexport function rowObjectBuilder(table, props) {\n  return compile.expr(rowObjectCode(table, props));\n}\n","import { isFunction } from './is-function.js';\n\nexport function toFunction(value) {\n  return isFunction(value) ? value : () => value;\n}\n","import { compile } from './compile.js';\nimport { rowObjectCode } from './row-object.js';\nimport { error } from '../util/error.js';\nimport { toFunction } from '../util/to-function.js';\n\nconst ERROR_ESC_AGGRONLY = 'Escaped functions are not valid as rollup or pivot values.';\n\nexport function parseEscape(ctx, spec, params) {\n  if (ctx.aggronly) error(ERROR_ESC_AGGRONLY);\n\n  // generate escaped function invocation code\n  const code = `(row,data)=>fn(${rowObjectCode(ctx.table)},$)`;\n\n  return { escape: compile.escape(code, toFunction(spec.expr), params) };\n}\n","// This file was generated. Do not modify manually!\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\n// This file was generated. Do not modify manually!\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\n\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords$1 = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n  return false\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords[name] = new TokenType(name, options)\n}\n\nvar types$1 = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  privateId: new TokenType(\"privateId\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nfunction nextLineBreak(code, from, end) {\n  if ( end === void 0 ) end = code.length;\n\n  for (var i = from; i < end; i++) {\n    var next = code.charCodeAt(i);\n    if (isNewLine(next))\n      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }\n  }\n  return -1\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\nvar hasOwn = Object.hasOwn || (function (obj, propName) { return (\n  hasOwnProperty.call(obj, propName)\n); });\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nvar regexpCache = Object.create(null);\n\nfunction wordsRegexp(words) {\n  return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"))\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\nvar loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    var nextBreak = nextLineBreak(input, cur, offset);\n    if (nextBreak < 0) { return new Position(line, offset - cur) }\n    ++line;\n    cur = nextBreak;\n  }\n}\n\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n  // (the latest version the library supports). This influences\n  // support for strict mode, the set of reserved words, and support\n  // for new syntax features.\n  ecmaVersion: null,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called when\n  // a semicolon is automatically inserted. It will be passed the\n  // position of the inserted semicolon as an offset, and if\n  // `locations` is enabled, it is given the location as a `{line,\n  // column}` object as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program, and an import.meta expression\n  // in a script isn't considered an error.\n  allowImportExportEverywhere: false,\n  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: null,\n  // When enabled, super identifiers are not constrained to\n  // appearing in methods and do not raise an error when they appear elsewhere.\n  allowSuperOutsideMethod: null,\n  // When enabled, hashbang directive in the beginning of file is\n  // allowed and treated as a line comment. Enabled by default when\n  // `ecmaVersion` >= 2023.\n  allowHashBang: false,\n  // By default, the parser will verify that private properties are\n  // only used in places where they are valid and have been declared.\n  // Set this to false to turn such checks off.\n  checkPrivateFields: true,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  // When this option has an array as value, objects representing the\n  // comments are pushed to it.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nvar warnedAboutEcmaVersion = false;\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion === \"latest\") {\n    options.ecmaVersion = 1e8;\n  } else if (options.ecmaVersion == null) {\n    if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n      warnedAboutEcmaVersion = true;\n      console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n    }\n    options.ecmaVersion = 11;\n  } else if (options.ecmaVersion >= 2015) {\n    options.ecmaVersion -= 2009;\n  }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (!opts || opts.allowHashBang == null)\n    { options.allowHashBang = options.ecmaVersion >= 14; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128,\n    SCOPE_CLASS_STATIC_BLOCK = 256,\n    SCOPE_CLASS_FIELD_INIT = 512,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal* and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types$1.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n  this.potentialArrowInForAwait = false;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = Object.create(null);\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n\n  // The stack of private names.\n  // Each element has two properties: 'declared' and 'used'.\n  // When it exited from the outermost class definition, all used private names must be declared.\n  this.privateNameStack = [];\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n\nprototypeAccessors.canAwait.get = function () {\n  for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n    var ref = this.scopeStack[i];\n      var flags = ref.flags;\n    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) { return false }\n    if (flags & SCOPE_FUNCTION) { return (flags & SCOPE_ASYNC) > 0 }\n  }\n  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction\n};\n\nprototypeAccessors.allowSuper.get = function () {\n  var ref = this.currentThisScope();\n    var flags = ref.flags;\n  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod\n};\n\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\nprototypeAccessors.allowNewDotTarget.get = function () {\n  for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n    var ref = this.scopeStack[i];\n      var flags = ref.flags;\n    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) ||\n        ((flags & SCOPE_FUNCTION) && !(flags & SCOPE_ARROW))) { return true }\n  }\n  return false\n};\n\nprototypeAccessors.inClassStaticBlock.get = function () {\n  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0\n};\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp$9 = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\[^]|[^'\\\\])*?)'|\"((?:\\\\[^]|[^\"\\\\])*?)\")/;\npp$9.strictDirective = function(start) {\n  if (this.options.ecmaVersion < 5) { return false }\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp$9.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp$9.isContextual = function(name) {\n  return this.type === types$1.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp$9.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp$9.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp$9.canInsertSemicolon = function() {\n  return this.type === types$1.eof ||\n    this.type === types$1.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp$9.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp$9.semicolon = function() {\n  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp$9.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp$9.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp$9.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n};\n\npp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\"); }\n};\n\npp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp$9.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp$9.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$8 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$8.parseTopLevel = function(node) {\n  var exports = Object.create(null);\n  if (!node.body) { node.body = []; }\n  while (this.type !== types$1.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$8.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91 || nextCh === 92) { return true } // '[', '\\'\n  if (context) { return false }\n\n  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }\n    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$8.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, after;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length ||\n     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))\n};\n\npp$8.isUsingKeyword = function(isAwaitUsing, isFor) {\n  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? \"await\" : \"using\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n\n  if (lineBreak.test(this.input.slice(this.pos, next))) { return false }\n\n  if (isAwaitUsing) {\n    var awaitEndPos = next + 5 /* await */, after;\n    if (this.input.slice(next, awaitEndPos) !== \"using\" ||\n      awaitEndPos === this.input.length ||\n      isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) ||\n      (after > 0xd7ff && after < 0xdc00)\n    ) { return false }\n\n    skipWhiteSpace.lastIndex = awaitEndPos;\n    var skipAfterUsing = skipWhiteSpace.exec(this.input);\n    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) { return false }\n  }\n\n  if (isFor) {\n    var ofEndPos = next + 2 /* of */, after$1;\n    if (this.input.slice(next, ofEndPos) === \"of\") {\n      if (ofEndPos === this.input.length ||\n        (!isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 0xd7ff && after$1 < 0xdc00))) { return false }\n    }\n  }\n\n  var ch = this.input.charCodeAt(next);\n  return isIdentifierStart(ch, true) || ch === 92 // '\\'\n};\n\npp$8.isAwaitUsing = function(isFor) {\n  return this.isUsingKeyword(true, isFor)\n};\n\npp$8.isUsing = function(isFor) {\n  return this.isUsingKeyword(false, isFor)\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$8.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types$1._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types$1._debugger: return this.parseDebuggerStatement(node)\n  case types$1._do: return this.parseDoStatement(node)\n  case types$1._for: return this.parseForStatement(node)\n  case types$1._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types$1._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types$1._if: return this.parseIfStatement(node)\n  case types$1._return: return this.parseReturnStatement(node)\n  case types$1._switch: return this.parseSwitchStatement(node)\n  case types$1._throw: return this.parseThrowStatement(node)\n  case types$1._try: return this.parseTryStatement(node)\n  case types$1._const: case types$1._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types$1._while: return this.parseWhileStatement(node)\n  case types$1._with: return this.parseWithStatement(node)\n  case types$1.braceL: return this.parseBlock(true, node)\n  case types$1.semi: return this.parseEmptyStatement(node)\n  case types$1._export:\n  case types$1._import:\n    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var usingKind = this.isAwaitUsing(false) ? \"await using\" : this.isUsing(false) ? \"using\" : null;\n    if (usingKind) {\n      if (topLevel && this.options.sourceType === \"script\") {\n        this.raise(this.start, \"Using declaration cannot appear in the top level when source type is `script`\");\n      }\n      if (usingKind === \"await using\") {\n        if (!this.canAwait) {\n          this.raise(this.start, \"Await using cannot appear outside of async function\");\n        }\n        this.next();\n      }\n      this.next();\n      this.parseVar(node, false, usingKind);\n      this.semicolon();\n      return this.finishNode(node, \"VariableDeclaration\")\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$8.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types$1.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$8.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$8.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types$1._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types$1.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$8.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types$1.parenL);\n  if (this.type === types$1.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types$1._var || this.type === types$1._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    return this.parseForAfterInit(node, init$1, awaitAt)\n  }\n  var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n\n  var usingKind = this.isUsing(true) ? \"using\" : this.isAwaitUsing(true) ? \"await using\" : null;\n  if (usingKind) {\n    var init$2 = this.startNode();\n    this.next();\n    if (usingKind === \"await using\") { this.next(); }\n    this.parseVar(init$2, true, usingKind);\n    this.finishNode(init$2, \"VariableDeclaration\");\n    return this.parseForAfterInit(node, init$2, awaitAt)\n  }\n  var containsEsc = this.containsEsc;\n  var refDestructuringErrors = new DestructuringErrors;\n  var initPos = this.start;\n  var init = awaitAt > -1\n    ? this.parseExprSubscripts(refDestructuringErrors, \"await\")\n    : this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)\n      if (this.type === types$1._in) { this.unexpected(awaitAt); }\n      node.await = true;\n    } else if (isForOf && this.options.ecmaVersion >= 8) {\n      if (init.start === initPos && !containsEsc && init.type === \"Identifier\" && init.name === \"async\") { this.unexpected(); }\n      else if (this.options.ecmaVersion >= 9) { node.await = false; }\n    }\n    if (startsWithLet && isForOf) { this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\"); }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLValPattern(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\n// Helper method to parse for loop after variable initialization\npp$8.parseForAfterInit = function(node, init, awaitAt) {\n  if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types$1._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    return this.parseForIn(node, init)\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$8.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$8.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$8.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types$1.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types$1.braceR;) {\n    if (this.type === types$1._case || this.type === types$1._default) {\n      var isCase = this.type === types$1._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types$1.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$8.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty$1 = [];\n\npp$8.parseCatchClauseParam = function() {\n  var param = this.parseBindingAtom();\n  var simple = param.type === \"Identifier\";\n  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n  this.expect(types$1.parenR);\n\n  return param\n};\n\npp$8.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types$1._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types$1.parenL)) {\n      clause.param = this.parseCatchClauseParam();\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n  this.next();\n  this.parseVar(node, false, kind, allowMissingInitializer);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$8.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$8.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$8.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$8.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types$1.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types$1.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$8.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types$1.semi);\n  node.test = this.type === types$1.semi ? null : this.parseExpression();\n  this.expect(types$1.semi);\n  node.update = this.type === types$1.parenR ? null : this.parseExpression();\n  this.expect(types$1.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$8.parseForIn = function(node, init) {\n  var isForIn = this.type === types$1._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types$1.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types$1.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (!allowMissingInitializer && (kind === \"using\" || kind === \"await using\") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual(\"of\")) {\n      this.raise(this.lastTokEnd, (\"Missing initializer in \" + kind + \" declaration\"));\n    } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types$1.comma)) { break }\n  }\n  return node\n};\n\npp$8.parseVarId = function(decl, kind) {\n  decl.id = kind === \"using\" || kind === \"await using\"\n    ? this.parseIdent()\n    : this.parseBindingAtom();\n\n  this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types$1.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types$1.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$8.parseFunctionParams = function(node) {\n  this.expect(types$1.parenL);\n  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$8.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var privateNameMap = this.enterClassBody();\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types$1.braceL);\n  while (this.type !== types$1.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n        this.raiseRecoverable(element.key.start, (\"Identifier '#\" + (element.key.name) + \"' has already been declared\"));\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  this.exitClassBody();\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$8.parseClassElement = function(constructorAllowsSuper) {\n  if (this.eat(types$1.semi)) { return null }\n\n  var ecmaVersion = this.options.ecmaVersion;\n  var node = this.startNode();\n  var keyName = \"\";\n  var isGenerator = false;\n  var isAsync = false;\n  var kind = \"method\";\n  var isStatic = false;\n\n  if (this.eatContextual(\"static\")) {\n    // Parse static init block\n    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n      this.parseClassStaticBlock(node);\n      return node\n    }\n    if (this.isClassElementNameStart() || this.type === types$1.star) {\n      isStatic = true;\n    } else {\n      keyName = \"static\";\n    }\n  }\n  node.static = isStatic;\n  if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n      isAsync = true;\n    } else {\n      keyName = \"async\";\n    }\n  }\n  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n    isGenerator = true;\n  }\n  if (!keyName && !isAsync && !isGenerator) {\n    var lastValue = this.value;\n    if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n      if (this.isClassElementNameStart()) {\n        kind = lastValue;\n      } else {\n        keyName = lastValue;\n      }\n    }\n  }\n\n  // Parse element name\n  if (keyName) {\n    // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n    // The last token is any of those. Make it the element name.\n    node.computed = false;\n    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n    node.key.name = keyName;\n    this.finishNode(node.key, \"Identifier\");\n  } else {\n    this.parseClassElementName(node);\n  }\n\n  // Parse element value\n  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n    var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n    var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n    if (isConstructor && kind !== \"method\") { this.raise(node.key.start, \"Constructor can't have get/set modifier\"); }\n    node.kind = isConstructor ? \"constructor\" : kind;\n    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n  } else {\n    this.parseClassField(node);\n  }\n\n  return node\n};\n\npp$8.isClassElementNameStart = function() {\n  return (\n    this.type === types$1.name ||\n    this.type === types$1.privateId ||\n    this.type === types$1.num ||\n    this.type === types$1.string ||\n    this.type === types$1.bracketL ||\n    this.type.keyword\n  )\n};\n\npp$8.parseClassElementName = function(element) {\n  if (this.type === types$1.privateId) {\n    if (this.value === \"constructor\") {\n      this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n    }\n    element.computed = false;\n    element.key = this.parsePrivateIdent();\n  } else {\n    this.parsePropertyName(element);\n  }\n};\n\npp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  // Check key and flags\n  var key = method.key;\n  if (method.kind === \"constructor\") {\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n  } else if (method.static && checkKeyName(method, \"prototype\")) {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n\n  // Parse value\n  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n\n  // Check value\n  if (method.kind === \"get\" && value.params.length !== 0)\n    { this.raiseRecoverable(value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && value.params.length !== 1)\n    { this.raiseRecoverable(value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\"); }\n\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$8.parseClassField = function(field) {\n  if (checkKeyName(field, \"constructor\")) {\n    this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n  } else if (field.static && checkKeyName(field, \"prototype\")) {\n    this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n  }\n\n  if (this.eat(types$1.eq)) {\n    // To raise SyntaxError if 'arguments' exists in the initializer.\n    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);\n    field.value = this.parseMaybeAssign();\n    this.exitScope();\n  } else {\n    field.value = null;\n  }\n  this.semicolon();\n\n  return this.finishNode(field, \"PropertyDefinition\")\n};\n\npp$8.parseClassStaticBlock = function(node) {\n  node.body = [];\n\n  var oldLabels = this.labels;\n  this.labels = [];\n  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n  while (this.type !== types$1.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  this.next();\n  this.exitScope();\n  this.labels = oldLabels;\n\n  return this.finishNode(node, \"StaticBlock\")\n};\n\npp$8.parseClassId = function(node, isStatement) {\n  if (this.type === types$1.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$8.parseClassSuper = function(node) {\n  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n};\n\npp$8.enterClassBody = function() {\n  var element = {declared: Object.create(null), used: []};\n  this.privateNameStack.push(element);\n  return element.declared\n};\n\npp$8.exitClassBody = function() {\n  var ref = this.privateNameStack.pop();\n  var declared = ref.declared;\n  var used = ref.used;\n  if (!this.options.checkPrivateFields) { return }\n  var len = this.privateNameStack.length;\n  var parent = len === 0 ? null : this.privateNameStack[len - 1];\n  for (var i = 0; i < used.length; ++i) {\n    var id = used[i];\n    if (!hasOwn(declared, id.name)) {\n      if (parent) {\n        parent.used.push(id);\n      } else {\n        this.raiseRecoverable(id.start, (\"Private field '#\" + (id.name) + \"' must be declared in an enclosing class\"));\n      }\n    }\n  }\n};\n\nfunction isPrivateNameConflicted(privateNameMap, element) {\n  var name = element.key.name;\n  var curr = privateNameMap[name];\n\n  var next = \"true\";\n  if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n    next = (element.static ? \"s\" : \"i\") + element.kind;\n  }\n\n  // `class { get #a(){}; static set #a(_){} }` is also conflict.\n  if (\n    curr === \"iget\" && next === \"iset\" ||\n    curr === \"iset\" && next === \"iget\" ||\n    curr === \"sget\" && next === \"sset\" ||\n    curr === \"sset\" && next === \"sget\"\n  ) {\n    privateNameMap[name] = \"true\";\n    return false\n  } else if (!curr) {\n    privateNameMap[name] = next;\n    return false\n  } else {\n    return true\n  }\n}\n\nfunction checkKeyName(node, name) {\n  var computed = node.computed;\n  var key = node.key;\n  return !computed && (\n    key.type === \"Identifier\" && key.name === name ||\n    key.type === \"Literal\" && key.value === name\n  )\n}\n\n// Parses module export declaration.\n\npp$8.parseExportAllDeclaration = function(node, exports) {\n  if (this.options.ecmaVersion >= 11) {\n    if (this.eatContextual(\"as\")) {\n      node.exported = this.parseModuleExportName();\n      this.checkExport(exports, node.exported, this.lastTokStart);\n    } else {\n      node.exported = null;\n    }\n  }\n  this.expectContextual(\"from\");\n  if (this.type !== types$1.string) { this.unexpected(); }\n  node.source = this.parseExprAtom();\n  if (this.options.ecmaVersion >= 16)\n    { node.attributes = this.parseWithClause(); }\n  this.semicolon();\n  return this.finishNode(node, \"ExportAllDeclaration\")\n};\n\npp$8.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types$1.star)) {\n    return this.parseExportAllDeclaration(node, exports)\n  }\n  if (this.eat(types$1._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    node.declaration = this.parseExportDefaultDeclaration();\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseExportDeclaration(node);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n    if (this.options.ecmaVersion >= 16)\n      { node.attributes = []; }\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types$1.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      if (this.options.ecmaVersion >= 16)\n        { node.attributes = this.parseWithClause(); }\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n\n        if (spec.local.type === \"Literal\") {\n          this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n        }\n      }\n\n      node.source = null;\n      if (this.options.ecmaVersion >= 16)\n        { node.attributes = []; }\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$8.parseExportDeclaration = function(node) {\n  return this.parseStatement(null)\n};\n\npp$8.parseExportDefaultDeclaration = function() {\n  var isAsync;\n  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n    var fNode = this.startNode();\n    this.next();\n    if (isAsync) { this.next(); }\n    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)\n  } else if (this.type === types$1._class) {\n    var cNode = this.startNode();\n    return this.parseClass(cNode, \"nullableID\")\n  } else {\n    var declaration = this.parseMaybeAssign();\n    this.semicolon();\n    return declaration\n  }\n};\n\npp$8.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (typeof name !== \"string\")\n    { name = name.type === \"Identifier\" ? name.name : name.value; }\n  if (hasOwn(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$8.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n};\n\npp$8.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$8.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$8.parseExportSpecifier = function(exports) {\n  var node = this.startNode();\n  node.local = this.parseModuleExportName();\n\n  node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n  this.checkExport(\n    exports,\n    node.exported,\n    node.exported.start\n  );\n\n  return this.finishNode(node, \"ExportSpecifier\")\n};\n\npp$8.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types$1.braceL);\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    nodes.push(this.parseExportSpecifier(exports));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$8.parseImport = function(node) {\n  this.next();\n\n  // import '...'\n  if (this.type === types$1.string) {\n    node.specifiers = empty$1;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n  }\n  if (this.options.ecmaVersion >= 16)\n    { node.attributes = this.parseWithClause(); }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$8.parseImportSpecifier = function() {\n  var node = this.startNode();\n  node.imported = this.parseModuleExportName();\n\n  if (this.eatContextual(\"as\")) {\n    node.local = this.parseIdent();\n  } else {\n    this.checkUnreserved(node.imported);\n    node.local = node.imported;\n  }\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n\n  return this.finishNode(node, \"ImportSpecifier\")\n};\n\npp$8.parseImportDefaultSpecifier = function() {\n  // import defaultObj, { x, y as z } from '...'\n  var node = this.startNode();\n  node.local = this.parseIdent();\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n  return this.finishNode(node, \"ImportDefaultSpecifier\")\n};\n\npp$8.parseImportNamespaceSpecifier = function() {\n  var node = this.startNode();\n  this.next();\n  this.expectContextual(\"as\");\n  node.local = this.parseIdent();\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n  return this.finishNode(node, \"ImportNamespaceSpecifier\")\n};\n\npp$8.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types$1.name) {\n    nodes.push(this.parseImportDefaultSpecifier());\n    if (!this.eat(types$1.comma)) { return nodes }\n  }\n  if (this.type === types$1.star) {\n    nodes.push(this.parseImportNamespaceSpecifier());\n    return nodes\n  }\n  this.expect(types$1.braceL);\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    nodes.push(this.parseImportSpecifier());\n  }\n  return nodes\n};\n\npp$8.parseWithClause = function() {\n  var nodes = [];\n  if (!this.eat(types$1._with)) {\n    return nodes\n  }\n  this.expect(types$1.braceL);\n  var attributeKeys = {};\n  var first = true;\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    var attr = this.parseImportAttribute();\n    var keyName = attr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n    if (hasOwn(attributeKeys, keyName))\n      { this.raiseRecoverable(attr.key.start, \"Duplicate attribute key '\" + keyName + \"'\"); }\n    attributeKeys[keyName] = true;\n    nodes.push(attr);\n  }\n  return nodes\n};\n\npp$8.parseImportAttribute = function() {\n  var node = this.startNode();\n  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n  this.expect(types$1.colon);\n  if (this.type !== types$1.string) {\n    this.unexpected();\n  }\n  node.value = this.parseExprAtom();\n  return this.finishNode(node, \"ImportAttribute\")\n};\n\npp$8.parseModuleExportName = function() {\n  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n    var stringLiteral = this.parseLiteral(this.value);\n    if (loneSurrogate.test(stringLiteral.value)) {\n      this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n    }\n    return stringLiteral\n  }\n  return this.parseIdent(true)\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$8.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$8.isDirectiveCandidate = function(statement) {\n  return (\n    this.options.ecmaVersion >= 5 &&\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$7 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"AssignmentPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$7.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$7.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$7.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$7.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types$1.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types$1.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types$1.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types$1.comma); }\n    if (allowEmpty && this.type === types$1.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types$1.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types$1.comma) { this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      elts.push(this.parseAssignableListItem(allowModifiers));\n    }\n  }\n  return elts\n};\n\npp$7.parseAssignableListItem = function(allowModifiers) {\n  var elem = this.parseMaybeDefault(this.start, this.startLoc);\n  this.parseBindingListItem(elem);\n  return elem\n};\n\npp$7.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// The following three functions all verify that a node is an lvalue \n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += ;\n//     import a from '';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = );\n//     const a = ;\n//     try {  } catch (a) {  }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\n\npp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  var isBind = bindingType !== BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (isBind) {\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (checkClashes) {\n        if (hasOwn(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (isBind) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ParenthesizedExpression\":\n    if (isBind) { this.raiseRecoverable(expr.start, \"Binding parenthesized expression\"); }\n    return this.checkLValSimple(expr.expression, bindingType, checkClashes)\n\n  default:\n    this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\npp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n    this.checkLValInnerPattern(prop, bindingType, checkClashes);\n    }\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }\n    }\n    break\n\n  default:\n    this.checkLValSimple(expr, bindingType, checkClashes);\n  }\n};\n\npp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLValPattern(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLValPattern(expr.argument, bindingType, checkClashes);\n    break\n\n  default:\n    this.checkLValPattern(expr, bindingType, checkClashes);\n  }\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$6 = Parser.prototype;\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n};\n\npp$6.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\npp$6.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types.f_expr || parent === types.f_stat)\n    { return true }\n  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)\n    { return true }\n  if (prevType === types$1.braceL)\n    { return parent === types.b_stat }\n  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$6.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types$1.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n\npp$6.overrideContext = function(tokenCtx) {\n  if (this.curContext() !== tokenCtx) {\n    this.context[this.context.length - 1] = tokenCtx;\n  }\n};\n\n// Token-specific context update code\n\ntypes$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes$1.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes$1.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes$1.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n  this.context.push(statementParens ? types.p_stat : types.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes$1.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types$1._else &&\n      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&\n      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))\n    { this.context.push(types.f_expr); }\n  else\n    { this.context.push(types.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes$1.colon.updateContext = function() {\n  if (this.curContext().token === \"function\") { this.context.pop(); }\n  this.exprAllowed = true;\n};\n\ntypes$1.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes$1.star.updateContext = function(prevType) {\n  if (prevType === types$1._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types.f_expr)\n      { this.context[index] = types.f_expr_gen; }\n    else\n      { this.context[index] = types.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes$1.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\nvar pp$5 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0) {\n            refDestructuringErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n        }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$5.parseExpression = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n  if (this.type === types$1.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(forInit) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    oldDoubleProto = refDestructuringErrors.doubleProto;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types$1.parenL || this.type === types$1.name) {\n    this.potentialArrowAt = this.start;\n    this.potentialArrowInForAwait = forInit === \"await\";\n  }\n  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    if (this.type === types$1.eq)\n      { left = this.toAssignable(left, false, refDestructuringErrors); }\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    if (this.type === types$1.eq)\n      { this.checkLValPattern(left); }\n    else\n      { this.checkLValSimple(left); }\n    node.left = left;\n    this.next();\n    node.right = this.parseMaybeAssign(forInit);\n    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(forInit, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types$1.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types$1.colon);\n    node.alternate = this.parseMaybeAssign(forInit);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n  var prec = this.type.binop;\n  if (prec != null && (!forInit || this.type !== types$1._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n      var coalesce = this.type === types$1.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types$1.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)\n    }\n  }\n  return left\n};\n\npp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  if (right.type === \"PrivateIdentifier\") { this.raise(right.start, \"Private identifier can only be left side of binary expression\"); }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && this.canAwait) {\n    expr = this.parseAwait(forInit);\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types$1.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, update, forInit);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLValSimple(node.argument); }\n    else if (this.strict && node.operator === \"delete\" && isLocalVariableAccess(node.argument))\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument))\n      { this.raiseRecoverable(node.start, \"Private fields can not be deleted\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (!sawUnary && this.type === types$1.privateId) {\n    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }\n    expr = this.parsePrivateIdent();\n    // only could be private fields in 'in', such as #x in obj\n    if (this.type !== types$1._in) { this.unexpected(); }\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLValSimple(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!incDec && this.eat(types$1.starstar)) {\n    if (sawUnary)\n      { this.unexpected(this.lastTokStart); }\n    else\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false) }\n  } else {\n    return expr\n  }\n};\n\nfunction isLocalVariableAccess(node) {\n  return (\n    node.type === \"Identifier\" ||\n    node.type === \"ParenthesizedExpression\" && isLocalVariableAccess(node.expression)\n  )\n}\n\nfunction isPrivateFieldAccess(node) {\n  return (\n    node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" ||\n    node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression) ||\n    node.type === \"ParenthesizedExpression\" && isPrivateFieldAccess(node.expression)\n  )\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }\n  }\n  return result\n};\n\npp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$5.shouldParseAsyncArrow = function() {\n  return !this.canInsertSemicolon() && this.eat(types$1.arrow)\n};\n\npp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)\n};\n\npp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types$1.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types$1.bracketL);\n  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(types$1.bracketR);\n    } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n      node.property = this.parsePrivateIdent();\n    } else {\n      node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n    }\n    node.computed = !!computed;\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types$1.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types$1.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types$1.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types$1._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types$1.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types$1._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types$1.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n      this.overrideContext(types.f_expr);\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)\n    }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types$1.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc &&\n          (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)\n      }\n    }\n    return id\n\n  case types$1.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types$1.num: case types$1.string:\n    return this.parseLiteral(this.value)\n\n  case types$1._null: case types$1._true: case types$1._false:\n    node = this.startNode();\n    node.value = this.type === types$1._null ? null : this.type === types$1._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types$1.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types$1.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types$1.braceL:\n    this.overrideContext(types.b_expr);\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types$1._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types$1._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types$1._new:\n    return this.parseNew()\n\n  case types$1.backQuote:\n    return this.parseTemplate()\n\n  case types$1._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport(forNew)\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    return this.parseExprAtomDefault()\n  }\n};\n\npp$5.parseExprAtomDefault = function() {\n  this.unexpected();\n};\n\npp$5.parseExprImport = function(forNew) {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  this.next();\n\n  if (this.type === types$1.parenL && !forNew) {\n    return this.parseDynamicImport(node)\n  } else if (this.type === types$1.dot) {\n    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n    meta.name = \"import\";\n    node.meta = this.finishNode(meta, \"Identifier\");\n    return this.parseImportMeta(node)\n  } else {\n    this.unexpected();\n  }\n};\n\npp$5.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  if (this.options.ecmaVersion >= 16) {\n    if (!this.eat(types$1.parenR)) {\n      this.expect(types$1.comma);\n      if (!this.afterTrailingComma(types$1.parenR)) {\n        node.options = this.parseMaybeAssign();\n        if (!this.eat(types$1.parenR)) {\n          this.expect(types$1.comma);\n          if (!this.afterTrailingComma(types$1.parenR)) {\n            this.unexpected();\n          }\n        }\n      } else {\n        node.options = null;\n      }\n    } else {\n      node.options = null;\n    }\n  } else {\n    // Verify ending.\n    if (!this.eat(types$1.parenR)) {\n      var errorPos = this.start;\n      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n        this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n      } else {\n        this.unexpected(errorPos);\n      }\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$5.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere)\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$5.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110)\n    { node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, \"\"); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$5.parseParenExpression = function() {\n  this.expect(types$1.parenL);\n  var val = this.parseExpression();\n  this.expect(types$1.parenR);\n  return val\n};\n\npp$5.shouldParseArrow = function(exprList) {\n  return !this.canInsertSemicolon()\n};\n\npp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types$1.parenR) {\n      first ? first = false : this.expect(types$1.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types$1.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types$1.comma) {\n          this.raiseRecoverable(\n            this.start,\n            \"Comma is not permitted after the rest element\"\n          );\n        }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n    this.expect(types$1.parenR);\n\n    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$5.parseParenItem = function(item) {\n  return item\n};\n\npp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty = [];\n\npp$5.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  this.next();\n  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n    meta.name = \"new\";\n    node.meta = this.finishNode(meta, \"Identifier\");\n    this.next();\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.allowNewDotTarget)\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$5.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types$1.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value.replace(/\\r\\n?/g, \"\\n\"),\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types$1.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$5.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types$1.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types$1.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types$1.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$5.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$5.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types$1.comma) {\n        this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types$1.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n    this.parsePropertyName(prop);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$5.parseGetterSetter = function(prop) {\n  var kind = prop.key.name;\n  this.parsePropertyName(prop);\n  prop.value = this.parseMethod(false);\n  prop.kind = kind;\n  var paramCount = prop.kind === \"get\" ? 0 : 1;\n  if (prop.value.params.length !== paramCount) {\n    var start = prop.value.start;\n    if (prop.kind === \"get\")\n      { this.raiseRecoverable(start, \"getter should have no params\"); }\n    else\n      { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n  } else {\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n  }\n};\n\npp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types$1.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types$1.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n    prop.kind = \"init\";\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.parseGetterSetter(prop);\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n    } else if (this.type === types$1.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n    } else {\n      prop.value = this.copyNode(prop.key);\n    }\n    prop.kind = \"init\";\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$5.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types$1.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types$1.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$5.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types$1.parenL);\n  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false, forInit);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n  var isExpression = isArrowFunction && this.type !== types$1.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign(forInit);\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$5.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$5.checkParams = function(node, allowDuplicates) {\n  var nameHash = Object.create(null);\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types$1.comma)\n      { elt = null; }\n    else if (this.type === types$1.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$5.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === \"arguments\")\n    { this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\"); }\n  if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\"))\n    { this.raise(start, (\"Cannot use \" + name + \" in class static initialization block\")); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$5.parseIdent = function(liberal) {\n  var node = this.parseIdentNode();\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\npp$5.parseIdentNode = function() {\n  var node = this.startNode();\n  if (this.type === types$1.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n      (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n    this.type = types$1.name;\n  } else {\n    this.unexpected();\n  }\n  return node\n};\n\npp$5.parsePrivateIdent = function() {\n  var node = this.startNode();\n  if (this.type === types$1.privateId) {\n    node.name = this.value;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"PrivateIdentifier\");\n\n  // For validating existence\n  if (this.options.checkPrivateFields) {\n    if (this.privateNameStack.length === 0) {\n      this.raise(node.start, (\"Private field '#\" + (node.name) + \"' must be declared in an enclosing class\"));\n    } else {\n      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n    }\n  }\n\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$5.parseYield = function(forInit) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types$1.star);\n    node.argument = this.parseMaybeAssign(forInit);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$5.parseAwait = function(forInit) {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true, false, forInit);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  if (this.sourceFile) {\n    message += \" in \" + this.sourceFile;\n  }\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$3 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$3.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$3.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$3.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$3.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$3.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$3.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$3.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$3.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) &&\n        !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$2 = Parser.prototype;\n\npp$2.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$2.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$2.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$2.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\npp$2.copyNode = function(node) {\n  var newNode = new Node(this, node.start, this.startLoc);\n  for (var prop in node) { newNode[prop] = node[prop]; }\n  return newNode\n};\n\n// This file was generated by \"bin/generate-unicode-script-values.js\". Do not modify manually!\nvar scriptValuesAddedInUnicode = \"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\";\n\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar ecma13BinaryProperties = ecma12BinaryProperties;\nvar ecma14BinaryProperties = ecma13BinaryProperties;\n\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties,\n  12: ecma12BinaryProperties,\n  13: ecma13BinaryProperties,\n  14: ecma14BinaryProperties\n};\n\n// #table-binary-unicode-properties-of-strings\nvar ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n\nvar unicodeBinaryPropertiesOfStrings = {\n  9: \"\",\n  10: \"\",\n  11: \"\",\n  12: \"\",\n  13: \"\",\n  14: ecma14BinaryPropertiesOfStrings\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar ecma14ScriptValues = ecma13ScriptValues + \" \" + scriptValuesAddedInUnicode;\n\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues,\n  12: ecma12ScriptValues,\n  13: ecma13ScriptValues,\n  14: ecma14ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\n\nfor (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {\n  var ecmaVersion = list[i];\n\n  buildUnicodeData(ecmaVersion);\n}\n\nvar pp$1 = Parser.prototype;\n\n// Track disjunction structure to determine whether a duplicate\n// capture group name is allowed because it is in a separate branch.\nvar BranchID = function BranchID(parent, base) {\n  // Parent disjunction branch\n  this.parent = parent;\n  // Identifies this set of sibling branches\n  this.base = base || this;\n};\n\nBranchID.prototype.separatedFrom = function separatedFrom (alt) {\n  // A branch is separate from another branch if they or any of\n  // their parents are siblings in a given disjunction\n  for (var self = this; self; self = self.parent) {\n    for (var other = alt; other; other = other.parent) {\n      if (self.base === other.base && self !== other) { return true }\n    }\n  }\n  return false\n};\n\nBranchID.prototype.sibling = function sibling () {\n  return new BranchID(this.parent, this.base)\n};\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchV = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = Object.create(null);\n  this.backReferenceNames = [];\n  this.branchID = null;\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicodeSets = flags.indexOf(\"v\") !== -1;\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n    this.switchU = true;\n    this.switchV = true;\n    this.switchN = true;\n  } else {\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchV = false;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  }\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nRegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var pos = this.pos;\n  for (var i = 0, list = chs; i < list.length; i += 1) {\n    var ch = list[i];\n\n      var current = this.at(pos, forceU);\n    if (current === -1 || current !== ch) {\n      return false\n    }\n    pos = this.nextIndex(pos, forceU);\n  }\n  this.pos = pos;\n  return true\n};\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$1.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  var u = false;\n  var v = false;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n    if (flag === \"u\") { u = true; }\n    if (flag === \"v\") { v = true; }\n  }\n  if (this.options.ecmaVersion >= 15 && u && v) {\n    this.raise(state.start, \"Invalid regular expression flag\");\n  }\n};\n\nfunction hasProp(obj) {\n  for (var _ in obj) { return true }\n  return false\n}\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$1.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$1.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames = Object.create(null);\n  state.backReferenceNames.length = 0;\n  state.branchID = null;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (!state.groupNames[name]) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$1.regexp_disjunction = function(state) {\n  var trackDisjunction = this.options.ecmaVersion >= 16;\n  if (trackDisjunction) { state.branchID = new BranchID(state.branchID, null); }\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    if (trackDisjunction) { state.branchID = state.branchID.sibling(); }\n    this.regexp_alternative(state);\n  }\n  if (trackDisjunction) { state.branchID = state.branchID.parent; }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$1.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$1.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$1.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$1.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$1.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$1.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.options.ecmaVersion >= 16) {\n        var addModifiers = this.regexp_eatModifiers(state);\n        var hasHyphen = state.eat(0x2D /* - */);\n        if (addModifiers || hasHyphen) {\n          for (var i = 0; i < addModifiers.length; i++) {\n            var modifier = addModifiers.charAt(i);\n            if (addModifiers.indexOf(modifier, i + 1) > -1) {\n              state.raise(\"Duplicate regular expression modifiers\");\n            }\n          }\n          if (hasHyphen) {\n            var removeModifiers = this.regexp_eatModifiers(state);\n            if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */) {\n              state.raise(\"Invalid regular expression modifiers\");\n            }\n            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {\n              var modifier$1 = removeModifiers.charAt(i$1);\n              if (\n                removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||\n                addModifiers.indexOf(modifier$1) > -1\n              ) {\n                state.raise(\"Duplicate regular expression modifiers\");\n              }\n            }\n          }\n        }\n      }\n      if (state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n// RegularExpressionModifiers ::\n//   [empty]\n//   RegularExpressionModifiers RegularExpressionModifier\npp$1.regexp_eatModifiers = function(state) {\n  var modifiers = \"\";\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {\n    modifiers += codePointToString(ch);\n    state.advance();\n  }\n  return modifiers\n};\n// RegularExpressionModifier :: one of\n//   `i` `m` `s`\nfunction isRegularExpressionModifier(ch) {\n  return ch === 0x69 /* i */ || ch === 0x6d /* m */ || ch === 0x73 /* s */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$1.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$1.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$1.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$1.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$1.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (!this.regexp_eatGroupName(state)) { state.raise(\"Invalid group\"); }\n    var trackDisjunction = this.options.ecmaVersion >= 16;\n    var known = state.groupNames[state.lastStringValue];\n    if (known) {\n      if (trackDisjunction) {\n        for (var i = 0, list = known; i < list.length; i += 1) {\n          var altID = list[i];\n\n          if (!altID.separatedFrom(state.branchID))\n            { state.raise(\"Duplicate capture group name\"); }\n        }\n      } else {\n        state.raise(\"Duplicate capture group name\");\n      }\n    }\n    if (trackDisjunction) {\n      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);\n    } else {\n      state.groupNames[state.lastStringValue] = true;\n    }\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$1.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$1.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$1.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$1.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$1.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$1.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$1.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$1.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$1.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$1.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar CharSetNone = 0; // Nothing parsed\nvar CharSetOk = 1; // Construct parsed, cannot contain strings\nvar CharSetString = 2; // Construct parsed, can contain strings\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$1.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return CharSetOk\n  }\n\n  var negate = false;\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    var result;\n    if (\n      state.eat(0x7B /* { */) &&\n      (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&\n      state.eat(0x7D /* } */)\n    ) {\n      if (negate && result === CharSetString) { state.raise(\"Invalid property name\"); }\n      return result\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return CharSetNone\n};\n\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return CharSetOk\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)\n  }\n  return CharSetNone\n};\n\npp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!hasOwn(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\n\npp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }\n  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }\n  state.raise(\"Invalid property name\");\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$1.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\n\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$1.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    var negate = state.eat(0x5E /* ^ */);\n    var result = this.regexp_classContents(state);\n    if (!state.eat(0x5D /* ] */))\n      { state.raise(\"Unterminated character class\"); }\n    if (negate && result === CharSetString)\n      { state.raise(\"Negated character class may contain strings\"); }\n    return true\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\npp$1.regexp_classContents = function(state) {\n  if (state.current() === 0x5D /* ] */) { return CharSetOk }\n  if (state.switchV) { return this.regexp_classSetExpression(state) }\n  this.regexp_nonEmptyClassRanges(state);\n  return CharSetOk\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$1.regexp_nonEmptyClassRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$1.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$1.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\npp$1.regexp_classSetExpression = function(state) {\n  var result = CharSetOk, subResult;\n  if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {\n    if (subResult === CharSetString) { result = CharSetString; }\n    // https://tc39.es/ecma262/#prod-ClassIntersection\n    var start = state.pos;\n    while (state.eatChars([0x26, 0x26] /* && */)) {\n      if (\n        state.current() !== 0x26 /* & */ &&\n        (subResult = this.regexp_eatClassSetOperand(state))\n      ) {\n        if (subResult !== CharSetString) { result = CharSetOk; }\n        continue\n      }\n      state.raise(\"Invalid character in character class\");\n    }\n    if (start !== state.pos) { return result }\n    // https://tc39.es/ecma262/#prod-ClassSubtraction\n    while (state.eatChars([0x2D, 0x2D] /* -- */)) {\n      if (this.regexp_eatClassSetOperand(state)) { continue }\n      state.raise(\"Invalid character in character class\");\n    }\n    if (start !== state.pos) { return result }\n  } else {\n    state.raise(\"Invalid character in character class\");\n  }\n  // https://tc39.es/ecma262/#prod-ClassUnion\n  for (;;) {\n    if (this.regexp_eatClassSetRange(state)) { continue }\n    subResult = this.regexp_eatClassSetOperand(state);\n    if (!subResult) { return result }\n    if (subResult === CharSetString) { result = CharSetString; }\n  }\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetRange\npp$1.regexp_eatClassSetRange = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatClassSetCharacter(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {\n      var right = state.lastIntValue;\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetOperand\npp$1.regexp_eatClassSetOperand = function(state) {\n  if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }\n  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)\n};\n\n// https://tc39.es/ecma262/#prod-NestedClass\npp$1.regexp_eatNestedClass = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5B /* [ */)) {\n    var negate = state.eat(0x5E /* ^ */);\n    var result = this.regexp_classContents(state);\n    if (state.eat(0x5D /* ] */)) {\n      if (negate && result === CharSetString) {\n        state.raise(\"Negated character class may contain strings\");\n      }\n      return result\n    }\n    state.pos = start;\n  }\n  if (state.eat(0x5C /* \\ */)) {\n    var result$1 = this.regexp_eatCharacterClassEscape(state);\n    if (result$1) {\n      return result$1\n    }\n    state.pos = start;\n  }\n  return null\n};\n\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\npp$1.regexp_eatClassStringDisjunction = function(state) {\n  var start = state.pos;\n  if (state.eatChars([0x5C, 0x71] /* \\q */)) {\n    if (state.eat(0x7B /* { */)) {\n      var result = this.regexp_classStringDisjunctionContents(state);\n      if (state.eat(0x7D /* } */)) {\n        return result\n      }\n    } else {\n      // Make the same message as V8.\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return null\n};\n\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\npp$1.regexp_classStringDisjunctionContents = function(state) {\n  var result = this.regexp_classString(state);\n  while (state.eat(0x7C /* | */)) {\n    if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }\n  }\n  return result\n};\n\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\npp$1.regexp_classString = function(state) {\n  var count = 0;\n  while (this.regexp_eatClassSetCharacter(state)) { count++; }\n  return count === 1 ? CharSetOk : CharSetString\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\npp$1.regexp_eatClassSetCharacter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (\n      this.regexp_eatCharacterEscape(state) ||\n      this.regexp_eatClassSetReservedPunctuator(state)\n    ) {\n      return true\n    }\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n    state.pos = start;\n    return false\n  }\n  var ch = state.current();\n  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }\n  if (isClassSetSyntaxCharacter(ch)) { return false }\n  state.advance();\n  state.lastIntValue = ch;\n  return true\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction isClassSetReservedDoublePunctuatorCharacter(ch) {\n  return (\n    ch === 0x21 /* ! */ ||\n    ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||\n    ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||\n    ch === 0x2E /* . */ ||\n    ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||\n    ch === 0x5E /* ^ */ ||\n    ch === 0x60 /* ` */ ||\n    ch === 0x7E /* ~ */\n  )\n}\n\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction isClassSetSyntaxCharacter(ch) {\n  return (\n    ch === 0x28 /* ( */ ||\n    ch === 0x29 /* ) */ ||\n    ch === 0x2D /* - */ ||\n    ch === 0x2F /* / */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\npp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n  var ch = state.current();\n  if (isClassSetReservedPunctuator(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction isClassSetReservedPunctuator(ch) {\n  return (\n    ch === 0x21 /* ! */ ||\n    ch === 0x23 /* # */ ||\n    ch === 0x25 /* % */ ||\n    ch === 0x26 /* & */ ||\n    ch === 0x2C /* , */ ||\n    ch === 0x2D /* - */ ||\n    ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||\n    ch === 0x40 /* @ */ ||\n    ch === 0x60 /* ` */ ||\n    ch === 0x7E /* ~ */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$1.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$1.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$1.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$1.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp = Parser.prototype;\n\n// Move to the next token\n\npp.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp[Symbol.iterator] = function() {\n    var this$1$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1$1.getToken();\n        return {\n          done: token.type === types$1.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xdc00) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00\n};\n\npp.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {\n      ++this.curLine;\n      pos = this.lineStart = nextBreak;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types$1.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types$1.dot)\n  }\n};\n\npp.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.slash, 1)\n};\n\npp.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types$1.star : types$1.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types$1.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (this.options.ecmaVersion >= 12) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }\n    }\n    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)\n  }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)\n};\n\npp.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.bitwiseXOR, 1)\n};\n\npp.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types$1.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.plusMin, 1)\n};\n\npp.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }\n    return this.finishOp(types$1.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types$1.relational, size)\n};\n\npp.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types$1.arrow)\n  }\n  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)\n};\n\npp.readToken_question = function() { // '?'\n  var ecmaVersion = this.options.ecmaVersion;\n  if (ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }\n    }\n    if (next === 63) {\n      if (ecmaVersion >= 12) {\n        var next2$1 = this.input.charCodeAt(this.pos + 2);\n        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }\n      }\n      return this.finishOp(types$1.coalesce, 2)\n    }\n  }\n  return this.finishOp(types$1.question, 1)\n};\n\npp.readToken_numberSign = function() { // '#'\n  var ecmaVersion = this.options.ecmaVersion;\n  var code = 35; // '#'\n  if (ecmaVersion >= 13) {\n    ++this.pos;\n    code = this.fullCharCodeAtPos();\n    if (isIdentifierStart(code, true) || code === 92 /* '\\' */) {\n      return this.finishToken(types$1.privateId, this.readWord1())\n    }\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types$1.parenL)\n  case 41: ++this.pos; return this.finishToken(types$1.parenR)\n  case 59: ++this.pos; return this.finishToken(types$1.semi)\n  case 44: ++this.pos; return this.finishToken(types$1.comma)\n  case 91: ++this.pos; return this.finishToken(types$1.bracketL)\n  case 93: ++this.pos; return this.finishToken(types$1.bracketR)\n  case 123: ++this.pos; return this.finishToken(types$1.braceL)\n  case 125: ++this.pos; return this.finishToken(types$1.braceR)\n  case 58: ++this.pos; return this.finishToken(types$1.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types$1.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types$1.prefix, 1)\n\n  case 35: // '#'\n    return this.readToken_numberSign()\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n  // `len` is used for character escape sequences. In that case, disallow separators.\n  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n  // and isn't fraction part nor exponent part. In that case, if the first digit\n  // is zero then disallow separators.\n  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n  var start = this.pos, total = 0, lastCode = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n    if (allowSeparators && code === 95) {\n      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n      if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n      if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n      lastCode = code;\n      continue\n    }\n\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    lastCode = code;\n    total = total * radix + val;\n  }\n\n  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n  if (isLegacyOctalNumericLiteral) {\n    return parseInt(str, 8)\n  }\n\n  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n  return parseFloat(str.replace(/_/g, \"\"))\n}\n\nfunction stringToBigInt(str) {\n  if (typeof BigInt !== \"function\") {\n    return null\n  }\n\n  // `BigInt(value)` throws syntax error if the string contains numeric separators.\n  return BigInt(str.replace(/_/g, \"\"))\n}\n\npp.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types$1.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types$1.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var val = stringToNumber(this.input.slice(start, this.pos), octal);\n  return this.finishToken(types$1.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\npp.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else if (ch === 0x2028 || ch === 0x2029) {\n      if (this.options.ecmaVersion < 10) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n      if (this.options.locations) {\n        this.curLine++;\n        this.lineStart = this.pos;\n      }\n    } else {\n      if (isNewLine(ch)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types$1.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types$1.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types$1.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types$1.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") { break }\n      // fall through\n    case \"`\":\n      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    case \"\\r\":\n      if (this.input[this.pos + 1] === \"\\n\") { ++this.pos; }\n      // fall through\n    case \"\\n\": case \"\\u2028\": case \"\\u2029\":\n      ++this.curLine;\n      this.lineStart = this.pos + 1;\n      break\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (this.strict) {\n      this.invalidStringToken(\n        this.pos - 1,\n        \"Invalid escape sequence\"\n      );\n    }\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp.readWord = function() {\n  var word = this.readWord1();\n  var type = types$1.name;\n  if (this.keywords.test(word)) {\n    type = keywords[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n\n\nvar version = \"8.15.0\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types$1,\n  keywordTypes: keywords,\n  TokContext: TokContext,\n  tokContexts: types,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and returns\n// an abstract syntax tree as specified by the [ESTree spec][estree].\n//\n// [estree]: https://github.com/estree/estree\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\nexport { Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywords as keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, types as tokContexts, types$1 as tokTypes, tokenizer, version };\n","export const constants = {\n  undefined: 'void(0)',\n  Infinity:  'Number.POSITIVE_INFINITY',\n  NaN:       'Number.NaN',\n  E:         'Math.E',\n  LN2:       'Math.LN2',\n  LN10:      'Math.LN10',\n  LOG2E:     'Math.LOG2E',\n  LOG10E:    'Math.LOG10E',\n  PI:        'Math.PI',\n  SQRT1_2:   'Math.SQRT1_2',\n  SQRT2:     'Math.SQRT2'\n};\n","/**\n * @param {*} value\n * @returns {value is number}\n */\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n","import { parse } from 'acorn';\nimport {\n  ArrayPattern,\n  Constant,\n  Function,\n  Identifier,\n  Literal,\n  MemberExpression,\n  ObjectPattern,\n  Op,\n  Parameter,\n  Property\n} from './ast/constants.js';\nimport { is, isFunctionExpression } from './ast/util.js';\nimport { walk } from './ast/walk.js';\nimport { constants } from './constants.js';\nimport { rewrite } from './rewrite.js';\nimport { ROW_OBJECT, rowObjectExpression } from './row-object.js';\nimport {\n  getAggregate, getWindow,\n  hasAggregate, hasFunction, hasWindow\n} from '../op/index.js';\n\nimport { error } from '../util/error.js';\nimport { isArray } from '../util/is-array.js';\nimport { isNumber } from '../util/is-number.js';\nimport { toString } from '../util/to-string.js';\n\nconst PARSER_OPT = { ecmaVersion: 11 };\nconst DEFAULT_PARAM_ID = '$';\nconst DEFAULT_TUPLE_ID = 'd';\nconst DEFAULT_TUPLE_ID1 = 'd1';\nconst DEFAULT_TUPLE_ID2 = 'd2';\n\nconst NO = msg => (node, ctx) => ctx.error(node, msg + ' not allowed');\nconst ERROR_AGGREGATE = NO('Aggregate function');\nconst ERROR_WINDOW = NO('Window function');\nconst ERROR_ARGUMENT = 'Invalid argument';\nconst ERROR_COLUMN = 'Invalid column reference';\nconst ERROR_AGGRONLY = ERROR_COLUMN + ' (must be input to an aggregate function)';\nconst ERROR_FUNCTION = 'Invalid function call';\nconst ERROR_MEMBER = 'Invalid member expression';\nconst ERROR_OP_PARAMETER = 'Invalid operator parameter';\nconst ERROR_PARAM = 'Invalid param reference';\nconst ERROR_VARIABLE = 'Invalid variable reference';\nconst ERROR_VARIABLE_OP = 'Variable not accessible in operator call';\nconst ERROR_DECLARATION = 'Unsupported variable declaration';\nconst ERROR_DESTRUCTURE = 'Unsupported destructuring pattern';\nconst ERROR_CLOSURE = 'Table expressions do not support closures';\nconst ERROR_ESCAPE = 'Use aq.escape(fn) to use a function as-is (including closures)';\nconst ERROR_USE_PARAMS = 'use table.params({ name: value }) to define dynamic parameters';\nconst ERROR_ADD_FUNCTION = 'use aq.addFunction(name, fn) to add new op functions';\nconst ERROR_VARIABLE_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_USE_PARAMS}.`;\nconst ERROR_FUNCTION_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_ADD_FUNCTION}.`;\nconst ERROR_ROW_OBJECT = `The ${ROW_OBJECT} method is not valid in multi-table expressions.`;\n\nexport function parseExpression(ctx, spec) {\n  const ast = parseAST(spec);\n  let node = ctx.root = ast;\n  ctx.spec = spec;\n  ctx.tuple = null;\n  ctx.tuple1 = null;\n  ctx.tuple2 = null;\n  ctx.$param = null;\n  ctx.$op = 0;\n  ctx.scope = new Set();\n  ctx.paramsRef = new Map();\n  ctx.columnRef = new Map();\n\n  // parse input column parameters\n  // if no function def, assume default tuple identifiers\n  if (isFunctionExpression(node)) {\n    parseFunction(node, ctx);\n    node = node.body;\n  } else if (ctx.join) {\n    ctx.scope.add(ctx.tuple1 = DEFAULT_TUPLE_ID1);\n    ctx.scope.add(ctx.tuple2 = DEFAULT_TUPLE_ID2);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  } else {\n    ctx.scope.add(ctx.tuple = DEFAULT_TUPLE_ID);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  }\n\n  // rewrite column references & function calls\n  walk(node, ctx, visitors);\n\n  return ctx.root;\n}\n\nfunction parseAST(expr) {\n  try {\n    const code = expr.field ? fieldRef(expr)\n      : isArray(expr) ? toString(expr)\n      : expr;\n    // @ts-ignore\n    return parse(`expr=(${code})`, PARSER_OPT).body[0].expression.right;\n  } catch (err) { // eslint-disable-line no-unused-vars\n    error(`Expression parse error: ${expr+''}`);\n  }\n}\n\nfunction fieldRef(expr) {\n  const col = JSON.stringify(expr+'');\n  return !(expr.table || 0) ? `d=>d[${col}]` : `(a,b)=>b[${col}]`;\n}\n\nconst visitors = {\n  FunctionDeclaration: NO('Function definitions'),\n  ForStatement: NO('For loops'),\n  ForOfStatement: NO('For-of loops'),\n  ForInStatement: NO('For-in loops'),\n  WhileStatement: NO('While loops'),\n  DoWhileStatement: NO('Do-while loops'),\n  AwaitExpression: NO('Await expressions'),\n  ArrowFunctionExpression: NO('Function definitions'),\n  AssignmentExpression: NO('Assignments'),\n  FunctionExpression: NO('Function definitions'),\n  NewExpression: NO('Use of \"new\"'),\n  UpdateExpression: NO('Update expressions'),\n\n  VariableDeclarator(node, ctx) {\n    handleDeclaration(node.id, ctx);\n  },\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent) && !ctx.scope.has(node.name)) {\n      // handle identifier passed responsibility here\n      // raise error if identifier not defined in scope\n      ctx.error(node, ERROR_VARIABLE, ERROR_VARIABLE_NOTE);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n    const def = getAggregate(name) || getWindow(name);\n\n    // parse operator and rewrite invocation\n    if (def) {\n      if ((ctx.join || ctx.aggregate === false) && hasAggregate(name)) {\n        ERROR_AGGREGATE(node, ctx);\n      }\n      if ((ctx.join || ctx.window === false) && hasWindow(name)) {\n        ERROR_WINDOW(node, ctx);\n      }\n\n      ctx.$op = 1;\n      if (ctx.ast) {\n        updateFunctionNode(node, name, ctx);\n        node.arguments.forEach(arg => walk(arg, ctx, opVisitors));\n      } else {\n        const op = ctx.op(parseOperator(ctx, def, name, node.arguments));\n        Object.assign(node, { type: Op, name: op.id });\n      }\n      ctx.$op = 0;\n      return false;\n    } else if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  },\n  MemberExpression(node, ctx, parent) {\n    const { object, property } = node;\n\n    // bail if left head is not an identifier\n    // in this case we will recurse and handle it later\n    if (!is(Identifier, object)) return;\n    const { name } = object;\n\n    // allow use of Math prefix to access constant values\n    if (isMath(node) && is(Identifier, property)\n        && Object.hasOwn(constants, property.name)) {\n      updateConstantNode(node, property.name);\n      return;\n    }\n\n    const index = name === ctx.tuple ? 0\n      : name === ctx.tuple1 ? 1\n      : name === ctx.tuple2 ? 2\n      : -1;\n\n    if (index >= 0) {\n      // replace member expression with column ref\n      return spliceMember(node, index, ctx, checkColumn, parent);\n    } else if (name === ctx.$param) {\n      // replace member expression with param ref\n      return spliceMember(node, index, ctx, checkParam);\n    } else if (ctx.paramsRef.has(name)) {\n      updateParameterNode(node, ctx.paramsRef.get(name));\n    } else if (ctx.columnRef.has(name)) {\n      updateColumnNode(object, name, ctx, node);\n    } else if (Object.hasOwn(ctx.params, name)) {\n      updateParameterNode(object, name);\n    }\n  }\n};\n\nfunction spliceMember(node, index, ctx, check, parent) {\n  const { property, computed } = node;\n  let name;\n\n  if (!computed) {\n    name = property.name;\n  } else if (is(Literal, property)) {\n    name = property.value;\n  } else try {\n    // visit subtree to ensure nodes are rewritten as needed\n    // then compile the code to compute the property name\n    walk(property, ctx, visitors, node);\n    name = ctx.param(property);\n  } catch (e) { // eslint-disable-line no-unused-vars\n    ctx.error(node, ERROR_MEMBER);\n  }\n\n  check(node, name, index, ctx, parent);\n  return false;\n}\n\nconst opVisitors = {\n  ...visitors,\n  VariableDeclarator: NO('Variable declaration in operator call'),\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent)) {\n      ctx.error(node, ERROR_VARIABLE_OP);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n\n    // rewrite if built-in function\n    if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  }\n};\n\nfunction parseFunction(node, ctx) {\n  if (node.generator) NO('Generator functions')(node, ctx);\n  if (node.async) NO('Async functions')(node, ctx);\n\n  const { params } = node;\n  const len = params.length;\n  const setc = index => (name, key) => ctx.columnRef.set(name, [key, index]);\n  const setp = (name, key) => ctx.paramsRef.set(name, key);\n\n  if (!len) {\n    // do nothing\n  } else if (ctx.join) {\n    parseRef(ctx, params[0], 'tuple1', setc(1));\n    if (len > 1) parseRef(ctx, params[1], 'tuple2', setc(2));\n    if (len > 2) parseRef(ctx, params[2], '$param', setp);\n  } else {\n    parseRef(ctx, params[0], 'tuple', setc(0));\n    if (len > 1) parseRef(ctx, params[1], '$param', setp);\n  }\n\n  ctx.root = node.body;\n}\n\nfunction parseRef(ctx, node, refName, alias) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n    ctx[refName] = node.name;\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(p => {\n      const key = is(Identifier, p.key) ? p.key.name\n        : is(Literal, p.key) ? p.key.value\n        : ctx.error(p, ERROR_ARGUMENT);\n      if (!is(Identifier, p.value)) {\n        ctx.error(p.value, ERROR_DESTRUCTURE);\n      }\n      alias(p.value.name, key);\n    });\n  }\n}\n\nfunction parseOperator(ctx, def, name, args) {\n  const fields = [];\n  const params = [];\n  const idxFields = def.param[0] || 0;\n  const idxParams = idxFields + (def.param[1] || 0);\n\n  args.forEach((arg, index) => {\n    if (index < idxFields) {\n      walk(arg, ctx, opVisitors);\n      fields.push(ctx.field(arg));\n    } else if (index < idxParams) {\n      walk(arg, ctx, opVisitors);\n      params.push(ctx.param(arg));\n    } else {\n      ctx.error(arg, ERROR_OP_PARAMETER);\n    }\n  });\n\n  return { name, fields, params, ...(ctx.spec.window || {}) };\n}\n\nfunction functionName(node) {\n  return is(Identifier, node) ? node.name\n    : !is(MemberExpression, node) ? null\n    : isMath(node) ? rewriteMath(node.property.name)\n    : node.property.name;\n}\n\nfunction isMath(node) {\n  return is(Identifier, node.object) && node.object.name === 'Math';\n}\n\nfunction rewriteMath(name) {\n  return name === 'max' ? 'greatest'\n    : name === 'min' ? 'least'\n    : name;\n}\n\nfunction handleIdentifier(node, ctx, parent) {\n  const { name } = node;\n\n  if (is(MemberExpression, parent) && parent.property === node) {\n    // do nothing: check head node, not nested properties\n  } else if (is(Property, parent) && parent.key === node) {\n    // do nothing: identifiers allowed in object expressions\n  } else if (ctx.paramsRef.has(name)) {\n    updateParameterNode(node, ctx.paramsRef.get(name));\n  } else if (ctx.columnRef.has(name)) {\n    updateColumnNode(node, name, ctx, parent);\n  } else if (Object.hasOwn(ctx.params, name)) {\n    updateParameterNode(node, name);\n  } else if (Object.hasOwn(constants, name)) {\n    updateConstantNode(node, name);\n  } else {\n    return true;\n  }\n}\n\nfunction checkColumn(node, name, index, ctx, parent) {\n  // check column existence if we have a backing table\n  const table = index === 0 ? ctx.table\n    : index > 0 ? ctx.join[index - 1]\n    : null;\n  const col = table && table.column(name);\n  if (table && !col) {\n    ctx.error(node, ERROR_COLUMN);\n  }\n\n  // check if column reference is valid in current context\n  if (ctx.aggronly && !ctx.$op) {\n    ctx.error(node, ERROR_AGGRONLY);\n  }\n\n  // rewrite ast node as a column access\n  rewrite(node, name, index, col, parent);\n}\n\nfunction updateColumnNode(node, key, ctx, parent) {\n  const [name, index] = ctx.columnRef.get(key);\n  checkColumn(node, name, index, ctx, parent);\n}\n\nfunction checkParam(node, name, index, ctx) {\n  if (ctx.params && !Object.hasOwn(ctx.params, name)) {\n    ctx.error(node, ERROR_PARAM);\n  }\n  updateParameterNode(node, name);\n}\n\nfunction updateParameterNode(node, name) {\n  node.type = Parameter;\n  node.name = name;\n}\n\nfunction updateConstantNode(node, name) {\n  node.type = Constant;\n  node.name = name;\n  node.raw = constants[name];\n}\n\nfunction updateFunctionNode(node, name, ctx) {\n  if (name === ROW_OBJECT) {\n    const t = ctx.table;\n    if (!t) ctx.error(node, ERROR_ROW_OBJECT);\n    rowObjectExpression(node, t,\n      node.arguments.length\n        ? node.arguments.map(node => {\n            const col = ctx.param(node);\n            const name = isNumber(col) ? t.columnName(col) : col;\n            if (!t.column(name)) ctx.error(node, ERROR_COLUMN);\n            return name;\n          })\n        : t.columnNames()\n    );\n  } else {\n    node.callee = { type: Function, name };\n  }\n}\n\nfunction handleDeclaration(node, ctx) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n  } else if (is(ArrayPattern, node)) {\n    node.elements.forEach(elm => handleDeclaration(elm, ctx));\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(prop => handleDeclaration(prop.value, ctx));\n  } else {\n    ctx.error(node.id, ERROR_DECLARATION);\n  }\n}\n","import { entries } from '../util/entries.js';\nimport { error } from '../util/error.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isObject } from '../util/is-object.js';\nimport { Column, Literal, Op } from './ast/constants.js';\nimport { clean } from './ast/clean.js';\nimport { is } from './ast/util.js';\nimport { codegen } from './codegen.js';\nimport { compile}  from './compile.js';\nimport { parseEscape } from './parse-escape.js';\nimport { parseExpression } from './parse-expression.js';\n\nconst ANNOTATE = { [Column]: 1, [Op]: 1 };\n\nexport function parse(input, opt = {}) {\n  const generate = opt.generate || codegen;\n  const compiler = opt.compiler || compile;\n  const params = getParams(opt);\n  const fields = {};\n  const opcall = {};\n  const names = [];\n  const exprs = [];\n  let fieldId = 0;\n  let opId = -1;\n\n  const compileExpr = opt.join ? compiler.join\n    : opt.index == 1 ? compiler.expr2\n    : compiler.expr;\n\n  // parser context\n  const ctx = {\n    op(op) {\n      const key = opKey(op);\n      return opcall[key] || (op.id = ++opId, opcall[key] = op);\n    },\n    field(node) {\n      const code = generate(node);\n      return fields[code] || (fields[code] = ++fieldId);\n    },\n    param(node) {\n      return is(Literal, node)\n        ? node.value\n        : compiler.param(generate(node), params);\n    },\n    value(name, node) {\n      names.push(name);\n      const e = node.escape || (opt.ast\n        ? clean(node)\n        : compileExpr(generate(node), params));\n      exprs.push(e);\n      // annotate expression if it is a direct column or op access\n      // this permits downstream optimizations\n      if (ANNOTATE[node.type] && e !== node && isObject(e)) {\n        e.field = node.name;\n      }\n    },\n    error(node, msg, note = '') {\n      // both expresions and fields are parsed\n      // with added code prefixes of length 6!\n      const i = node.start - 6;\n      const j = node.end - 6;\n      const snippet = String(ctx.spec).slice(i, j);\n      error(`${msg}: \"${snippet}\"${note}`);\n    }\n  };\n\n  // copy all options to context, potentially overwriting methods\n  Object.assign(ctx, opt, { params });\n\n  // parse each expression\n  for (const [name, value] of entries(input)) {\n    ctx.value(\n      name + '',\n      value.escape\n        ? parseEscape(ctx, value, params)\n        : parseExpression(ctx, value)\n    );\n  }\n\n  // return expression asts if requested\n  if (opt.ast) {\n    return { names, exprs };\n  }\n\n  // compile input field accessors\n  const f = [];\n  for (const key in fields) {\n    f[fields[key]] = compiler.expr(key, params);\n  }\n\n  // resolve input fields to operations\n  const ops = Object.values(opcall);\n  ops.forEach(op => op.fields = op.fields.map(id => f[id]));\n\n  return { names, exprs, ops };\n}\n\nfunction opKey(op) {\n  let key = `${op.name}(${op.fields.concat(op.params).join(',')})`;\n  if (op.frame) {\n    const frame = op.frame.map(v => Number.isFinite(v) ? Math.abs(v) : -1);\n    key += `[${frame},${!!op.peers}]`;\n  }\n  return key;\n}\n\nfunction getParams(opt) {\n  return (opt.table ? getTableParams(opt.table)\n    : opt.join ? {\n        ...getTableParams(opt.join[1]),\n        ...getTableParams(opt.join[0])\n      }\n    : {}) || {};\n}\n\nfunction getTableParams(table) {\n  return table && isFunction(table.params) ? table.params() : {};\n}\n","import { isFunction } from '../util/is-function.js';\n\n/**\n * Annotate an expression in an object wrapper.\n * @param {string|Function|object} expr An expression to annotate.\n * @param {object} properties The properties to annotate with.\n * @return {object} A new wrapped expression object.\n */\nexport function wrap(expr, properties) {\n  return expr && expr.expr\n    ? new Wrapper({ ...expr, ...properties })\n    : new Wrapper(properties, expr);\n}\n\nclass Wrapper {\n  constructor(properties, expr) {\n    this.expr = expr;\n    Object.assign(this, properties);\n  }\n  toString() {\n    return String(this.expr);\n  }\n  toObject() {\n    return {\n      ...this,\n      expr: this.toString(),\n      ...(isFunction(this.expr) ? { func: true } : {})\n    };\n  }\n}\n","import { wrap } from './wrap.js';\n\n/**\n * Annotate an expression to indicate it is a string field reference.\n * @param {string|object} expr The column name, or an existing wrapped\n *  expression for a column name.\n * @param {string} [name] The column name to use. If provided, will\n *  overwrite the input expression value.\n * @param {number} [table=0] The table index of the field, in case of\n *  expressions over multiple tables.\n * @return A wrapped expression for a named column.\n * @example field('colA')\n */\nexport function field(expr, name, table = 0) {\n  const props = table ? { field: true, table } : { field: true };\n  return wrap(\n    expr,\n    name ? { expr: name, ...props } : props\n  );\n}\n","import { entries } from './entries.js';\n\nexport function assign(map, pairs) {\n  for (const [key, value] of entries(pairs)) {\n    map.set(key, value);\n  }\n  return map;\n}\n","import { assign } from '../util/assign.js';\nimport { error } from '../util/error.js';\nimport { escapeRegExp } from '../util/escape-regexp.js';\nimport { isArray } from '../util/is-array.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isNumber } from '../util/is-number.js';\nimport { isObject } from '../util/is-object.js';\nimport { isString } from '../util/is-string.js';\nimport { toString } from '../util/to-string.js';\n\nexport function resolve(table, sel, map = new Map()) {\n  sel = isNumber(sel) ? table.columnName(sel) : sel;\n\n  if (isString(sel)) {\n    map.set(sel, sel);\n  } else if (isArray(sel)) {\n    sel.forEach(r => resolve(table, r, map));\n  } else if (isFunction(sel)) {\n    resolve(table, sel(table), map);\n  } else if (isObject(sel)) {\n    assign(map, sel);\n  } else {\n    error(`Invalid column selection: ${toString(sel)}`);\n  }\n\n  return map;\n}\n\nfunction decorate(value, toObject) {\n  value.toObject = toObject;\n  return value;\n}\n\nfunction toObject(value) {\n  return isArray(value) ? value.map(toObject)\n    : value && value.toObject ? value.toObject()\n    : value;\n}\n\n/**\n * Proxy type for SelectHelper function.\n * @typedef {import('../table/types.js').SelectHelper} SelectHelper\n */\n\n/**\n * Select all columns in a table.\n * Returns a function-valued selection compatible with {@link Table#select}.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function all() {\n  return decorate(\n    table => table.columnNames(),\n    () => ({ all: [] })\n  );\n}\n\n/**\n * Negate a column selection, selecting all other columns in a table.\n * Returns a function-valued selection compatible with {@link Table#select}.\n * @param {...any} selection The selection to negate. May be a column name,\n *  column index, array of either, or a selection function (e.g., from range).\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function not(...selection) {\n  selection = selection.flat();\n  return decorate(\n    table => {\n      const drop = resolve(table, selection);\n      return table.columnNames(name => !drop.has(name));\n    },\n    () => ({ not: toObject(selection) })\n  );\n}\n\n/**\n * Select a contiguous range of columns.\n * @param {string|number} start The name/index of the first selected column.\n * @param {string|number} end The name/index of the last selected column.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function range(start, end) {\n  return decorate(\n    table => {\n      let i = isNumber(start) ? start : table.columnIndex(start);\n      let j = isNumber(end) ? end : table.columnIndex(end);\n      if (j < i) { const t = j; j = i; i = t; }\n      return table.columnNames().slice(i, j + 1);\n    },\n    () => ({ range: [start, end] })\n  );\n}\n\n/**\n * Select all columns whose names match a pattern.\n * @param {string|RegExp} pattern A string or regular expression pattern to match.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function matches(pattern) {\n  if (isString(pattern)) pattern = RegExp(escapeRegExp(pattern));\n  return decorate(\n    // @ts-ignore\n    table => table.columnNames(name => pattern.test(name)),\n    // @ts-ignore\n    () => ({ matches: [pattern.source, pattern.flags] })\n  );\n}\n\n/**\n * Select all columns whose names start with a string.\n * @param {string} string The string to match at the start of the column name.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function startswith(string) {\n  return matches(RegExp('^' + escapeRegExp(string)));\n}\n\n/**\n * Select all columns whose names end with a string.\n * @param {string} string The string to match at the end of the column name.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function endswith(string) {\n  return matches(RegExp(escapeRegExp(string) + '$'));\n}\n","import { parse } from '../../expression/parse.js';\nimport { field } from '../../helpers/field.js';\nimport { resolve } from '../../helpers/selection.js';\nimport { assign } from '../../util/assign.js';\nimport { error } from '../../util/error.js';\nimport { isNumber } from '../../util/is-number.js';\nimport { isObject } from '../../util/is-object.js';\nimport { isString } from '../../util/is-string.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { toArray } from '../../util/to-array.js';\n\nexport function parseValue(name, table, params, options = { window: false }) {\n  const exprs = new Map();\n\n  const marshal = param => {\n    param = isNumber(param) ? table.columnName(param) : param;\n    isString(param) ? exprs.set(param, field(param))\n      : isFunction(param) ? resolve(table, param).forEach(marshal)\n      : isObject(param) ? assign(exprs, param)\n      : error(`Invalid ${name} value: ${param+''}`);\n  };\n\n  toArray(params).forEach(marshal);\n\n  if (options.preparse) {\n    options.preparse(exprs);\n  }\n\n  return parse(exprs, { table, ...options });\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { keyFunction } from '../util/key-function.js';\n\nexport function groupby(table, ...values) {\n  return _groupby(table, parseValue('groupby', table, values.flat()));\n}\n\nexport function _groupby(table, exprs) {\n  return table.create({\n    groups: createGroups(table, exprs)\n  });\n}\n\nfunction createGroups(table, { names = [], exprs = [], ops = [] }) {\n  const n = names.length;\n  if (n === 0) return null;\n\n  // check for optimized path when grouping by a single field\n  // use pre-calculated groups if available\n  if (n === 1 && !table.isFiltered() && exprs[0].field) {\n    const col = table.column(exprs[0].field);\n    if (col.groups) return col.groups(names);\n  }\n\n  let get = aggregateGet(table, ops, exprs);\n  const getKey = keyFunction(get);\n  const nrows = table.totalRows();\n  const keys = new Uint32Array(nrows);\n  const index = {};\n  const rows = [];\n\n  // inline table scan for performance\n  const data = table.data();\n  const bits = table.mask();\n  if (bits) {\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      const key = getKey(i, data) + '';\n      keys[i] = (index[key] ??= rows.push(i) - 1);\n    }\n  } else {\n    for (let i = 0; i < nrows; ++i) {\n      const key = getKey(i, data) + '';\n      keys[i] = (index[key] ??= rows.push(i) - 1);\n    }\n  }\n\n  if (!ops.length) {\n    // capture data in closure, so no interaction with select\n    get = get.map(f => row => f(row, data));\n  }\n\n  return { keys, get, names, rows, size: rows.length };\n}\n","/**\n * Return a new column set instance.\n * @param {import('./Table.js').Table} [table] A base table whose columns\n *  should populate the returned set. If unspecified, create an empty set.\n * @return {ColumnSet} The column set.\n */\nexport function columnSet(table) {\n  return table\n    ? new ColumnSet({ ...table.data() }, table.columnNames())\n    : new ColumnSet();\n}\n\n/** An editable collection of named columns. */\nexport class ColumnSet {\n  /**\n   * Create a new column set instance.\n   * @param {import('./types.js').ColumnData} [data] Initial column data.\n   * @param {string[]} [names] Initial column names.\n   */\n  constructor(data, names) {\n    this.data = data || {};\n    this.names = names || [];\n  }\n\n  /**\n   * Add a new column to this set and return the column values.\n   * @template {import('./types.js').ColumnType} T\n   * @param {string} name The column name.\n   * @param {T} values The column values.\n   * @return {T} The provided column values.\n   */\n  add(name, values) {\n    if (!this.has(name)) this.names.push(name + '');\n    return this.data[name] = values;\n  }\n\n  /**\n   * Test if this column set has a columns with the given name.\n   * @param {string} name A column name\n   * @return {boolean} True if this set contains a column with the given name,\n   *  false otherwise.\n   */\n  has(name) {\n    return Object.hasOwn(this.data, name);\n  }\n\n  /**\n   * Add a groupby specification to this column set.\n   * @param {import('./types.js').GroupBySpec} groups A groupby specification.\n   * @return {this} This column set.\n   */\n  groupby(groups) {\n    this.groups = groups;\n    return this;\n  }\n\n  /**\n   * Create a new table with the contents of this column set, using the same\n   * type as a given prototype table. The new table does not inherit the\n   * filter, groupby, or orderby state of the prototype.\n   * @template {import('./Table.js').Table} T\n   * @param {T} proto A prototype table\n   * @return {T} The new table.\n   */\n  new(proto) {\n    const { data, names, groups = null } = this;\n    return proto.create({ data, names, groups, filter: null, order: null });\n  }\n\n  /**\n   * Create a derived table with the contents of this column set, using the same\n   * type as a given prototype table. The new table will inherit the filter,\n   * groupby, and orderby state of the prototype.\n   * @template {import('./Table.js').Table} T\n   * @param {T} proto A prototype table\n   * @return {T} The new table.\n   */\n  derive(proto) {\n    return proto.create(this);\n  }\n}\n","import { aggregate, groupOutput } from './reduce/util.js';\nimport { parse } from '../expression/parse.js';\nimport { columnSet } from '../table/ColumnSet.js';\n\nexport function rollup(table, values) {\n  return _rollup(table, parse(values, { table, aggronly: true, window: false }));\n}\n\nexport function _rollup(table, { names, exprs, ops = [] }) {\n  // output data\n  const cols = columnSet();\n  const groups = table.groups();\n\n  // write groupby fields to output\n  if (groups) groupOutput(cols, groups);\n\n  // compute and write aggregate output\n  output(names, exprs, groups, aggregate(table, ops), cols);\n\n  // return output table\n  return cols.new(table);\n}\n\nfunction output(names, exprs, groups, result = [], cols) {\n  if (!exprs.length) return;\n  const size = groups ? groups.size : 1;\n  const op = (id, row) => result[id][row];\n  const n = names.length;\n\n  for (let i = 0; i < n; ++i) {\n    const get = exprs[i];\n    if (get.field != null) {\n      // if expression is op only, use aggregates directly\n      cols.add(names[i], result[get.field]);\n    } else if (size > 1) {\n      // if multiple groups, evaluate expression for each\n      const col = cols.add(names[i], Array(size));\n      for (let j = 0; j < size; ++j) {\n        col[j] = get(j, null, op);\n      }\n    } else {\n      // if only one group, no need to loop\n      cols.add(names[i], [ get(0, null, op) ]);\n    }\n  }\n}\n","import { resolve } from '../helpers/selection.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { error } from '../util/error.js';\nimport { isString } from '../util/is-string.js';\n\nexport function select(table, ...columns) {\n  return _select(table, resolve(table, columns.flat()));\n}\n\nexport function _select(table, columns) {\n  const cols = columnSet();\n\n  columns.forEach((value, curr) => {\n    const next = isString(value) ? value : curr;\n    if (next) {\n      const col = table.column(curr) || error(`Unrecognized column: ${curr}`);\n      cols.add(next, col);\n    }\n  });\n\n  return cols.derive(table);\n}\n","import { array_agg, entries_agg, map_agg, object_agg } from '../op/op-api.js';\nimport { error } from '../util/error.js';\nimport { uniqueName } from '../util/unique-name.js';\nimport { groupby } from '../verbs/groupby.js';\nimport { rollup } from '../verbs/rollup.js';\nimport { select } from '../verbs/select.js';\n\n/**\n * Regroup table rows in response to a BitSet filter.\n * @param {import('./types.js').GroupBySpec} groups The current groupby specification.\n * @param {import('./BitSet.js').BitSet} filter The filter to apply.\n */\nexport function regroup(groups, filter) {\n  if (!groups || !filter) return groups;\n\n  // check for presence of rows for each group\n  const { keys, rows, size } = groups;\n  const map = new Uint32Array(size);\n  filter.scan(row => map[keys[row]] = 1);\n\n  // check sum, exit early if all groups occur\n  const sum = map.reduce((sum, val) => sum + val, 0);\n  if (sum === size) return groups;\n\n  // create group index map, filter exemplar rows\n  const _rows = Array(sum);\n  let _size = 0;\n  for (let i = 0; i < size; ++i) {\n    if (map[i]) _rows[map[i] = _size++] = rows[i];\n  }\n\n  // re-index the group keys\n  const _keys = new Uint32Array(keys.length);\n  filter.scan(row => _keys[row] = map[keys[row]]);\n\n  return { ...groups, keys: _keys, rows: _rows, size: _size };\n}\n\n/**\n * Regroup table rows in response to a re-indexing.\n * This operation may or may not involve filtering of rows.\n * @param {import('./types.js').GroupBySpec} groups\n *  The current groupby specification.\n * @param {Function} scan Function to scan new row indices.\n * @param {boolean} filter Flag indicating if filtering may occur.\n * @param {number} nrows The number of rows in the new table.\n */\nexport function reindex(groups, scan, filter, nrows) {\n  const { keys, rows, size } = groups;\n  let _rows = rows;\n  let _size = size;\n  let map = null;\n\n  if (filter) {\n    // check for presence of rows for each group\n    map = new Int32Array(size);\n    scan(row => map[keys[row]] = 1);\n\n    // check sum, regroup if not all groups occur\n    const sum = map.reduce((sum, val) => sum + val, 0);\n    if (sum !== size) {\n      // create group index map, filter exemplar rows\n      _rows = Array(sum);\n      _size = 0;\n      for (let i = 0; i < size; ++i) {\n        if (map[i]) _rows[map[i] = _size++] = rows[i];\n      }\n    }\n  }\n\n  // re-index the group keys\n  let r = -1;\n  const _keys = new Uint32Array(nrows);\n  const fn = _size !== size\n    ? row => _keys[++r] = map[keys[row]]\n    : row => _keys[++r] = keys[row];\n  scan(fn);\n\n  return { ...groups, keys: _keys, rows: _rows, size: _size };\n}\n\nexport function nest(table, idx, obj, type) {\n  const agg = type === 'map' || type === true ? map_agg\n    : type === 'entries' ? entries_agg\n    : type === 'object' ? object_agg\n    : error('groups option must be \"map\", \"entries\", or \"object\".');\n\n  const { names } = table.groups();\n  const col = uniqueName(table.columnNames(), '_');\n\n  // create table with one column of row objects\n  // then aggregate into per-group arrays\n  let t = select(table, {}).reify(idx).create({ data: { [col]: obj } });\n  t = rollup(t, { [col]: array_agg(col) });\n\n  // create nested structures for each level of grouping\n  for (let i = names.length; --i >= 0;) {\n    t = rollup(\n        groupby(t, names.slice(0, i)),\n        // @ts-ignore\n        { [col]: agg(names[i], col) }\n      );\n  }\n\n  // return the final aggregated structure\n  return t.get(col);\n}\n","import { isTypedArray } from './is-typed-array.js';\n\n/**\n * @param {*} column\n * @returns {ArrayConstructor | import('../table/types.js').TypedArrayConstructor}\n */\nexport function arrayType(column) {\n  // @ts-ignore\n  return isTypedArray(column) ? column.constructor : Array;\n}\n","import { nest, regroup, reindex } from './regroup.js';\nimport { rowObjectBuilder } from '../expression/row-object.js';\nimport { all, resolve } from '../helpers/selection.js';\nimport { arrayType } from '../util/array-type.js';\nimport { error } from '../util/error.js';\nimport { isArrayType } from '../util/is-array-type.js';\nimport { isNumber } from '../util/is-number.js';\nimport { repeat } from '../util/repeat.js';\n\n/**\n * Base class representing a column-oriented data table.\n */\nexport class Table {\n  /**\n   * Instantiate a Table instance.\n   * @param {import('./types.js').ColumnData} columns\n   *  An object mapping column names to values.\n   * @param {string[]} [names]\n   *  An ordered list of column names.\n   * @param {import('./BitSet.js').BitSet} [filter]\n   *  A filtering BitSet.\n   * @param {import('./types.js').GroupBySpec} [group]\n   *  A groupby specification.\n   * @param {import('./types.js').RowComparator} [order]\n   *  A row comparator function.\n   * @param {import('./types.js').Params} [params]\n   *  An object mapping parameter names to values.\n   */\n  constructor(columns, names, filter, group, order, params) {\n    const data = Object.freeze({ ...columns });\n    names = names?.slice() ?? Object.keys(data);\n    const nrows = names.length ? data[names[0]].length : 0;\n    /**\n     * @private\n     * @type {readonly string[]}\n     */\n    this._names = Object.freeze(names);\n    /**\n     * @private\n     * @type {import('./types.js').ColumnData}\n     */\n    this._data = data;\n    /**\n     * @private\n     * @type {number}\n     */\n    this._total = nrows;\n    /**\n     * @private\n     * @type {number}\n     */\n    this._nrows = filter?.count() ?? nrows;\n    /**\n     * @private\n     * @type {import('./BitSet.js').BitSet}\n     */\n    this._mask = filter ?? null;\n    /**\n     * @private\n     * @type {import('./types.js').GroupBySpec}\n     */\n    this._group = group ?? null;\n    /**\n     * @private\n     * @type {import('./types.js').RowComparator}\n     */\n    this._order = order ?? null;\n    /**\n     * @private\n     * @type {import('./types.js').Params}\n     */\n    this._params = params;\n    /**\n     * @private\n     * @type {Uint32Array}\n     */\n    this._index = null;\n    /**\n     * @private\n     * @type {number[][] | Uint32Array[]}\n     */\n    this._partitions = null;\n  }\n\n  /**\n   * Create a new table with the same type as this table.\n   * The new table may have different data, filter, grouping, or ordering\n   * based on the values of the optional configuration argument. If a\n   * setting is not specified, it is inherited from the current table.\n   * @param {import('./types.js').CreateOptions} [options]\n   *  Creation options for the new table.\n   * @return {this} A newly created table.\n   */\n  create({\n    data = undefined,\n    names = undefined,\n    filter = undefined,\n    groups = undefined,\n    order = undefined\n  } = {}) {\n    const f = filter !== undefined ? filter : this.mask();\n    // @ts-ignore\n    return new this.constructor(\n      data || this._data,\n      names || (!data ? this._names : null),\n      f,\n      groups !== undefined ? groups : regroup(this._group, filter && f),\n      order !== undefined ? order : this._order,\n      this._params\n    );\n  }\n\n  /**\n   * Get or set table expression parameter values.\n   * If called with no arguments, returns the current parameter values\n   * as an object. Otherwise, adds the provided parameters to this\n   * table's parameter set and returns the table. Any prior parameters\n   * with names matching the input parameters are overridden.\n   * @param {import('./types.js').Params} [values]\n   *  The parameter values.\n   * @return {this|import('./types.js').Params}\n   *  The current parameter values (if called with no arguments) or this table.\n   */\n  params(values) {\n    if (arguments.length) {\n      if (values) {\n        this._params = { ...this._params, ...values };\n      }\n      return this;\n    } else {\n      return this._params;\n    }\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    if (!this._names) return 'Object'; // bail if called on prototype\n    const nr = this.numRows();\n    const nc = this.numCols();\n    const plural = v => v !== 1 ? 's' : '';\n    return `Table: ${nc} col${plural(nc)} x ${nr} row${plural(nr)}`\n      + (this.isFiltered() ? ` (${this.totalRows()} backing)` : '')\n      + (this.isGrouped() ? `, ${this._group.size} groups` : '')\n      + (this.isOrdered() ? ', ordered' : '');\n  }\n\n  /**\n   * Indicates if the table has a filter applied.\n   * @return {boolean} True if filtered, false otherwise.\n   */\n  isFiltered() {\n    return !!this._mask;\n  }\n\n  /**\n   * Indicates if the table has a groupby specification.\n   * @return {boolean} True if grouped, false otherwise.\n   */\n  isGrouped() {\n    return !!this._group;\n  }\n\n  /**\n   * Indicates if the table has a row order comparator.\n   * @return {boolean} True if ordered, false otherwise.\n   */\n  isOrdered() {\n    return !!this._order;\n  }\n\n  /**\n   * Get the backing column data for this table.\n   * @return {import('./types.js').ColumnData}\n   *  Object of named column instances.\n   */\n  data() {\n    return this._data;\n  }\n\n  /**\n   * Returns the filter bitset mask, if defined.\n   * @return {import('./BitSet.js').BitSet} The filter bitset mask.\n   */\n  mask() {\n    return this._mask;\n  }\n\n  /**\n   * Returns the groupby specification, if defined.\n   * @return {import('./types.js').GroupBySpec} The groupby specification.\n   */\n  groups() {\n    return this._group;\n  }\n\n  /**\n   * Returns the row order comparator function, if specified.\n   * @return {import('./types.js').RowComparator}\n   *  The row order comparator function.\n   */\n  comparator() {\n    return this._order;\n  }\n\n  /**\n   * The total number of rows in this table, counting both\n   * filtered and unfiltered rows.\n   * @return {number} The number of total rows.\n   */\n  totalRows() {\n    return this._total;\n  }\n\n  /**\n   * The number of active rows in this table. This number may be\n   * less than the *totalRows* if the table has been filtered.\n   * @return {number} The number of rows.\n   */\n  numRows() {\n    return this._nrows;\n  }\n\n  /**\n   * The number of active rows in this table. This number may be\n   * less than the *totalRows* if the table has been filtered.\n   * @return {number} The number of rows.\n   */\n  get size() {\n    return this._nrows;\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  numCols() {\n    return this._names.length;\n  }\n\n  /**\n   * Filter function invoked for each column name.\n   * @callback NameFilter\n   * @param {string} name The column name.\n   * @param {number} index The column index.\n   * @param {string[]} array The array of names.\n   * @return {boolean} Returns true to retain the column name.\n   */\n\n  /**\n   * The table column names, optionally filtered.\n   * @param {NameFilter} [filter] An optional filter function.\n   *  If unspecified, all column names are returned.\n   * @return {string[]} An array of matching column names.\n   */\n  columnNames(filter) {\n    return filter ? this._names.filter(filter) : this._names.slice();\n  }\n\n  /**\n   * The column name at the given index.\n   * @param {number} index The column index.\n   * @return {string} The column name,\n   *  or undefined if the index is out of range.\n   */\n  columnName(index) {\n    return this._names[index];\n  }\n\n  /**\n   * The column index for the given name.\n   * @param {string} name The column name.\n   * @return {number} The column index, or -1 if the name is not found.\n   */\n  columnIndex(name) {\n    return this._names.indexOf(name);\n  }\n\n  /**\n   * Get the column instance with the given name.\n   * @param {string} name The column name.\n   * @return {import('./types.js').ColumnType | undefined}\n   *  The named column, or undefined if it does not exist.\n   */\n  column(name) {\n    return this._data[name];\n  }\n\n  /**\n   * Get the column instance at the given index position.\n   * @param {number} index The zero-based column index.\n   * @return {import('./types.js').ColumnType | undefined}\n   *  The column, or undefined if it does not exist.\n   */\n  columnAt(index) {\n    return this._data[this._names[index]];\n  }\n\n  /**\n   * Get an array of values contained in a column. The resulting array\n   * respects any table filter or orderby criteria.\n   * @param {string} name The column name.\n   * @param {ArrayConstructor | import('./types.js').TypedArrayConstructor} [constructor=Array]\n   *  The array constructor for instantiating the output array.\n   * @return {import('./types.js').DataValue[] | import('./types.js').TypedArray}\n   *  The array of column values.\n   */\n  array(name, constructor = Array) {\n    const column = this.column(name);\n    const array = new constructor(this.numRows());\n    let idx = -1;\n    this.scan(row => array[++idx] = column.at(row), true);\n    return array;\n  }\n\n  /**\n   * Get the value for the given column and row.\n   * @param {string} name The column name.\n   * @param {number} [row=0] The row index, defaults to zero if not specified.\n   * @return {import('./types.js').DataValue} The table value at (column, row).\n   */\n  get(name, row = 0) {\n    const column = this.column(name);\n    return this.isFiltered() || this.isOrdered()\n      ? column.at(this.indices()[row])\n      : column.at(row);\n  }\n\n  /**\n   * Returns an accessor (\"getter\") function for a column. The returned\n   * function takes a row index as its single argument and returns the\n   * corresponding column value.\n   * @param {string} name The column name.\n   * @return {import('./types.js').ColumnGetter} The column getter function.\n   */\n  getter(name) {\n    const column = this.column(name);\n    const indices = this.isFiltered() || this.isOrdered() ? this.indices() : null;\n    if (indices) {\n      return row => column.at(indices[row]);\n    } else if (column) {\n      return row => column.at(row);\n    } else {\n      error(`Unrecognized column: ${name}`);\n    }\n  }\n\n  /**\n   * Returns an object representing a table row.\n   * @param {number} [row=0] The row index, defaults to zero if not specified.\n   * @return {object} A row object with named properties for each column.\n   */\n  object(row = 0) {\n    return objectBuilder(this)(row);\n  }\n\n  /**\n   * Returns an array of objects representing table rows.\n   * @param {import('./types.js').ObjectsOptions} [options]\n   *  The options for row object generation.\n   * @return {object[]} An array of row objects.\n   */\n  objects(options = {}) {\n    const { grouped, limit, offset } = options;\n\n    // generate array of row objects\n    const names = resolve(this, options.columns || all());\n    const createRow = rowObjectBuilder(this, names);\n    const obj = [];\n    this.scan(\n      (row, data) => obj.push(createRow(row, data)),\n      true, limit, offset\n    );\n\n    // produce nested output as requested\n    if (grouped && this.isGrouped()) {\n      const idx = [];\n      this.scan(row => idx.push(row), true, limit, offset);\n      return nest(this, idx, obj, grouped);\n    }\n\n    return obj;\n  }\n\n  /**\n   * Returns an iterator over objects representing table rows.\n   * @return {Iterator<object>} An iterator over row objects.\n   */\n  *[Symbol.iterator]() {\n    const createRow = objectBuilder(this);\n    const n = this.numRows();\n    for (let i = 0; i < n; ++i) {\n      yield createRow(i);\n    }\n  }\n\n  /**\n   * Returns an iterator over column values.\n   * @return {Iterator<object>} An iterator over row objects.\n   */\n  *values(name) {\n    const get = this.getter(name);\n    const n = this.numRows();\n    for (let i = 0; i < n; ++i) {\n      yield get(i);\n    }\n  }\n\n  /**\n   * Print the contents of this table using the console.table() method.\n   * @param {import('./types.js').PrintOptions|number} options\n   *  The options for row object generation, determining which rows and\n   *  columns are printed. If number-valued, specifies the row limit.\n   * @return {this} The table instance.\n   */\n  print(options = {}) {\n    const opt = isNumber(options)\n      ? { limit: +options }\n      // @ts-ignore\n      : { ...options, limit: 10 };\n\n    const obj = this.objects({ ...opt, grouped: false });\n    const msg = `${this[Symbol.toStringTag]}. Showing ${obj.length} rows.`;\n\n    console.log(msg);   // eslint-disable-line no-console\n    console.table(obj); // eslint-disable-line no-console\n    return this;\n  }\n\n  /**\n   * Returns an array of indices for all rows passing the table filter.\n   * @param {boolean} [order=true] A flag indicating if the returned\n   *  indices should be sorted if this table is ordered. If false, the\n   *  returned indices may or may not be sorted.\n   * @return {Uint32Array} An array of row indices.\n   */\n  indices(order = true) {\n    if (this._index) return this._index;\n\n    const n = this.numRows();\n    const index = new Uint32Array(n);\n    const ordered = this.isOrdered();\n    const bits = this.mask();\n    let row = -1;\n\n    // inline the following for performance:\n    // this.scan(row => index[++i] = row);\n    if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        index[++row] = i;\n      }\n    } else {\n      for (let i = 0; i < n; ++i) {\n        index[++row] = i;\n      }\n    }\n\n    // sort index vector\n    if (order && ordered) {\n      const { _order, _data } = this;\n      index.sort((a, b) => _order(a, b, _data));\n    }\n\n    // save indices if they reflect table metadata\n    if (order || !ordered) {\n      this._index = index;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns an array of indices for each group in the table.\n   * If the table is not grouped, the result is the same as\n   * the *indices* method, but wrapped within an array.\n   * @param {boolean} [order=true] A flag indicating if the returned\n   *  indices should be sorted if this table is ordered. If false, the\n   *  returned indices may or may not be sorted.\n   * @return {number[][] | Uint32Array[]} An array of row index arrays, one\n   *  per group. The indices will be filtered if the table is filtered.\n   */\n  partitions(order = true) {\n    // return partitions if already generated\n    if (this._partitions) {\n      return this._partitions;\n    }\n\n    // if not grouped, return a single partition\n    if (!this.isGrouped()) {\n      return [ this.indices(order) ];\n    }\n\n    // generate partitions\n    const { keys, size } = this._group;\n    const part = repeat(size, () => []);\n\n    // populate partitions, don't sort if indices don't exist\n    // inline the following for performance:\n    // this.scan(row => part[keys[row]].push(row), sort);\n    const sort = this._index;\n    const bits = this.mask();\n    const n = this.numRows();\n    if (sort && this.isOrdered()) {\n      for (let i = 0, r; i < n; ++i) {\n        r = sort[i];\n        part[keys[r]].push(r);\n      }\n    } else if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        part[keys[i]].push(i);\n      }\n    } else {\n      for (let i = 0; i < n; ++i) {\n        part[keys[i]].push(i);\n      }\n    }\n\n    // if ordered but not yet sorted, sort partitions directly\n    if (order && !sort && this.isOrdered()) {\n      const compare = this._order;\n      const data = this._data;\n      for (let i = 0; i < size; ++i) {\n        part[i].sort((a, b) => compare(a, b, data));\n      }\n    }\n\n    // save partitions if they reflect table metadata\n    if (order || !this.isOrdered()) {\n      this._partitions = part;\n    }\n\n    return part;\n  }\n\n  /**\n   * Create a new fully-materialized instance of this table.\n   * All filter and orderby settings are removed from the new table.\n   * Instead, the backing data itself is filtered and ordered as needed.\n   * @param {number[]} [indices] Ordered row indices to materialize.\n   *  If unspecified, all rows passing the table filter are used.\n   * @return {this} A reified table.\n   */\n  reify(indices) {\n    const nrows = indices ? indices.length : this.numRows();\n    const names = this._names;\n    let data, groups;\n\n    if (!indices && !this.isOrdered()) {\n      if (!this.isFiltered()) {\n        return this; // data already reified\n      } else if (nrows === this.totalRows()) {\n        data = this.data(); // all rows pass filter, skip copy\n      }\n    }\n\n    if (!data) {\n      const scan = indices ? f => indices.forEach(f) : f => this.scan(f, true);\n      const ncols = names.length;\n      data = {};\n\n      for (let i = 0; i < ncols; ++i) {\n        const name = names[i];\n        const prev = this.column(name);\n        const curr = data[name] = new (arrayType(prev))(nrows);\n        let r = -1;\n        // optimize array access\n        isArrayType(prev)\n          ? scan(row => curr[++r] = prev[row])\n          : scan(row => curr[++r] = prev.at(row));\n      }\n\n      if (this.isGrouped()) {\n        groups = reindex(this.groups(), scan, !!indices, nrows);\n      }\n    }\n\n    return this.create({ data, names, groups, filter: null, order: null });\n  }\n\n  /**\n   * Callback function to cancel a table scan.\n   * @callback ScanStop\n   * @return {void}\n   */\n\n  /**\n   * Callback function invoked for each row of a table scan.\n   * @callback ScanVisitor\n   * @param {number} [row] The table row index.\n   * @param {import('./types.js').ColumnData} [data]\n   *  The backing table data store.\n   * @param {ScanStop} [stop] Function to stop the scan early.\n   *  Callees can invoke this function to prevent future calls.\n   * @return {void}\n   */\n\n  /**\n   * Perform a table scan, visiting each row of the table.\n   * If this table is filtered, only rows passing the filter are visited.\n   * @param {ScanVisitor} fn Callback invoked for each row of the table.\n   * @param {boolean} [order=false] Indicates if the table should be\n   *  scanned in the order determined by *orderby*. This\n   *  argument has no effect if the table is unordered.\n   * @property {number} [limit=Infinity] The maximum number of rows to scan.\n   * @property {number} [offset=0] The row offset indicating how many\n   *  initial rows to skip.\n   */\n  scan(fn, order, limit = Infinity, offset = 0) {\n    const filter = this._mask;\n    const nrows = this._nrows;\n    const data = this._data;\n\n    let i = offset || 0;\n    if (i > nrows) return;\n\n    const n = Math.min(nrows, i + limit);\n    const stop = () => i = this._total;\n\n    if (order && this.isOrdered() || filter && this._index) {\n      const index = this.indices();\n      const data = this._data;\n      for (; i < n; ++i) {\n        fn(index[i], data, stop);\n      }\n    } else if (filter) {\n      let c = n - i + 1;\n      for (i = filter.nth(i); --c && i > -1; i = filter.next(i + 1)) {\n        fn(i, data, stop);\n      }\n    } else {\n      for (; i < n; ++i) {\n        fn(i, data, stop);\n      }\n    }\n  }\n}\n\nfunction objectBuilder(table) {\n  let b = table._builder;\n\n  if (!b) {\n    const createRow = rowObjectBuilder(table);\n    const data = table.data();\n    if (table.isOrdered() || table.isFiltered()) {\n      const indices = table.indices();\n      b = row => createRow(indices[row], data);\n    } else {\n      b = row => createRow(row, data);\n    }\n    table._builder = b;\n  }\n\n  return b;\n}\n","import { columnSet } from '../table/ColumnSet.js';\nimport { Table } from '../table/Table.js';\nimport { error } from '../util/error.js';\n\nexport function assign(table, ...others) {\n  others = others.flat();\n  const nrows = table.numRows();\n  const base = table.reify();\n  const cols = columnSet(base).groupby(base.groups());\n  others.forEach(input => {\n    input = input instanceof Table ? input : new Table(input);\n    if (input.numRows() !== nrows) error('Assign row counts do not match');\n    input = input.reify();\n    input.columnNames(name => cols.add(name, input.column(name)));\n  });\n  return cols.new(table);\n}\n","import { columnSet } from '../table/ColumnSet.js';\nimport { NULL } from '../util/null.js';\n\nexport function concat(table, ...others) {\n  others = others.flat();\n  const trows = table.numRows();\n  const nrows = trows + others.reduce((n, t) => n + t.numRows(), 0);\n  if (trows === nrows) return table;\n\n  const tables = [table, ...others];\n  const cols = columnSet();\n\n  table.columnNames().forEach(name => {\n    const arr = Array(nrows);\n    let row = 0;\n    tables.forEach(table => {\n      const col = table.column(name) || { at: () => NULL };\n      table.scan(trow => arr[row++] = col.at(trow));\n    });\n    cols.add(name, arr);\n  });\n\n  return cols.new(table);\n}\n","import { _select } from './select.js';\nimport { resolve } from '../helpers/selection.js';\nimport { error } from '../util/error.js';\n\nexport function relocate(table, columns, {\n  before = undefined,\n  after = undefined\n} = {}) {\n  const bef = before != null;\n  const aft = after != null;\n\n  if (!(bef || aft)) {\n    error('relocate requires a before or after option.');\n  }\n  if (bef && aft) {\n    error('relocate accepts only one of the before or after options.');\n  }\n\n  columns = resolve(table, columns);\n  const anchors = [...resolve(table, bef ? before : after).keys()];\n  const anchor = bef ? anchors[0] : anchors.pop();\n  const select = new Map();\n\n  // marshal inputs to select in desired order\n  table.columnNames().forEach(name => {\n    // check if we should assign the current column\n    const assign = !columns.has(name);\n\n    // at anchor column, insert relocated columns\n    if (name === anchor) {\n      if (aft && assign) select.set(name, name);\n      for (const [key, value] of columns) {\n        select.set(key, value);\n      }\n      if (aft) return; // exit if current column has been handled\n    }\n\n    if (assign) select.set(name, name);\n  });\n\n  return _select(table, select);\n}\n","export function bisector(compare) {\n  return {\n    left(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n","import { ascending } from '../../util/ascending.js';\nimport { bisector } from '../../util/bisector.js';\nimport { concat } from '../../util/concat.js';\nimport { unroll } from '../../util/unroll.js';\n\nconst bisect = bisector(ascending);\n\nexport function windowState(data, frame, adjust, ops, aggrs) {\n  let rows, peer, cells, result, key;\n  const isPeer = index => peer[index - 1] === peer[index];\n  const numOps = ops.length;\n  const numAgg = aggrs.length;\n\n  const evaluate = ops.length\n    ? unroll(\n        ['w', 'r', 'k'],\n        '{' + concat(ops, (_, i) => `r[_${i}.id][k]=_${i}.value(w,_${i}.get);`) + '}',\n        ops\n      )\n    : () => {};\n\n  const w = {\n    i0: 0,\n    i1: 0,\n    index: 0,\n    size: 0,\n    peer: isPeer,\n\n    init(partition, peers, results, group) {\n      w.index = w.i0 = w.i1 = 0;\n      w.size = peers.length;\n      rows = partition;\n      peer = peers;\n      result = results;\n      key = group;\n\n      // initialize aggregates\n      cells = aggrs ? aggrs.map(aggr => aggr.init()) : null;\n\n      // initialize window ops\n      for (let i = 0; i < numOps; ++i) {\n        ops[i].init();\n      }\n\n      return w;\n    },\n\n    value(index, get) {\n      return get(rows[index], data);\n    },\n\n    step(idx) {\n      const [f0, f1] = frame;\n      const n = w.size;\n      const p0 = w.i0;\n      const p1 = w.i1;\n\n      w.i0 = f0 != null ? Math.max(0, idx - Math.abs(f0)) : 0;\n      w.i1 = f1 != null ? Math.min(n, idx + Math.abs(f1) + 1) : n;\n      w.index = idx;\n\n      if (adjust) {\n        if (w.i0 > 0 && isPeer(w.i0)) {\n          w.i0 = bisect.left(peer, peer[w.i0]);\n        }\n        if (w.i1 < n && isPeer(w.i1)) {\n          w.i1 = bisect.right(peer, peer[w.i1 - 1]);\n        }\n      }\n\n      // evaluate aggregates\n      for (let i = 0; i < numAgg; ++i) {\n        const aggr = aggrs[i];\n        const cell = cells[i];\n        for (let j = p0; j < w.i0; ++j) {\n          aggr.rem(cell, rows[j], data);\n        }\n        for (let j = p1; j < w.i1; ++j) {\n          aggr.add(cell, rows[j], data);\n        }\n        aggr.write(cell, result, key);\n      }\n\n      // evaluate window ops\n      evaluate(w, result, key);\n\n      return result;\n    }\n  };\n\n  return w;\n}\n","import { reducers } from '../reduce/util.js';\nimport { getWindow, hasAggregate } from '../../op/index.js';\nimport { concat } from '../../util/concat.js';\nimport { unroll } from '../../util/unroll.js';\nimport { windowState } from './window-state.js';\n\nconst frameValue = op =>\n  (op.frame || [null, null]).map(v => Number.isFinite(v) ? Math.abs(v) : null);\n\nconst peersValue = op => !!op.peers;\n\nfunction windowOp(spec) {\n  const { id, name, fields = [], params = [] } = spec;\n  return {\n    ...getWindow(name).create(...params),\n    get: fields.length ? fields[0] : null,\n    id\n  };\n}\n\nexport function window(table, cols, exprs, result = {}, ops) {\n  // instantiate window states\n  const data = table.data();\n  const states = windowStates(ops, data);\n  const nstate = states.length;\n\n  const write = unroll(\n    ['r', 'd', 'op'],\n    '{' + concat(cols, (_, i) => `_${i}[r] = $${i}(r, d, op);`) + '}',\n    cols, exprs\n  );\n\n  // scan each ordered partition\n  table.partitions().forEach((rows, key) => {\n    const size = rows.length;\n    const peers = windowPeers(table, rows);\n\n    // initialize window states\n    for (let i = 0; i < nstate; ++i) {\n      states[i].init(rows, peers, result, key);\n    }\n\n    // calculate window values per-row\n    const op = id => result[id][key];\n    for (let index = 0; index < size; ++index) {\n      // advance window frame, updates result object\n      for (let i = 0; i < nstate; ++i) {\n        states[i].step(index);\n      }\n      write(rows[index], data, op);\n    }\n  });\n}\n\nfunction windowStates(ops, data) {\n  const map = {};\n\n  // group operations by window frame parameters\n  ops.forEach(op => {\n    const frame = frameValue(op);\n    const peers = peersValue(op);\n    const key = `${frame},${peers}`;\n    const { aggOps, winOps } = map[key] || (map[key] = {\n      frame,\n      peers,\n      aggOps: [],\n      winOps: []\n    });\n    hasAggregate(op.name)\n      ? aggOps.push(op)\n      : winOps.push(windowOp(op));\n  });\n\n  return Object.values(map).map(_ => windowState(\n    data, _.frame, _.peers, _.winOps,\n    reducers(_.aggOps, _.frame[0] != null ? -1 : 1)\n  ));\n}\n\nfunction windowPeers(table, rows) {\n  if (table.isOrdered()) {\n    // generate peer ids for sort equality checking\n    const compare = table.comparator();\n    const data = table.data();\n    const nrows = rows.length;\n    const peers = new Uint32Array(nrows);\n    for (let i = 1, index = 0; i < nrows; ++i) {\n      peers[i] = compare(rows[i - 1], rows[i], data) ? ++index : index;\n    }\n    return peers;\n  } else {\n    // no sort, no peers: reuse row indices as peer ids\n    return rows;\n  }\n}\n","import { relocate } from './relocate.js';\nimport { aggregate } from './reduce/util.js';\nimport { window } from './window/window.js';\nimport { parse } from '../expression/parse.js';\nimport { hasWindow } from '../op/index.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { repeat } from '../util/repeat.js';\n\nfunction isWindowed(op) {\n  return hasWindow(op.name) ||\n    op.frame && (\n      Number.isFinite(op.frame[0]) ||\n      Number.isFinite(op.frame[1])\n    );\n}\n\nexport function derive(table, values, options = {}) {\n  const dt = _derive(table, parse(values, { table }), options);\n\n  return options.drop || (options.before == null && options.after == null)\n    ? dt\n    : relocate(\n        dt,\n        Object.keys(values).filter(name => !table.column(name)),\n        options\n      );\n}\n\nexport function _derive(table, { names, exprs, ops = [] }, options = {}) {\n  // instantiate output data\n  const total = table.totalRows();\n  const cols = columnSet(options.drop ? null : table);\n  const data = names.map(name => cols.add(name, Array(total)));\n\n  // analyze operations, compute non-windowed aggregates\n  const [ aggOps, winOps ] = segmentOps(ops);\n\n  const size = table.isGrouped() ? table.groups().size : 1;\n  const result = aggregate(\n    table, aggOps,\n    repeat(ops.length, () => Array(size))\n  );\n\n  // perform table scans to generate output values\n  winOps.length\n    ? window(table, data, exprs, result, winOps)\n    : output(table, data, exprs, result);\n\n  return cols.derive(table);\n}\n\nfunction segmentOps(ops) {\n  const aggOps = [];\n  const winOps = [];\n  const n = ops.length;\n\n  for (let i = 0; i < n; ++i) {\n    const op = ops[i];\n    op.id = i;\n    (isWindowed(op) ? winOps : aggOps).push(op);\n  }\n\n  return [aggOps, winOps];\n}\n\nfunction output(table, cols, exprs, result) {\n  const bits = table.mask();\n  const data = table.data();\n  const { keys } = table.groups() || {};\n  const op = keys\n    ? (id, row) => result[id][keys[row]]\n    : id => result[id][0];\n\n  const m = cols.length;\n  for (let j = 0; j < m; ++j) {\n    const get = exprs[j];\n    const col = cols[j];\n\n    // inline the following for performance:\n    // table.scan((i, data) => col[i] = get(i, data, op));\n    if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        col[i] = get(i, data, op);\n      }\n    } else {\n      const n = table.totalRows();\n      for (let i = 0; i < n; ++i) {\n        col[i] = get(i, data, op);\n      }\n    }\n  }\n}\n","import { _derive } from './derive.js';\nimport { parse } from '../expression/parse.js';\nimport { BitSet } from '../table/BitSet.js';\n\nexport function filter(table, criteria) {\n  const test = parse({ p: criteria }, { table });\n  let predicate = test.exprs[0];\n  if (test.ops.length) {\n    const data = _derive(table, test, { drop: true }).column('p');\n    predicate = row => data.at(row);\n  }\n  return _filter(table, predicate);\n}\n\nexport function _filter(table, predicate) {\n  const n = table.totalRows();\n  const bits = table.mask();\n  const data = table.data();\n  const filter = new BitSet(n);\n\n  // inline the following for performance:\n  // table.scan((row, data) => { if (predicate(row, data)) filter.set(row); });\n  if (bits) {\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      if (predicate(i, data)) filter.set(i);\n    }\n  } else {\n    for (let i = 0; i < n; ++i) {\n      if (predicate(i, data)) filter.set(i);\n    }\n  }\n\n  return table.create({ filter });\n}\n","import { groupby } from './groupby.js';\nimport { filter } from './filter.js';\n\nexport function dedupe(table, ...keys) {\n  keys = keys.flat();\n  const gt = groupby(table, keys.length ? keys : table.columnNames());\n  return filter(gt, 'row_number() === 1').ungroup().reify();\n}\n","export function rowLookup(table, hash) {\n  const lut = new Map();\n  table.scan((row, data) => {\n    const key = hash(row, data);\n    if (key != null && key === key) {\n      lut.set(key, row);\n    }\n  });\n  return lut;\n}\n\nexport function indexLookup(idx, data, hash) {\n  const lut = new Map();\n  const n = idx.length;\n  for (let i = 0; i < n; ++i) {\n    const row = idx[i];\n    const key = hash(row, data);\n    if (key != null && key === key) {\n      lut.has(key)\n        ? lut.get(key).push(i)\n        : lut.set(key, [i]);\n    }\n  }\n  return lut;\n}\n","export function intersect(a, b) {\n  const set = new Set(b);\n  return a.filter(x => set.has(x));\n}\n","import { parse } from '../../expression/parse.js';\nimport { field } from '../../helpers/field.js';\nimport { error } from '../../util/error.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { isNumber } from '../../util/is-number.js';\nimport { isObject } from '../../util/is-object.js';\nimport { isString } from '../../util/is-string.js';\nimport { keyFunction } from '../../util/key-function.js';\nimport { toArray } from '../../util/to-array.js';\n\nexport function parseKey(name, table, params) {\n  const exprs = new Map();\n\n  toArray(params).forEach((param, i) => {\n    param = isNumber(param) ? table.columnName(param) : param;\n    isString(param) ? exprs.set(i, field(param))\n      : isFunction(param) || isObject(param) && param.expr ? exprs.set(i, param)\n      : error(`Invalid ${name} key value: ${param+''}`);\n  });\n\n  const fn = parse(exprs, { table, aggregate: false, window: false });\n  return keyFunction(fn.exprs, true);\n}\n","import { error } from '../../util/error.js';\nimport { intersect } from '../../util/intersect.js';\nimport { isArray } from '../../util/is-array.js';\nimport { isString } from '../../util/is-string.js';\nimport { parseKey } from './parse-key.js';\n\nexport function inferKeys(tableL, tableR, on) {\n  if (!on) {\n    // perform natural join if join condition not provided\n    const isect = intersect(tableL.columnNames(), tableR.columnNames());\n    if (!isect.length) error('Natural join requires shared column names.');\n    on = [isect, isect];\n  } else if (isString(on)) {\n    on = [on, on];\n  } else if (isArray(on) && on.length === 1) {\n    on = [on[0], on[0]];\n  }\n\n  return on;\n}\n\nexport function keyPredicate(tableL, tableR, onL, onR) {\n  if (onL.length !== onR.length) {\n    error('Mismatched number of join keys');\n  }\n  return [\n    parseKey('join', tableL, onL),\n    parseKey('join', tableR, onR)\n  ];\n}\n","import { rowLookup } from './join/lookup.js';\nimport { inferKeys, keyPredicate } from './util/join-keys.js';\nimport { parse } from '../expression/parse.js';\nimport { BitSet } from '../table/BitSet.js';\nimport { isArray } from '../util/is-array.js';\nimport { toArray } from '../util/to-array.js';\n\nexport function semijoin(tableL, tableR, on) {\n  return join_filter(tableL, tableR, on, { anti: false });\n}\n\nexport function antijoin(tableL, tableR, on) {\n  return join_filter(tableL, tableR, on, { anti: true });\n}\n\nexport function join_filter(tableL, tableR, on, options) {\n  on = inferKeys(tableL, tableR, on);\n\n  const predicate = isArray(on)\n    ? keyPredicate(tableL, tableR, ...on.map(toArray))\n    : parse({ on }, { join: [tableL, tableR] }).exprs[0];\n\n  return _join_filter(tableL, tableR, predicate, options);\n}\n\nexport function _join_filter(tableL, tableR, predicate, options = {}) {\n  // calculate semi-join filter mask\n  const filter = new BitSet(tableL.totalRows());\n  const join = isArray(predicate) ? hashSemiJoin : loopSemiJoin;\n  join(filter, tableL, tableR, predicate);\n\n  // if anti-join, negate the filter\n  if (options.anti) {\n    filter.not().and(tableL.mask());\n  }\n\n  return tableL.create({ filter });\n}\n\nfunction hashSemiJoin(filter, tableL, tableR, [keyL, keyR]) {\n  // build lookup table\n  const lut = rowLookup(tableR, keyR);\n\n  // scan table, update filter with matches\n  tableL.scan((rowL, data) => {\n    const rowR = lut.get(keyL(rowL, data));\n    if (rowR >= 0) filter.set(rowL);\n  });\n}\n\nfunction loopSemiJoin(filter, tableL, tableR, predicate) {\n  const nL = tableL.numRows();\n  const nR = tableR.numRows();\n  const dataL = tableL.data();\n  const dataR = tableR.data();\n\n  if (tableL.isFiltered() || tableR.isFiltered()) {\n    // use indices as at least one table is filtered\n    const idxL = tableL.indices(false);\n    const idxR = tableR.indices(false);\n    for (let i = 0; i < nL; ++i) {\n      const rowL = idxL[i];\n      for (let j = 0; j < nR; ++j) {\n        if (predicate(rowL, dataL, idxR[j], dataR)) {\n          filter.set(rowL);\n          break;\n        }\n      }\n    }\n  } else {\n    // no filters, enumerate row indices directly\n    for (let i = 0; i < nL; ++i) {\n      for (let j = 0; j < nR; ++j) {\n        if (predicate(i, dataL, j, dataR)) {\n          filter.set(i);\n          break;\n        }\n      }\n    }\n  }\n}\n","import { dedupe } from './dedupe.js';\nimport { antijoin } from './join-filter.js';\n\nexport function except(table, ...others) {\n  others = others.flat();\n  if (others.length === 0) return table;\n  const names = table.columnNames();\n  return dedupe(others.reduce((a, b) => antijoin(a, b.select(names)), table));\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { toArray } from '../util/to-array.js';\n\nexport function unroll(table, values, options) {\n  return _unroll(\n    table,\n    parseValue('unroll', table, values),\n    options && options.drop\n      ? { ...options, drop: parseValue('unroll', table, options.drop).names }\n      : options\n  );\n}\n\nexport function _unroll(table, { names = [], exprs = [], ops = [] }, options = {}) {\n  if (!names.length) return table;\n\n  const limit = options.limit > 0 ? +options.limit : Infinity;\n  const index = options.index\n    ? options.index === true ? 'index' : options.index + ''\n    : null;\n  const drop = new Set(options.drop);\n  const get = aggregateGet(table, ops, exprs);\n\n  // initialize output columns\n  const cols = columnSet();\n  const nset = new Set(names);\n  const priors = [];\n  const copies = [];\n  const unroll = [];\n\n  // original and copied columns\n  table.columnNames().forEach(name => {\n    if (!drop.has(name)) {\n      const col = cols.add(name, []);\n      if (!nset.has(name)) {\n        priors.push(table.column(name));\n        copies.push(col);\n      }\n    }\n  });\n\n  // unrolled output columns\n  names.forEach(name => {\n    if (!drop.has(name)) {\n      if (!cols.has(name)) cols.add(name, []);\n      unroll.push(cols.data[name]);\n    }\n  });\n\n  // index column, if requested\n  const icol = index ? cols.add(index, []) : null;\n\n  let start = 0;\n  const m = priors.length;\n  const n = unroll.length;\n\n  const copy = (row, maxlen) => {\n    for (let i = 0; i < m; ++i) {\n      copies[i].length = start + maxlen;\n      copies[i].fill(priors[i].at(row), start, start + maxlen);\n    }\n  };\n\n  const indices = icol\n    ? (row, maxlen) => {\n        for (let i = 0; i < maxlen; ++i) {\n          icol[row + i] = i;\n        }\n      }\n    : () => {};\n\n  if (n === 1) {\n    // optimize common case of one array-valued column\n    const fn = get[0];\n    const col = unroll[0];\n\n    table.scan((row, data) => {\n      // extract array data\n      const array = toArray(fn(row, data));\n      const maxlen = Math.min(array.length, limit);\n\n      // copy original table data\n      copy(row, maxlen);\n\n      // copy unrolled array data\n      for (let j = 0; j < maxlen; ++j) {\n        col[start + j] = array[j];\n      }\n\n      // fill in array indices\n      indices(start, maxlen);\n\n      start += maxlen;\n    });\n  } else {\n    table.scan((row, data) => {\n      let maxlen = 0;\n\n      // extract parallel array data\n      const arrays = get.map(fn => {\n        const value = toArray(fn(row, data));\n        maxlen = Math.min(Math.max(maxlen, value.length), limit);\n        return value;\n      });\n\n      // copy original table data\n      copy(row, maxlen);\n\n      // copy unrolled array data\n      for (let i = 0; i < n; ++i) {\n        const col = unroll[i];\n        const arr = arrays[i];\n        for (let j = 0; j < maxlen; ++j) {\n          col[start + j] = arr[j];\n        }\n      }\n\n      // fill in array indices\n      indices(start, maxlen);\n\n      start += maxlen;\n    });\n  }\n\n  return cols.new(table);\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { _unroll } from './unroll.js';\nimport { parseValue } from './util/parse.js';\n\nexport function fold(table, values, options) {\n  return _fold(table, parseValue('fold', table, values), options);\n}\n\nexport function _fold(table, { names = [], exprs = [], ops = [] }, options = {}) {\n  if (names.length === 0) return table;\n\n  const [k = 'key', v = 'value'] = options.as || [];\n  const vals = aggregateGet(table, ops, exprs);\n\n  return _unroll(\n    table,\n    {\n      names: [k, v],\n      exprs: [() => names, (row, data) => vals.map(fn => fn(row, data))]\n    },\n    { ...options, drop: names }\n  );\n}\n","export function ungroup(table) {\n  return table.isGrouped()\n    ? table.create({ groups: null })\n    : table;\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { _rollup } from './rollup.js';\nimport { ungroup } from './ungroup.js';\nimport { parseValue } from './util/parse.js';\nimport { parse } from '../expression/parse.js';\nimport { array_agg_distinct } from '../op/op-api.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { error } from '../util/error.js';\nimport { isValid } from '../util/is-valid.js';\nimport { keyFunction } from '../util/key-function.js';\nimport { toString } from '../util/to-string.js';\nimport { unroll } from '../util/unroll.js';\n\nexport function impute(table, values, options = {}) {\n  values = parse(values, { table });\n\n  values.names.forEach(name =>\n    table.column(name) ? 0 : error(`Invalid impute column ${toString(name)}`)\n  );\n\n  if (options.expand) {\n    const opt = { preparse, window: false, aggronly: true };\n    const params = parseValue('impute', table, options.expand, opt);\n    const result = _rollup(ungroup(table), params);\n    return _impute(\n      table, values, params.names,\n      params.names.map(name => result.get(name, 0))\n    );\n  } else {\n    return _impute(table, values);\n  }\n}\n\n// map direct field reference to \"unique\" aggregate\nfunction preparse(map) {\n  map.forEach((value, key) =>\n    value.field ? map.set(key, array_agg_distinct(value + '')) : 0\n  );\n}\n\nexport function _impute(table, values, keys, arrays) {\n  const write = keys && keys.length;\n  table = write ? expand(table, keys, arrays) : table;\n  const { names, exprs, ops } = values;\n  const gets = aggregateGet(table, ops, exprs);\n  const cols = write ? null : columnSet(table);\n  const rows = table.totalRows();\n\n  names.forEach((name, i) => {\n    const col = table.column(name);\n    const out = write ? col : cols.add(name, Array(rows));\n    const get = gets[i];\n\n    table.scan(idx => {\n      const v = col.at(idx);\n      out[idx] = !isValid(v) ? get(idx) : v;\n    });\n  });\n\n  return write ? table : table.create(cols);\n}\n\nfunction expand(table, keys, values) {\n  const groups = table.groups();\n  const data = table.data();\n\n  // expansion keys and accessors\n  const keyNames = (groups ? groups.names : []).concat(keys);\n  const keyGet = (groups ? groups.get : [])\n    .concat(keys.map(key => table.getter(key)));\n\n  // build hash of existing rows\n  const hash = new Set();\n  const keyTable = keyFunction(keyGet);\n  table.scan((idx, data) => hash.add(keyTable(idx, data)));\n\n  // initialize output table data\n  const names = table.columnNames();\n  const cols = columnSet();\n  const out = names.map(name => cols.add(name, []));\n  names.forEach((name, i) => {\n    const old = data[name];\n    const col = out[i];\n    table.scan(row => col.push(old.at(row)));\n  });\n\n  // enumerate expanded value sets and augment output table\n  const keyEnum = keyFunction(keyGet.map((k, i) => a => a[i]));\n  const set = unroll(\n    'v',\n    '{' + out.map((_, i) => `_${i}.push(v[$${i}]);`).join('') + '}',\n    out, names.map(name => keyNames.indexOf(name))\n  );\n\n  if (groups) {\n    let row = groups.keys.length;\n    const prod = values.reduce((p, a) => p * a.length, groups.size);\n    const keys = new Uint32Array(prod + (row - hash.size));\n    keys.set(groups.keys);\n    enumerate(groups, values, (vec, idx) => {\n      if (!hash.has(keyEnum(vec))) {\n        set(vec);\n        keys[row++] = idx[0];\n      }\n    });\n    cols.groupby({ ...groups, keys });\n  } else {\n    enumerate(groups, values, vec => {\n      if (!hash.has(keyEnum(vec))) set(vec);\n    });\n  }\n\n  return cols.new(table);\n}\n\nfunction enumerate(groups, values, callback) {\n  const offset = groups ? groups.get.length : 0;\n  const pad = groups ? 1 : 0;\n  const len = pad + values.length;\n  const lens = new Int32Array(len);\n  const idxs = new Int32Array(len);\n  const set = [];\n\n  if (groups) {\n    const { get, rows, size } = groups;\n    lens[0] = size;\n    set.push((vec, idx) => {\n      const row = rows[idx];\n      for (let i = 0; i < offset; ++i) {\n        vec[i] = get[i](row);\n      }\n    });\n  }\n\n  values.forEach((a, i) => {\n    const j = i + offset;\n    lens[i + pad] = a.length;\n    set.push((vec, idx) => vec[j] = a[idx]);\n  });\n\n  const vec = Array(offset + values.length);\n\n  // initialize value vector\n  for (let i = 0; i < len; ++i) {\n    set[i](vec, 0);\n  }\n  callback(vec, idxs);\n\n  // enumerate all combinations of values\n  for (let i = len - 1; i >= 0;) {\n    const idx = ++idxs[i];\n    if (idx < lens[i]) {\n      set[i](vec, idx);\n      callback(vec, idxs);\n      i = len - 1;\n    } else {\n      idxs[i] = 0;\n      set[i](vec, 0);\n      --i;\n    }\n  }\n}\n","import { dedupe } from './dedupe.js';\nimport { semijoin } from './join-filter.js';\n\nexport function intersect(table, ...others) {\n  others = others.flat();\n  const names = table.columnNames();\n  return others.length\n    ? dedupe(others.reduce((a, b) => semijoin(a, b.select(names)), table))\n    : table.reify([]);\n}\n","import { indexLookup } from './join/lookup.js';\nimport { inferKeys, keyPredicate } from './util/join-keys.js';\nimport { parseValue } from './util/parse.js';\nimport { parse } from '../expression/parse.js';\nimport { all, not } from '../helpers/selection.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { concat } from '../util/concat.js';\nimport { isArray } from '../util/is-array.js';\nimport { isString } from '../util/is-string.js';\nimport { toArray } from '../util/to-array.js';\nimport { toString } from '../util/to-string.js';\nimport { unroll } from '../util/unroll.js';\n\nconst OPT_L = { aggregate: false, window: false };\nconst OPT_R = { ...OPT_L, index: 1 };\nconst NONE = -Infinity;\n\nexport function cross(table, other, values, options) {\n  return join(\n    table,\n    other,\n    () => true,\n    values,\n    { ...options, left: true, right: true }\n  );\n}\n\nexport function join(tableL, tableR, on, values, options = {}) {\n  on = inferKeys(tableL, tableR, on);\n  const optParse = { join: [tableL, tableR] };\n  let predicate;\n\n  if (isArray(on)) {\n    const [onL, onR] = on.map(toArray);\n    predicate = keyPredicate(tableL, tableR, onL, onR);\n\n    if (!values) {\n      // infer output columns, suppress duplicated key columns\n      values = inferValues(tableL, onL, onR, options);\n    }\n  } else {\n    predicate = parse({ on }, optParse).exprs[0];\n\n    if (!values) {\n      // include all table columns if values not provided\n      values = [all(), all()];\n    }\n  }\n\n  return _join(\n    tableL, tableR, predicate,\n    parseValues(tableL, tableR, values, optParse, options && options.suffix),\n    options\n  );\n}\n\nfunction inferValues(tableL, onL, onR, options) {\n  const isect = [];\n  onL.forEach((s, i) => isString(s) && s === onR[i] ? isect.push(s) : 0);\n  const vR = not(isect);\n\n  if (options.left && options.right) {\n    // for full join, merge shared key columns together\n    const shared = new Set(isect);\n    return [\n      tableL.columnNames().map(s => {\n        const c = `[${toString(s)}]`;\n        return shared.has(s)\n          ? { [s]: `(a, b) => a${c} == null ? b${c} : a${c}` }\n          : s;\n      }),\n      vR\n    ];\n  }\n\n  return options.right ? [vR, all()] : [all(), vR];\n}\n\nfunction parseValues(tableL, tableR, values, optParse, suffix = []) {\n  if (isArray(values)) {\n    let vL, vR, vJ, n = values.length;\n    vL = vR = vJ = { names: [], exprs: [] };\n\n    if (n--) {\n      vL = parseValue('join', tableL, values[0], optParse);\n    }\n    if (n--) {\n      vR = parseValue('join', tableR, values[1], OPT_R);\n    }\n    if (n--) {\n      vJ = parse(values[2], optParse);\n    }\n\n    // handle name collisions\n    const rename = new Set();\n    const namesL = new Set(vL.names);\n    vR.names.forEach(name => {\n      if (namesL.has(name)) {\n        rename.add(name);\n      }\n    });\n    if (rename.size) {\n      suffix[0] !== '' && rekey(vL.names, rename, suffix[0] || '_1');\n      suffix[1] !== '' && rekey(vR.names, rename, suffix[1] || '_2');\n    }\n\n    return {\n      names: vL.names.concat(vR.names, vJ.names),\n      exprs: vL.exprs.concat(vR.exprs, vJ.exprs)\n    };\n  } else {\n    return parse(values, optParse);\n  }\n}\n\nfunction rekey(names, rename, suffix) {\n  names.forEach((name, i) => rename.has(name)\n    ? (names[i] = name + suffix)\n    : 0);\n}\n\nfunction emitter(columns, getters) {\n  const args = ['i', 'a', 'j', 'b'];\n  return unroll(\n    args,\n    '{' + concat(columns, (_, i) => `_${i}.push($${i}(${args}));`) + '}',\n    columns, getters\n  );\n}\n\nexport function _join(tableL, tableR, predicate, { names, exprs }, options = {}) {\n  // initialize data for left table\n  const dataL = tableL.data();\n  const idxL = tableL.indices(false);\n  const nL = idxL.length;\n  const hitL = new Int32Array(nL);\n\n  // initialize data for right table\n  const dataR = tableR.data();\n  const idxR = tableR.indices(false);\n  const nR = idxR.length;\n  const hitR = new Int32Array(nR);\n\n  // initialize output data\n  const ncols = names.length;\n  const cols = columnSet();\n  const columns = Array(ncols);\n  const getters = Array(ncols);\n  for (let i = 0; i < names.length; ++i) {\n    columns[i] = cols.add(names[i], []);\n    getters[i] = exprs[i];\n  }\n  const emit = emitter(columns, getters);\n\n  // perform join\n  const join = isArray(predicate) ? hashJoin : loopJoin;\n  join(emit, predicate, dataL, dataR, idxL, idxR, hitL, hitR, nL, nR);\n\n  if (options.left) {\n    for (let i = 0; i < nL; ++i) {\n      if (!hitL[i]) {\n        emit(idxL[i], dataL, NONE, dataR);\n      }\n    }\n  }\n\n  if (options.right) {\n    for (let j = 0; j < nR; ++j) {\n      if (!hitR[j]) {\n        emit(NONE, dataL, idxR[j], dataR);\n      }\n    }\n  }\n\n  return cols.new(tableL);\n}\n\nfunction loopJoin(emit, predicate, dataL, dataR, idxL, idxR, hitL, hitR, nL, nR) {\n  // perform nested-loops join\n  for (let i = 0; i < nL; ++i) {\n    const rowL = idxL[i];\n    for (let j = 0; j < nR; ++j) {\n      const rowR = idxR[j];\n      if (predicate(rowL, dataL, rowR, dataR)) {\n        emit(rowL, dataL, rowR, dataR);\n        hitL[i] = 1;\n        hitR[j] = 1;\n      }\n    }\n  }\n}\n\nfunction hashJoin(emit, [keyL, keyR], dataL, dataR, idxL, idxR, hitL, hitR, nL, nR) {\n  // determine which table to hash\n  let dataScan, keyScan, hitScan, idxScan;\n  let dataHash, keyHash, hitHash, idxHash;\n  let emitScan = emit;\n  if (nL >= nR) {\n    dataScan = dataL; keyScan = keyL; hitScan = hitL; idxScan = idxL;\n    dataHash = dataR; keyHash = keyR; hitHash = hitR; idxHash = idxR;\n  } else {\n    dataScan = dataR; keyScan = keyR; hitScan = hitR; idxScan = idxR;\n    dataHash = dataL; keyHash = keyL; hitHash = hitL; idxHash = idxL;\n    emitScan = (i, a, j, b) => emit(j, b, i, a);\n  }\n\n  // build lookup table\n  const lut = indexLookup(idxHash, dataHash, keyHash);\n\n  // scan other table\n  const m = idxScan.length;\n  for (let j = 0; j < m; ++j) {\n    const rowScan = idxScan[j];\n    const list = lut.get(keyScan(rowScan, dataScan));\n    if (list) {\n      const n = list.length;\n      for (let k = 0; k < n; ++k) {\n        const i = list[k];\n        emitScan(rowScan, dataScan, idxHash[i], dataHash);\n        hitHash[i] = 1;\n      }\n      hitScan[j] = 1;\n    }\n  }\n}\n","import { not } from '../helpers/selection.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { concat } from '../util/concat.js';\nimport { NULL } from '../util/null.js';\nimport { unroll } from '../util/unroll.js';\nimport { rowLookup } from './join/lookup.js';\nimport { aggregateGet } from './reduce/util.js';\nimport { inferKeys } from './util/join-keys.js';\nimport { parseKey } from './util/parse-key.js';\nimport { parseValue } from './util/parse.js';\n\nexport function lookup(tableL, tableR, on, ...values) {\n  on = inferKeys(tableL, tableR, on);\n  values = values.length === 0\n    ? [not(tableL.columnNames())]\n    : values.flat();\n  return _lookup(\n    tableL,\n    tableR,\n    [ parseKey('lookup', tableL, on[0]), parseKey('lookup', tableR, on[1]) ],\n    parseValue('lookup', tableR, values)\n  );\n}\n\nexport function _lookup(tableL, tableR, [keyL, keyR], { names, exprs, ops = [] }) {\n  // instantiate output data\n  const cols = columnSet(tableL);\n  const total = tableL.totalRows();\n  names.forEach(name => cols.add(name, Array(total).fill(NULL)));\n\n  // build lookup table\n  const lut = rowLookup(tableR, keyR);\n\n  // generate setter function for lookup match\n  const set = unroll(\n    ['lr', 'rr', 'data'],\n    '{' + concat(names, (_, i) => `_[${i}][lr] = $[${i}](rr, data);`) + '}',\n    names.map(name => cols.data[name]),\n    aggregateGet(tableR, ops, exprs)\n  );\n\n  // find matching rows, set values on match\n  const dataR = tableR.data();\n  tableL.scan((lrow, data) => {\n    const rrow = lut.get(keyL(lrow, data));\n    if (rrow >= 0) set(lrow, rrow, dataR);\n  });\n\n  return cols.derive(tableL);\n}\n","import { codegen } from './codegen.js';\nimport { parse } from './parse.js';\nimport { aggregate } from '../verbs/reduce/util.js';\n\n// generate code to compare a single field\nconst _compare = (u, v, lt, gt) => `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt} : (u > v || v == null) && u != null ? ${gt} : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt} : v !== v && u === u ? ${gt} : `;\nconst _collate = (u, v, lt, gt, f) => `(v = ${v}, (u = ${u}) == null && v == null) ? 0 : v == null ? ${gt} : u == null ? ${lt} : (u = ${f}(u,v)) ? u : `;\n\nexport function compare(table, fields) {\n  // parse expressions, generate code for both a and b values\n  const names = [];\n  const exprs = [];\n  const fn = [];\n  let keys = null, opA = '0', opB = '0';\n  if (table.isGrouped()) {\n    keys = table.groups().keys;\n    opA = 'ka';\n    opB = 'kb';\n  }\n  const { ops } = parse(fields, {\n    table,\n    value: (name, node) => {\n      names.push(name);\n      if (node.escape) {\n        // if an escaped function, invoke it directly\n        const f = i => `fn[${fn.length}](${i}, data)`;\n        exprs.push([f('a'), f('b')]);\n        fn.push(node.escape);\n      } else {\n        // generate code to extract values to compare\n        exprs.push([\n          codegen(node, { index: 'a', op: opA }),\n          codegen(node, { index: 'b', op: opB })\n        ]);\n      }\n    },\n    window: false\n  });\n\n  // calculate aggregate values if needed\n  const result = aggregate(table, ops);\n  const op = (id, row) => result[id][row];\n\n  // generate comparison code for each field\n  const n = names.length;\n  let code = 'return (a, b) => {'\n    + (op && table.isGrouped() ? 'const ka = keys[a], kb = keys[b];' : '')\n    + 'let u, v; return ';\n  for (let i = 0; i < n; ++i) {\n    const field = fields.get(names[i]);\n    const o = field.desc ? -1 : 1;\n    const [u, v] = exprs[i];\n    if (field.collate) {\n      code += _collate(u, v, -o, o, `${o < 0 ? '-' : ''}fn[${fn.length}]`);\n      fn.push(field.collate);\n    } else {\n      code += _compare(u, v, -o, o);\n    }\n  }\n  code += '0;};';\n\n  // instantiate and return comparator function\n  return Function('op', 'keys', 'fn', 'data', code)(op, keys, fn, table.data());\n}\n","import { compare } from '../expression/compare.js';\nimport { field } from '../helpers/field.js';\nimport { error } from '../util/error.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isObject } from '../util/is-object.js';\nimport { isNumber } from '../util/is-number.js';\nimport { isString } from '../util/is-string.js';\n\nexport function orderby(table, ...values) {\n  return _orderby(table, parseValues(table, values.flat()));\n}\n\nfunction parseValues(table, params) {\n  let index = -1;\n  const exprs = new Map();\n  const add = val => exprs.set(++index + '', val);\n\n  params.forEach(param => {\n    const expr = param.expr != null ? param.expr : param;\n\n    if (isObject(expr) && !isFunction(expr)) {\n      for (const key in expr) add(expr[key]);\n    } else {\n      add(\n        isNumber(expr) ? field(param, table.columnName(expr))\n          : isString(expr) ? field(param)\n          : isFunction(expr) ? param\n          : error(`Invalid orderby field: ${param+''}`)\n      );\n    }\n  });\n\n  return compare(table, exprs);\n}\n\nexport function _orderby(table, comparator) {\n  return table.create({ order: comparator });\n}\n","import { aggregate, aggregateGet, groupOutput } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { ungroup } from './ungroup.js';\nimport { any } from '../op/op-api.js';\nimport { columnSet } from '../table/ColumnSet.js';\n\n// TODO: enforce aggregates only (no output changes) for values\nexport function pivot(table, on, values, options) {\n  return _pivot(\n    table,\n    parseValue('fold', table, on),\n    parseValue('fold', table, values, { preparse, window: false, aggronly: true }),\n    options\n  );\n}\n\n// map direct field reference to \"any\" aggregate\nfunction preparse(map) {\n  map.forEach((value, key) =>\n    value.field ? map.set(key, any(value + '')) : 0\n  );\n}\n\nconst opt = (value, defaultValue) => value != null ? value : defaultValue;\n\nexport function _pivot(table, on, values, options = {}) {\n  const { keys, keyColumn } = pivotKeys(table, on, options);\n  const vsep = opt(options.valueSeparator, '_');\n  const namefn = values.names.length > 1\n    ? (i, name) => name + vsep + keys[i]\n    : i => keys[i];\n\n  // perform separate aggregate operations for each key\n  // if keys do not match, emit NaN so aggregate skips it\n  // use custom toString method for proper field resolution\n  const results = keys.map(\n    k => aggregate(table, values.ops.map(op => {\n      if (op.name === 'count') { // fix #273\n        const fn = r => k === keyColumn[r] ? 1 : NaN;\n        fn.toString = () => k + ':1';\n        return { ...op, name: 'sum', fields: [fn] };\n      }\n      const fields = op.fields.map(f => {\n        const fn = (r, d) => k === keyColumn[r] ? f(r, d) : NaN;\n        fn.toString = () => k + ':' + f;\n        return fn;\n      });\n      return { ...op, fields };\n    }))\n  );\n\n  return output(values, namefn, table.groups(), results).new(table);\n}\n\nfunction pivotKeys(table, on, options) {\n  const limit = options.limit > 0 ? +options.limit : Infinity;\n  const sort = opt(options.sort, true);\n  const ksep = opt(options.keySeparator, '_');\n\n  // construct key accessor function\n  const get = aggregateGet(table, on.ops, on.exprs);\n  const key = get.length === 1\n    ? get[0]\n    : (row, data) => get.map(fn => fn(row, data)).join(ksep);\n\n  // generate vector of per-row key values\n  const kcol = Array(table.totalRows());\n  table.scan((row, data) => kcol[row] = key(row, data));\n\n  // collect unique key values\n  const uniq = aggregate(\n    ungroup(table),\n    [ {\n      id: 0,\n      name: 'array_agg_distinct',\n      fields: [(row => kcol[row])], params: []\n    } ]\n  )[0][0];\n\n  // get ordered set of unique key values\n  const keys = sort ? uniq.sort() : uniq;\n\n  // return key values\n  return {\n    keys: Number.isFinite(limit) ? keys.slice(0, limit) : keys,\n    keyColumn: kcol\n  };\n}\n\nfunction output({ names, exprs }, namefn, groups, results) {\n  const size = groups ? groups.size : 1;\n  const cols = columnSet();\n  const m = results.length;\n  const n = names.length;\n\n  let result;\n  const op = (id, row) => result[id][row];\n\n  // write groupby fields to output\n  if (groups) groupOutput(cols, groups);\n\n  // write pivot values to output\n  for (let i = 0; i < n; ++i) {\n    const get = exprs[i];\n    if (get.field != null) {\n      // if expression is op only, use aggregates directly\n      for (let j = 0; j < m; ++j) {\n        cols.add(namefn(j, names[i]), results[j][get.field]);\n      }\n    } else if (size > 1) {\n      // if multiple groups, evaluate expression for each\n      for (let j = 0; j < m; ++j) {\n        result = results[j];\n        const col = cols.add(namefn(j, names[i]), Array(size));\n        for (let k = 0; k < size; ++k) {\n          col[k] = get(k, null, op);\n        }\n      }\n    } else {\n      // if only one group, no need to loop\n      for (let j = 0; j < m; ++j) {\n        result = results[j];\n        cols.add(namefn(j, names[i]), [ get(0, null, op) ]);\n      }\n    }\n  }\n\n  return cols;\n}\n","import { reduceFlat, reduceGroups } from './reduce/util.js';\nimport { columnSet } from '../table/ColumnSet.js';\n\nexport function reduce(table, reducer) {\n  const cols = columnSet();\n  const groups = table.groups();\n\n  // initialize groups\n  const { get, names = [], rows, size = 1 } = groups || {};\n  const counts = new Uint32Array(size + 1);\n  names.forEach(name => cols.add(name, null));\n\n  // compute reduced values\n  const cells = groups\n    ? reduceGroups(table, reducer, groups)\n    : [ reduceFlat(table, reducer) ];\n\n  // initialize output columns\n  reducer.outputs().map(name => cols.add(name, []));\n\n  // write reduced values to output columns\n  const n = counts.length - 1;\n  let len = 0;\n  for (let i = 0; i < n; ++i) {\n    len += counts[i + 1] = reducer.write(cells[i], cols.data, counts[i]);\n  }\n\n  // write group values to output columns\n  if (groups) {\n    const data = table.data();\n    names.forEach((name, index) => {\n      const column = cols.data[name] = Array(len);\n      const getter = get[index];\n      for (let i = 0, j = 0; i < size; ++i) {\n        column.fill(getter(rows[i], data), j, j += counts[i + 1]);\n      }\n    });\n  }\n\n  return cols.new(table);\n}\n","import { _select } from './select.js';\nimport { resolve } from '../helpers/selection.js';\n\nexport function rename(table, ...columns) {\n  const map = new Map();\n  table.columnNames(x => (map.set(x, x), 0));\n  return _select(table, resolve(table, columns.flat(), map));\n}\n","import { ascending } from './ascending.js';\nimport { bisector } from './bisector.js';\nimport { random } from './random.js';\n\nexport function sample(buffer, replace, index, weight) {\n  return (\n    replace\n      ? (weight ? sampleRW : sampleRU)\n      : (weight ? sampleNW : sampleNU)\n  )(buffer.length, buffer, index, weight);\n}\n\n// uniform sampling with replacement\n// uses straightforward uniform sampling\nfunction sampleRU(size, buffer, index) {\n  const n = index.length;\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[(n * random()) | 0];\n  }\n  return buffer;\n}\n\n// weighted sampling with replacement\n// uses binary search lookup against cumulative weight\nfunction sampleRW(size, buffer, index, weight) {\n  const n = index.length;\n  const w = new Float64Array(n);\n\n  let sum = 0;\n  for (let i = 0; i < n; ++i) {\n    w[i] = (sum += weight(index[i]));\n  }\n\n  const bisect = bisector(ascending).right;\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[bisect(w, sum * random())];\n  }\n  return buffer;\n}\n\n// uniform sampling without replacement\n// uses reservoir sampling to build out the sample\n// https://en.wikipedia.org/wiki/Reservoir_sampling\nfunction sampleNU(size, buffer, index) {\n  const n = index.length;\n  if (size >= n) return index;\n\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[i];\n  }\n\n  for (let i = size; i < n; ++i) {\n    const j = i * random();\n    if (j < size) {\n      buffer[j | 0] = index[i];\n    }\n  }\n\n  return buffer;\n}\n\n// weighted sample without replacement\n// uses method of Efraimidis and Spirakis\n// TODO: could use min-heap to improve efficiency\nfunction sampleNW(size, buffer, index, weight) {\n  const n = index.length;\n  if (size >= n) return index;\n\n  const w = new Float32Array(n);\n  const k = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) {\n    k[i] = i;\n    w[i] = -Math.log(random()) / weight(index[i]);\n  }\n\n  k.sort((a, b) => w[a] - w[b]);\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[k[i]];\n  }\n  return buffer;\n}\n","import { random } from './random.js';\n\nexport function shuffle(array, lo = 0, hi = array.length) {\n  let n = hi - (lo = +lo);\n\n  while (n) {\n    const i = random() * n-- | 0;\n    const v = array[n + lo];\n    array[n + lo] = array[i + lo];\n    array[i + lo] = v;\n  }\n\n  return array;\n}\n","import { _derive } from './derive.js';\nimport { _rollup } from './rollup.js';\nimport { parse } from '../expression/parse.js';\nimport { isNumber } from '../util/is-number.js';\nimport { isString } from '../util/is-string.js';\nimport { sample as sampleIndices } from '../util/sample.js';\nimport { shuffle as shuffleIndices } from '../util/shuffle.js';\n\nexport function sample(table, size, options = {}) {\n  return _sample(\n    table,\n    parseSize(table, size),\n    parseWeight(table, options.weight),\n    options\n  );\n}\n\nconst get = col => row => col.at(row) || 0;\n\nfunction parseSize(table, size) {\n  return isNumber(size)\n    ? () => size\n    : get(_rollup(table, parse({ size }, { table, window: false })).column('size'));\n}\n\nfunction parseWeight(table, w) {\n  if (w == null) return null;\n  w = isNumber(w) ? table.columnName(w) : w;\n  return get(\n    isString(w)\n      ? table.column(w)\n      : _derive(table, parse({ w }, { table }), { drop: true }).column('w')\n  );\n}\n\nexport function _sample(table, size, weight, options = {}) {\n  const { replace, shuffle } = options;\n  const parts = table.partitions(false);\n\n  let total = 0;\n  size = parts.map((idx, group) => {\n    let s = size(group);\n    total += (s = (replace ? s : Math.min(idx.length, s)));\n    return s;\n  });\n\n  const samples = new Uint32Array(total);\n  let curr = 0;\n\n  parts.forEach((idx, group) => {\n    const sz = size[group];\n    const buf = samples.subarray(curr, curr += sz);\n\n    if (!replace && sz === idx.length) {\n      // sample size === data size, no replacement\n      // no need to sample, just copy indices\n      buf.set(idx);\n    } else {\n      sampleIndices(buf, replace, idx, weight);\n    }\n  });\n\n  if (shuffle !== false && (parts.length > 1 || !replace)) {\n    // sampling with replacement methods shuffle, so in\n    // that case a single partition is already good to go\n    shuffleIndices(samples);\n  }\n\n  return table.reify(samples);\n}\n","/**\n * Generate a table expression that filters a table based on ordered row\n * indices from start to end (end not included), where start and end\n * represent per-group ordered row numbers in the table. The resulting\n * string can be used as the input to the filter verb.\n * @param {number} [start] Zero-based index at which to start extraction.\n *  A negative index indicates an offset from the end of the group.\n *  If start is undefined, slice starts from the index 0.\n * @param {number} [end] Zero-based index before which to end extraction.\n *  A negative index indicates an offset from the end of the group.\n *  If end is omitted, slice extracts through the end of the group.\n * @return {string} A table expression string for slicing values.\n * @example slice(1, -1)\n */\nexport function slice(start = 0, end = Infinity) {\n  return `${prep(start)} < row_number() && row_number() <= ${prep(end)}`;\n}\n\nfunction prep(index) {\n  return index < 0 ? `count() + ${index}` : index;\n}\n","import { filter } from './filter.js';\nimport { slice as _slice } from '../helpers/slice.js';\n\nexport function slice(table, start = 0, end = Infinity) {\n  if (table.isGrouped()) {\n    return filter(table, _slice(start, end)).reify();\n  }\n\n  // if not grouped, scan table directly\n  const indices = [];\n  const nrows = table.numRows();\n  start = Math.max(0, start + (start < 0 ? nrows : 0));\n  end = Math.min(nrows, Math.max(0, end + (end < 0 ? nrows : 0)));\n  table.scan(row => indices.push(row), true, end - start, start);\n  return table.reify(indices);\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { NULL } from '../util/null.js';\nimport { toArray } from '../util/to-array.js';\n\nexport function spread(table, values, options) {\n  return _spread(table, parseValue('spread', table, values), options);\n}\n\nexport function _spread(table, { names, exprs, ops = [] }, options = {}) {\n  if (names.length === 0) return table;\n\n  // ignore 'as' if there are multiple field names\n  const as = (names.length === 1 && options.as) || [];\n  const drop = options.drop == null ? true : !!options.drop;\n  const limit = options.limit == null\n    ? as.length || Infinity\n    : Math.max(1, +options.limit || 1);\n\n  const get = aggregateGet(table, ops, exprs);\n  const cols = columnSet();\n  const map = names.reduce((map, name, i) => map.set(name, i), new Map());\n\n  const add = (index, name) => {\n    const columns = spreadCols(table, get[index], limit);\n    const n = columns.length;\n    for (let i = 0; i < n; ++i) {\n      cols.add(as[i] || `${name}_${i + 1}`, columns[i]);\n    }\n  };\n\n  table.columnNames().forEach(name => {\n    if (map.has(name)) {\n      if (!drop) cols.add(name, table.column(name));\n      add(map.get(name), name);\n      map.delete(name);\n    } else {\n      cols.add(name, table.column(name));\n    }\n  });\n\n  map.forEach(add);\n\n  return cols.derive(table);\n}\n\nfunction spreadCols(table, get, limit) {\n  const nrows = table.totalRows();\n  const columns = [];\n\n  table.scan((row, data) => {\n    const values = toArray(get(row, data));\n    const n = Math.min(values.length, limit);\n    while (columns.length < n) {\n      columns.push(Array(nrows).fill(NULL));\n    }\n    for (let i = 0; i < n; ++i) {\n      columns[i][row] = values[i];\n    }\n  });\n\n  return columns;\n}\n","import { concat } from './concat.js';\nimport { dedupe } from './dedupe.js';\n\nexport function union(table, ...others) {\n  return dedupe(concat(table, others.flat()));\n}\n","export function unorder(table) {\n  return table.isOrdered()\n    ? table.create({ order: null })\n    : table;\n}\n","/** Magic bytes 'ARROW1' indicating the Arrow 'file' format. */\nexport const MAGIC = Uint8Array.of(65, 82, 82, 79, 87, 49);\n\n/** Bytes for an 'end of stream' message. */\nexport const EOS = Uint8Array.of(255, 255, 255, 255, 0, 0, 0, 0);\n\n/**\n * Apache Arrow version.\n */\nexport const Version = /** @type {const} */ ({\n  /** 0.1.0 (October 2016). */\n  V1: 0,\n  /** 0.2.0 (February 2017). Non-backwards compatible with V1. */\n  V2: 1,\n  /** 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2. */\n  V3: 2,\n  /** >= 0.8.0 (December 2017). Non-backwards compatible with V3. */\n  V4: 3,\n  /**\n   * >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can read V4\n   * metadata and IPC messages). Implementations are recommended to provide a\n   * V4 compatibility mode with V5 format changes disabled.\n   *\n   * Incompatible changes between V4 and V5:\n   * - Union buffer layout has changed.\n   *   In V5, Unions don't have a validity bitmap buffer.\n   */\n  V5: 4\n});\n\n/**\n * Endianness of Arrow-encoded data.\n */\nexport const Endianness = /** @type {const} */ ({\n  Little: 0,\n  Big: 1\n});\n\n/**\n * Message header type codes.\n */\nexport const MessageHeader = /** @type {const} */ ({\n  NONE: 0,\n  /**\n   * A Schema describes the columns in a record batch.\n   */\n  Schema: 1,\n  /**\n   * For sending dictionary encoding information. Any Field can be\n   * dictionary-encoded, but in this case none of its children may be\n   * dictionary-encoded.\n   * There is one vector / column per dictionary, but that vector / column\n   * may be spread across multiple dictionary batches by using the isDelta\n   * flag.\n   */\n  DictionaryBatch: 2,\n  /**\n   * A data header describing the shared memory layout of a \"record\" or \"row\"\n   * batch. Some systems call this a \"row batch\" internally and others a \"record\n   * batch\".\n   */\n  RecordBatch: 3,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional arrays, aka \"tensors\" or\n   * \"ndarrays\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  Tensor: 4,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional sparse arrays, aka \"sparse\n   * tensors\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  SparseTensor: 5\n});\n\n/**\n * Field data type ids.\n * Only non-negative values ever occur in IPC flatbuffer binary data.\n */\nexport const Type = /** @type {const} */ ({\n  /**\n   * Dictionary types compress data by using a set of integer indices to\n   * lookup potentially repeated vales in a separate dictionary of values.\n   *\n   * This type entry is provided for API convenience, it does not occur\n   * in actual Arrow IPC binary data.\n   */\n  Dictionary: -1,\n  /** No data type. Included for flatbuffer compatibility. */\n  NONE: 0,\n  /** Null values only. */\n  Null: 1,\n  /** Integers, either signed or unsigned, with 8, 16, 32, or 64 bit widths. */\n  Int: 2,\n  /** Floating point numbers with 16, 32, or 64 bit precision. */\n  Float: 3,\n  /** Opaque binary data. */\n  Binary: 4,\n  /** Unicode with UTF-8 encoding. */\n  Utf8: 5,\n  /** Booleans represented as 8 bit bytes. */\n  Bool: 6,\n  /**\n   * Exact decimal value represented as an integer value in two's complement.\n   * Currently only 128-bit (16-byte) and 256-bit (32-byte) integers are used.\n   * The representation uses the endianness indicated in the schema.\n   */\n  Decimal: 7,\n  /**\n   * Date is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:\n   * - Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n   * leap seconds), where the values are evenly divisible by 86400000\n   * - Days (32 bits) since the UNIX epoch\n   */\n  Date: 8,\n  /**\n   * Time is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since midnight, stored in either of four units: seconds,\n   * milliseconds, microseconds or nanoseconds.\n   *\n   * The integer `bitWidth` depends on the `unit` and must be one of the following:\n   * - SECOND and MILLISECOND: 32 bits\n   * - MICROSECOND and NANOSECOND: 64 bits\n   *\n   * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds\n   * (exclusive), adjusted for the time unit (for example, up to 86400000\n   * exclusive for the MILLISECOND unit).\n   * This definition doesn't allow for leap seconds. Time values from\n   * measurements with leap seconds will need to be corrected when ingesting\n   * into Arrow (for example by replacing the value 86400 with 86399).\n   */\n  Time: 9,\n  /**\n   * Timestamp is a 64-bit signed integer representing an elapsed time since a\n   * fixed epoch, stored in either of four units: seconds, milliseconds,\n   * microseconds or nanoseconds, and is optionally annotated with a timezone.\n   *\n   * Timestamp values do not include any leap seconds (in other words, all\n   * days are considered 86400 seconds long).\n   *\n   * The timezone is an optional string for the name of a timezone, one of:\n   *\n   *  - As used in the Olson timezone database (the \"tz database\" or\n   *    \"tzdata\"), such as \"America/New_York\".\n   *  - An absolute timezone offset of the form \"+XX:XX\" or \"-XX:XX\",\n   *    such as \"+07:30\".\n   *\n   * Whether a timezone string is present indicates different semantics about\n   * the data.\n   */\n  Timestamp: 10,\n  /**\n   * A \"calendar\" interval which models types that don't necessarily\n   * have a precise duration without the context of a base timestamp (e.g.\n   * days can differ in length during day light savings time transitions).\n   * All integers in the units below are stored in the endianness indicated\n   * by the schema.\n   *\n   *  - YEAR_MONTH - Indicates the number of elapsed whole months, stored as\n   *    4-byte signed integers.\n   *  - DAY_TIME - Indicates the number of elapsed days and milliseconds (no\n   *    leap seconds), stored as 2 contiguous 32-bit signed integers (8-bytes\n   *    in total). Support of this IntervalUnit is not required for full arrow\n   *    compatibility.\n   *  - MONTH_DAY_NANO - A triple of the number of elapsed months, days, and\n   *    nanoseconds. The values are stored contiguously in 16-byte blocks.\n   *    Months and days are encoded as 32-bit signed integers and nanoseconds\n   *    is encoded as a 64-bit signed integer. Nanoseconds does not allow for\n   *    leap seconds. Each field is independent (e.g. there is no constraint\n   *    that nanoseconds have the same sign as days or that the quantity of\n   *    nanoseconds represents less than a day's worth of time).\n   */\n  Interval: 11,\n  /**\n   * List (vector) data supporting variably-sized lists.\n   * A list has a single child data type for list entries.\n   */\n  List: 12,\n  /**\n   * A struct consisting of multiple named child data types.\n   */\n  Struct: 13,\n  /**\n   * A union is a complex type with parallel child data types. By default ids\n   * in the type vector refer to the offsets in the children. Optionally\n   * typeIds provides an indirection between the child offset and the type id.\n   * For each child `typeIds[offset]` is the id used in the type vector.\n   */\n  Union: 14,\n  /**\n   * Binary data where each entry has the same fixed size.\n   */\n  FixedSizeBinary: 15,\n  /**\n   * List (vector) data where every list has the same fixed size.\n   * A list has a single child data type for list entries.\n   */\n  FixedSizeList: 16,\n  /**\n   * A Map is a logical nested type that is represented as\n   * List<entries: Struct<key: K, value: V>>\n   *\n   * In this layout, the keys and values are each respectively contiguous. We do\n   * not constrain the key and value types, so the application is responsible\n   * for ensuring that the keys are hashable and unique. Whether the keys are sorted\n   * may be set in the metadata for this field.\n   *\n   * In a field with Map type, the field has a child Struct field, which then\n   * has two children: key type and the second the value type. The names of the\n   * child fields may be respectively \"entries\", \"key\", and \"value\", but this is\n   * not enforced.\n   *\n   * Map\n   * ```text\n   *   - child[0] entries: Struct\n   *   - child[0] key: K\n   *   - child[1] value: V\n   *  ```\n   * Neither the \"entries\" field nor the \"key\" field may be nullable.\n   *\n   * The metadata is structured so that Arrow systems without special handling\n   * for Map can make Map an alias for List. The \"layout\" attribute for the Map\n   * field must have the same contents as a List.\n   */\n  Map: 17,\n  /**\n   * An absolute length of time unrelated to any calendar artifacts. For the\n   * purposes of Arrow implementations, adding this value to a Timestamp\n   * (\"t1\") naively (i.e. simply summing the two numbers) is acceptable even\n   * though in some cases the resulting Timestamp (t2) would not account for\n   * leap-seconds during the elapsed time between \"t1\" and \"t2\". Similarly,\n   * representing the difference between two Unix timestamp is acceptable, but\n   * would yield a value that is possibly a few seconds off from the true\n   * elapsed time.\n   *\n   * The resolution defaults to millisecond, but can be any of the other\n   * supported TimeUnit values as with Timestamp and Time types. This type is\n   * always represented as an 8-byte integer.\n   */\n  Duration: 18,\n  /**\n   * Same as Binary, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeBinary: 19,\n  /**\n   * Same as Utf8, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeUtf8: 20,\n  /**\n   * Same as List, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeList: 21,\n  /**\n   * Contains two child arrays, run_ends and values. The run_ends child array\n   * must be a 16/32/64-bit integer array which encodes the indices at which\n   * the run with the value in each corresponding index in the values child\n   * array ends. Like list/struct types, the value array can be of any type.\n   */\n  RunEndEncoded: 22,\n  /**\n   * Logically the same as Binary, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  BinaryView: 23,\n  /**\n   * Logically the same as Utf8, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  Utf8View: 24,\n  /**\n   * Represents the same logical types that List can, but contains offsets and\n   * sizes allowing for writes in any order and sharing of child values among\n   * list values.\n   */\n  ListView: 25,\n  /**\n   * Same as ListView, but with 64-bit offsets and sizes, allowing to represent\n   * extremely large data values.\n   */\n  LargeListView: 26\n});\n\n/**\n * Floating point number precision.\n */\nexport const Precision = /** @type {const} */ ({\n  /** 16-bit floating point number. */\n  HALF: 0,\n  /** 32-bit floating point number. */\n  SINGLE: 1,\n  /** 64-bit floating point number. */\n  DOUBLE: 2\n});\n\n/**\n * Date units.\n */\nexport const DateUnit = /** @type {const} */ ({\n  /* Days (as 32 bit int) since the UNIX epoch. */\n  DAY: 0,\n  /**\n   * Milliseconds (as 64 bit int) indicating UNIX time elapsed since the epoch\n   * (no leap seconds), with values evenly divisible by 86400000.\n   */\n  MILLISECOND: 1\n});\n\n/**\n * Time units.\n */\nexport const TimeUnit = /** @type {const} */ ({\n  /** Seconds. */\n  SECOND: 0,\n  /** Milliseconds. */\n  MILLISECOND: 1,\n  /** Microseconds. */\n  MICROSECOND: 2,\n  /** Nanoseconds. */\n  NANOSECOND: 3\n});\n\n/**\n * Date/time interval units.\n */\nexport const IntervalUnit = /** @type {const} */ ({\n  /**\n   * Indicates the number of elapsed whole months, stored as 4-byte signed\n   * integers.\n   */\n  YEAR_MONTH: 0,\n  /**\n   * Indicates the number of elapsed days and milliseconds (no leap seconds),\n   * stored as 2 contiguous 32-bit signed integers (8-bytes in total). Support\n   * of this IntervalUnit is not required for full arrow compatibility.\n   */\n  DAY_TIME: 1,\n  /**\n   * A triple of the number of elapsed months, days, and nanoseconds.\n   * The values are stored contiguously in 16-byte blocks. Months and days are\n   * encoded as 32-bit signed integers and nanoseconds is encoded as a 64-bit\n   * signed integer. Nanoseconds does not allow for leap seconds. Each field is\n   * independent (e.g. there is no constraint that nanoseconds have the same\n   * sign as days or that the quantity of nanoseconds represents less than a\n   * day's worth of time).\n   */\n  MONTH_DAY_NANO: 2\n});\n\n/**\n * Union type modes.\n */\nexport const UnionMode = /** @type {const} */ ({\n  /** Sparse union layout with full arrays for each sub-type. */\n  Sparse: 0,\n  /** Dense union layout with offsets into value arrays. */\n  Dense: 1\n});\n","/**\n * @import { Int64ArrayConstructor, IntArrayConstructor, IntegerArray, TypedArray } from '../types.js'\n */\nexport const uint8Array = Uint8Array;\nexport const uint16Array = Uint16Array;\nexport const uint32Array = Uint32Array;\nexport const uint64Array = BigUint64Array;\nexport const int8Array = Int8Array;\nexport const int16Array = Int16Array;\nexport const int32Array = Int32Array;\nexport const int64Array = BigInt64Array;\nexport const float32Array = Float32Array;\nexport const float64Array = Float64Array;\n\n/**\n * Check if an input value is an ArrayBuffer or SharedArrayBuffer.\n * @param {unknown} data\n * @returns {data is ArrayBufferLike}\n */\nexport function isArrayBufferLike(data) {\n  return data instanceof ArrayBuffer || (\n    typeof SharedArrayBuffer !== 'undefined' &&\n    data instanceof SharedArrayBuffer\n  );\n}\n\n/**\n * Return the appropriate typed array constructor for the given\n * integer type metadata.\n * @param {number} bitWidth The integer size in bits.\n * @param {boolean} signed Flag indicating if the integer is signed.\n * @returns {IntArrayConstructor}\n */\nexport function intArrayType(bitWidth, signed) {\n  const i = Math.log2(bitWidth) - 3;\n  return (\n    signed\n      ? [int8Array, int16Array, int32Array, int64Array]\n      : [uint8Array, uint16Array, uint32Array, uint64Array]\n  )[i];\n}\n\n/** Shared prototype for typed arrays. */\nconst TypedArray = Object.getPrototypeOf(Int8Array);\n\n/**\n * Check if a value is a typed array.\n * @param {*} value The value to check.\n * @returns {value is TypedArray}\n *  True if value is a typed array, false otherwise.\n */\nexport function isTypedArray(value) {\n  return value instanceof TypedArray;\n}\n\n/**\n * Check if a value is either a standard array or typed array.\n * @param {*} value The value to check.\n * @returns {value is (Array | TypedArray)}\n *  True if value is an array, false otherwise.\n */\nexport function isArray(value) {\n  return Array.isArray(value) || isTypedArray(value);\n}\n\n/**\n * Check if a value is an array type (constructor) for 64-bit integers,\n * one of BigInt64Array or BigUint64Array.\n * @param {*} value The value to check.\n * @returns {value is Int64ArrayConstructor}\n *  True if value is a 64-bit array type, false otherwise.\n */\nexport function isInt64ArrayType(value) {\n  return value === int64Array || value === uint64Array;\n}\n\n/**\n * Determine the correct index into an offset array for a given\n * full column row index. Assumes offset indices can be manipulated\n * as 32-bit signed integers.\n * @param {IntegerArray} offsets The offsets array.\n * @param {number} index The full column row index.\n */\nexport function bisect(offsets, index) {\n  let a = 0;\n  let b = offsets.length;\n  if (b <= 2147483648) { // 2 ** 31\n    // fast version, use unsigned bit shift\n    // array length fits within 32-bit signed integer\n    do {\n      const mid = (a + b) >>> 1;\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  } else {\n    // slow version, use division and truncate\n    // array length exceeds 32-bit signed integer\n    do {\n      const mid = Math.trunc((a + b) / 2);\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  }\n  return a;\n}\n\n/**\n * Compute a 64-bit aligned buffer size.\n * @param {number} length The starting size.\n * @param {number} bpe Bytes per element.\n * @returns {number} The aligned size.\n */\nfunction align64(length, bpe = 1) {\n  return (((length * bpe) + 7) & ~7) / bpe;\n}\n\n/**\n * Return a 64-bit aligned version of the array.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} length The current array length.\n * @returns {T} The aligned array.\n */\nexport function align(array, length = array.length) {\n  const alignedLength = align64(length, array.BYTES_PER_ELEMENT);\n  return array.length > alignedLength ? /** @type {T} */ (array.subarray(0, alignedLength))\n    : array.length < alignedLength ? resize(array, alignedLength)\n    : array;\n}\n\n/**\n * Resize a typed array to exactly the specified length.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} newLength The new length.\n * @param {number} [offset] The offset at which to copy the old array.\n * @returns {T} The resized array.\n */\nexport function resize(array, newLength, offset = 0) {\n  // @ts-ignore\n  const newArray = new array.constructor(newLength);\n  newArray.set(array, offset);\n  return newArray;\n}\n\n/**\n * Grow a typed array to accommdate a minimum index. The array size is\n * doubled until it exceeds the minimum index.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} index The minimum index.\n * @param {boolean} [shift] Flag to shift copied bytes to back of array.\n * @returns {T} The resized array.\n */\nexport function grow(array, index, shift) {\n  while (array.length <= index) {\n    array = resize(array, array.length << 1, shift ? array.length : 0);\n  }\n  return array;\n}\n","/**\n * Check if a value is a Date instance\n * @param {*} value The value to check.\n * @returns {value is Date} True if value is a Date, false otherwise.\n */\nexport function isDate(value) {\n  return value instanceof Date;\n}\n\n/**\n * Check if a value is iterable.\n * @param {*} value The value to check.\n * @returns {value is Iterable} True if value is iterable, false otherwise.\n */\nexport function isIterable(value) {\n  return typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * Return the input value if it passes a test.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {(value: T) => boolean} test The test function.\n * @param {(value: *) => string} message Message generator.\n * @returns {T} The input value.\n * @throws if the value does not pass the test\n */\nexport function check(value, test, message) {\n  if (test(value)) return value;\n  throw new Error(message(value));\n}\n\n/**\n * Return the input value if it exists in the provided set.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {T[] | Record<string,T>} set The set of valid values.\n * @param {(value: *) => string} [message] Message generator.\n * @returns {T} The input value.\n * @throws if the value is not included in the set\n */\nexport function checkOneOf(value, set, message) {\n  set = Array.isArray(set) ? set : Object.values(set);\n  return check(\n    value,\n    (value) => set.includes(value),\n    message ?? (() => `${value} must be one of ${set}`)\n  );\n}\n\n/**\n * Return the first object key that pairs with the given value.\n * @param {Record<string,any>} object The object to search.\n * @param {any} value The value to lookup.\n * @returns {string} The first matching key, or '<Unknown>' if not found.\n */\nexport function keyFor(object, value) {\n  for (const [key, val] of Object.entries(object)) {\n    if (val === value) return key;\n  }\n  return '<Unknown>';\n}\n","/**\n * @import { BinaryType, BinaryViewType, BoolType, DataType, DateType, DateUnit_, DecimalType, DictionaryType, DurationType, Field, FixedSizeBinaryType, FixedSizeListType, FloatType, IntBitWidth, IntervalType, IntervalUnit_, IntType, LargeBinaryType, LargeListType, LargeListViewType, LargeUtf8Type, ListType, ListViewType, MapType, NullType, Precision_, RunEndEncodedType, StructType, TimestampType, TimeType, TimeUnit_, UnionMode_, UnionType, Utf8Type, Utf8ViewType } from './types.js'\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from './constants.js';\nimport { intArrayType, float32Array, float64Array, int32Array, int64Array, uint16Array, uint64Array } from './util/arrays.js';\nimport { check, checkOneOf, keyFor } from './util/objects.js';\n\n/**\n * @typedef {Field | DataType} FieldInput\n */\n\nexport const invalidDataType = (typeId) =>\n  `Unsupported data type: \"${keyFor(Type, typeId)}\" (id ${typeId})`;\n\n/**\n * Return a new field instance for use in a schema or type definition. A field\n * represents a field name, data type, and additional metadata. Fields are used\n * to represent child types within nested types like List, Struct, and Union.\n * @param {string} name The field name.\n * @param {DataType} type The field data type.\n * @param {boolean} [nullable=true] Flag indicating if the field is nullable\n *  (default `true`).\n * @param {Map<string,string>|null} [metadata=null] Custom field metadata\n *  annotations (default `null`).\n * @returns {Field} The field instance.\n */\nexport const field = (name, type, nullable = true, metadata = null) => ({\n  name,\n  type,\n  nullable,\n  metadata\n});\n\n/**\n * Checks if a value is a field instance.\n * @param {any} value\n * @returns {value is Field}\n */\nfunction isField(value) {\n  return Object.hasOwn(value, 'name') && isDataType(value.type)\n}\n\n/**\n * Checks if a value is a data type instance.\n * @param {any} value\n * @returns {value is DataType}\n */\nfunction isDataType(value) {\n  return typeof value?.typeId === 'number';\n}\n\n/**\n * Return a field instance from a field or data type input.\n * @param {FieldInput} value\n *  The value to map to a field.\n * @param {string} [defaultName] The default field name.\n * @param {boolean} [defaultNullable=true] The default nullable value.\n * @returns {Field} The field instance.\n */\nfunction asField(value, defaultName = '', defaultNullable = true) {\n  return isField(value)\n    ? value\n    : field(\n        defaultName,\n        check(value, isDataType, () => `Data type expected.`),\n        defaultNullable\n      );\n}\n\n/////\n\n/**\n * Return a basic type with only a type id.\n * @template {typeof Type[keyof typeof Type]} T\n * @param {T} typeId The type id.\n */\nconst basicType = (typeId) => ({ typeId });\n\n/**\n * Return a Dictionary data type instance.  A dictionary type consists of a\n * dictionary of values (which may be of any type) and corresponding integer\n * indices that reference those values. If values are repeated, a dictionary\n * encoding can provide substantial space savings. In the IPC format,\n * dictionary indices reside alongside other columns in a record batch, while\n * dictionary values are written to special dictionary batches, linked by a\n * unique dictionary *id*.\n * @param {DataType} type The data type of dictionary\n *  values.\n * @param {IntType} [indexType] The data type of\n *  dictionary indices. Must be an integer type (default `int32`).\n * @param {boolean} [ordered=false] Indicates if dictionary values are\n *  ordered (default `false`).\n * @param {number} [id=-1] The dictionary id. The default value (-1) indicates\n *  the dictionary applies to a single column only. Provide an explicit id in\n *  order to reuse a dictionary across columns when building, in which case\n *  different dictionaries *must* have different unique ids. All dictionary\n *  ids are later resolved (possibly to new values) upon IPC encoding.\n * @returns {DictionaryType}\n */\nexport const dictionary = (type, indexType, ordered = false, id = -1) => ({\n  typeId: Type.Dictionary,\n  id,\n  dictionary: type,\n  indices: indexType || int32(),\n  ordered\n});\n\n/**\n * Return a Null data type instance. Null data requires no storage and all\n * extracted values are `null`.\n * @returns {NullType} The null data type.\n */\nexport const nullType = () => basicType(Type.Null);\n\n/**\n * Return an Int data type instance.\n * @param {IntBitWidth} [bitWidth=32] The integer bit width.\n *  One of `8`, `16`, `32` (default), or `64`.\n * @param {boolean} [signed=true] Flag for signed or unsigned integers\n *  (default `true`).\n * @returns {IntType} The integer data type.\n */\nexport const int = (bitWidth = 32, signed = true) => ({\n  typeId: Type.Int,\n  bitWidth: checkOneOf(bitWidth, [8, 16, 32, 64]),\n  signed,\n  values: intArrayType(bitWidth, signed)\n});\n/**\n * Return an Int data type instance for 8 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int8 = () => int(8);\n/**\n * Return an Int data type instance for 16 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int16 = () => int(16);\n/**\n * Return an Int data type instance for 32 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int32 = () => int(32);\n/**\n * Return an Int data type instance for 64 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int64 = () => int(64);\n/**\n * Return an Int data type instance for 8 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint8 = () => int(8, false);\n/**\n * Return an Int data type instance for 16 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint16 = () => int(16, false);\n/**\n * Return an Int data type instance for 32 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint32 = () => int(32, false);\n/**\n * Return an Int data type instance for 64 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint64 = () => int(64, false);\n\n/**\n * Return a Float data type instance for floating point numbers.\n * @param {Precision_} [precision=2] The floating point\n *  precision. One of `Precision.HALF` (16-bit), `Precision.SINGLE` (32-bit)\n *  or `Precision.DOUBLE` (64-bit, default).\n * @returns {FloatType} The floating point data type.\n */\nexport const float = (precision = 2) => ({\n  typeId: Type.Float,\n  precision: checkOneOf(precision, Precision),\n  values: [uint16Array, float32Array, float64Array][precision]\n});\n/**\n * Return a Float data type instance for half-precision (16 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float16 = () => float(Precision.HALF);\n/**\n * Return a Float data type instance for single-precision (32 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float32 = () => float(Precision.SINGLE);\n/**\n * Return a Float data type instance for double-precision (64 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float64 = () => float(Precision.DOUBLE);\n\n/**\n * Return a Binary data type instance for variably-sized opaque binary data\n * with 32-bit offsets.\n * @returns {BinaryType} The binary data type.\n */\nexport const binary = () => ({\n  typeId: Type.Binary,\n  offsets: int32Array\n});\n\n/**\n * Return a Utf8 data type instance for Unicode string data.\n * [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored as\n * binary data.\n * @returns {Utf8Type} The utf8 data type.\n */\nexport const utf8 = () => ({\n  typeId: Type.Utf8,\n  offsets: int32Array\n});\n\n/**\n * Return a Bool data type instance. Bool values are stored compactly in\n * bitmaps with eight values per byte.\n * @returns {BoolType} The bool data type.\n */\nexport const bool = () => basicType(Type.Bool);\n\n/**\n * Return a Decimal data type instance. Decimal values are represented as 32,\n * 64, 128, or 256 bit integers in two's complement. Decimals are fixed point\n * numbers with a set *precision* (total number of decimal digits) and *scale*\n * (number of fractional digits). For example, the number `35.42` can be\n * represented as `3542` with *precision*  4 and *scale* = 2.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @param {32 | 64 | 128 | 256} [bitWidth] The decimal bit width.\n *  One of 32, 64, 128 (default), or 256.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal = (precision, scale, bitWidth = 128) => ({\n  typeId: Type.Decimal,\n  precision,\n  scale,\n  bitWidth: checkOneOf(bitWidth, [32, 64, 128, 256]),\n  values: bitWidth === 32 ? int32Array : uint64Array\n});\n/**\n * Return an Decimal data type instance with a bit width of 32.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal32 = (precision, scale) => decimal(precision, scale, 32);\n/**\n * Return an Decimal data type instance with a bit width of 64.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal64 = (precision, scale) => decimal(precision, scale, 64);\n/**\n * Return an Decimal data type instance with a bit width of 128.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal128 = (precision, scale) => decimal(precision, scale, 128);\n/**\n * Return an Decimal data type instance with a bit width of 256.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal256 = (precision, scale) => decimal(precision, scale, 256);\n\n/**\n * Return a Date data type instance. Date values are 32-bit or 64-bit signed\n * integers representing elapsed time since the UNIX epoch (Jan 1, 1970 UTC),\n * either in units of days (32 bits) or milliseconds (64 bits, with values\n * evenly divisible by 86400000).\n * @param {DateUnit_} unit The date unit.\n *  One of `DateUnit.DAY` or `DateUnit.MILLISECOND`.\n * @returns {DateType} The date data type.\n */\nexport const date = (unit) => ({\n  typeId: Type.Date,\n  unit: checkOneOf(unit, DateUnit),\n  values: unit === DateUnit.DAY ? int32Array : int64Array\n});\n/**\n * Return a Date data type instance with units of days.\n * @returns {DateType} The date data type.\n */\nexport const dateDay = () => date(DateUnit.DAY);\n/**\n * Return a Date data type instance with units of milliseconds.\n * @returns {DateType} The date data type.\n */\nexport const dateMillisecond = () => date(DateUnit.MILLISECOND);\n\n/**\n * Return a Time data type instance, stored in one of four *unit*s: seconds,\n * milliseconds, microseconds or nanoseconds. The integer *bitWidth* is\n * inferred from the *unit* and is 32 bits for seconds and milliseconds or\n * 64 bits for microseconds and nanoseconds. The allowed values are between 0\n * (inclusive) and 86400 (=24*60*60) seconds (exclusive), adjusted for the\n * time unit (for example, up to 86400000 exclusive for the\n * `DateUnit.MILLISECOND` unit.\n *\n * This definition doesn't allow for leap seconds. Time values from\n * measurements with leap seconds will need to be corrected when ingesting\n * into Arrow (for example by replacing the value 86400 with 86399).\n * @param {TimeUnit_} unit The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @returns {TimeType} The time data type.\n */\nexport const time = (unit = TimeUnit.MILLISECOND) => {\n  unit = checkOneOf(unit, TimeUnit);\n  const bitWidth = unit === TimeUnit.SECOND || unit === TimeUnit.MILLISECOND ? 32 : 64;\n  return {\n    typeId: Type.Time,\n    unit,\n    bitWidth,\n    values: bitWidth === 32 ? int32Array : int64Array\n  };\n};\n/**\n * Return a Time data type instance, represented as seconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeSecond = () => time(TimeUnit.SECOND);\n/**\n * Return a Time data type instance, represented as milliseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeMillisecond = () => time(TimeUnit.MILLISECOND);\n/**\n * Return a Time data type instance, represented as microseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeMicrosecond = () => time(TimeUnit.MICROSECOND);\n/**\n * Return a Time data type instance, represented as nanoseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeNanosecond = () => time(TimeUnit.NANOSECOND);\n\n/**\n * Return a Timestamp data type instance. Timestamp values are 64-bit signed\n * integers representing an elapsed time since a fixed epoch, stored in either\n * of four units: seconds, milliseconds, microseconds or nanoseconds, and are\n * optionally annotated with a timezone. Timestamp values do not include any\n * leap seconds (in other words, all days are considered 86400 seconds long).\n * @param {TimeUnit_} [unit] The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @param {string|null} [timezone=null] An optional string for the name of a\n *  timezone. If provided, the value should either be a string as used in the\n *  Olson timezone database (the \"tz database\" or \"tzdata\"), such as\n *  \"America/New_York\", or an absolute timezone offset of the form \"+XX:XX\" or\n *  \"-XX:XX\", such as \"+07:30\".Whether a timezone string is present indicates\n *  different semantics about the data.\n * @returns {TimestampType} The time data type.\n */\nexport const timestamp = (unit = TimeUnit.MILLISECOND, timezone = null) => ({\n  typeId: Type.Timestamp,\n  unit: checkOneOf(unit, TimeUnit),\n  timezone,\n  values: int64Array\n});\n\n/**\n * Return an Interval type instance. Values represent calendar intervals stored\n * as integers for each date part. The supported *unit*s are year/moth,\n * day/time, and month/day/nanosecond intervals.\n *\n * `IntervalUnit.YEAR_MONTH` indicates the number of elapsed whole months,\n * stored as 32-bit signed integers.\n *\n * `IntervalUnit.DAY_TIME` indicates the number of elapsed days and\n * milliseconds (no leap seconds), stored as 2 contiguous 32-bit signed\n * integers (8-bytes in total).\n *\n * `IntervalUnit.MONTH_DAY_NANO` is a triple of the number of elapsed months,\n * days, and nanoseconds. The values are stored contiguously in 16-byte blocks.\n * Months and days are encoded as 32-bit signed integers and nanoseconds is\n * encoded as a 64-bit signed integer. Nanoseconds does not allow for leap\n * seconds. Each field is independent (e.g. there is no constraint that\n * nanoseconds have the same sign as days or that the quantity of nanoseconds\n * represents less than a day's worth of time).\n * @param {IntervalUnit_} unit  The interval unit.\n *  One of `IntervalUnit.YEAR_MONTH`, `IntervalUnit.DAY_TIME`, or\n *  `IntervalUnit.MONTH_DAY_NANO` (default).\n * @returns {IntervalType} The interval data type.\n */\nexport const interval = (unit = IntervalUnit.MONTH_DAY_NANO) => ({\n  typeId: Type.Interval,\n  unit: checkOneOf(unit, IntervalUnit),\n  values: unit === IntervalUnit.MONTH_DAY_NANO ? undefined : int32Array\n});\n\n/**\n * Return a List data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. A list has a single child data type for\n * list entries. Lists are represented using integer offsets that indicate\n * list extents within a single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {ListType} The list data type.\n */\nexport const list = (child) => ({\n  typeId: Type.List,\n  children: [ asField(child) ],\n  offsets: int32Array\n});\n\n/**\n * Return a Struct data type instance. A struct consists of multiple named\n * child data types. Struct values are stored as parallel child batches, one\n * per child type, and extracted to standard JavaScript objects.\n * @param {Field[] | Record<string, DataType>} children\n *  An array of property fields, or an object mapping property names to data\n *  types. If an object, the instantiated fields are assumed to be nullable\n *  and have no metadata.\n * @returns {StructType} The struct data type.\n */\nexport const struct = (children) => ({\n  typeId: Type.Struct,\n  children: Array.isArray(children) && isField(children[0])\n    ? /** @type {Field[]} */ (children)\n    : Object.entries(children).map(([name, type]) => field(name, type))\n});\n\n/**\n * Return a Union type instance. A union is a complex type with parallel\n * *children* data types. Union values are stored in either a sparse\n * (`UnionMode.Sparse`) or dense (`UnionMode.Dense`) layout *mode*. In a\n * sparse layout, child types are stored in parallel arrays with the same\n * lengths, resulting in many unused, empty values. In a dense layout, child\n * types have variable lengths and an offsets array is used to index the\n * appropriate value.\n *\n * By default, ids in the type vector refer to the index in the children\n * array. Optionally, *typeIds* provide an indirection between the child\n * index and the type id. For each child, `typeIds[index]` is the id used\n * in the type vector. The *typeIdForValue* argument provides a lookup\n * function for mapping input data to the proper child type id, and is\n * required if using builder methods.\n * @param {UnionMode_} mode The union mode.\n *  One of `UnionMode.Sparse` or `UnionMode.Dense`.\n * @param {FieldInput[]} children The children fields or data types.\n *  Types are mapped to nullable fields with no metadata.\n * @param {number[]} [typeIds]  Children type ids, in the same order as the\n *  children types. Type ids provide a level of indirection over children\n *  types. If not provided, the children indices are used as the type ids.\n * @param {(value: any, index: number) => number} [typeIdForValue]\n *  A function that takes an arbitrary value and a row index and returns a\n *  correponding union type id. Required by builder methods.\n * @returns {UnionType} The union data type.\n */\nexport const union = (mode, children, typeIds, typeIdForValue) => {\n  typeIds ??= children.map((v, i) => i);\n  return {\n    typeId: Type.Union,\n    mode: checkOneOf(mode, UnionMode),\n    typeIds,\n    typeMap: typeIds.reduce((m, id, i) => ((m[id] = i), m), {}),\n    children: children.map((v, i) => asField(v, `_${i}`)),\n    typeIdForValue,\n    offsets: int32Array,\n  };\n};\n\n/**\n * Create a FixedSizeBinary data type instance for opaque binary data where\n * each entry has the same fixed size.\n * @param {number} stride The fixed size in bytes.\n * @returns {FixedSizeBinaryType} The fixed size binary data type.\n */\nexport const fixedSizeBinary = (stride) => ({\n  typeId: Type.FixedSizeBinary,\n  stride\n});\n\n/**\n * Return a FixedSizeList type instance for list (array) data where every list\n * has the same fixed size. A list has a single child data type for list\n * entries. Fixed size lists are represented as a single child array containing\n * all list values, indexed using the known stride.\n * @param {FieldInput} child The list item data type.\n * @param {number} stride The fixed list size.\n * @returns {FixedSizeListType} The fixed size list data type.\n */\nexport const fixedSizeList = (child, stride) => ({\n  typeId: Type.FixedSizeList,\n  stride,\n  children: [ asField(child) ]\n});\n\n/**\n * Internal method to create a Map type instance.\n * @param {boolean} keysSorted Flag indicating if the map keys are sorted.\n * @param {Field} child The child fields.\n * @returns {MapType} The map data type.\n */\nexport const mapType = (keysSorted, child) => ({\n  typeId: Type.Map,\n  keysSorted,\n  children: [child],\n  offsets: int32Array\n});\n\n/**\n * Return a Map data type instance representing collections of key-value pairs.\n * A Map is a logical nested type that is represented as a list of key-value\n * structs. The key and value types are not constrained, so the application is\n * responsible for ensuring that the keys are hashable and unique, and that\n * keys are properly sorted if *keysSorted* is `true`.\n * @param {FieldInput} keyField The map key field or data type.\n * @param {FieldInput} valueField The map value field or data type.\n * @param {boolean} [keysSorted=false] Flag indicating if the map keys are\n *  sorted (default `false`).\n * @returns {MapType} The map data type.\n */\nexport const map = (keyField, valueField, keysSorted = false) => mapType(\n  keysSorted,\n  field(\n    'entries',\n    struct([ asField(keyField, 'key', false), asField(valueField, 'value') ]),\n    false\n  )\n);\n\n/**\n * Return a Duration data type instance. Durations represent an absolute length\n * of time unrelated to any calendar artifacts. The resolution defaults to\n * millisecond, but can be any of the other `TimeUnit` values. This type is\n * always represented as a 64-bit integer.\n * @param {TimeUnit_} unit\n * @returns {DurationType} The duration data type.\n */\nexport const duration = (unit = TimeUnit.MILLISECOND) => ({\n  typeId: Type.Duration,\n  unit: checkOneOf(unit, TimeUnit),\n  values: int64Array\n});\n\n/**\n * Return a LargeBinary data type instance for variably-sized opaque binary\n * data with 64-bit offsets, allowing representation of extremely large data\n * values.\n * @returns {LargeBinaryType} The large binary data type.\n */\nexport const largeBinary = () => ({\n  typeId: Type.LargeBinary,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeUtf8 data type instance for Unicode string data of variable\n * length with 64-bit offsets, allowing representation of extremely large data\n * values. [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored\n * as binary data.\n * @returns {LargeUtf8Type} The large utf8 data type.\n */\nexport const largeUtf8 = () => ({\n  typeId: Type.LargeUtf8,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeList data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. A list has a single child data type for list entries. Lists\n * are represented using integer offsets that indicate list extents within a\n * single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {LargeListType} The large list data type.\n */\nexport const largeList = (child) => ({\n  typeId: Type.LargeList,\n  children: [ asField(child) ],\n  offsets: int64Array\n});\n\n/**\n * Return a RunEndEncoded data type instance, which compresses data by\n * representing consecutive repeated values as a run. This data type uses two\n * child arrays, `run_ends` and `values`. The `run_ends` child array must be\n * a 16, 32, or 64 bit integer array which encodes the indices at which the\n * run with the value in each corresponding index in the values child array\n * ends. Like list and struct types, the `values` array can be of any type.\n * @param {FieldInput} runsField The run-ends field or data type.\n * @param {FieldInput} valuesField The values field or data type.\n * @returns {RunEndEncodedType} The large list data type.\n */\nexport const runEndEncoded = (runsField, valuesField) => ({\n  typeId: Type.RunEndEncoded,\n  children: [\n    check(\n      asField(runsField, 'run_ends'),\n      (field) => field.type.typeId === Type.Int,\n      () => 'Run-ends must have an integer type.'\n    ),\n    asField(valuesField, 'values')\n  ]\n});\n\n/**\n * Return a BinaryView data type instance. BinaryView data is logically the\n * same as the Binary type, but the internal representation uses a view struct\n * that contains the string length and either the string's entire data inline\n * (for small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode BinaryView data; however, Flechette does\n * not currently support building BinaryView columns from JavaScript values.\n * @returns {BinaryViewType} The binary view data type.\n */\nexport const binaryView = () => /** @type {BinaryViewType} */\n  (basicType(Type.BinaryView));\n\n/**\n * Return a Utf8View data type instance. Utf8View data is logically the same as\n * the Utf8 type, but the internal representation uses a view struct that\n * contains the string length and either the string's entire data inline (for\n * small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode Utf8View data; however, Flechette does\n * not currently support building Utf8View columns from JavaScript values.\n * @returns {Utf8ViewType} The utf8 view data type.\n */\nexport const utf8View = () => /** @type {Utf8ViewType} */\n  (basicType(Type.Utf8View));\n\n/**\n * Return a ListView data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. ListView data represents the same logical\n * types that List can, but contains both offsets and sizes allowing for\n * writes in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode ListView data; however, Flechette does not\n * currently support building ListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {ListViewType} The list view data type.\n */\nexport const listView = (child) => ({\n  typeId: Type.ListView,\n  children: [ asField(child, 'value') ],\n  offsets: int32Array\n});\n\n/**\n * Return a LargeListView data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. LargeListView data represents the same logical types that\n * LargeList can, but contains both offsets and sizes allowing for writes\n * in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode LargeListView data; however, Flechette does\n * not currently support building LargeListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {LargeListViewType} The large list view data type.\n */\nexport const largeListView = (child) => ({\n  typeId: Type.LargeListView,\n  children: [ asField(child, 'value') ],\n  offsets: int64Array\n});\n","/**\n * @import { TimeUnit_, TypedArray } from '../types.js';\n */\nimport { float64Array, int32Array, int64Array, isInt64ArrayType, uint32Array, uint8Array } from './arrays.js';\nimport { TimeUnit } from '../constants.js';\n\n// typed arrays over a shared buffer to aid binary conversion\nconst f64 = new float64Array(2);\nconst buf = f64.buffer;\nconst i64 = new int64Array(buf);\nconst u32 = new uint32Array(buf);\nconst i32 = new int32Array(buf);\nconst u8 = new uint8Array(buf);\n\n/**\n * Return a value unchanged.\n * @template T\n * @param {T} value The value.\n * @returns {T} The value.\n */\nexport function identity(value) {\n  return value;\n}\n\n/**\n * Return a value coerced to a BigInt.\n * @param {*} value The value.\n * @returns {bigint} The BigInt value.\n */\nexport function toBigInt(value) {\n  return BigInt(value);\n}\n\n/**\n * Return an offset conversion method for the given data type.\n * @param {{ offsets: TypedArray}} type The array type.\n */\nexport function toOffset(type) {\n  return isInt64ArrayType(type) ? toBigInt : identity;\n}\n\n/**\n * Return the number of days from a millisecond timestamp.\n * @param {number} value The millisecond timestamp.\n * @returns {number} The number of days.\n */\nexport function toDateDay(value) {\n  return (value / 864e5) | 0;\n}\n\n/**\n * Return a timestamp conversion method for the given time unit.\n * @param {TimeUnit_} unit The time unit.\n * @returns {(value: number) => bigint} The conversion method.\n */\nexport function toTimestamp(unit) {\n  return unit === TimeUnit.SECOND ? value => toBigInt(value / 1e3)\n    : unit === TimeUnit.MILLISECOND ? toBigInt\n    : unit === TimeUnit.MICROSECOND ? value => toBigInt(value * 1e3)\n    : value => toBigInt(value * 1e6);\n}\n\n/**\n * Write month/day/nanosecond interval to a byte buffer.\n * @param {Array | Float64Array} interval The interval data.\n * @returns {Uint8Array} A byte buffer with the interval data.\n *  The returned buffer is reused across calls, and so should be\n *  copied to a target buffer immediately.\n */\nexport function toMonthDayNanoBytes([m, d, n]) {\n  i32[0] = m;\n  i32[1] = d;\n  i64[1] = toBigInt(n);\n  return u8;\n}\n\n/**\n * Coerce a bigint value to a number. Throws an error if the bigint value\n * lies outside the range of what a number can precisely represent.\n * @param {bigint} value The value to check and possibly convert.\n * @returns {number} The converted number value.\n */\nexport function toNumber(value) {\n  if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n    throw Error(`BigInt exceeds integer number representation: ${value}`);\n  }\n  return Number(value);\n}\n\n/**\n * Divide one BigInt value by another, and return the result as a number.\n * The division may involve unsafe integers and a loss of precision.\n * @param {bigint} num The numerator.\n * @param {bigint} div The divisor.\n * @returns {number} The result of the division as a floating point number.\n */\nexport function divide(num, div) {\n  return Number(num / div) + Number(num % div) / Number(div);\n}\n\n/**\n * Return a 32-bit decimal conversion method for the given decimal scale.\n * @param {number} scale The scale mapping fractional digits to integers.\n * @returns {(value: number|bigint) => number} A conversion method that maps\n *  floating point numbers to 32-bit decimals.\n */\nexport function toDecimal32(scale) {\n  return (value) => typeof value === 'bigint'\n    ? Number(value)\n    : Math.trunc(value * scale);\n}\n\n/**\n * Convert a floating point number or bigint to decimal bytes.\n * @param {number|bigint} value The number to encode. If a bigint, we assume\n *  it already represents the decimal in integer form with the correct scale.\n *  Otherwise, we assume a float that requires scaled integer conversion.\n * @param {BigUint64Array} buf The uint64 array to write to.\n * @param {number} offset The starting index offset into the array.\n * @param {number} stride The stride of an encoded decimal, in 64-bit steps.\n * @param {number} scale The scale mapping fractional digits to integers.\n */\nexport function toDecimal(value, buf, offset, stride, scale) {\n  const v = typeof value === 'bigint'\n    ? value\n    : toBigInt(Math.trunc(value * scale));\n  // assignment into uint64array performs needed truncation for us\n  buf[offset] = v;\n  if (stride > 1) {\n    buf[offset + 1] = (v >> 64n);\n    if (stride > 2) {\n      buf[offset + 2] = (v >> 128n);\n      buf[offset + 3] = (v >> 192n);\n    }\n  }\n}\n\n// helper method to extract uint64 values from bigints\nconst asUint64 = v => BigInt.asUintN(64, v);\n\n/**\n * Convert a 64-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal64(buf, offset) {\n  return BigInt.asIntN(64, buf[offset]);\n}\n\n/**\n * Convert a 128-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal128(buf, offset) {\n  const i = offset << 1;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 1]) < 0) {\n    x = asUint64(~buf[i]) | (asUint64(~buf[i + 1]) << 64n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i] | (buf[i + 1] << 64n);\n  }\n  return x;\n}\n\n/**\n * Convert a 256-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal256(buf, offset) {\n  const i = offset << 2;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 3]) < 0) {\n    x = asUint64(~buf[i])\n      | (asUint64(~buf[i + 1]) << 64n)\n      | (asUint64(~buf[i + 2]) << 128n)\n      | (asUint64(~buf[i + 3]) << 192n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i]\n      | (buf[i + 1] << 64n)\n      | (buf[i + 2] << 128n)\n      | (buf[i + 3] << 192n);\n  }\n  return x;\n}\n\n/**\n * Convert a 16-bit float from integer bytes to a number.\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The float as a 16-bit integer.\n * @returns {number} The converted 64-bit floating point number.\n */\nexport function fromFloat16(value) {\n  const expo = (value & 0x7C00) >> 10;\n  const sigf = (value & 0x03FF) / 1024;\n  const sign = (-1) ** ((value & 0x8000) >> 15);\n  switch (expo) {\n    case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n    case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n  }\n  return sign * (2 ** (expo - 15)) * (1 + sigf);\n}\n\n/**\n * Convert a number to a 16-bit float as integer bytes..\n * Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The 64-bit floating point number to convert.\n * @returns {number} The converted 16-bit integer.\n */\nexport function toFloat16(value) {\n  if (value !== value) return 0x7E00; // NaN\n  f64[0] = value;\n\n  // Magic numbers:\n  // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n  // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n  // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n  const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n  let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;\n\n  if (expo >= 0x40F00000) {\n    //\n    // If exponent overflowed, the float16 is either NaN or Infinity.\n    // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n    //\n    // Magic numbers:\n    // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n    // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n    //\n    // returns:\n    // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n    // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n    // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n    // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n    //\n    // If mantissa is greater than 23 bits, set to +Infinity like numpy\n    if (u32[0] > 0) {\n      expo = 0x7C00;\n    } else {\n      expo = (expo & 0x7C000000) >> 16;\n      sigf = (u32[1] & 0x000FFFFF) >> 10;\n    }\n  } else if (expo <= 0x3F000000) {\n    //\n    // If exponent underflowed, the float is either signed zero or subnormal.\n    //\n    // Magic numbers:\n    // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n    //\n    sigf = 0x100000 + (u32[1] & 0x000FFFFF);\n    sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;\n    expo = 0;\n  } else {\n    //\n    // No overflow or underflow, rebase the exponent and round the mantissa\n    // Magic numbers:\n    // 0x200 = 00000010 00000000 -- masks off the 10th bit\n    //\n    // Ensure the first mantissa bit (the 10th one) is 1 and round\n    expo = (expo - 0x3F000000) >> 10;\n    sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;\n  }\n  return sign | expo | sigf & 0xFFFF;\n}\n","import { isArray } from './arrays.js';\nimport { isDate } from './objects.js';\n\nconst textDecoder = new TextDecoder('utf-8');\nconst textEncoder = new TextEncoder();\n\n/**\n * Return a UTF-8 string decoded from a byte buffer.\n * @param {Uint8Array} buf The byte buffer.\n * @returns {string} The decoded string.\n */\nexport function decodeUtf8(buf) {\n  return textDecoder.decode(buf);\n}\n\n/**\n * Return a byte buffer encoded from a UTF-8 string.\n * @param {string } str The string to encode.\n * @returns {Uint8Array} The encoded byte buffer.\n */\nexport function encodeUtf8(str) {\n  return textEncoder.encode(str);\n}\n\n/**\n * Return a string-coercible key value that uniquely identifies a value.\n * @param {*} value The input value.\n * @returns {string} The key string.\n */\nexport function keyString(value) {\n  const val = typeof value !== 'object' || !value ? (value ?? null)\n    : isDate(value) ? +value\n    // @ts-ignore\n    : isArray(value) ? `[${value.map(keyString)}]`\n    : objectKey(value);\n  return `${val}`;\n}\n\nfunction objectKey(value) {\n  let s = '';\n  let i = -1;\n  for (const k in value) {\n    if (++i > 0) s += ',';\n    s += `\"${k}\":${keyString(value[k])}`;\n  }\n  return `{${s}}`;\n}\n","import { toNumber } from './numbers.js';\nimport { decodeUtf8 } from './strings.js';\n\n/** The size in bytes of a 32-bit integer. */\nexport const SIZEOF_INT = 4;\n\n/** The size in bytes of a 16-bit integer. */\nexport const SIZEOF_SHORT = 2;\n\n/**\n * Return a boolean for a single bit in a bitmap.\n * @param {Uint8Array} bitmap The bitmap.\n * @param {number} index The bit index to read.\n * @returns {boolean} The boolean bitmap value.\n */\nexport function decodeBit(bitmap, index) {\n  return (bitmap[index >> 3] & 1 << (index % 8)) !== 0;\n}\n\n/**\n * Lookup helper for flatbuffer object (table) entries.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The base index of the object.\n */\nexport function readObject(buf, index) {\n  const pos = index + readInt32(buf, index);\n  const vtable = pos - readInt32(buf, pos);\n  const size = readInt16(buf, vtable);\n  /**\n   * Retrieve a value from a flatbuffer table layout.\n   * @template T\n   * @param {number} index The table entry index.\n   * @param {(buf: Uint8Array, offset: number) => T} read Read function to invoke.\n   * @param {T} [fallback=null] The default fallback value.\n   * @returns {T}\n   */\n  return (index, read, fallback = null) => {\n    if (index < size) {\n      const off = readInt16(buf, vtable + index);\n      if (off) return read(buf, pos + off);\n    }\n    return fallback;\n  };\n}\n\n/**\n * Return a buffer offset value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readOffset(buf, offset) {\n  return offset;\n}\n\n/**\n * Return a boolean value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {boolean}\n */\nexport function readBoolean(buf, offset) {\n  return !!readInt8(buf, offset);\n}\n\n/**\n * Return a signed 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt8(buf, offset) {\n  return readUint8(buf, offset) << 24 >> 24;\n}\n\n/**\n * Return an unsigned 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint8(buf, offset) {\n  return buf[offset];\n}\n\n/**\n * Return a signed 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt16(buf, offset) {\n  return readUint16(buf, offset) << 16 >> 16;\n}\n\n/**\n * Return an unsigned 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint16(buf, offset) {\n  return buf[offset] | buf[offset + 1] << 8;\n}\n\n/**\n * Return a signed 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt32(buf, offset) {\n  return buf[offset]\n    | buf[offset + 1] << 8\n    | buf[offset + 2] << 16\n    | buf[offset + 3] << 24;\n}\n\n/**\n * Return an unsigned 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint32(buf, offset) {\n  return readInt32(buf, offset) >>> 0;\n}\n\n/**\n * Return a signed 64-bit integer value coerced to a JS number.\n * Throws an error if the value exceeds what a JS number can represent.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt64(buf, offset) {\n  return toNumber(BigInt.asIntN(\n    64,\n    BigInt(readUint32(buf, offset)) +\n      (BigInt(readUint32(buf, offset + SIZEOF_INT)) << 32n)\n  ));\n}\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The index of the string entry.\n * @returns {string} The decoded string.\n */\nexport function readString(buf, index) {\n  let offset = index + readInt32(buf, index); // get the string offset\n  const length = readInt32(buf, offset);  // get the string length\n  offset += SIZEOF_INT; // skip length value\n  return decodeUtf8(buf.subarray(offset, offset + length));\n}\n\n/**\n * Extract a flatbuffer vector to an array.\n * @template T\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} offset The offset location of the vector.\n * @param {number} stride The stride between vector entries.\n * @param {(buf: Uint8Array, pos: number) => T} extract Vector entry extraction function.\n * @returns {T[]} The extracted vector entries.\n */\nexport function readVector(buf, offset, stride, extract) {\n  if (!offset) return [];\n\n  // get base position by adding offset delta\n  const base = offset + readInt32(buf, offset);\n\n  // read vector size, extract entries\n  return Array.from(\n    { length: readInt32(buf, base) },\n    (_, i) => extract(buf, base + SIZEOF_INT + i * stride)\n  );\n}\n","/**\n * @import { Batch } from '../batch.js';\n */\n\n/**\n * Symbol for the row index value of a struct object proxy.\n */\nexport const RowIndex = Symbol('rowIndex');\n\n/**\n * Returns a row proxy object factory. The resulting method takes a\n * batch-level row index as input and returns an object that proxies\n * access to underlying batches.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function proxyFactory(names, batches) {\n  class RowObject {\n    /**\n     * Create a new proxy row object representing a struct or table row.\n     * @param {number} index The record batch row index.\n     */\n    constructor(index) {\n      this[RowIndex] = index;\n    }\n\n    /**\n     * Return a JSON-compatible object representation.\n     */\n    toJSON() {\n      return structObject(names, batches, this[RowIndex]);\n    }\n  };\n\n  // prototype for row proxy objects\n  const proto = RowObject.prototype;\n\n  for (let i = 0; i < names.length; ++i) {\n    // skip duplicated column names\n    if (Object.hasOwn(proto, names[i])) continue;\n\n    // add a getter method for the current batch\n    const batch = batches[i];\n    Object.defineProperty(proto, names[i], {\n      get() { return batch.at(this[RowIndex]); },\n      enumerable: true\n    });\n  }\n\n  return index => new RowObject(index);\n}\n\n/**\n * Returns a row object factory. The resulting method takes a\n * batch-level row index as input and returns an object whose property\n * values have been extracted from the batches.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function objectFactory(names, batches) {\n  return index => structObject(names, batches, index);\n}\n\n/**\n * Return a vanilla object representing a struct (row object) type.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @param {number} index The record batch row index.\n * @returns {Record<string, any>}\n */\nexport function structObject(names, batches, index) {\n  const obj = {};\n  for (let i = 0; i < names.length; ++i) {\n    obj[names[i]] = batches[i].at(index);\n  }\n  return obj;\n}\n","/**\n * @import { Column } from './column.js'\n * @import { DataType, DecimalType, IntegerArray, OffsetArray, TypedArray, TypedArrayConstructor, ValueArray } from './types.js'\n */\nimport { bisect, float64Array } from './util/arrays.js';\nimport { divide, fromDecimal128, fromDecimal256, fromDecimal64, toNumber } from './util/numbers.js';\nimport { decodeBit, readInt32, readInt64 } from './util/read.js';\nimport { decodeUtf8 } from './util/strings.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * Check if the input is a batch that supports direct access to\n * binary data in the form of typed arrays.\n * @param {Batch<any>?} batch The data batch to check.\n * @returns {boolean} True if a direct batch, false otherwise.\n */\nexport function isDirectBatch(batch) {\n  return batch instanceof DirectBatch;\n}\n\n/**\n * Column values from a single record batch.\n * A column may contain multiple batches.\n * @template T\n */\nexport class Batch {\n  /**\n   * The array type to use when extracting data from the batch.\n   * A null value indicates that the array type should match\n   * the type of the batch's values array.\n   * @type {ArrayConstructor | TypedArrayConstructor | null}\n   */\n  static ArrayType = null;\n\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {TypedArray} [options.values] Values buffer\n   * @param {OffsetArray} [options.offsets] Offsets buffer\n   * @param {OffsetArray} [options.sizes] Sizes buffer\n   * @param {Batch[]} [options.children] Children batches\n   */\n  constructor({\n    length,\n    nullCount,\n    type,\n    validity,\n    values,\n    offsets,\n    sizes,\n    children\n  }) {\n    this.length = length;\n    this.nullCount = nullCount;\n    this.type = type;\n    this.validity = validity;\n    this.values = values;\n    this.offsets = offsets;\n    this.sizes = sizes;\n    this.children = children;\n\n    // optimize access if this batch has no null values\n    // some types (like union) may have null values in\n    // child batches, but no top-level validity buffer\n    if (!nullCount || !this.validity) {\n      /** @type {(index: number) => T | null} */\n      this.at = index => this.value(index);\n    }\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Batch';\n  }\n\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    return this.isValid(index) ? this.value(index) : null;\n  }\n\n  /**\n   * Check if a value at the given index is valid (non-null).\n   * @param {number} index The value index.\n   * @returns {boolean} True if valid, false otherwise.\n   */\n  isValid(index) {\n    return decodeBit(this.validity, index);\n  }\n\n  /**\n   * Return the value at the given index. This method does not check the\n   * validity bitmap and is intended primarily for internal use. In most\n   * cases, callers should use the `at()` method instead.\n   * @param {number} index The value index\n   * @returns {T} The value, ignoring the validity bitmap.\n   */\n  value(index) {\n    return /** @type {T} */ (this.values[index]);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    const n = end - start;\n    const values = Array(n);\n    for (let i = 0; i < n; ++i) {\n      values[i] = this.at(start + i);\n    }\n    return values;\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; ++i) {\n      yield this.at(i);\n    }\n  }\n}\n\n/**\n * A batch whose value buffer can be used directly, without transformation.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DirectBatch extends Batch {\n  /**\n   * Create a new column batch with direct value array access.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {TypedArray} options.values Values buffer\n   */\n  constructor(options) {\n    super(options);\n    // underlying buffers may be padded, exceeding the logical batch length\n    // we trim the values array so we can safely access it directly\n    const { length, values } = this;\n    this.values = values.subarray(0, length);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * When feasible, a zero-copy subarray of a typed array is returned.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    // @ts-ignore\n    return this.nullCount\n      ? super.slice(start, end)\n      : this.values.subarray(start, end);\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    return this.nullCount\n      ? super[Symbol.iterator]()\n      : /** @type {Iterator<T?>} */ (this.values[Symbol.iterator]());\n  }\n}\n\n/**\n * A batch whose values are transformed to 64-bit numbers.\n * @extends {Batch<number>}\n */\nexport class NumberBatch extends Batch {\n  static ArrayType = float64Array;\n}\n\n/**\n * A batch whose values should be returned in a standard array.\n * @template T\n * @extends {Batch<T>}\n */\nexport class ArrayBatch extends Batch {\n  static ArrayType = Array;\n}\n\n/**\n * A batch of null values only.\n * @extends {ArrayBatch<null>}\n */\nexport class NullBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {null}\n   */\n  value(index) { // eslint-disable-line no-unused-vars\n    return null;\n  }\n}\n\n/**\n * A batch that coerces BigInt values to 64-bit numbers.\n * @extends {NumberBatch}\n */\nexport class Int64Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return toNumber(/** @type {bigint} */ (this.values[index]));\n  }\n}\n\n/**\n * A batch of 16-bit floating point numbers, accessed as unsigned\n * 16-bit ints and transformed to 64-bit numbers.\n */\nexport class Float16Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const v = /** @type {number} */ (this.values[index]);\n    const expo = (v & 0x7C00) >> 10;\n    const sigf = (v & 0x03FF) / 1024;\n    const sign = (-1) ** ((v & 0x8000) >> 15);\n    switch (expo) {\n      case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n      case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n    }\n    return sign * (2 ** (expo - 15)) * (1 + sigf);\n  }\n}\n\n/**\n * A batch of boolean values stored as a bitmap.\n * @extends {ArrayBatch<boolean>}\n */\nexport class BoolBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return decodeBit(/** @type {Uint8Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of 32-bit decimal numbers, returned as converted 64-bit floating\n * point numbers. Number coercion may be lossy if the decimal precision can\n * not be represented in a 64-bit floating point format.\n * @extends {NumberBatch}\n */\nexport class Decimal32NumberBatch extends NumberBatch {\n  constructor(options) {\n    super(options);\n    const { scale } = /** @type {DecimalType} */ (this.type);\n    this.scale = 10 ** scale;\n  }\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return /** @type {number} */(this.values[index]) / this.scale;\n  }\n}\n\n/**\n * An abstract class for a batch of 64-, 128- or 256-bit decimal numbers,\n * accessed in strided BigUint64Arrays.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DecimalBatch extends Batch {\n  constructor(options) {\n    super(options);\n    const { bitWidth, scale } = /** @type {DecimalType} */ (this.type);\n    this.decimal = bitWidth === 64 ? fromDecimal64\n      : bitWidth === 128 ? fromDecimal128\n      : fromDecimal256;\n    this.scale = 10n ** BigInt(scale);\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as converted\n * 64-bit floating point numbers. Number coercion may be lossy if the decimal\n * precision can not be represented in a 64-bit floating point format.\n * @extends {DecimalBatch<number>}\n */\nexport class DecimalNumberBatch extends DecimalBatch {\n  static ArrayType = float64Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return divide(\n      this.decimal(/** @type {BigUint64Array} */ (this.values), index),\n      this.scale\n    );\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as scaled\n * bigint values, such that all fractional digits have been shifted\n * to integer places by the decimal type scale factor.\n * @extends {DecimalBatch<bigint>}\n */\nexport class DecimalBigIntBatch extends DecimalBatch {\n  static ArrayType = Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return this.decimal(/** @type {BigUint64Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of date or timestamp values that are coerced to UNIX epoch timestamps\n * and returned as JS Date objects. This batch wraps a source batch that provides\n * timestamp values.\n * @extends {ArrayBatch<Date>}\n */\nexport class DateBatch extends ArrayBatch {\n  /**\n   * Create a new date batch.\n   * @param {Batch<number>} batch A batch of timestamp values.\n   */\n  constructor(batch) {\n    super(batch);\n    this.source = batch;\n  }\n\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return new Date(this.source.value(index));\n  }\n}\n\n/**\n * A batch of dates as day counts, coerced to timestamp numbers.\n */\nexport class DateDayBatch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {number}\n   */\n  value(index) {\n    // epoch days to milliseconds\n    return 86400000 * /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * A batch of dates as millisecond timestamps, coerced to numbers.\n */\nexport const DateDayMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in seconds, coerced to millisecond numbers.\n */\nexport class TimestampSecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return super.value(index) * 1e3; // seconds to milliseconds\n  }\n}\n\n/**\n * A batch of timestaps in milliseconds, coerced to numbers.\n */\nexport const TimestampMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in microseconds, coerced to millisecond numbers.\n */\nexport class TimestampMicrosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // microseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000n);\n  }\n}\n\n/**\n * A batch of timestaps in nanoseconds, coerced to millisecond numbers.\n */\nexport class TimestampNanosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // nanoseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000000n);\n  }\n}\n\n/**\n * A batch of day/time intervals, returned as two-element 32-bit int arrays.\n * @extends {ArrayBatch<Int32Array>}\n */\nexport class IntervalDayTimeBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {Int32Array}\n   */\n  value(index) {\n    const values = /** @type {Int32Array} */ (this.values);\n    return values.subarray(index << 1, (index + 1) << 1);\n  }\n}\n\n/**\n * A batch of month/day/nanosecond intervals, returned as three-element arrays.\n * @extends {ArrayBatch<Float64Array>}\n */\nexport class IntervalMonthDayNanoBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const values = /** @type {Uint8Array} */ (this.values);\n    const base = index << 4;\n    return Float64Array.of(\n      readInt32(values, base),\n      readInt32(values, base + 4),\n      readInt64(values, base + 8)\n    );\n  }\n}\n\nconst offset32 = ({values, offsets}, index) => values.subarray(offsets[index], offsets[index + 1]);\nconst offset64 = ({values, offsets}, index) => values.subarray(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 32-bit ints.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class BinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset32(this, index);\n  }\n}\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 64-bit ints. Value extraction will\n * fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class LargeBinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset64(this, index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 32-bit ints.\n * @extends {ArrayBatch<string>}\n */\nexport class Utf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset32(this, index));\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 64-bit ints.\n * Value extraction will fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<string>}\n */\nexport class LargeUtf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset64(this, index));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 32-bit ints.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class ListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {Int32Array} */ (this.offsets);\n    return this.children[0].slice(offsets[index], offsets[index + 1]);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 64-bit ints. Value extraction will fail if an offset exceeds\n * `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class LargeListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {BigInt64Array} */ (this.offsets);\n    return this.children[0].slice(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 32-bit ints.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class ListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {number} */ (this.offsets[index]);\n    const b = a + /** @type {number} */ (this.sizes[index]);\n    return this.children[0].slice(a, b);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 64-bit ints. Value extraction will fail if an offset or size\n * exceeds `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class LargeListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {bigint} */ (this.offsets[index]);\n    const b = a + /** @type {bigint} */ (this.sizes[index]);\n    return this.children[0].slice(toNumber(a), toNumber(b));\n  }\n}\n\n/**\n * A batch with a fixed stride.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass FixedBatch extends ArrayBatch {\n  constructor(options) {\n    super(options);\n    /** @type {number} */\n    // @ts-ignore\n    this.stride = this.type.stride;\n  }\n}\n\n/**\n * A batch of binary blobs of fixed size, returned as byte buffers of unsigned\n * 8-bit integers.\n * @extends {FixedBatch<Uint8Array>}\n */\nexport class FixedBinaryBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    const { stride, values } = this;\n    return /** @type {Uint8Array} */ (values)\n      .subarray(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * A batch of list (array) values of fixed length.\n * @template V\n * @extends {FixedBatch<ValueArray<V>>}\n */\nexport class FixedListBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const { children, stride } = this;\n    return children[0].slice(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * Extract Map key-value pairs from parallel child batches.\n */\nfunction pairs({ children, offsets }, index) {\n  const [ keys, vals ] = children[0].children;\n  const start = offsets[index];\n  const end = offsets[index + 1];\n  const entries = [];\n  for (let i = start; i < end; ++i) {\n    entries.push([keys.at(i), vals.at(i)]);\n  }\n  return entries;\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<[K, V][]>}\n */\nexport class MapEntryBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {[K, V][]} The map entries as an array of [key, value] arrays.\n   */\n  value(index) {\n    return /** @type {[K, V][]} */ (pairs(this, index));\n  }\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<Map<K, V>>}\n */\nexport class MapBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {Map<K, V>} The map value.\n   */\n  value(index) {\n    return new Map(/** @type {[K, V][]} */ (pairs(this, index)));\n  }\n}\n\n/**\n * A batch of union-type values with a sparse layout, enabling direct\n * lookup from the child value batches.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class SparseUnionBatch extends ArrayBatch {\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Int32Array} [options.offsets] Offsets buffer\n   * @param {Batch[]} options.children Children batches\n   * @param {Int8Array} options.typeIds Union type ids buffer\n   * @param {Record<string, number>} options.map A typeId to children index map\n   */\n  constructor({ typeIds, ...options }) {\n    super(options);\n    /** @type {Int8Array} */\n    this.typeIds = typeIds;\n    /** @type {Record<string, number>} */\n    // @ts-ignore\n    this.typeMap = this.type.typeMap;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index, offset = index) {\n    const { typeIds, children, typeMap } = this;\n    return children[typeMap[typeIds[index]]].at(offset);\n  }\n}\n\n/**\n * A batch of union-type values with a dense layout, reqiring offset\n * lookups from the child value batches.\n * @template T\n * @extends {SparseUnionBatch<T>}\n */\nexport class DenseUnionBatch extends SparseUnionBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return super.value(index, /** @type {number} */ (this.offsets[index]));\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Struct property values are extracted and returned as JS objects.\n * @extends {ArrayBatch<Record<string, any>>}\n */\nexport class StructBatch extends ArrayBatch {\n  constructor(options, factory = objectFactory) {\n    super(options);\n    /** @type {string[]} */\n    // @ts-ignore\n    this.names = this.type.children.map(child => child.name);\n    this.factory = factory(this.names, this.children);\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {Record<string, any>}\n   */\n  value(index) {\n    return this.factory(index);\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Structs are returned as proxy objects that extract data directly\n * from underlying Arrow batches.\n * @extends {StructBatch}\n */\nexport class StructProxyBatch extends StructBatch {\n  constructor(options) {\n    super(options, proxyFactory);\n  }\n}\n\n/**\n * A batch of run-end-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class RunEndEncodedBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    const [ { values: runs }, vals ] = this.children;\n    return vals.at(\n      bisect(/** @type {IntegerArray} */(runs), index)\n    );\n  }\n}\n\n/**\n * A batch of dictionary-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class DictionaryBatch extends ArrayBatch {\n  /**\n   * Register the backing dictionary. Dictionaries are added\n   * after batch creation as the complete dictionary may not\n   * be finished across multiple record batches.\n   * @param {Column<T>} dictionary\n   * The dictionary of column values.\n   */\n  setDictionary(dictionary) {\n    this.dictionary = dictionary;\n    this.cache = dictionary.cache();\n    return this;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.cache[this.key(index)];\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {number} The dictionary key\n   */\n  key(index) {\n    return /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass ViewBatch extends ArrayBatch {\n  /**\n   * Create a new view batch.\n   * @param {object} options Batch options.\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Uint8Array} options.values Values buffer\n   * @param {Uint8Array[]} options.data View data buffers\n   */\n  constructor({ data, ...options }) {\n    super(options);\n    this.data = data;\n  }\n\n  /**\n   * Get the binary data at the provided index.\n   * @param {number} index The value index.\n   * @returns {Uint8Array}\n   */\n  view(index) {\n    const { values, data } = this;\n    const offset = index << 4; // each entry is 16 bytes\n    let start = offset + 4;\n    let buf = /** @type {Uint8Array} */ (values);\n    const length = readInt32(buf, offset);\n    if (length > 12) {\n      // longer strings are in a data buffer\n      start = readInt32(buf, offset + 12);\n      buf = data[readInt32(buf, offset + 8)];\n    }\n    return buf.subarray(start, start + length);\n  }\n}\n\n/**\n * A batch of binary blobs from variable data buffers, returned as byte\n * buffers of unsigned 8-bit integers.\n * @extends {ViewBatch<Uint8Array>}\n */\nexport class BinaryViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.view(index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings from variable data buffers.\n * @extends {ViewBatch<string>}\n */\nexport class Utf8ViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return decodeUtf8(this.view(index));\n  }\n}\n","/**\n * @import { Batch } from './batch.js'\n * @import { DataType, ValueArray } from './types.js'\n */\nimport { bisect } from './util/arrays.js';\nimport { isDirectBatch } from './batch.js';\n\n/**\n * Build up a column from batches.\n */\nexport function columnBuilder(type) {\n  let data = [];\n  return {\n    add(batch) { data.push(batch); return this; },\n    clear: () => data = [],\n    done: () => new Column(data, type)\n  };\n}\n\n/**\n * A data column. A column provides a view over one or more value batches,\n * each drawn from an Arrow record batch. This class supports random access\n * to column values by integer index; however, extracting arrays using\n * `toArray()` or iterating over values (`for (const value of column) {...}`)\n * provide more efficient ways for bulk access or scanning.\n * @template T\n */\nexport class Column {\n  /**\n   * Create a new column instance.\n   * @param {Batch<T>[]} data The value batches.\n   * @param {DataType} [type] The column data type.\n   *  If not specified, the type is extracted from the batches.\n   */\n  constructor(data, type = data[0]?.type) {\n    /**\n     * The column data type.\n     * @type {DataType}\n     * @readonly\n     */\n    this.type = type;\n    /**\n     * The column length.\n     * @type {number}\n     * @readonly\n     */\n    this.length = data.reduce((m, c) => m + c.length, 0);\n    /**\n     * The count of null values in the column.\n     * @type {number}\n     * @readonly\n     */\n    this.nullCount = data.reduce((m, c) => m + c.nullCount, 0);\n    /**\n     * An array of column data batches.\n     * @type {readonly Batch<T>[]}\n     * @readonly\n     */\n    this.data = data;\n\n    const n = data.length;\n    const offsets = new Int32Array(n + 1);\n    if (n === 1) {\n      const [ batch ] = data;\n      offsets[1] = batch.length;\n      // optimize access to single batch\n      this.at = index => batch.at(index);\n    } else {\n      for (let i = 0, s = 0; i < n; ++i) {\n        offsets[i + 1] = (s += data[i].length);\n      }\n    }\n\n    /**\n     * Index offsets for data batches.\n     * Used to map a column row index to a batch-specific index.\n     * @type {Int32Array}\n     * @readonly\n     */\n    this.offsets = offsets;\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Column';\n  }\n\n  /**\n   * Return an iterator over the values in this column.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    const data = this.data;\n    return data.length === 1\n      ? data[0][Symbol.iterator]()\n      : batchedIterator(data);\n  }\n\n  /**\n   * Return the column value at the given index. If a column has multiple\n   * batches, this method performs binary search over the batch lengths to\n   * determine the batch from which to retrieve the value. The search makes\n   * lookup less efficient than a standard array access. If making a full\n   * scan of a column, consider extracting arrays via `toArray()` or using an\n   * iterator (`for (const value of column) {...}`).\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    // NOTE: if there is only one batch, this method is replaced with an\n    // optimized version in the Column constructor.\n    const { data, offsets } = this;\n    const i = bisect(offsets, index) - 1;\n    return data[i]?.at(index - offsets[i]); // undefined if out of range\n  }\n\n  /**\n   * Return the column value at the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  get(index) {\n    return this.at(index);\n  }\n\n  /**\n   * Extract column values into a single array instance. When possible,\n   * a zero-copy subarray of the input Arrow data is returned.\n   * @returns {ValueArray<T?>}\n   */\n  toArray() {\n    const { length, nullCount, data } = this;\n    const copy = !nullCount && isDirectBatch(data[0]);\n    const n = data.length;\n\n    if (copy && n === 1) {\n      // use batch array directly\n      // @ts-ignore\n      return data[0].values;\n    }\n\n    // determine output array type\n    const ArrayType = !n || nullCount > 0 ? Array\n      // @ts-ignore\n      : (data[0].constructor.ArrayType ?? data[0].values.constructor);\n\n    const array = new ArrayType(length);\n    return copy ? copyArray(array, data) : extractArray(array, data);\n  }\n\n  /**\n   * Return an array of cached column values.\n   * Used internally to accelerate dictionary types.\n   */\n  cache() {\n    return this._cache ?? (this._cache = this.toArray());\n  }\n}\n\nfunction *batchedIterator(data) {\n  for (let i = 0; i < data.length; ++i) {\n    const iter = data[i][Symbol.iterator]();\n    for (let next = iter.next(); !next.done; next = iter.next()) {\n      yield next.value;\n    }\n  }\n}\n\nfunction copyArray(array, data) {\n  for (let i = 0, offset = 0; i < data.length; ++i) {\n    const { values } = data[i];\n    array.set(values, offset);\n    offset += values.length;\n  }\n  return array;\n}\n\nfunction extractArray(array, data) {\n  let index = -1;\n  for (let i = 0; i < data.length; ++i) {\n    const batch = data[i];\n    for (let j = 0; j < batch.length; ++j) {\n      array[++index] = batch.at(j);\n    }\n  }\n  return array;\n}\n","/**\n * @import { Column } from './column.js'\n * @import { Schema, StructFactory, TypeMap, ValueArray } from './types.js'\n */\nimport { bisect } from './util/arrays.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * A table consists of a collection of named columns (or 'children').\n * To work with table data directly in JavaScript, use `toColumns()`\n * to extract an object that maps column names to extracted value arrays,\n * or `toArray()` to extract an array of row objects. For random access\n * by row index, use `getChild()` to access data for a specific column.\n * @template {TypeMap} [T=TypeMap]\n */\nexport class Table {\n  /**\n   * Create a new table with the given schema and columns (children).\n   * @param {Schema} schema The table schema.\n   * @param {Column[]} children The table columns.\n   * @param {boolean} [useProxy=false] Flag indicating if row proxy\n   *  objects should be used to represent table rows (default `false`).\n   */\n  constructor(schema, children, useProxy = false) {\n    const names = schema.fields.map(f => f.name);\n\n    /**\n     * @type {Schema}\n     * @readonly\n     */\n    this.schema = schema;\n    /**\n     * @type {(keyof T)[]}\n     * @readonly\n     */\n    this.names = names;\n    /**\n     * @type {Column[]}\n     * @readonly\n     */\n    this.children = children;\n    /**\n     * @type {StructFactory}\n     * @readonly\n     */\n    this.factory = useProxy ? proxyFactory : objectFactory;\n\n    // lazily created row object generators\n    const gen = [];\n\n    /**\n     * Returns a row object generator for the given batch index.\n     * @private\n     * @readonly\n     * @param {number} b The batch index.\n     * @returns {(index: number) => { [P in keyof T]: T[P] }}\n     */\n    this.getFactory = b => gen[b]\n      ?? (gen[b] = this.factory(names, children.map(c => c.data[b])));\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Table';\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  get numCols() {\n    return this.names.length;\n  }\n\n  /**\n   * The number of rows in this table.\n   * @return {number} The number of rows.\n   */\n  get numRows() {\n    return this.children[0]?.length ?? 0;\n  }\n\n  /**\n   * Return the child column at the given index position.\n   * @template {T[keyof T]} R\n   * @param {number} index The column index.\n   * @returns {Column<R>}\n   */\n  getChildAt(index) {\n    return this.children[index];\n  }\n\n  /**\n   * Return the first child column with the given name.\n   * @template {keyof T} P\n   * @param {P} name The column name.\n   * @returns {Column<T[P]>}\n   */\n  getChild(name) {\n    const i = this.names.findIndex(x => x === name);\n    return i > -1 ? this.children[i] : undefined;\n  }\n\n  /**\n   * Construct a new table containing only columns at the specified indices.\n   * The order of columns in the new table matches the order of input indices.\n   * @template {T[keyof T]} V\n   * @param {number[]} indices The indices of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns {Table<{ [key: string]: V }>} A new table with selected columns.\n   */\n  selectAt(indices, as = []) {\n    const { children, factory, schema } = this;\n    const { fields } = schema;\n    return new Table(\n      {\n        ...schema,\n        fields: indices.map((i, j) => renameField(fields[i], as[j]))\n      },\n      indices.map(i => children[i]),\n      factory === proxyFactory\n    );\n  }\n\n  /**\n   * Construct a new table containing only columns with the specified names.\n   * If columns have duplicate names, the first (with lowest index) is used.\n   * The order of columns in the new table matches the order of input names.\n   * @template {keyof T} K\n   * @param {K[]} names Names of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns A new table with columns matching the specified names.\n   */\n  select(names, as) {\n    const all = /** @type {K[]} */(this.names);\n    const indices = names.map(name => all.indexOf(name));\n    return this.selectAt(indices, as);\n  }\n\n  /**\n   * Return an object mapping column names to extracted value arrays.\n   * @returns {{ [P in keyof T]: ValueArray<T[P]> }}\n   */\n  toColumns() {\n    const { children, names } = this;\n    /** @type {{ [P in keyof T]: ValueArray<T[P]> }} */\n    // @ts-expect-error assign to empty object\n    const cols = {};\n    names.forEach((name, i) => cols[name] = children[i]?.toArray() ?? [] );\n    return cols;\n  }\n\n  /**\n   * Return an array of objects representing the rows of this table.\n   * @returns {{ [P in keyof T]: T[P] }[]}\n   */\n  toArray() {\n    const { children, getFactory, numRows } = this;\n    const data = children[0]?.data ?? [];\n    const output = Array(numRows);\n    for (let b = 0, row = -1; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        output[++row] = f(i);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Return an iterator over objects representing the rows of this table.\n   * @returns {Generator<{ [P in keyof T]: T[P] }, any, any>}\n   */\n  *[Symbol.iterator]() {\n    const { children, getFactory } = this;\n    const data = children[0]?.data ?? [];\n    for (let b = 0; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        yield f(i);\n      }\n    }\n  }\n\n  /**\n   * Return a row object for the given index.\n   * @param {number} index The row index.\n   * @returns {{ [P in keyof T]: T[P] }} The row object.\n   */\n  at(index) {\n    const { children, getFactory, numRows } = this;\n    if (index < 0 || index >= numRows) return null;\n    const [{ offsets }] = children;\n    const b = bisect(offsets, index) - 1;\n    return getFactory(b)(index - offsets[b]);\n  }\n\n  /**\n   * Return a row object for the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {{ [P in keyof T]: T[P] }} The row object.\n   */\n  get(index) {\n    return this.at(index);\n  }\n}\n\nfunction renameField(field, name) {\n  return (name != null && name !== field.name)\n    ? { ...field, name }\n    : field;\n}\n","/**\n * @import { DataType, ExtractionOptions } from './types.js';\n */\nimport { BinaryBatch, BinaryViewBatch, BoolBatch, DateBatch, DateDayBatch, DateDayMillisecondBatch, Decimal32NumberBatch, DecimalBigIntBatch, DecimalNumberBatch, DenseUnionBatch, DictionaryBatch, DirectBatch, FixedBinaryBatch, FixedListBatch, Float16Batch, Int64Batch, IntervalDayTimeBatch, IntervalMonthDayNanoBatch, LargeBinaryBatch, LargeListBatch, LargeListViewBatch, LargeUtf8Batch, ListBatch, ListViewBatch, MapBatch, MapEntryBatch, NullBatch, RunEndEncodedBatch, SparseUnionBatch, StructBatch, StructProxyBatch, TimestampMicrosecondBatch, TimestampMillisecondBatch, TimestampNanosecondBatch, TimestampSecondBatch, Utf8Batch, Utf8ViewBatch } from './batch.js';\nimport { DateUnit, IntervalUnit, TimeUnit, Type } from './constants.js';\nimport { invalidDataType } from './data-types.js';\n\n/**\n * Return a batch constructor for the given data type and extraction options.\n * @param {DataType} type The data type.\n * @param {ExtractionOptions} options The extraction options.\n */\nexport function batchType(type, options = {}) {\n  const { typeId, bitWidth, mode, precision, unit } = /** @type {any} */(type);\n  const { useBigInt, useDate, useDecimalInt, useMap, useProxy } = options;\n\n  switch (typeId) {\n    case Type.Null: return NullBatch;\n    case Type.Bool: return BoolBatch;\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return useBigInt || bitWidth < 64 ? DirectBatch : Int64Batch;\n    case Type.Float:\n      return precision ? DirectBatch : Float16Batch;\n    case Type.Date:\n      return wrap(\n        unit === DateUnit.DAY ? DateDayBatch : DateDayMillisecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Timestamp:\n      return wrap(\n        unit === TimeUnit.SECOND ? TimestampSecondBatch\n          : unit === TimeUnit.MILLISECOND ? TimestampMillisecondBatch\n          : unit === TimeUnit.MICROSECOND ? TimestampMicrosecondBatch\n          : TimestampNanosecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Decimal:\n      return bitWidth === 32\n        ? (useDecimalInt ? DirectBatch : Decimal32NumberBatch)\n        : (useDecimalInt ? DecimalBigIntBatch : DecimalNumberBatch);\n    case Type.Interval:\n      return unit === IntervalUnit.DAY_TIME ? IntervalDayTimeBatch\n        : unit === IntervalUnit.YEAR_MONTH ? DirectBatch\n        : IntervalMonthDayNanoBatch;\n    case Type.FixedSizeBinary: return FixedBinaryBatch;\n    case Type.Utf8: return Utf8Batch;\n    case Type.LargeUtf8: return LargeUtf8Batch;\n    case Type.Binary: return BinaryBatch;\n    case Type.LargeBinary: return LargeBinaryBatch;\n    case Type.BinaryView: return BinaryViewBatch;\n    case Type.Utf8View: return Utf8ViewBatch;\n    case Type.List: return ListBatch;\n    case Type.LargeList: return LargeListBatch;\n    case Type.Map: return useMap ? MapBatch : MapEntryBatch;\n    case Type.ListView: return ListViewBatch;\n    case Type.LargeListView: return LargeListViewBatch;\n    case Type.FixedSizeList: return FixedListBatch;\n    case Type.Struct: return useProxy ? StructProxyBatch : StructBatch;\n    case Type.RunEndEncoded: return RunEndEncodedBatch;\n    case Type.Dictionary: return DictionaryBatch;\n    case Type.Union: return mode ? DenseUnionBatch : SparseUnionBatch;\n  }\n  throw new Error(invalidDataType(typeId));\n}\n\nfunction wrap(BaseClass, WrapperClass) {\n  return WrapperClass\n    ? class WrapBatch extends WrapperClass {\n        constructor(options) {\n          super(new BaseClass(options));\n        }\n      }\n    : BaseClass;\n}\n","import { readInt32, readInt64, readVector } from '../util/read.js';\n\n/**\n * Decode a block that points to messages within an Arrow 'file' format.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns The file block.\n */\nexport function decodeBlock(buf, index) {\n  //  0: offset\n  //  8: metadataLength\n  // 16: bodyLength\n  return {\n    offset: readInt64(buf, index),\n    metadataLength: readInt32(buf, index + 8),\n    bodyLength: readInt64(buf, index + 16)\n  }\n}\n\n/**\n * Decode a vector of blocks.\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns An array of file blocks.\n */\nexport function decodeBlocks(buf, index) {\n  return readVector(buf, index, 24, decodeBlock);\n}\n","/**\n * @import { RecordBatch, Version_ } from '../types.js'\n */\nimport { Version } from '../constants.js';\nimport { readInt64, readObject, readOffset, readVector } from '../util/read.js';\n\n/**\n * Decode a record batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {RecordBatch} The record batch\n */\nexport function decodeRecordBatch(buf, index, version) {\n  //  4: length\n  //  6: nodes\n  //  8: buffers\n  // 10: compression (not supported)\n  // 12: variadicBuffers (buffer counts for view-typed fields)\n  const get = readObject(buf, index);\n  if (get(10, readOffset, 0)) {\n    throw new Error('Record batch compression not implemented');\n  }\n\n  // If an Arrow buffer was written before version 4,\n  // advance 8 bytes to skip the now-removed page_id field\n  const offset = version < Version.V4 ? 8 : 0;\n\n  return {\n    length: get(4, readInt64, 0),\n    nodes: readVector(buf, get(6, readOffset), 16, (buf, pos) => ({\n      length: readInt64(buf, pos),\n      nullCount: readInt64(buf, pos + 8)\n    })),\n    regions: readVector(buf, get(8, readOffset), 16 + offset, (buf, pos) => ({\n      offset: readInt64(buf, pos + offset),\n      length: readInt64(buf, pos + offset + 8)\n    })),\n    variadic: readVector(buf, get(12, readOffset), 8, readInt64)\n  };\n}\n","/**\n * @import { DictionaryBatch, Version_ } from '../types.js'\n */\nimport { readBoolean, readInt64, readObject } from '../util/read.js';\nimport { decodeRecordBatch } from './record-batch.js';\n\n/**\n * Decode a dictionary batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {DictionaryBatch} The dictionary batch\n */\nexport function decodeDictionaryBatch(buf, index, version) {\n  //  4: id\n  //  6: data\n  //  8: isDelta\n  const get = readObject(buf, index);\n  return {\n    id: get(4, readInt64, 0),\n    data: get(6, (buf, off) => decodeRecordBatch(buf, off, version)),\n    /**\n     * If isDelta is true the values in the dictionary are to be appended to a\n     * dictionary with the indicated id. If isDelta is false this dictionary\n     * should replace the existing dictionary.\n     */\n    isDelta: get(8, readBoolean, false)\n  };\n}\n","/**\n * @import { DataType, Field } from '../types.js'\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { binary, date, decimal, duration, fixedSizeBinary, fixedSizeList, float, int, interval, invalidDataType, largeBinary, largeList, largeListView, largeUtf8, list, listView, mapType, runEndEncoded, struct, time, timestamp, union, utf8 } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\nimport { readBoolean, readInt16, readInt32, readObject, readOffset, readString, readVector } from '../util/read.js';\n\n/**\n * Decode a data type definition for a field.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @param {number} typeId The data type id.\n * @param {Field[]} [children] A list of parsed child fields.\n * @returns {DataType} The data type.\n */\nexport function decodeDataType(buf, index, typeId, children) {\n  checkOneOf(typeId, Type, invalidDataType);\n  const get = readObject(buf, index);\n\n  switch (typeId) {\n    // types without flatbuffer objects\n    case Type.Binary: return binary();\n    case Type.Utf8: return utf8();\n    case Type.LargeBinary: return largeBinary();\n    case Type.LargeUtf8: return largeUtf8();\n    case Type.List: return list(children[0]);\n    case Type.ListView: return listView(children[0]);\n    case Type.LargeList: return largeList(children[0]);\n    case Type.LargeListView: return largeListView(children[0]);\n    case Type.Struct: return struct(children);\n    case Type.RunEndEncoded: return runEndEncoded(children[0], children[1]);\n\n    // types with flatbuffer objects\n    case Type.Int: return int(\n      // @ts-ignore\n      get(4, readInt32, 0), // bitwidth\n      get(6, readBoolean, false) // signed\n    );\n    case Type.Float: return float(\n      // @ts-ignore\n      get(4, readInt16, Precision.HALF) // precision\n    );\n    case Type.Decimal: return decimal(\n      get(4, readInt32, 0), // precision\n      get(6, readInt32, 0), // scale\n      // @ts-ignore\n      get(8, readInt32, 128) // bitwidth\n    );\n    case Type.Date: return date(\n      // @ts-ignore\n      get(4, readInt16, DateUnit.MILLISECOND) // unit\n    );\n    case Type.Time: return time(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n    case Type.Timestamp: return timestamp(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.SECOND), // unit\n      get(6, readString) // timezone\n    );\n    case Type.Interval: return interval(\n      // @ts-ignore\n      get(4, readInt16, IntervalUnit.YEAR_MONTH) // unit\n    );\n    case Type.Duration: return duration(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n\n    case Type.FixedSizeBinary: return fixedSizeBinary(\n      get(4, readInt32, 0) // stride\n    );\n    case Type.FixedSizeList: return fixedSizeList(\n      children[0],\n      get(4, readInt32, 0), // stride\n    );\n    case Type.Map: return mapType(\n      get(4, readBoolean, false), // keysSorted\n      children[0]\n    );\n\n    case Type.Union: return union(\n      // @ts-ignore\n      get(4, readInt16, UnionMode.Sparse), // mode\n      children,\n      readVector(buf, get(6, readOffset), 4, readInt32) // type ids\n    );\n  }\n  // case Type.NONE:\n  // case Type.Null:\n  // case Type.Bool:\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // @ts-ignore\n  return { typeId };\n}\n","/**\n * @import { Metadata } from '../types.js'\n */\nimport { readObject, readString, readVector } from '../util/read.js';\n\n/**\n * Decode custom metadata consisting of key-value string pairs.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {Metadata | null} The custom metadata map\n */\nexport function decodeMetadata(buf, index) {\n  const entries = readVector(buf, index, 4, (buf, pos) => {\n    const get = readObject(buf, pos);\n    return /** @type {[string, string]} */ ([\n      get(4, readString), // 4: key (string)\n      get(6, readString)  // 6: key (string)\n    ]);\n  });\n  return entries.length ? new Map(entries) : null;\n}\n","/**\n * @import { DictionaryType, Endianness_, Field, IntType, Schema, Version_ } from '../types.js'\n */\nimport { Type } from '../constants.js';\nimport { dictionary, int32 } from '../data-types.js';\nimport { readBoolean, readInt16, readInt64, readObject, readOffset, readString, readUint8, readVector } from '../util/read.js';\nimport { decodeDataType } from './data-type.js';\nimport { decodeMetadata } from './metadata.js';\n\n/**\n * Decode a table schema describing the fields and their data types.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {Schema} The schema\n */\nexport function decodeSchema(buf, index, version) {\n  //  4: endianness (int16)\n  //  6: fields (vector)\n  //  8: metadata (vector)\n  // 10: features (int64[])\n  const get = readObject(buf, index);\n  return {\n    version,\n    endianness: /** @type {Endianness_} */ (get(4, readInt16, 0)),\n    fields: get(6, decodeSchemaFields, []),\n    metadata: get(8, decodeMetadata)\n  };\n}\n\n/**\n * @returns {Field[] | null}\n */\nfunction decodeSchemaFields(buf, fieldsOffset) {\n  return readVector(buf, fieldsOffset, 4, decodeField);\n}\n\n/**\n * @returns {Field}\n */\nfunction decodeField(buf, index) {\n  //  4: name (string)\n  //  6: nullable (bool)\n  //  8: type id (uint8)\n  // 10: type (union)\n  // 12: dictionary (table)\n  // 14: children (vector)\n  // 16: metadata (vector)\n  const get = readObject(buf, index);\n  const typeId = get(8, readUint8, Type.NONE);\n  const typeOffset = get(10, readOffset, 0);\n  const dict = get(12, decodeDictionary);\n  const children = get(14, (buf, off) => decodeFieldChildren(buf, off));\n\n  let type = decodeDataType(buf, typeOffset, typeId, children);\n  if (dict) {\n    dict.dictionary = type;\n    type = dict;\n  }\n\n  return {\n    name: get(4, readString),\n    type,\n    nullable: get(6, readBoolean, false),\n    metadata: get(16, decodeMetadata)\n  };\n}\n\n/**\n * @returns {Field[] | null}\n */\nfunction decodeFieldChildren(buf, fieldOffset) {\n  const children = readVector(buf, fieldOffset, 4, decodeField);\n  return children.length ? children : null;\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns {DictionaryType}\n */\nfunction decodeDictionary(buf, index) {\n  if (!index) return null;\n  //  4: id (int64)\n  //  6: indexType (Int type)\n  //  8: isOrdered (boolean)\n  // 10: kind (int16) currently only dense array is supported\n  const get = readObject(buf, index);\n  return dictionary(\n    null, // data type will be populated by caller\n    get(6, decodeInt, int32()), // index type\n    get(8, readBoolean, false), // ordered\n    get(4, readInt64, 0), // id\n  );\n}\n\n/**\n * Decode an integer data type.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @returns {IntType}\n */\nfunction decodeInt(buf, index) {\n  return /** @type {IntType} */ (\n    decodeDataType(buf, index, Type.Int)\n  );\n}\n","/**\n * @import { Message, MessageHeader_, Version_ } from '../types.js'\n */\nimport { MessageHeader, Version } from '../constants.js';\nimport { keyFor } from '../util/objects.js';\nimport { SIZEOF_INT, readInt16, readInt32, readInt64, readObject, readOffset, readUint8 } from '../util/read.js';\nimport { decodeDictionaryBatch } from './dictionary-batch.js';\nimport { decodeRecordBatch } from './record-batch.js';\nimport { decodeSchema } from './schema.js';\n\nconst invalidMessageMetadata = (expected, actual) =>\n  `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n\nconst invalidMessageBodyLength = (expected, actual) =>\n  `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\nconst invalidMessageType = (type) =>\n  `Unsupported message type: ${type} (${keyFor(MessageHeader, type)})`;\n\n/**\n * A \"message\" contains a block of Apache Arrow data, such as a schema,\n * record batch, or dictionary batch. This message decodes a single\n * message, returning its associated metadata and content.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {Message} The decoded message.\n */\nexport function decodeMessage(buf, index) {\n  // get message start\n  let metadataLength = readInt32(buf, index) || 0;\n  index += SIZEOF_INT;\n\n  // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n  // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n  // pre-v0.15 message, where the first 4 bytes are the metadata length.\n  if (metadataLength === -1) {\n    metadataLength = readInt32(buf, index) || 0;\n    index += SIZEOF_INT;\n  }\n  if (metadataLength === 0) return null;\n\n  const head = buf.subarray(index, index += metadataLength);\n  if (head.byteLength < metadataLength) {\n    throw new Error(invalidMessageMetadata(metadataLength, head.byteLength));\n  }\n\n  // decode message metadata\n  //  4: version\n  //  6: headerType\n  //  8: headerIndex\n  // 10: bodyLength\n  const get = readObject(head, 0);\n  const version = /** @type {Version_} */\n    (get(4, readInt16, Version.V1));\n  const type = /** @type {MessageHeader_} */\n    (get(6, readUint8, MessageHeader.NONE));\n  const offset = get(8, readOffset, 0);\n  const bodyLength = get(10, readInt64, 0);\n  let content;\n\n  if (offset) {\n    // decode message header\n    const decoder = type === MessageHeader.Schema ? decodeSchema\n      : type === MessageHeader.DictionaryBatch ? decodeDictionaryBatch\n      : type === MessageHeader.RecordBatch ? decodeRecordBatch\n      : null;\n    if (!decoder) throw new Error(invalidMessageType(type));\n    content = decoder(head, offset, version);\n\n    // extract message body\n    if (bodyLength > 0) {\n      const body = buf.subarray(index, index += bodyLength);\n      if (body.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, body.byteLength));\n      }\n      // @ts-ignore\n      content.body = body;\n    } else if (type !== MessageHeader.Schema) {\n      // table-from-ipc.js buffer accessor requires body to exist, even for empty batches\n      // @ts-ignore\n      content.body = new Uint8Array(0);\n    }\n  }\n\n  return { version, type, index, content };\n}\n","/**\n * @import { ArrowData, Version_ } from '../types.js'\n */\nimport { MAGIC, MessageHeader, Version } from '../constants.js';\nimport { isArrayBufferLike } from '../util/arrays.js';\nimport { readInt16, readInt32, readObject } from '../util/read.js';\nimport { decodeBlocks } from './block.js';\nimport { decodeMessage } from './message.js';\nimport { decodeMetadata } from './metadata.js';\nimport { decodeSchema } from './schema.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return parsed schema, record batch,\n * and dictionary batch definitions. The input binary data may be either\n * an `ArrayBuffer` or `Uint8Array`. For Arrow data in the IPC 'stream' format,\n * an array of `Uint8Array` instances is also supported.\n *\n * This method stops short of generating views over field buffers. Use the\n * `createData()` method on the result to enable column data access.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * @param {ArrayBufferLike | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @returns {import('../types.js').ArrowData}\n */\nexport function decodeIPC(data) {\n  const source = isArrayBufferLike(data) ? new Uint8Array(data) : data;\n  return source instanceof Uint8Array && isArrowFileFormat(source)\n    ? decodeIPCFile(source)\n    : decodeIPCStream(source);\n}\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isArrowFileFormat(buf) {\n  if (!buf || buf.length < 4) return false;\n  for (let i = 0; i < 6; ++i) {\n    if (MAGIC[i] !== buf[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Decode data in the [Arrow IPC 'stream' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {Uint8Array | Uint8Array[]} data The source byte buffer, or an\n *  array of buffers. If an array, each byte array may contain one or more\n *  self-contained messages. Messages may NOT span multiple byte arrays.\n * @returns {ArrowData}\n */\nexport function decodeIPCStream(data) {\n  const stream = [data].flat();\n\n  let schema;\n  const records = [];\n  const dictionaries = [];\n\n  // consume each message in the stream\n  for (const buf of stream) {\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error(`IPC data batch was not a Uint8Array.`);\n    }\n    let offset = 0;\n\n    // decode all messages in current buffer\n    while (true) {\n      const m = decodeMessage(buf, offset);\n      if (m === null) break; // end of messages\n      offset = m.index;\n      if (!m.content) continue;\n      switch (m.type) {\n        case MessageHeader.Schema:\n          // ignore repeated schema messages\n          if (!schema) schema = m.content;\n          break;\n        case MessageHeader.RecordBatch:\n          records.push(m.content);\n          break;\n        case MessageHeader.DictionaryBatch:\n          dictionaries.push(m.content);\n          break;\n      }\n    }\n  }\n\n  return /** @type {ArrowData} */ (\n    { schema, dictionaries, records, metadata: null }\n  );\n}\n\n/**\n * Decode data in the [Arrow IPC 'file' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format\n * @param {Uint8Array} data The source byte buffer.\n * @returns {ArrowData}\n */\nexport function decodeIPCFile(data) {\n  // find footer location\n  const offset = data.byteLength - (MAGIC.length + 4);\n  const length = readInt32(data, offset);\n\n  // decode file footer\n  //  4: version\n  //  6: schema\n  //  8: dictionaries (vector)\n  // 10: batches (vector)\n  // 12: metadata\n  const get = readObject(data, offset - length);\n  const version = /** @type {Version_} */\n    (get(4, readInt16, Version.V1));\n  const dicts = get(8, decodeBlocks, []);\n  const recs = get(10, decodeBlocks, []);\n\n  return /** @type {ArrowData} */ ({\n    schema: get(6, (buf, index) => decodeSchema(buf, index, version)),\n    dictionaries: dicts.map(({ offset }) => decodeMessage(data, offset).content),\n    records: recs.map(({ offset }) => decodeMessage(data, offset).content),\n    metadata: get(12, decodeMetadata)\n  });\n}\n","/**\n * @import { ArrowData, ExtractionOptions, Field, RecordBatch, Schema } from '../types.js'\n */\nimport { batchType } from '../batch-type.js';\nimport { columnBuilder } from '../column.js';\nimport { Type, UnionMode, Version } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { Table } from '../table.js';\nimport { int8Array } from '../util/arrays.js';\nimport { decodeIPC } from './decode-ipc.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return a new Table. The input binary\n * data may be either an `ArrayBuffer` or `Uint8Array`. For Arrow data in the\n * [IPC 'stream' format][2], an array of `Uint8Array` values is also supported.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * [2]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {ArrayBufferLike | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @param {ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from an Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function tableFromIPC(data, options) {\n  return createTable(decodeIPC(data), options);\n}\n\n/**\n * Create a table from parsed IPC data.\n * @param {ArrowData} data\n *  The IPC data, as returned by parseIPC.\n * @param {ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from am Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function createTable(data, options = {}) {\n  const { schema = { fields: [] }, dictionaries, records } = data;\n  const { version, fields } = schema;\n  const dictionaryMap = new Map;\n  const context = contextGenerator(options, version, dictionaryMap);\n\n  // build dictionary type map\n  const dictionaryTypes = new Map;\n  visitSchemaFields(schema, field => {\n    const type = field.type;\n    if (type.typeId === Type.Dictionary) {\n      dictionaryTypes.set(type.id, type.dictionary);\n    }\n  });\n\n  // decode dictionaries, build dictionary column map\n  const dicts = new Map;\n  for (const dict of dictionaries) {\n    const { id, data, isDelta, body } = dict;\n    const type = dictionaryTypes.get(id);\n    const batch = visit(type, context({ ...data, body }));\n    if (!dicts.has(id)) {\n      if (isDelta) {\n        throw new Error('Delta update can not be first dictionary batch.');\n      }\n      dicts.set(id, columnBuilder(type).add(batch));\n    } else {\n      const dict = dicts.get(id);\n      if (!isDelta) dict.clear();\n      dict.add(batch);\n    }\n  }\n  dicts.forEach((value, key) => dictionaryMap.set(key, value.done()));\n\n  // decode column fields\n  const cols = fields.map(f => columnBuilder(f.type));\n  for (const batch of records) {\n    const ctx = context(batch);\n    fields.forEach((f, i) => cols[i].add(visit(f.type, ctx)));\n  }\n\n  return new Table(schema, cols.map(c => c.done()), options.useProxy);\n}\n\n/**\n * Visit all fields within a schema.\n * @param {Schema} schema\n * @param {(field: Field) => void} visitor\n */\nfunction visitSchemaFields(schema, visitor) {\n  schema.fields.forEach(function visitField(field) {\n    visitor(field);\n    // @ts-ignore\n    field.type.dictionary?.children?.forEach(visitField);\n    // @ts-ignore\n    field.type.children?.forEach(visitField);\n  });\n}\n\n/**\n * Context object generator for field visitation and buffer definition.\n */\nfunction contextGenerator(options, version, dictionaryMap) {\n  const base = {\n    version,\n    options,\n    dictionary: id => dictionaryMap.get(id),\n  };\n\n  /**\n   * Return a context generator.\n   * @param {RecordBatch} batch\n   */\n  return batch => {\n    const { length, nodes, regions, variadic, body } = batch;\n    let nodeIndex = -1;\n    let bufferIndex = -1;\n    let variadicIndex = -1;\n    return {\n      ...base,\n      length,\n      node: () => nodes[++nodeIndex],\n      buffer: (ArrayType) => {\n        const { length, offset } = regions[++bufferIndex];\n        return ArrayType\n          ? new ArrayType(body.buffer, body.byteOffset + offset, length / ArrayType.BYTES_PER_ELEMENT)\n          : body.subarray(offset, offset + length)\n      },\n      variadic: () => variadic[++variadicIndex],\n      visit(children) { return children.map(f => visit(f.type, this)); }\n    };\n  };\n}\n\n/**\n * Visit a field, instantiating views of buffer regions.\n */\nfunction visit(type, ctx) {\n  const { typeId } = type;\n  const { options, node, buffer, variadic, version } = ctx;\n  const BatchType = batchType(type, options);\n\n  // extract the next { length, nullCount } field node - ALL fields have field nodes\n  const base = { ...node(), type };\n\n  if (typeId === Type.Null) {\n    // null fields have field nodes but no data buffers\n    return new BatchType({ ...base, nullCount: base.length });\n  }\n\n  switch (typeId) {\n    // validity and data value buffers\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Decimal:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(type.values)\n      });\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        values: buffer()\n      });\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(), // views buffer\n        data: Array.from({ length: variadic() }, () => buffer()) // data buffers\n      });\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        sizes: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        children: ctx.visit(type.children)\n      });\n\n    // children only\n    case Type.RunEndEncoded:\n      return new BatchType({\n        ...base,\n        children: ctx.visit(type.children)\n      });\n\n    // dictionary\n    case Type.Dictionary: {\n      const { id, indices } = type;\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(indices.values),\n      }).setDictionary(ctx.dictionary(id));\n    }\n\n    // union\n    case Type.Union: {\n      if (version < Version.V5) {\n        buffer(); // skip unused null bitmap\n      }\n      return new BatchType({\n        ...base,\n        typeIds: buffer(int8Array),\n        offsets: type.mode === UnionMode.Sparse ? null : buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","/**\n * @import { Sink } from './sink.js';\n */\nimport { grow } from '../util/arrays.js';\nimport { SIZEOF_INT, SIZEOF_SHORT, readInt16 } from '../util/read.js';\nimport { encodeUtf8 } from '../util/strings.js';\n\nexport function writeInt32(buf, index, value) {\n  buf[index] = value;\n  buf[index + 1] = value >> 8;\n  buf[index + 2] = value >> 16;\n  buf[index + 3] = value >> 24;\n}\n\nconst INIT_SIZE = 1024;\n\n/** Flatbuffer binary builder. */\nexport class Builder {\n  /**\n   * Create a new builder instance.\n   * @param {Sink} sink The byte consumer.\n   */\n  constructor(sink) {\n    /**\n     * Sink that consumes built byte buffers;\n     * @type {Sink}\n     */\n    this.sink = sink;\n    /**\n     * Minimum alignment encountered so far.\n     * @type {number}\n     */\n    this.minalign = 1;\n    /**\n     * Current byte buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = new Uint8Array(INIT_SIZE);\n    /**\n     * Remaining space in the current buffer.\n     * @type {number}\n     */\n    this.space = INIT_SIZE;\n    /**\n     * List of offsets of all vtables. Used to find and\n     * reuse tables upon duplicated table field schemas.\n     * @type {number[]}\n     */\n    this.vtables = [];\n    /**\n     * Total bytes written to sink thus far.\n     */\n    this.outputBytes = 0;\n  }\n\n  /**\n   * Returns the flatbuffer offset, relative to the end of the current buffer.\n   * @returns {number} Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.buf.length - this.space;\n  }\n\n  /**\n   * Write a flatbuffer int8 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt8(value) {\n    this.buf[this.space -= 1] = value;\n  }\n\n  /**\n   * Write a flatbuffer int16 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt16(value) {\n    this.buf[this.space -= 2] = value;\n    this.buf[this.space + 1] = value >> 8;\n  }\n\n  /**\n   * Write a flatbuffer int32 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt32(value) {\n    writeInt32(this.buf, this.space -= 4, value);\n  }\n\n  /**\n   * Write a flatbuffer int64 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt64(value) {\n    const v = BigInt(value);\n    this.writeInt32(Number(BigInt.asIntN(32, v >> BigInt(32))));\n    this.writeInt32(Number(BigInt.asIntN(32, v)));\n  }\n\n  /**\n   * Add a flatbuffer int8 value, properly aligned,\n   * @param value The int8 value to add the buffer.\n   */\n  addInt8(value) {\n    prep(this, 1, 0);\n    this.writeInt8(value);\n  }\n\n  /**\n   * Add a flatbuffer int16 value, properly aligned,\n   * @param value The int16 value to add the buffer.\n   */\n  addInt16(value) {\n    prep(this, 2, 0);\n    this.writeInt16(value);\n  }\n\n  /**\n   * Add a flatbuffer int32 value, properly aligned,\n   * @param value The int32 value to add the buffer.\n   */\n  addInt32(value) {\n    prep(this, 4, 0);\n    this.writeInt32(value);\n  }\n\n  /**\n   * Add a flatbuffer int64 values, properly aligned.\n   * @param value The int64 value to add the buffer.\n   */\n  addInt64(value) {\n    prep(this, 8, 0);\n    this.writeInt64(value);\n  }\n\n  /**\n   * Add a flatbuffer offset, relative to where it will be written.\n   * @param {number} offset The offset to add.\n   */\n  addOffset(offset) {\n    prep(this, SIZEOF_INT, 0); // Ensure alignment is already done.\n    this.writeInt32(this.offset() - offset + SIZEOF_INT);\n  }\n\n  /**\n   * Add a flatbuffer object (vtable).\n   * @param {number} numFields The maximum number of fields\n   *  this object may include.\n   * @param {(tableBuilder: ReturnType<objectBuilder>) => void} [addFields]\n   *  A callback function that writes all fields using an object builder.\n   * @returns {number} The object offset.\n   */\n  addObject(numFields, addFields) {\n    const b = objectBuilder(this, numFields);\n    addFields?.(b);\n    return b.finish();\n  }\n\n  /**\n   * Add a flatbuffer vector (list).\n   * @template T\n   * @param {T[]} items An array of items to write.\n   * @param {number} itemSize The size in bytes of a serialized item.\n   * @param {number} alignment The desired byte alignment value.\n   * @param {(builder: this, item: T) => void} writeItem A callback\n   *  function that writes a vector item to this builder.\n   * @returns {number} The vector offset.\n   */\n  addVector(items, itemSize, alignment, writeItem) {\n    const n = items?.length;\n    if (!n) return 0;\n    prep(this, SIZEOF_INT, itemSize * n);\n    prep(this, alignment, itemSize * n); // Just in case alignment > int.\n    for (let i = n; --i >= 0;) {\n      writeItem(this, items[i]);\n    }\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Convenience method for writing a vector of byte buffer offsets.\n   * @param {number[]} offsets\n   * @returns {number} The vector offset.\n   */\n  addOffsetVector(offsets) {\n    return this.addVector(offsets, 4, 4, (b, off) => b.addOffset(off));\n  }\n\n  /**\n   * Add a flatbuffer UTF-8 string.\n   * @param {string} s The string to encode.\n   * @return {number} The string offset.\n   */\n  addString(s) {\n    if (s == null) return 0;\n    const utf8 = encodeUtf8(s);\n    const n = utf8.length;\n    this.addInt8(0); // string null terminator\n    prep(this, SIZEOF_INT, n);\n    this.buf.set(utf8, this.space -= n);\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Finish the current flatbuffer by adding a root offset.\n   * @param {number} rootOffset The root offset.\n   */\n  finish(rootOffset) {\n    prep(this, this.minalign, SIZEOF_INT);\n    this.addOffset(rootOffset);\n  }\n\n  /**\n   * Flush the current flatbuffer byte buffer content to the sink,\n   * and reset the flatbuffer builder state.\n   */\n  flush() {\n    const { buf, sink } = this;\n    const bytes = buf.subarray(this.space, buf.length);\n    sink.write(bytes);\n    this.outputBytes += bytes.byteLength;\n    this.minalign = 1;\n    this.vtables = [];\n    this.buf = new Uint8Array(INIT_SIZE);\n    this.space = INIT_SIZE;\n  }\n\n  /**\n   * Add a byte buffer directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * buffer to the sink *before* the flatbuffer.\n   * The buffer will be padded for 64-bit (8-byte) alignment as needed.\n   * @param {Uint8Array} buffer The buffer to add.\n   * @returns {number} The total byte count of the buffer and padding.\n   */\n  addBuffer(buffer) {\n    const size = buffer.byteLength;\n    if (!size) return 0;\n    this.sink.write(buffer);\n    this.outputBytes += size;\n    const pad = ((size + 7) & ~7) - size;\n    this.addPadding(pad);\n    return size + pad;\n  }\n\n  /**\n   * Write padding bytes directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * padding bytes to the sink *before* the flatbuffer.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  addPadding(byteCount) {\n    if (byteCount > 0) {\n      this.sink.write(new Uint8Array(byteCount));\n      this.outputBytes += byteCount;\n    }\n  }\n}\n\n/**\n * Prepare to write an element of `size` after `additionalBytes` have been\n * written, e.g. if we write a string, we need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * we need to do is alignment, `additionalBytes` will be 0.\n * @param {Builder} builder The builder to prep.\n * @param {number} size The size of the new element to write.\n * @param {number} additionalBytes Additional padding size.\n */\nexport function prep(builder, size, additionalBytes) {\n  let { buf, space, minalign } = builder;\n\n  // track the biggest thing we've ever aligned to\n  if (size > minalign) {\n    builder.minalign = size;\n  }\n\n  // find alignment needed so that `size` aligns after `additionalBytes`\n  const bufSize = buf.length;\n  const used = bufSize - space + additionalBytes;\n  const alignSize = (~used + 1) & (size - 1);\n\n  // reallocate the buffer if needed\n  buf = grow(buf, used + alignSize + size - 1, true);\n  space += buf.length - bufSize;\n\n  // add padding\n  for (let i = 0; i < alignSize; ++i) {\n    buf[--space] = 0;\n  }\n\n  // update builder state\n  builder.buf = buf;\n  builder.space = space;\n}\n\n/**\n * Returns a builder object for flatbuffer objects (vtables).\n * @param {Builder} builder The underlying flatbuffer builder.\n * @param {number} numFields The expected number of fields, not\n *  including the standard size fields.\n */\nfunction objectBuilder(builder, numFields) {\n  /** @type {number[]} */\n  const vtable = Array(numFields).fill(0);\n  const startOffset = builder.offset();\n\n  function slot(index) {\n    vtable[index] = builder.offset();\n  }\n\n  return {\n    /**\n     * Add an int8-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt8(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt8(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int16-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt16(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt16(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int32-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt32(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt32(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int64-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt64(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt64(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add a buffer offset-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addOffset(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addOffset(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Write the vtable to the buffer and return the table offset.\n     * @returns {number} The buffer offset to the vtable.\n     */\n    finish() {\n      // add offset entry, will overwrite later with actual offset\n      builder.addInt32(0);\n      const vtableOffset = builder.offset();\n\n      // trim zero-valued fields (indicating default value)\n      let i = numFields;\n      while (--i >= 0 && vtable[i] === 0) {} // eslint-disable-line no-empty\n      const size = i + 1;\n\n      // Write out the current vtable.\n      for (; i >= 0; --i) {\n        // Offset relative to the start of the table.\n        builder.addInt16(vtable[i] ? (vtableOffset - vtable[i]) : 0);\n      }\n\n      const standardFields = 2; // size fields\n      builder.addInt16(vtableOffset - startOffset);\n      const len = (size + standardFields) * SIZEOF_SHORT;\n      builder.addInt16(len);\n\n      // Search for an existing vtable that matches the current one.\n      let existingTable = 0;\n      const { buf, vtables, space: vt1 } = builder;\n    outer_loop:\n      for (i = 0; i < vtables.length; ++i) {\n        const vt2 = buf.length - vtables[i];\n        if (len == readInt16(buf, vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (readInt16(buf, vt1 + j) != readInt16(buf, vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existingTable = vtables[i];\n          break;\n        }\n      }\n\n      if (existingTable) {\n        // Found a match: remove the current vtable.\n        // Point table to existing vtable.\n        builder.space = buf.length - vtableOffset;\n        writeInt32(buf, builder.space, existingTable - vtableOffset);\n      } else {\n        // No match: add the location of the current vtable to the vtables list.\n        // Point table to current vtable.\n        const off = builder.offset();\n        vtables.push(off);\n        writeInt32(buf, buf.length - vtableOffset, off - vtableOffset);\n      }\n\n      return vtableOffset;\n    }\n  }\n}\n","/**\n * @import { RecordBatch } from '../types.js';\n * @import { Builder } from './builder.js';\n */\n\n/**\n * @param {Builder} builder\n * @param {RecordBatch} batch\n * @returns {number}\n */\nexport function encodeRecordBatch(builder, batch) {\n  const { nodes, regions, variadic } = batch;\n  const nodeVector = builder.addVector(nodes, 16, 8,\n    (builder, node) => {\n      builder.writeInt64(node.nullCount);\n      builder.writeInt64(node.length);\n      return builder.offset();\n    }\n  );\n  const regionVector = builder.addVector(regions, 16, 8,\n    (builder, region) => {\n      builder.writeInt64(region.length);\n      builder.writeInt64(region.offset);\n      return builder.offset();\n    }\n  );\n  const variadicVector = builder.addVector(variadic, 8, 8,\n    (builder, count) => builder.addInt64(count)\n  );\n  return builder.addObject(5, b => {\n    b.addInt64(0, nodes[0].length, 0);\n    b.addOffset(1, nodeVector, 0);\n    b.addOffset(2, regionVector, 0);\n    // NOT SUPPORTED: 3, compression offset\n    b.addOffset(4, variadicVector, 0);\n  });\n}\n","/**\n * @import { DictionaryBatch } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { encodeRecordBatch } from './record-batch.js';\n\n/**\n * @param {Builder} builder\n * @param {DictionaryBatch} dictionaryBatch\n * @returns {number}\n */\nexport function encodeDictionaryBatch(builder, dictionaryBatch) {\n  const dataOffset = encodeRecordBatch(builder, dictionaryBatch.data);\n  return builder.addObject(3, b => {\n    b.addInt64(0, dictionaryBatch.id, 0);\n    b.addOffset(1, dataOffset, 0);\n    b.addInt8(2, +dictionaryBatch.isDelta, 0);\n  });\n}\n","/**\n * @import { Builder } from './builder.js';\n */\n\n/**\n * @param {Builder} builder\n * @param {Map<string, string>} metadata\n * @returns {number}\n */\nexport function encodeMetadata(builder, metadata) {\n  return metadata?.size > 0\n     ? builder.addOffsetVector(Array.from(metadata, ([k, v]) => {\n        const key = builder.addString(`${k}`);\n        const val = builder.addString(`${v}`);\n        return builder.addObject(2, b => {\n          b.addOffset(0, key, 0);\n          b.addOffset(1, val, 0);\n        });\n      }))\n    : 0;\n}\n","/**\n * @import { DataType } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\n\n/**\n * Encode a data type into a flatbuffer.\n * @param {Builder} builder\n * @param {DataType} type\n * @returns {number} The offset at which the data type is written.\n */\nexport function encodeDataType(builder, type) {\n  const typeId = checkOneOf(type.typeId, Type, invalidDataType);\n\n  switch (typeId) {\n    case Type.Dictionary:\n      return encodeDictionary(builder, type);\n    case Type.Int:\n      return encodeInt(builder, type);\n    case Type.Float:\n      return encodeFloat(builder, type);\n    case Type.Decimal:\n      return encodeDecimal(builder, type);\n    case Type.Date:\n      return encodeDate(builder, type);\n    case Type.Time:\n      return encodeTime(builder, type);\n    case Type.Timestamp:\n      return encodeTimestamp(builder, type);\n    case Type.Interval:\n      return encodeInterval(builder, type);\n    case Type.Duration:\n      return encodeDuration(builder, type);\n    case Type.FixedSizeBinary:\n    case Type.FixedSizeList:\n      return encodeFixedSize(builder, type);\n    case Type.Map:\n      return encodeMap(builder, type);\n    case Type.Union:\n      return encodeUnion(builder, type);\n  }\n  // case Type.Null:\n  // case Type.Binary:\n  // case Type.LargeBinary:\n  // case Type.BinaryView:\n  // case Type.Bool:\n  // case Type.Utf8:\n  // case Type.Utf8View:\n  // case Type.LargeUtf8:\n  // case Type.List:\n  // case Type.ListView:\n  // case Type.LargeList:\n  // case Type.LargeListView:\n  // case Type.RunEndEncoded:\n  // case Type.Struct:\n  return builder.addObject(0);\n}\n\nfunction encodeDate(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, DateUnit.MILLISECOND);\n  });\n}\n\nfunction encodeDecimal(builder, type) {\n  return builder.addObject(3, b => {\n    b.addInt32(0, type.precision, 0);\n    b.addInt32(1, type.scale, 0);\n    b.addInt32(2, type.bitWidth, 128);\n  });\n}\n\nfunction encodeDuration(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n  });\n}\n\nfunction encodeFixedSize(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt32(0, type.stride, 0);\n  });\n}\n\nfunction encodeFloat(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.precision, Precision.HALF);\n  });\n}\n\nfunction encodeInt(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt32(0, type.bitWidth, 0);\n    b.addInt8(1, +type.signed, 0);\n  });\n}\n\nfunction encodeInterval(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, IntervalUnit.YEAR_MONTH);\n  });\n}\n\nfunction encodeMap(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt8(0, +type.keysSorted, 0);\n  });\n}\n\nfunction encodeTime(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n    b.addInt32(1, type.bitWidth, 32);\n  });\n}\n\nfunction encodeTimestamp(builder, type) {\n  const timezoneOffset = builder.addString(type.timezone);\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.SECOND);\n    b.addOffset(1, timezoneOffset, 0);\n  });\n}\n\nfunction encodeUnion(builder, type) {\n  const typeIdsOffset = builder.addVector(\n    type.typeIds, 4, 4,\n    (builder, value) => builder.addInt32(value)\n  );\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.mode, UnionMode.Sparse);\n    b.addOffset(1, typeIdsOffset, 0);\n  });\n}\n\nfunction encodeDictionary(builder, type) {\n  // The Arrow spec uses signed 32-bit integers as the default index type.\n  // However, multiple 3rd party tools fail on a null (default) index type,\n  // so we always encode the index data type explicitly here.\n  return builder.addObject(4, b => {\n    b.addInt64(0, type.id, 0);\n    b.addOffset(1, encodeDataType(builder, type.indices), 0);\n    b.addInt8(2, +type.ordered, 0);\n    // NOT SUPPORTED: 3, dictionaryKind (defaults to dense array)\n  });\n}\n","/**\n * @import { DictionaryType, Field, Schema } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { Type } from '../constants.js';\nimport { encodeDataType } from './data-type.js';\nimport { encodeMetadata } from './metadata.js';\n\nconst isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n/**\n * @param {Builder} builder\n * @param {Schema} schema\n * @returns {number}\n */\nexport function encodeSchema(builder, schema) {\n  const { fields, metadata } = schema;\n  const fieldOffsets = fields.map(f => encodeField(builder, f));\n  const fieldsVectorOffset = builder.addOffsetVector(fieldOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  return builder.addObject(4, b => {\n    b.addInt16(0, +(!isLittleEndian), 0);\n    b.addOffset(1, fieldsVectorOffset, 0);\n    b.addOffset(2, metadataOffset, 0);\n    // NOT SUPPORTED: 3, features\n  });\n}\n\n/**\n * @param {Builder} builder\n * @param {Field} field\n * @returns {number}\n */\nfunction encodeField(builder, field) {\n  const { name, nullable, type, metadata } = field;\n  let { typeId } = type;\n\n  // encode field data type\n  let typeOffset = 0;\n  let dictionaryOffset = 0;\n  if (typeId !== Type.Dictionary) {\n    typeOffset = encodeDataType(builder, type);\n  } else {\n    const dict = /** @type {DictionaryType} */ (type).dictionary;\n    typeId = dict.typeId;\n    dictionaryOffset = encodeDataType(builder, type);\n    typeOffset = encodeDataType(builder, dict);\n  }\n\n  // encode children, metadata, name, and field object\n  // @ts-ignore\n  const childOffsets = (type.children || []).map(f => encodeField(builder, f));\n  const childrenVectorOffset = builder.addOffsetVector(childOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const nameOffset = builder.addString(name);\n  return builder.addObject(7, b => {\n    b.addOffset(0, nameOffset, 0);\n    b.addInt8(1, +nullable, +false);\n    b.addInt8(2, typeId, Type.NONE);\n    b.addOffset(3, typeOffset, 0);\n    b.addOffset(4, dictionaryOffset, 0);\n    b.addOffset(5, childrenVectorOffset, 0);\n    b.addOffset(6, metadataOffset, 0);\n  });\n}\n","/**\n * @import { Block, Schema } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { MAGIC, Version } from '../constants.js';\nimport { encodeMetadata } from './metadata.js';\nimport { encodeSchema } from './schema.js';\n\n/**\n * Write a file footer.\n * @param {Builder} builder The binary builder.\n * @param {Schema} schema The table schema.\n * @param {Block[]} dictBlocks Dictionary batch file blocks.\n * @param {Block[]} recordBlocks Record batch file blocks.\n * @param {Map<string,string> | null} metadata File-level metadata.\n */\nexport function writeFooter(builder, schema, dictBlocks, recordBlocks, metadata) {\n  // encode footer flatbuffer\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const recsOffset = builder.addVector(recordBlocks, 24, 8, encodeBlock);\n  const dictsOffset = builder.addVector(dictBlocks, 24, 8, encodeBlock);\n  const schemaOffset = encodeSchema(builder, schema);\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addOffset(1, schemaOffset, 0);\n      b.addOffset(2, dictsOffset, 0);\n      b.addOffset(3, recsOffset, 0);\n      b.addOffset(4, metadataOffset, 0);\n    })\n  );\n  const size = builder.offset();\n\n  // add eos with continuation indicator\n  builder.addInt32(0);\n  builder.addInt32(-1);\n\n  // write builder contents\n  builder.flush();\n\n  // write file tail\n  builder.sink.write(new Uint8Array(Int32Array.of(size).buffer));\n  builder.sink.write(MAGIC);\n}\n\n/**\n * Encode a file pointer block.\n * @param {Builder} builder\n * @param {Block} block\n * @returns {number} the current block offset\n */\nfunction encodeBlock(builder, { offset, metadataLength, bodyLength }) {\n  builder.writeInt64(bodyLength);\n  builder.writeInt32(0);\n  builder.writeInt32(metadataLength);\n  builder.writeInt64(offset);\n  return builder.offset();\n}\n","/**\n * @import { Block, MessageHeader_ } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { MessageHeader, Version } from '../constants.js';\n\n/**\n * Write an IPC message to the builder sink.\n * @param {Builder} builder\n * @param {MessageHeader_} headerType\n * @param {number} headerOffset\n * @param {number} bodyLength\n * @param {Block[]} [blocks]\n */\nexport function writeMessage(builder, headerType, headerOffset, bodyLength, blocks) {\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addInt8(1, headerType, MessageHeader.NONE);\n      b.addOffset(2, headerOffset, 0);\n      b.addInt64(3, bodyLength, 0);\n      // NOT SUPPORTED: 4, message-level metadata\n    })\n  );\n\n  const prefixSize = 8; // continuation indicator + message size\n  const messageSize = builder.offset();\n  const alignedSize = (messageSize + prefixSize + 7) & ~7;\n\n  // track blocks for file footer\n  blocks?.push({\n    offset: builder.outputBytes,\n    metadataLength: alignedSize,\n    bodyLength\n  });\n\n  // write size prefix (including padding)\n  builder.addInt32(alignedSize - prefixSize);\n\n  // write the stream continuation indicator\n  builder.addInt32(-1);\n\n  // flush the builder content\n  builder.flush();\n\n  // add alignment padding as needed\n  builder.addPadding(alignedSize - messageSize - prefixSize);\n}\n","export class Sink {\n  /**\n   * Write bytes to this sink.\n   * @param {Uint8Array} bytes The byte buffer to write.\n   */\n  write(bytes) { // eslint-disable-line no-unused-vars\n  }\n\n  /**\n   * Write padding bytes (zeroes) to this sink.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  pad(byteCount) {\n    this.write(new Uint8Array(byteCount));\n  }\n\n  /**\n   * @returns {Uint8Array | null}\n   */\n  finish() {\n    return null;\n  }\n}\n\nexport class MemorySink extends Sink {\n  /**\n   * A sink that collects bytes in memory.\n   */\n  constructor() {\n    super();\n    this.buffers = [];\n  }\n\n  /**\n   * Write bytes\n   * @param {Uint8Array} bytes\n   */\n  write(bytes) {\n    this.buffers.push(bytes);\n  }\n\n  /**\n   * @returns {Uint8Array}\n   */\n  finish() {\n    const bufs = this.buffers;\n    const size = bufs.reduce((sum, b) => sum + b.byteLength, 0);\n    const buf = new Uint8Array(size);\n    for (let i = 0, off = 0; i < bufs.length; ++i) {\n      buf.set(bufs[i], off);\n      off += bufs[i].byteLength;\n    }\n    return buf;\n  }\n}\n","/**\n * @import { Sink } from './sink.js';\n */\nimport { EOS, MAGIC, MessageHeader } from '../constants.js';\nimport { Builder } from './builder.js';\nimport { encodeDictionaryBatch } from './dictionary-batch.js';\nimport { writeFooter } from './footer.js';\nimport { encodeRecordBatch } from './record-batch.js';\nimport { encodeSchema } from './schema.js';\nimport { writeMessage } from './message.js';\nimport { MemorySink } from './sink.js';\n\nconst STREAM = 'stream';\nconst FILE = 'file';\n\n/**\n * Encode assembled data into Arrow IPC binary format.\n * @param {any} data Assembled table data.\n * @param {object} options Encoding options.\n * @param {Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @returns {Sink} The sink that was passed in.\n */\nexport function encodeIPC(data, { sink, format = STREAM } = {}) {\n  if (format !== STREAM && format !== FILE) {\n    throw new Error(`Unrecognized Arrow IPC format: ${format}`);\n  }\n  const { schema, dictionaries = [], records = [], metadata } = data;\n  const builder = new Builder(sink || new MemorySink());\n  const file = format === FILE;\n  const dictBlocks = [];\n  const recordBlocks = [];\n\n  if (file) {\n    builder.addBuffer(MAGIC);\n  }\n\n  // both stream and file start with the schema\n  if (schema) {\n    writeMessage(\n      builder,\n      MessageHeader.Schema,\n      encodeSchema(builder, schema),\n      0\n    );\n  }\n\n  // write dictionary messages\n  for (const dict of dictionaries) {\n    const { data } = dict;\n    writeMessage(\n      builder,\n      MessageHeader.DictionaryBatch,\n      encodeDictionaryBatch(builder, dict),\n      data.byteLength,\n      dictBlocks\n    );\n    writeBuffers(builder, data.buffers);\n  }\n\n  // write record batch messages\n  for (const batch of records) {\n    writeMessage(\n      builder,\n      MessageHeader.RecordBatch,\n      encodeRecordBatch(builder, batch),\n      batch.byteLength,\n      recordBlocks\n    );\n    writeBuffers(builder, batch.buffers);\n  }\n\n  // both stream and file include end-of-stream message\n  builder.addBuffer(EOS);\n\n  if (file) {\n    writeFooter(builder, schema, dictBlocks, recordBlocks, metadata);\n  }\n\n  return builder.sink;\n}\n\n/**\n * Write byte buffers to the builder sink.\n * Buffers are aligned to 64 bits (8 bytes) as needed.\n * @param {Builder} builder\n * @param {Uint8Array[]} buffers\n */\nfunction writeBuffers(builder, buffers) {\n  for (let i = 0; i < buffers.length; ++i) {\n    builder.addBuffer(buffers[i]); // handles alignment for us\n  }\n}\n","/**\n * @import { Batch, DictionaryBatch } from '../batch.js'\n * @import { Column } from '../column.js'\n * @import { Table } from '../table.js'\n * @import { DataType, RecordBatch, Schema, TypedArray } from '../types.js'\n * @import { Sink } from './sink.js';\n */\nimport { Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { encodeIPC } from './encode-ipc.js';\n\n/**\n * Encode an Arrow table into Arrow IPC binary format.\n * @param {Table} table The Arrow table to encode.\n * @param {object} options Encoding options.\n * @param {Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @returns {Uint8Array | null} The generated bytes (for an in-memory sink)\n *  or null (if using a sink that writes bytes elsewhere).\n */\nexport function tableToIPC(table, options) {\n  // accept a format string option for Arrow-JS compatibility\n  if (typeof options === 'string') {\n    options = { format: options };\n  }\n\n  const columns = table.children;\n  checkBatchLengths(columns);\n\n  const { dictionaries, idMap } = assembleDictionaryBatches(columns);\n  const records = assembleRecordBatches(columns);\n  const schema = assembleSchema(table.schema, idMap);\n  const data = { schema, dictionaries, records };\n  return encodeIPC(data, options).finish();\n}\n\nfunction checkBatchLengths(columns) {\n  const n = columns[0]?.data.map(d => d.length);\n  columns.forEach(({ data }) => {\n    if (data.length !== n.length || data.some((b, i) => b.length !== n[i])) {\n      throw new Error('Columns have inconsistent batch sizes.');\n    }\n  });\n}\n\n/**\n * Create a new assembly context.\n */\nfunction assembleContext() {\n  let byteLength = 0;\n  const nodes = [];\n  const regions = [];\n  const buffers = [];\n  const variadic = [];\n  return {\n    /**\n     * @param {number} length\n     * @param {number} nullCount\n     */\n    node(length, nullCount) {\n      nodes.push({ length, nullCount });\n    },\n    /**\n     * @param {TypedArray} b\n     */\n    buffer(b) {\n      const size = b.byteLength;\n      const length = ((size + 7) & ~7);\n      regions.push({ offset: byteLength, length });\n      byteLength += length;\n      buffers.push(new Uint8Array(b.buffer, b.byteOffset, size));\n    },\n    /**\n     * @param {number} length\n     */\n    variadic(length) {\n      variadic.push(length);\n    },\n    /**\n     * @param {DataType} type\n     * @param {Batch} batch\n     */\n    children(type, batch) {\n      // @ts-ignore\n      type.children.forEach((field, index) => {\n        visit(field.type, batch.children[index], this);\n      });\n    },\n    /**\n     * @returns {RecordBatch}\n     */\n    done() {\n      return { byteLength, nodes, regions, variadic, buffers };\n    }\n  };\n}\n\n/**\n * Assemble dictionary batches and their unique ids.\n * @param {Column[]} columns The table columns.\n * @returns {{\n *    dictionaries: DictionaryBatch[],\n *    idMap: Map<DataType, number>\n *  }}\n *  The assembled dictionary batches and a map from dictionary column\n *  instances to dictionary ids.\n */\nfunction assembleDictionaryBatches(columns) {\n  const dictionaries = [];\n  const dictMap = new Map;\n  const idMap = new Map;\n  let id = -1;\n\n  // track dictionaries, key by dictionary column, assign ids\n  const visitor = dictionaryColumn => {\n    if (!dictMap.has(dictionaryColumn)) {\n      dictMap.set(dictionaryColumn, ++id);\n      for (let i = 0; i < dictionaryColumn.data.length; ++i) {\n        dictionaries.push({\n          id,\n          isDelta: i > 0,\n          data: assembleRecordBatch([dictionaryColumn], i)\n        });\n      }\n      idMap.set(dictionaryColumn.type, id);\n    } else {\n      idMap.set(dictionaryColumn.type, dictMap.get(dictionaryColumn));\n    }\n  };\n\n  // recurse through column batches to find dictionaries\n  // it is sufficient to visit the first batch only,\n  // as all batches have the same dictionary column\n  columns.forEach(col => visitDictionaries(col.data[0], visitor));\n\n  return { dictionaries, idMap };\n}\n\n/**\n * Traverse column batches to visit dictionary columns.\n * @param {Batch} batch\n * @param {(column: Column) => void} visitor\n */\nfunction visitDictionaries(batch, visitor) {\n  if (batch?.type.typeId === Type.Dictionary) {\n    // @ts-ignore - batch has type DictionaryBatch\n    const dictionary = batch.dictionary;\n    visitor(dictionary);\n    visitDictionaries(dictionary.data[0], visitor);\n  }\n  batch?.children?.forEach(child => visitDictionaries(child, visitor));\n}\n\n/**\n * Assemble a schema with resolved dictionary ids.\n * @param {Schema} schema The schema.\n * @param {Map<DataType, number>} idMap A map\n *  from dictionary value types to dictionary ids.\n * @returns {Schema} A new schema with resolved\n *  dictionary ids. If there are no dictionaries, the input schema is\n *  returned unchanged.\n */\nfunction assembleSchema(schema, idMap) {\n  // early exit if no dictionaries\n  if (!idMap.size) return schema;\n\n  const visit = type => {\n    if (type.typeId === Type.Dictionary) {\n      type.id = idMap.get(type.dictionary); // lookup and set id\n      visitDictType(type);\n    }\n    if (type.children) {\n      (type.children = type.children.slice()).forEach(visitFields);\n    }\n  };\n\n  // visit a field in a field array\n  const visitFields = (field, index, array) => {\n    const type = { ...field.type };\n    array[index] = { ...field, type };\n    visit(type);\n  };\n\n  // visit a dictionary values type\n  const visitDictType = (parentType) => {\n    const type = { ...parentType.dictionary };\n    parentType.dictionary = type;\n    visit(type);\n  };\n\n  schema = { ...schema, fields: schema.fields.slice() };\n  schema.fields.forEach(visitFields);\n  return schema;\n}\n\n/**\n * Assemble record batches with marshalled buffers.\n * @param {Column[]} columns The table columns.\n * @returns {RecordBatch[]} The assembled record batches.\n */\nfunction assembleRecordBatches(columns) {\n  return (columns[0]?.data || [])\n    .map((_, index) => assembleRecordBatch(columns, index));\n}\n\n/**\n * Assemble a record batch with marshalled buffers.\n * @param {Column[]} columns The table columns.\n * @param {number} batchIndex The batch index.\n * @returns {RecordBatch} The assembled record batch.\n */\nfunction assembleRecordBatch(columns, batchIndex = 0) {\n  const ctx = assembleContext();\n  columns.forEach(column => {\n    visit(column.type, column.data[batchIndex], ctx);\n  });\n  return ctx.done();\n}\n\n/**\n * Visit a column batch, assembling buffer data.\n * @param {DataType} type The data type.\n * @param {Batch} batch The column batch.\n * @param {ReturnType<assembleContext>} ctx The assembly context.\n */\nfunction visit(type, batch, ctx) {\n  const { typeId } = type;\n\n  // record field node info - ALL fields need field nodes, including nulls\n  ctx.node(batch.length, batch.nullCount);\n\n  // null fields have field nodes but no data buffers\n  if (typeId === Type.Null) return;\n\n  switch (typeId) {\n    // validity and value buffers\n    // backing dictionaries handled elsewhere\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Decimal:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n    case Type.Dictionary: // dict key values\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      return;\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.values);\n      return;\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      // @ts-ignore\n      ctx.variadic(batch.data.length);\n      // @ts-ignore\n      batch.data.forEach(b => ctx.buffer(b));\n      return;\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.children(type, batch);\n      return;\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.sizes);\n      ctx.children(type, batch);\n      return;\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      ctx.buffer(batch.validity);\n      ctx.children(type, batch);\n      return;\n\n    // children only\n    case Type.RunEndEncoded:\n      ctx.children(type, batch);\n      return;\n\n    // union\n    case Type.Union: {\n      // @ts-ignore\n      ctx.buffer(batch.typeIds);\n      if (type.mode === UnionMode.Dense) {\n        ctx.buffer(batch.offsets);\n      }\n      ctx.children(type, batch);\n      return;\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","/**\n * @import { TypedArray, TypedArrayConstructor } from '../types.js'\n */\nimport { align, grow, uint8Array } from '../util/arrays.js';\n\n/**\n * Create a new resizable buffer instance.\n * @param {TypedArrayConstructor} [arrayType]\n *  The array type.\n * @returns {Buffer} The buffer.\n */\nexport function buffer(arrayType) {\n  return new Buffer(arrayType);\n}\n\n/**\n * Resizable byte buffer.\n */\nexport class Buffer {\n  /**\n   * Create a new resizable buffer instance.\n   * @param {TypedArrayConstructor} arrayType\n   */\n  constructor(arrayType = uint8Array) {\n    this.buf = new arrayType(512);\n  }\n  /**\n   * Return the underlying data as a 64-bit aligned array of minimum size.\n   * @param {number} size The desired minimum array size.\n   * @returns {TypedArray} The 64-bit aligned array.\n   */\n  array(size) {\n    return align(this.buf, size);\n  }\n  /**\n   * Prepare for writes to the given index, resizing as necessary.\n   * @param {number} index The array index to prepare to write to.\n   */\n  prep(index) {\n    if (index >= this.buf.length) {\n      this.buf = grow(this.buf, index);\n    }\n  }\n  /**\n   * Return the value at the given index.\n   * @param {number} index The array index.\n   */\n  get(index) {\n    return this.buf[index];\n  }\n  /**\n   * Set a value at the given index.\n   * @param {number | bigint} value The value to set.\n   * @param {number} index The index to write to.\n   */\n  set(value, index) {\n    this.prep(index);\n    this.buf[index] = value;\n  }\n  /**\n   * Write a byte array at the given index. The method should be called\n   * only when the underlying buffer is of type Uint8Array.\n   * @param {Uint8Array} bytes The byte array.\n   * @param {number} index The starting index to write to.\n   */\n  write(bytes, index) {\n    this.prep(index + bytes.length);\n    /** @type {Uint8Array} */ (this.buf).set(bytes, index);\n  }\n}\n\n/**\n * Create a new resizable bitmap instance.\n * @returns {Bitmap} The bitmap buffer.\n */\nexport function bitmap() {\n  return new Bitmap();\n}\n\n/**\n * Resizable bitmap buffer.\n */\nexport class Bitmap extends Buffer {\n  /**\n   * Set a bit to true at the given bitmap index.\n   * @param {number} index The index to write to.\n   */\n  set(index) {\n    const i = index >> 3;\n    this.prep(i);\n    /** @type {Uint8Array} */ (this.buf)[i] |= (1 << (index % 8));\n  }\n}\n","/**\n * @import { Batch } from '../../batch.js'\n */\n\n/**\n * Abstract class for building a column data batch.\n */\nexport class BatchBuilder {\n  constructor(type, ctx) {\n    this.type = type;\n    this.ctx = ctx;\n    this.batchClass = ctx.batchType(type);\n  }\n\n  /**\n   * Initialize the builder state.\n   * @returns {this} This builder.\n   */\n  init() {\n    this.index = -1;\n    return this;\n  }\n\n  /**\n   * Write a value to the builder.\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    return false;\n  }\n\n  /**\n   * Returns a batch constructor options object.\n   * Used internally to marshal batch data.\n   * @returns {Record<string, any>}\n   */\n  done() {\n    return null;\n  }\n\n  /**\n   * Returns a completed batch and reinitializes the builder state.\n   * @returns {Batch}\n   */\n  batch() {\n    const b = new this.batchClass(this.done());\n    this.init();\n    return b;\n  }\n}\n","import { uint8Array } from '../../util/arrays.js';\nimport { bitmap } from '../buffer.js';\nimport { BatchBuilder } from './batch.js';\n\n/**\n * Builder for validity bitmaps within batches.\n */\nexport class ValidityBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.validity = bitmap();\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    const isValid = value != null;\n    if (isValid) {\n      this.validity.set(index);\n    } else {\n      this.nullCount++;\n    }\n    return isValid;\n  }\n\n  done() {\n    const { index, nullCount, type, validity } = this;\n    return {\n      length: index + 1,\n      nullCount,\n      type,\n      validity: nullCount\n        ? validity.array((index >> 3) + 1)\n        : new uint8Array(0)\n    };\n  }\n}\n","/**\n * @import { builderContext } from '../builder.js'\n * @import { DictionaryType, ExtractionOptions } from '../../types.js'\n */\nimport { Column } from '../../column.js';\nimport { keyString } from '../../util/strings.js';\nimport { batchType } from '../../batch-type.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Create a context object for managing dictionary builders.\n */\nexport function dictionaryContext() {\n  const idMap = new Map;\n  const dicts = new Set;\n  return {\n    /**\n     * Get a dictionary values builder for the given dictionary type.\n     * @param {DictionaryType} type\n     *  The dictionary type.\n     * @param {*} ctx The builder context.\n     * @returns {ReturnType<dictionaryValues>}\n     */\n    get(type, ctx) {\n      // if a dictionary has a non-negative id, assume it was set\n      // intentionally and track it for potential reuse across columns\n      // otherwise the dictionary is used for a single column only\n      const id = type.id;\n      if (id >= 0 && idMap.has(id)) {\n        return idMap.get(id);\n      } else {\n        const dict = dictionaryValues(type, ctx);\n        if (id >= 0) idMap.set(id, dict);\n        dicts.add(dict);\n        return dict;\n      }\n    },\n    /**\n     * Finish building dictionary values columns and assign them to\n     * their corresponding dictionary batches.\n     * @param {ExtractionOptions} options\n     */\n    finish(options) {\n      dicts.forEach(dict => dict.finish(options));\n    }\n  };\n}\n\n/**\n * Builder helper for creating dictionary values.\n * @param {DictionaryType} type\n *  The dictionary data type.\n * @param {ReturnType<builderContext>} ctx\n *  The builder context.\n */\nexport function dictionaryValues(type, ctx) {\n  const keys = Object.create(null);\n  const values = ctx.builder(type.dictionary);\n  const batches = [];\n\n  values.init();\n  let index = -1;\n\n  return {\n    type,\n    values,\n\n    add(batch) {\n      batches.push(batch);\n      return batch;\n    },\n\n    key(value) {\n      const v = keyString(value);\n      let k = keys[v];\n      if (k === undefined) {\n        keys[v] = k = ++index;\n        values.set(value, k);\n      }\n      return k;\n    },\n\n    finish(options) {\n      const valueType = type.dictionary;\n      const batch = new (batchType(valueType, options))(values.done());\n      const dictionary = new Column([batch]);\n      batches.forEach(batch => batch.setDictionary(dictionary));\n    }\n  };\n}\n\n/**\n * Builder for dictionary-typed data batches.\n */\nexport class DictionaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.dict = ctx.dictionary(type);\n  }\n\n  init() {\n    this.values = buffer(this.type.indices.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(this.dict.key(value), index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n\n  batch() {\n    // register batch with dictionary\n    // batch will be updated when the dictionary is finished\n    return this.dict.add(super.batch());\n  }\n}\n","/**\n * @import { DataType, IntType, UnionType } from '../types.js'\n */\nimport { bool, dateDay, dictionary, field, fixedSizeList, float64, int16, int32, int64, int8, list, nullType, struct, timestamp, utf8 } from '../data-types.js';\nimport { isArray } from '../util/arrays.js';\n\n/**\n * Infer the data type for a given input array.\n * @param {(visitor: (value: any) => void) => void} visit\n *  A function that applies a callback to successive data values.\n * @returns {DataType} The data type.\n */\nexport function inferType(visit) {\n  const profile = profiler();\n  visit(value => profile.add(value));\n  return profile.type();\n}\n\nfunction profiler() {\n  let length = 0;\n  let nullCount = 0;\n  let boolCount = 0;\n  let numberCount = 0;\n  let intCount = 0;\n  let bigintCount = 0;\n  let dateCount = 0;\n  let dayCount = 0;\n  let stringCount = 0;\n  let arrayCount = 0;\n  let structCount = 0;\n  let min = Infinity;\n  let max = -Infinity;\n  let minLength = Infinity;\n  let maxLength = -Infinity;\n  let minBigInt;\n  let maxBigInt;\n  let arrayProfile;\n  let structProfiles = {};\n\n  return {\n    add(value) {\n      length++;\n      if (value == null) {\n        nullCount++;\n        return;\n      }\n      switch (typeof value) {\n        case 'string':\n          stringCount++;\n          break;\n        case 'number':\n          numberCount++;\n          if (value < min) min = value;\n          if (value > max) max = value;\n          if (Number.isInteger(value)) intCount++;\n          break;\n        case 'bigint':\n          bigintCount++;\n          if (minBigInt === undefined) {\n            minBigInt = maxBigInt = value;\n          } else {\n            if (value < minBigInt) minBigInt = value;\n            if (value > maxBigInt) maxBigInt = value;\n          }\n          break;\n        case 'boolean':\n          boolCount++;\n          break;\n        case 'object':\n          if (value instanceof Date) {\n            dateCount++;\n            // 1 day = 1000ms * 60s * 60min * 24hr = 86400000\n            if ((+value % 864e5) === 0) dayCount++;\n          } else if (isArray(value)) {\n            arrayCount++;\n            const len = value.length;\n            if (len < minLength) minLength = len;\n            if (len > maxLength) maxLength = len;\n            arrayProfile ??= profiler();\n            value.forEach(arrayProfile.add);\n          } else {\n            structCount++;\n            for (const key in value) {\n              const fieldProfiler = structProfiles[key]\n                ?? (structProfiles[key] = profiler());\n              fieldProfiler.add(value[key]);\n            }\n          }\n      }\n    },\n    type() {\n      const valid = length - nullCount;\n      return valid === 0 ? nullType()\n        : intCount === valid ? intType(min, max)\n        : numberCount === valid ? float64()\n        : bigintCount === valid ? bigintType(minBigInt, maxBigInt)\n        : boolCount === valid ? bool()\n        : dayCount === valid ? dateDay()\n        : dateCount === valid ? timestamp()\n        : stringCount === valid ? dictionary(utf8())\n        : arrayCount === valid ? arrayType(arrayProfile.type(), minLength, maxLength)\n        : structCount === valid ? struct(\n            Object.entries(structProfiles).map(_ => field(_[0], _[1].type()))\n          )\n        : unionType();\n    }\n  };\n}\n\n/**\n * Return a list or fixed list type.\n * @param {DataType} type The child data type.\n * @param {number} minLength The minumum list length.\n * @param {number} maxLength The maximum list length.\n * @returns {DataType} The data type.\n */\nfunction arrayType(type, minLength, maxLength) {\n  return maxLength === minLength\n    ? fixedSizeList(type, minLength)\n    : list(type);\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @returns {DataType}\n */\nfunction intType(min, max) {\n  const v = Math.max(Math.abs(min) - 1, max);\n  return v < (1 << 7) ? int8()\n    : v < (1 << 15) ? int16()\n    : v < (2 ** 31) ? int32()\n    : float64();\n}\n\n/**\n * @param {bigint} min\n * @param {bigint} max\n * @returns {IntType}\n */\nfunction bigintType(min, max) {\n  const v = -min > max ? -min - 1n : max;\n  if (v >= 2 ** 63) {\n    throw new Error(`BigInt exceeds 64 bits: ${v}`);\n  }\n  return int64();\n}\n\n/**\n * @returns {UnionType}\n */\nfunction unionType() {\n  throw new Error('Mixed types detected, please define a union type.');\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of binary-typed data.\n */\nexport class BinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.toOffset = toOffset(type.offsets);\n  }\n\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    this.values = buffer();\n    this.pos = 0;\n    return super.init();\n  }\n\n  set(value, index) {\n    const { offsets, values, toOffset } = this;\n    if (super.set(value, index)) {\n      values.write(value, this.pos);\n      this.pos += value.length;\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      values: this.values.array(this.pos + 1)\n    };\n  }\n}\n","import { bitmap } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of bool-typed data.\n */\nexport class BoolBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.values = bitmap();\n    return super.init();\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    if (value) this.values.set(index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index >> 3) + 1)\n    }\n  }\n}\n","import { toDecimal } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of decimal-typed data (64-bits or more).\n */\nexport class DecimalBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.scale = 10 ** type.scale;\n    this.stride = type.bitWidth >> 6;\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    const { scale, stride, values } = this;\n    if (super.set(value, index)) {\n      values.prep((index + 1) * stride);\n      // @ts-ignore\n      toDecimal(value, values.buf, index * stride, stride, scale);\n    }\n  }\n\n  done() {\n    const { index, stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array((index + 1) * stride)\n    };\n  }\n}\n","import { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-binary-typed data batches.\n */\nexport class FixedSizeBinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(value, index * this.stride);\n    }\n  }\n\n  done() {\n    const { stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array(stride * (this.index + 1))\n    };\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-list-typed data batches.\n */\nexport class FixedSizeListBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.child = ctx.builder(this.type.children[0].type);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.child.init();\n    return super.init();\n  }\n\n  set(value, index) {\n    const { child, stride } = this;\n    const base = index * stride;\n    if (super.set(value, index)) {\n      for (let i = 0; i < stride; ++i) {\n        child.set(value[i], base + i);\n      }\n    } else {\n      child.index = base + stride;\n    }\n  }\n\n  done() {\n    const { child } = this;\n    return {\n      ...super.done(),\n      children: [ child.batch() ]\n    };\n  }\n}\n","import { toMonthDayNanoBytes } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for day/time interval-typed data batches.\n */\nexport class IntervalDayTimeBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      const i = index << 1;\n      this.values.set(value[0], i);\n      this.values.set(value[1], i + 1);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 1)\n    }\n  }\n}\n\n/**\n * Builder for month/day/nano interval-typed data batches.\n */\nexport class IntervalMonthDayNanoBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(toMonthDayNanoBytes(value), index << 4);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 4)\n    }\n  }\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list data batches.\n */\nexport class AbstractListBuilder extends ValidityBuilder {\n  constructor(type, ctx, child) {\n    super(type, ctx);\n    this.child = child;\n  }\n\n  init() {\n    this.child.init();\n    const offsetType = this.type.offsets;\n    this.offsets = buffer(offsetType);\n    this.toOffset = toOffset(offsetType);\n    this.pos = 0;\n    return super.init();\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      children: [ this.child.batch() ]\n    };\n  }\n}\n\n/**\n * Builder for list-typed data batches.\n */\nexport class ListBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, ctx.builder(type.children[0].type));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      value.forEach(v => child.set(v, this.pos++));\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list-typed data batches.\n */\nexport class AbstractStructBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  done() {\n    const { children } = this;\n    children.forEach(c => c.index = this.index);\n    return {\n      ...super.done(),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for struct-typed data batches.\n */\nexport class StructBuilder extends AbstractStructBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.setters = this.children.map((child, i) => {\n      const name = type.children[i].name;\n      return (value, index) => child.set(value?.[name], index);\n    });\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    const setters = this.setters;\n    for (let i = 0; i < setters.length; ++i) {\n      setters[i](value, index);\n    }\n  }\n}\n","import { AbstractListBuilder } from './list.js';\nimport { AbstractStructBuilder } from './struct.js';\n\n/**\n * Builder for map-typed data batches.\n */\nexport class MapBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, new MapStructBuilder(type.children[0].type, ctx));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      for (const keyValuePair of value) {\n        child.set(keyValuePair, this.pos++);\n      }\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n\n/**\n * Builder for key-value struct batches within a map.\n */\nclass MapStructBuilder extends AbstractStructBuilder {\n  set(value, index) {\n    super.set(value, index);\n    const [key, val] = this.children;\n    key.set(value[0], index);\n    val.set(value[1], index);\n  }\n}\n","import { keyString } from '../../util/strings.js';\nimport { BatchBuilder } from './batch.js';\n\nconst NO_VALUE = {}; // empty object that fails strict equality\n\n/**\n * Builder for run-end-encoded-typed data batches.\n */\nexport class RunEndEncodedBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.pos = 0;\n    this.key = null;\n    this.value = NO_VALUE;\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  next() {\n    const [runs, vals] = this.children;\n    runs.set(this.index + 1, this.pos);\n    vals.set(this.value, this.pos++);\n  }\n\n  set(value, index) {\n    // perform fast strict equality test\n    if (value !== this.value) {\n      // if no match, fallback to key string test\n      const key = keyString(value);\n      if (key !== this.key) {\n        // if key doesn't match, write prior run and update\n        if (this.key) this.next();\n        this.key = key;\n        this.value = value;\n      }\n    }\n    this.index = index;\n  }\n\n  done() {\n    this.next();\n    const { children, index, type } = this;\n    return {\n      length: index + 1,\n      nullCount: 0,\n      type,\n      children: children.map(c => c.batch())\n    };\n  }\n}\n","import { int8Array } from '../../util/arrays.js';\nimport { BatchBuilder } from './batch.js';\nimport { buffer } from '../buffer.js';\n\n/**\n * Abstract class for building union-typed data batches.\n */\nexport class AbstractUnionBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n    this.typeMap = type.typeMap;\n    this.lookup = type.typeIdForValue;\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.typeIds = buffer(int8Array);\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  set(value, index) {\n    const { children, lookup, typeMap, typeIds } = this;\n    this.index = index;\n    const typeId = lookup(value, index);\n    const child = children[typeMap[typeId]];\n    typeIds.set(typeId, index);\n    if (value == null) ++this.nullCount;\n    // @ts-ignore\n    this.update(value, index, child);\n  }\n\n  done() {\n    const { children, nullCount, type, typeIds } = this;\n    const length = this.index + 1;\n    return {\n      length,\n      nullCount,\n      type,\n      typeIds: typeIds.array(length),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for sparse union-typed data batches.\n */\nexport class SparseUnionBuilder extends AbstractUnionBuilder {\n  update(value, index, child) {\n    // update selected child with value\n    // then set all other children to null\n    child.set(value, index);\n    this.children.forEach(c => { if (c !== child) c.set(null, index) });\n  }\n}\n\n/**\n * Builder for dense union-typed data batches.\n */\nexport class DenseUnionBuilder extends AbstractUnionBuilder {\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    return super.init();\n  }\n\n  update(value, index, child) {\n    const offset = child.index + 1;\n    child.set(value, offset);\n    this.offsets.set(offset, index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 1)\n    };\n  }\n}\n","import { encodeUtf8 } from '../../util/strings.js';\nimport { BinaryBuilder } from './binary.js';\n\n/**\n * Builder for utf8-typed data batches.\n */\nexport class Utf8Builder extends BinaryBuilder {\n  set(value, index) {\n    super.set(value && encodeUtf8(value), index);\n  }\n}\n","import { toBigInt } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for data batches that can be accessed directly as typed arrays.\n */\nexport class DirectBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.values = buffer(type.values);\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(value, index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n}\n\n/**\n * Builder for int64/uint64 data batches written as bigints.\n */\nexport class Int64Builder extends DirectBuilder {\n  set(value, index) {\n    super.set(value == null ? value : toBigInt(value), index);\n  }\n}\n\n/**\n * Builder for data batches whose values must pass through a transform\n * function prior to be written to a backing buffer.\n */\nexport class TransformBuilder extends DirectBuilder {\n  constructor(type, ctx, transform) {\n    super(type, ctx);\n    this.transform = transform;\n  }\n  set(value, index) {\n    super.set(value == null ? value : this.transform(value), index);\n  }\n}\n","/**\n * @import { DataType, ExtractionOptions } from '../types.js'\n * @import { BatchBuilder } from './builders/batch.js'\n */\nimport { batchType } from '../batch-type.js';\nimport { IntervalUnit, Type } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { isInt64ArrayType } from '../util/arrays.js';\nimport { toBigInt, toDateDay, toDecimal32, toFloat16, toTimestamp } from '../util/numbers.js';\nimport { BinaryBuilder } from './builders/binary.js';\nimport { BoolBuilder } from './builders/bool.js';\nimport { DecimalBuilder } from './builders/decimal.js';\nimport { DictionaryBuilder, dictionaryContext } from './builders/dictionary.js';\nimport { FixedSizeBinaryBuilder } from './builders/fixed-size-binary.js';\nimport { FixedSizeListBuilder } from './builders/fixed-size-list.js';\nimport { IntervalDayTimeBuilder, IntervalMonthDayNanoBuilder } from './builders/interval.js';\nimport { ListBuilder } from './builders/list.js';\nimport { MapBuilder } from './builders/map.js';\nimport { RunEndEncodedBuilder } from './builders/run-end-encoded.js';\nimport { StructBuilder } from './builders/struct.js';\nimport { DenseUnionBuilder, SparseUnionBuilder } from './builders/union.js';\nimport { Utf8Builder } from './builders/utf8.js';\nimport { DirectBuilder, Int64Builder, TransformBuilder } from './builders/values.js';\n\n/**\n * Create a context object for shared builder state.\n * @param {ExtractionOptions} [options]  Batch extraction options.\n* @param {ReturnType<dictionaryContext>} [dictionaries]\n *  Context object for tracking dictionaries.\n */\nexport function builderContext(\n  options = {},\n  dictionaries = dictionaryContext()\n) {\n  return {\n    batchType: type => batchType(type, options),\n    builder(type) { return builder(type, this); },\n    dictionary(type) { return dictionaries.get(type, this); },\n    finish: () => dictionaries.finish(options)\n  };\n}\n\n/**\n * Returns a batch builder for the given type and builder context.\n * @param {DataType} type A data type.\n * @param {ReturnType<builderContext>} [ctx] A builder context.\n * @returns {BatchBuilder}\n */\nexport function builder(type, ctx = builderContext()) {\n  const { typeId } = type;\n  switch (typeId) {\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return isInt64ArrayType(type.values)\n        ? new Int64Builder(type, ctx)\n        : new DirectBuilder(type, ctx);\n    case Type.Float:\n      return type.precision\n        ? new DirectBuilder(type, ctx)\n        : new TransformBuilder(type, ctx, toFloat16)\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BinaryBuilder(type, ctx);\n    case Type.Utf8:\n    case Type.LargeUtf8:\n      return new Utf8Builder(type, ctx);\n    case Type.Bool:\n      return new BoolBuilder(type, ctx);\n    case Type.Decimal:\n      return type.bitWidth === 32\n        ? new TransformBuilder(type, ctx, toDecimal32(type.scale))\n        : new DecimalBuilder(type, ctx);\n    case Type.Date:\n      return new TransformBuilder(type, ctx, type.unit ? toBigInt : toDateDay);\n    case Type.Timestamp:\n      return new TransformBuilder(type, ctx, toTimestamp(type.unit));\n    case Type.Interval:\n      switch (type.unit) {\n        case IntervalUnit.DAY_TIME:\n          return new IntervalDayTimeBuilder(type, ctx);\n        case IntervalUnit.MONTH_DAY_NANO:\n          return new IntervalMonthDayNanoBuilder(type, ctx);\n      }\n      // case IntervalUnit.YEAR_MONTH:\n      return new DirectBuilder(type, ctx);\n    case Type.List:\n    case Type.LargeList:\n      return new ListBuilder(type, ctx);\n    case Type.Struct:\n      return new StructBuilder(type, ctx);\n    case Type.Union:\n      return type.mode\n        ? new DenseUnionBuilder(type, ctx)\n        : new SparseUnionBuilder(type, ctx);\n    case Type.FixedSizeBinary:\n      return new FixedSizeBinaryBuilder(type, ctx);\n    case Type.FixedSizeList:\n      return new FixedSizeListBuilder(type, ctx);\n    case Type.Map:\n      return new MapBuilder(type, ctx);\n    case Type.RunEndEncoded:\n      return new RunEndEncodedBuilder(type, ctx);\n\n    case Type.Dictionary:\n      return new DictionaryBuilder(type, ctx);\n  }\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // case Type.ListView:\n  // case Type.LargeListView:\n  throw new Error(invalidDataType(typeId));\n}\n","/**\n * @import { ColumnBuilderOptions, DataType, NullType } from '../types.js'\n * @import { dictionaryContext } from './builders/dictionary.js'\n */\nimport { NullBatch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { inferType } from './infer-type.js';\nimport { builder, builderContext } from './builder.js';\nimport { Type } from '../constants.js';\nimport { isIterable } from '../util/objects.js';\n\n/**\n * Create a new column by iterating over provided values.\n * @template T\n * @param {Iterable | ((callback: (value: any) => void) => void)} values\n *  Either an iterable object or a visitor function that applies a callback\n *  to successive data values (akin to Array.forEach).\n * @param {DataType} [type] The data type.\n * @param {ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<dictionaryContext>} [dicts]\n *  Dictionary context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromValues(values, type, options = {}, dicts) {\n  const visit = isIterable(values)\n    ? callback => { for (const value of values) callback(value); }\n    : values;\n\n  type ??= inferType(visit);\n  const { maxBatchRows = Infinity, ...opt } = options;\n  let data;\n\n  if (type.typeId === Type.Null) {\n    let length = 0;\n    visit(() => ++length);\n    data = nullBatches(type, length, maxBatchRows);\n  } else {\n    const ctx = builderContext(opt, dicts);\n    const b = builder(type, ctx).init();\n    const next = b => data.push(b.batch());\n    data = [];\n\n    let row = 0;\n    visit(value => {\n      b.set(value, row++);\n      if (row >= maxBatchRows) {\n        next(b);\n        row = 0;\n      }\n    });\n    if (row) next(b);\n\n    // resolve dictionaries\n    ctx.finish();\n  }\n\n  return new Column(data, type);\n}\n\n/**\n * Create null batches with the given batch size limit.\n * @param {NullType} type The null data type.\n * @param {number} length The total column length.\n * @param {number} limit The maximum batch size.\n * @returns {NullBatch[]} The null batches.\n */\nfunction nullBatches(type, length, limit) {\n  const data = [];\n  const batch = length => new NullBatch({ length, nullCount: length, type });\n  const numBatches = Math.floor(length / limit);\n  for (let i = 0; i < numBatches; ++i) {\n    data.push(batch(limit));\n  }\n  const rem = length % limit;\n  if (rem) data.push(batch(rem));\n  return data;\n}\n","/**\n * @import { ColumnBuilderOptions, DataType, TypedArray, TypedArrayConstructor } from '../types.js'\n * @import { dictionaryContext } from './builders/dictionary.js'\n */\nimport { float32Array, float64Array, int16Array, int32Array, int64Array, int8Array, isInt64ArrayType, isTypedArray, uint16Array, uint32Array, uint64Array, uint8Array } from '../util/arrays.js';\nimport { DirectBatch, Int64Batch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { float32, float64, int16, int32, int64, int8, uint16, uint32, uint64, uint8 } from '../data-types.js';\nimport { columnFromValues } from './column-from-values.js';\n\n/**\n * Create a new column from a provided data array.\n * @template T\n * @param {Array | TypedArray} array The input data.\n * @param {DataType} [type] The data type.\n *  If not specified, type inference is attempted.\n * @param {ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<dictionaryContext>} [dicts]\n *  Builder context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromArray(array, type, options = {}, dicts) {\n  return !type && isTypedArray(array)\n    ? columnFromTypedArray(array, options)\n    : columnFromValues(v => array.forEach(v), type, options, dicts);\n}\n\n/**\n * Create a new column from a typed array input.\n * @template T\n * @param {TypedArray} values The input data.\n * @param {ColumnBuilderOptions} options\n *  Builder options for the generated column.\n * @returns {Column<T>} The generated column.\n */\nfunction columnFromTypedArray(values, { maxBatchRows, useBigInt }) {\n  const arrayType = /** @type {TypedArrayConstructor} */ (\n    values.constructor\n  );\n  const type = typeForTypedArray(arrayType);\n  const length = values.length;\n  const limit = Math.min(maxBatchRows || Infinity, length);\n  const numBatches = Math.floor(length / limit);\n\n  const batches = [];\n  const batchType = isInt64ArrayType(arrayType) && !useBigInt ? Int64Batch : DirectBatch;\n  const add = (start, end) => batches.push(new batchType({\n    length: end - start,\n    nullCount: 0,\n    type,\n    validity: new uint8Array(0),\n    values: values.subarray(start, end)\n  }));\n\n  let idx = 0;\n  for (let i = 0; i < numBatches; ++i) add(idx, idx += limit);\n  if (idx < length) add(idx, length);\n\n  return new Column(batches);\n}\n\n/**\n * Return an Arrow data type for a given typed array type.\n * @param {TypedArrayConstructor} arrayType The typed array type.\n * @returns {DataType} The data type.\n */\nfunction typeForTypedArray(arrayType) {\n  switch (arrayType) {\n    case float32Array: return float32();\n    case float64Array: return float64();\n    case int8Array: return int8();\n    case int16Array: return int16();\n    case int32Array: return int32();\n    case int64Array: return int64();\n    case uint8Array: return uint8();\n    case uint16Array: return uint16();\n    case uint32Array: return uint32();\n    case uint64Array: return uint64();\n  }\n}\n","/**\n * @import { Column } from '../column.js'\n */\nimport { Endianness, Version } from '../constants.js';\nimport { field } from '../data-types.js';\nimport { Table } from '../table.js';\n\n/**\n * Create a new table from a collection of columns. Columns are assumed\n * to have the same record batch sizes.\n * @param {[string, Column][] | Record<string, Column>} data The columns,\n *  as an object with name keys, or an array of [name, column] pairs.\n * @param {boolean} [useProxy] Flag indicating if row proxy\n *  objects should be used to represent table rows (default `false`).\n * @returns {Table} The new table.\n */\nexport function tableFromColumns(data, useProxy) {\n  const fields = [];\n  const entries = Array.isArray(data) ? data : Object.entries(data);\n  const length = entries[0]?.[1].length;\n\n  const columns = entries.map(([name, col]) => {\n    if (col.length !== length) {\n      throw new Error('All columns must have the same length.');\n    }\n    fields.push(field(name, col.type));\n    return col;\n  });\n\n  const schema = {\n    version: Version.V5,\n    endianness: Endianness.Little,\n    fields,\n    metadata: null\n  };\n\n  return new Table(schema, columns, useProxy);\n}\n","import { isFunction } from '../../util/is-function.js';\n\n/**\n * Return a potentially filtered list of column names.\n * @param {import('../../table/Table.js').Table} table A data table.\n * @param {import('../types.js').ColumnSelectOptions} names The column names to select.\n * @returns {string[]} The selected column names.\n */\nexport function columns(table, names) {\n  // @ts-ignore\n  return isFunction(names) ? names(table)\n    : names || table.columnNames();\n}\n","import { columnFromArray, columnFromValues, tableFromColumns } from '@uwdata/flechette';\nimport { isArrayType } from '../util/is-array-type.js';\nimport { isFunction } from '../util/is-function.js';\nimport { columns as select } from './util/columns.js';\n\n/**\n * Create an Apache Arrow table for an input table.\n * @param {import('../table/Table.js').Table} table\n *  An input Arquero table to convert to Arrow format.\n * @param {import('./types.js').ArrowFormatOptions} [options]\n *  Encoding options, including column data types.\n * @return {import('@uwdata/flechette').Table} An Arrow Table instance.\n */\nexport function toArrow(table, options = {}) {\n  const { columns, limit = Infinity, offset = 0, types = {}, ...opt } = options;\n  const names = select(table, columns);\n  const data = table.data();\n\n  // make a full table scan with no indirection?\n  const fullScan = offset === 0\n    && table.numRows() <= limit\n    && !table.isFiltered()\n    && !table.isOrdered();\n\n  return tableFromColumns(names.map(name => {\n    const values = data[name];\n    const type = types[name];\n    const isArray = isArrayType(values);\n    let col;\n    if (fullScan && (isArray || isFunction(values.toArray))) {\n      // @ts-ignore - use faster path, takes advantange of typed arrays\n      col = columnFromArray(isArray ? values : values.toArray(), type, opt);\n    } else {\n      // use table scan method to visit column values\n      const get = isArray\n        ? row => values[row]\n        : row => values.at(row);\n      col = columnFromValues(\n        visit => table.scan(row => visit(get(row)), true, limit, offset),\n        type,\n        opt\n      );\n    }\n    return [name, col];\n  }));\n}\n","import { tableToIPC } from '@uwdata/flechette';\nimport { toArrow } from './to-arrow.js';\n\n/**\n * Format a table as binary data in the Apache Arrow IPC format.\n * @param {import('../table/Table.js').Table} data The table data\n * @param {import('./types.js').ArrowIPCFormatOptions} [options]\n *  The Arrow IPC formatting options. Set the *format* option to `'stream'`\n *  or `'file'` to specify the IPC format.\n * @return {Uint8Array} A new Uint8Array of Arrow-encoded binary data.\n */\nexport function toArrowIPC(data, options = {}) {\n  const { format = 'stream', ...toArrowOptions } = options;\n  return tableToIPC(toArrow(data, toArrowOptions), { format });\n}\n","export function identity(x) {\n  return x;\n}\n","import { identity } from '../../util/identity.js';\n\nexport function scan(table, names, limit = 100, offset, ctx) {\n  const { start = identity, cell, end = identity } = ctx;\n  const data = table.data();\n  const n = names.length;\n  table.scan(row => {\n    start(row);\n    for (let i = 0; i < n; ++i) {\n      const name = names[i];\n      cell(data[name].at(row), name, i);\n    }\n    end(row);\n  }, true, limit, offset);\n}\n","import { formatUTCDate } from '../util/format-date.js';\nimport { isDate } from '../util/is-date.js';\nimport { columns } from './util/columns.js';\nimport { scan } from './util/scan.js';\n\n/**\n * Options for CSV formatting.\n * @typedef {object} CSVFormatOptions\n * @property {string} [delimiter=','] The delimiter between values.\n * @property {boolean} [header=true] Flag to specify presence of header row.\n *  If true, includes a header row with column names.\n *  If false, the header is omitted.\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {Object.<string, (value: any) => any>} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions to invoke to transform column values prior\n *  to output. If specified, these override automatically inferred options.\n */\n\n/**\n * Format a table as a comma-separated values (CSV) string. Other\n * delimiters, such as tabs or pipes ('|'), can be specified using\n * the options argument.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {CSVFormatOptions} options The formatting options.\n * @return {string} A delimited-value format string.\n */\nexport function toCSV(table, options = {}) {\n  const names = columns(table, options.columns);\n  const format = options.format || {};\n  const delim = options.delimiter || ',';\n  const header = options.header ?? true;\n  const reFormat = new RegExp(`[\"${delim}\\n\\r]`);\n\n  const formatValue = value => value == null ? ''\n    : isDate(value) ? formatUTCDate(value, true)\n    : reFormat.test(value += '') ? '\"' + value.replace(/\"/g, '\"\"') + '\"'\n    : value;\n\n  const vals = names.map(formatValue);\n  let text = header ? (vals.join(delim) + '\\n') : '';\n\n  scan(table, names, options.limit || Infinity, options.offset, {\n    cell(value, name, index) {\n      vals[index] = formatValue(format[name] ? format[name](value) : value);\n    },\n    end() {\n      text += vals.join(delim) + '\\n';\n    }\n  });\n\n  return text;\n}\n","export function mapObject(obj, fn, output = {}) {\n  for (const key in obj) {\n    output[key] = fn(obj[key], key);\n  }\n  return output;\n}\n","import { isDate } from '../../util/is-date.js';\n\nfunction isExactDateUTC(d) {\n  return d.getUTCHours() === 0\n    && d.getUTCMinutes() === 0\n    && d.getUTCSeconds() === 0\n    && d.getUTCMilliseconds() === 0;\n}\n\nexport function inferFormat(scan, options = {}) {\n  let count = 0;\n  let nulls = 0;\n  let dates = 0;\n  let dutcs = 0;\n  let nums = 0;\n  let digits = 0;\n\n  scan(value => {\n    ++count;\n    if (value == null) {\n      ++nulls;\n      return;\n    }\n\n    const type = typeof value;\n    if (type === 'object' && isDate(value)) {\n      ++dates;\n      if (isExactDateUTC(value)) ++dutcs;\n    } else if (type === 'number') {\n      ++nums;\n      if (value === value &&  (value | 0) !== value) {\n        const s = value + '';\n        const p = s.indexOf('.');\n        if (p >= 0) {\n          const e = s.indexOf('e');\n          const l = e > 0 ? e : s.length;\n          digits = Math.max(digits, l - p - 1);\n        }\n      }\n    }\n  });\n\n  return {\n    align:  (nulls + nums + dates) / count > 0.5 ? 'r' : 'l',\n    format: {\n      utc:    dates === dutcs,\n      digits: Math.min(digits, options.maxdigits || 6)\n    }\n  };\n}\n","import { inferFormat } from './infer.js';\n\nexport function formats(table, names, options) {\n  const formatOpt = options.format || {};\n  const alignOpt = options.align || {};\n  const format = {};\n  const align = {};\n\n  names.forEach(name => {\n    const auto = inferFormat(values(table, name), options);\n    align[name] = alignOpt[name] || auto.align;\n    format[name] = formatOpt[name] || auto.format;\n  });\n\n  return { align, format };\n}\n\nfunction values(table, columnName) {\n  const column = table.column(columnName);\n  return fn => table.scan(row => fn(column.at(row)));\n}\n","import { formatDate, formatUTCDate } from '../../util/format-date.js';\nimport { isDate } from '../../util/is-date.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { isTypedArray } from '../../util/is-typed-array.js';\n\n/**\n * Format a value as a string.\n * @param {*} v The value to format.\n * @param {import('../types.js').ValueFormatOptions} options Formatting options.\n * @return {string} The formatted string.\n */\nexport function formatValue(v, options = {}) {\n  if (isFunction(options)) {\n    // @ts-ignore\n    return options(v) + '';\n  }\n\n  const type = typeof v;\n\n  if (type === 'object') {\n    if (isDate(v)) {\n      // @ts-ignore\n      return options.utc ? formatUTCDate(v) : formatDate(v);\n    } else {\n      const s = JSON.stringify(\n        v,\n        // @ts-ignore\n        (k, v) => isTypedArray(v) ? Array.from(v) : v\n      );\n      // @ts-ignore\n      const maxlen = options.maxlen || 30;\n      return s.length > maxlen\n        ? s.slice(0, 28) + '\\u2026' + (s[0] === '[' ? ']' : '}')\n        : s;\n    }\n  } else if (type === 'number') {\n    // @ts-ignore\n    const digits = options.digits || 0;\n    let a;\n    return v !== 0 && ((a = Math.abs(v)) >= 1e18 || a < Math.pow(10, -digits))\n      ? v.toExponential(digits)\n      : v.toFixed(digits);\n  } else {\n    return v + '';\n  }\n}\n","import { isFunction } from '../util/is-function.js';\nimport { mapObject } from '../util/map-object.js';\nimport { columns } from './util/columns.js';\nimport { formats } from './util/formats.js';\nimport { formatValue } from './util/format-value.js';\nimport { scan } from './util/scan.js';\n\n/**\n * Null format function.\n * @callback NullFormat\n * @param {null|undefined} [value] The value to format.\n * @return {string} The formatted HTML string.\n */\n\n/**\n * CSS style function.\n * @callback StyleFunction\n * @param {string} name The column name.\n * @param {number} row The table row index.\n * @return {string} A CSS style string.\n */\n\n/**\n * CSS style options.\n * @typedef {Object.<string, string | StyleFunction>} StyleOptions\n */\n\n/**\n * Options for HTML formatting.\n * @typedef {object} HTMLFormatOptions\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {import('./types.js').ColumnAlignOptions} [align] Object of column\n *  alignment options. The object keys should be column names. The object\n *  values should be aligment strings, one of 'l' (left), 'c' (center), or\n *  'r' (right). If specified, these override automatically inferred options.\n * @property {import('./types.js').ColumnFormatOptions} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions or specification objects. If specified,\n *  these override automatically inferred options.\n * @property {NullFormat} [null] Format function for null or undefined values.\n *  If specified, this function will be invoked with the null or undefined\n *  value as the sole input, and the return value will be used as the HTML\n *  output for the value.\n * @property {StyleOptions} [style] CSS styles to include in HTML output.\n *  The object keys should be HTML table tag names: 'table', 'thead',\n *  'tbody', 'tr', 'th', or 'td'. The object values should be strings of\n *  valid CSS style directives (such as \"font-weight: bold;\") or functions\n *  that take a column name and row as inputs and return a CSS string.\n * @property {number} [maxdigits=6] The maximum number of fractional digits\n *  to include when formatting numbers. This option is passed to the format\n *  inference method and is overridden by any explicit format options.\n */\n\n/**\n * Format a table as an HTML table string.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {HTMLFormatOptions} options The formatting options.\n * @return {string} An HTML table string.\n */\nexport function toHTML(table, options = {}) {\n  const names = columns(table, options.columns);\n  const { align, format } = formats(table, names, options);\n  const style = styles(options);\n  const nullish = options.null;\n\n  const alignValue = a => a === 'c' ? 'center' : a === 'r' ? 'right' : 'left';\n  const escape = s => s.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n  const baseFormat = (value, opt) => escape(formatValue(value, opt));\n  const formatter = nullish\n    ? (value, opt) => value == null ? nullish(value) : baseFormat(value, opt)\n    : baseFormat;\n\n  let r = -1;\n  let idx = -1;\n\n  const tag = (tag, name, shouldAlign) => {\n    const a = shouldAlign ? alignValue(align[name]) : '';\n    const s = style[tag] ? (style[tag](name, idx, r) || '') : '';\n    const css = (a ? (`text-align: ${a};` + (s ? ' ' : '')) : '') + s;\n    return `<${tag}${css ? ` style=\"${css}\"` : ''}>`;\n  };\n\n  let text = tag('table')\n    + tag('thead')\n    + tag('tr', r)\n    + names.map(name => `${tag('th', name, 1)}${name}</th>`).join('')\n    + '</tr></thead>'\n    + tag('tbody');\n\n  scan(table, names, options.limit, options.offset, {\n    start(row) {\n      r = row;\n      ++idx;\n      text += tag('tr');\n    },\n    cell(value, name) {\n      text += tag('td', name, 1)\n        + formatter(value, format[name])\n        + '</td>';\n    },\n    end() {\n      text += '</tr>';\n    }\n  });\n\n  return text + '</tbody></table>';\n}\n\nfunction styles(options) {\n  return mapObject(\n    options.style,\n    value => isFunction(value) ? value : () => value\n  );\n}\n","export const EOL = {};\nexport const BREAK = {};\nexport const QUOTE = 34;\nexport const NEWLINE = 10;\nexport const RETURN = 13;\n\nexport const COLUMNS = 'columns';\nexport const NDJSON = 'ndjson';\nexport const ROWS = 'rows';\n","import { formatUTCDate } from '../util/format-date.js';\nimport { identity } from '../util/identity.js';\nimport { isDate } from '../util/is-date.js';\nimport { COLUMNS, NDJSON } from './stream/constants.js';\nimport { columns } from './util/columns.js';\n\n/**\n * Options for JSON formatting.\n * @typedef {object} JSONFormatOptions\n * @property {'columns' | 'rows' | 'ndjson' | null} [type] The format type.\n *  One of `'columns'` (for an object with named column arrays)`, 'rows'` (for\n *  an array for row objects), or `'ndjson'` for [newline-delimited JSON][1]\n *  rows. For `'ndjson'`, each line of text will contain a JSON row object\n *  (with no trailing comma) and string properties will be stripped of any\n *  newline characters. If no format type is specified, defaults to `'rows'`.\n *\n *  [1]: https://github.com/ndjson/ndjson-spec\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial\n *  rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {Object.<string, (value: any) => any>} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions to invoke to transform column values prior\n *  to output. If specified, these override automatically inferred options.\n */\n\nconst defaultFormatter = value => isDate(value)\n  ? formatUTCDate(value, true)\n  : value;\n\n/**\n * Format a table as a JavaScript Object Notation (JSON) string.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {JSONFormatOptions} options The formatting options.\n * @return {string} A JSON string.\n */\nexport function toJSON(table, {\n  type,\n  columns: cols,\n  format = {},\n  limit,\n  offset\n} = {}) {\n  const names = columns(table, cols);\n  const fmt = names.map(name => format[name] || defaultFormatter);\n  const scan = fn => table.scan(fn, true, limit, offset);\n\n  return type === COLUMNS\n    ? toColumns(table, names, fmt, scan)\n    : toRows(table, names, fmt, scan, type === NDJSON);\n}\n\nfunction toColumns(table, names, format, scan) {\n  let text = '{';\n\n  names.forEach((name, i) => {\n    text += (i ? ',' : '') + JSON.stringify(name) + ':[';\n\n    const column = table.column(name);\n    const formatter = format[i];\n    let r = -1;\n    scan(row => {\n      const value = column.at(row);\n      text += (++r ? ',' : '') + JSON.stringify(formatter(value));\n    });\n\n    text += ']';\n  });\n\n  return text + '}';\n}\n\nfunction toRows(table, names, format, scan, nd = false) {\n  const n = names.length;\n  const keys = names.map(name => `\"${name}\":`);\n  const cols = names.map(name => table.column(name));\n\n  const finish = nd ? o => o.replaceAll('\\n', '') : identity;\n  const sep = nd ? '\\n' : ',';\n  let text = nd ? '' : '[';\n\n  let r = -1;\n  scan(row => {\n    const props = [];\n    for (let i = 0; i < n; ++i) {\n      props.push(keys[i] + JSON.stringify(format[i](cols[i].at(row))));\n    }\n    text += (++r ? sep : '') + finish(`{${props.join(',')}}`);\n  });\n\n  return text + (nd ? '' : ']');\n}\n","import { columns } from './util/columns.js';\nimport { formats } from './util/formats.js';\nimport { formatValue } from './util/format-value.js';\nimport { scan } from './util/scan.js';\n\n/**\n * Options for Markdown formatting.\n * @typedef {object} MarkdownFormatOptions\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial\n *  rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {import('./types.js').ColumnAlignOptions} [align] Object of column\n *  alignment options. The object keys should be column names. The object\n *  values should be aligment strings, one of 'l' (left), 'c' (center), or\n *  'r' (right). If specified, these override automatically inferred options.\n * @property {import('./types.js').ColumnFormatOptions} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions or specification objects. If specified,\n *  these override automatically inferred options.\n * @property {number} [maxdigits=6] The maximum number of fractional digits\n *  to include when formatting numbers. This option is passed to the format\n *  inference method and is overridden by any explicit format options.\n */\n\n/**\n * Format a table as a GitHub-Flavored Markdown table string.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {MarkdownFormatOptions} options The formatting options.\n * @return {string} A GitHub-Flavored Markdown table string.\n */\nexport function toMarkdown(table, options = {}) {\n  const names = columns(table, options.columns);\n  const { align, format } = formats(table, names, options);\n\n  const alignValue = a => a === 'c' ? ':-:' : a === 'r' ? '-:' : ':-';\n  const escape = s => s.replace(/\\|/g, '\\\\|');\n\n  let text = '|'\n    + names.map(escape).join('|')\n    + '|\\n|'\n    + names.map(name => alignValue(align[name])).join('|')\n    + '|\\n';\n\n  scan(table, names, options.limit, options.offset, {\n    start() {\n      text += '|';\n    },\n    cell(value, name) {\n      text += escape(formatValue(value, format[name])) + '|';\n    },\n    end() {\n      text += '\\n';\n    }\n  });\n\n  return text;\n}\n","import { Table } from './Table.js';\nimport {\n  antijoin,\n  assign,\n  concat,\n  cross,\n  dedupe,\n  derive,\n  except,\n  filter,\n  fold,\n  groupby,\n  impute,\n  intersect,\n  join,\n  lookup,\n  orderby,\n  pivot,\n  reduce,\n  relocate,\n  rename,\n  rollup,\n  sample,\n  select,\n  semijoin,\n  slice,\n  spread,\n  ungroup,\n  union,\n  unorder,\n  unroll\n} from '../verbs/index.js';\nimport { count } from '../op/op-api.js';\nimport { toArrow } from '../format/to-arrow.js';\nimport { toArrowIPC } from '../format/to-arrow-ipc.js';\nimport { toCSV } from '../format/to-csv.js';\nimport { toHTML } from '../format/to-html.js';\nimport { toJSON } from '../format/to-json.js';\nimport { toMarkdown } from '../format/to-markdown.js';\nimport { toArray } from '../util/to-array.js';\n\n/**\n * A data table with transformation verbs.\n */\nexport class ColumnTable extends Table {\n  /**\n   * Create a new table with additional columns drawn from one or more input\n   * tables. All tables must have the same numer of rows and are reified\n   * prior to assignment. In the case of repeated column names, input table\n   * columns overwrite existing columns.\n   * @param {...(Table|import('./types.js').ColumnData)} tables\n   *  The tables to merge with this table.\n   * @return {this} A new table with merged columns.\n   * @example table.assign(table1, table2)\n   */\n  assign(...tables) {\n    return assign(this, ...tables);\n  }\n\n  /**\n   * Count the number of values in a group. This method is a shorthand\n   * for *rollup* with a count aggregate function.\n   * @param {import('./types.js').CountOptions} [options]\n   *  Options for the count.\n   * @return {this} A new table with groupby and count columns.\n   * @example table.groupby('colA').count()\n   * @example table.groupby('colA').count({ as: 'num' })\n   */\n  count(options = {}) {\n    const { as = 'count' } = options;\n    return rollup(this, { [as]: count() });\n  }\n\n  /**\n   * Derive new column values based on the provided expressions. By default,\n   * new columns are added after (higher indices than) existing columns. Use\n   * the before or after options to place new columns elsewhere.\n   * @param {import('./types.js').ExprObject} values\n   *  Object of name-value pairs defining the columns to derive. The input\n   *  object should have output column names for keys and table expressions\n   *  for values.\n   * @param {import('./types.js').DeriveOptions} [options]\n   *  Options for dropping or relocating derived columns. Use either a before\n   *  or after property to indicate where to place derived columns. Specifying\n   *  both before and after is an error. Unlike the *relocate* verb, this\n   *  option affects only new columns; updated columns with existing names\n   *  are excluded from relocation.\n   * @return {this} A new table with derived columns added.\n   * @example table.derive({ sumXY: d => d.x + d.y })\n   * @example table.derive({ z: d => d.x * d.y }, { before: 'x' })\n   */\n  derive(values, options) {\n    return derive(this, values, options);\n  }\n\n  /**\n   * Filter a table to a subset of rows based on the input criteria.\n   * The resulting table provides a filtered view over the original data; no\n   * data copy is made. To create a table that copies only filtered data to\n   * new data structures, call *reify* on the output table.\n   * @param {import('./types.js').TableExpr} criteria\n   *  Filter criteria as a table expression. Both aggregate and window\n   *  functions are permitted, taking into account *groupby* or *orderby*\n   *  settings.\n   * @return {this} A new table with filtered rows.\n   * @example table.filter(d => abs(d.value) < 5)\n   */\n  filter(criteria) {\n    return filter(this, criteria);\n  }\n\n  /**\n   * Extract rows with indices from start to end (end not included), where\n   * start and end represent per-group ordered row numbers in the table.\n   * @param {number} [start] Zero-based index at which to start extraction.\n   *  A negative index indicates an offset from the end of the group.\n   *  If start is undefined, slice starts from the index 0.\n   * @param {number} [end] Zero-based index before which to end extraction.\n   *  A negative index indicates an offset from the end of the group.\n   *  If end is omitted, slice extracts through the end of the group.\n   * @return {this} A new table with sliced rows.\n   * @example table.slice(1, -1)\n   */\n  slice(start, end) {\n    return slice(this, start, end);\n  }\n\n  /**\n   * Group table rows based on a set of column values.\n   * Subsequent operations that are sensitive to grouping (such as\n   * aggregate functions) will operate over the grouped rows.\n   * To undo grouping, use *ungroup*.\n   * @param  {...import('./types.js').ExprList} keys\n   *  Key column values to group by. The keys may be specified using column\n   *  name strings, column index numbers, value objects with output column\n   *  names for keys and table expressions for values, or selection helper\n   *  functions.\n   * @return {this} A new table with grouped rows.\n   * @example table.groupby('colA', 'colB')\n   * @example table.groupby({ key: d => d.colA + d.colB })\n   */\n  groupby(...keys) {\n    return groupby(this, ...keys);\n  }\n\n  /**\n   * Order table rows based on a set of column values. Subsequent operations\n   * sensitive to ordering (such as window functions) will operate over sorted\n   * values. The resulting table provides an view over the original data,\n   * without any copying. To create a table with sorted data copied to new\n   * data strucures, call *reify* on the result of this method. To undo\n   * ordering, use *unorder*.\n   * @param  {...import('./types.js').OrderKeys} keys\n   *  Key values to sort by, in precedence order.\n   *  By default, sorting is done in ascending order.\n   *  To sort in descending order, wrap values using *desc*.\n   *  If a string, order by the column with that name.\n   *  If a number, order by the column with that index.\n   *  If a function, must be a valid table expression; aggregate functions\n   *  are permitted, but window functions are not.\n   *  If an object, object values must be valid values parameters\n   *  with output column names for keys and table expressions\n   *  for values (the output names will be ignored).\n   *  If an array, array values must be valid key parameters.\n   * @return {this} A new ordered table.\n   * @example table.orderby('a', desc('b'))\n   * @example table.orderby({ a: 'a', b: desc('b') )})\n   * @example table.orderby(desc(d => d.a))\n   */\n  orderby(...keys) {\n    return orderby(this, ...keys);\n  }\n\n  /**\n   * Relocate a subset of columns to change their positions, also\n   * potentially renaming them.\n   * @param {import('./types.js').Select} columns\n   *  An ordered selection of columns to relocate.\n   *  The input may consist of column name strings, column integer indices,\n   *  rename objects with current column names as keys and new column names\n   *  as values, or functions that take a table as input and returns a valid\n   *  selection parameter (typically the output of selection helper functions\n   *  such as *all*, *not*, or *range*).\n   * @param {import('./types.js').RelocateOptions} options\n   *  Options for relocating. Must include either the before or after property\n   *  to indicate where to place the relocated columns. Specifying both before\n   *  and after is an error.\n   * @return {this} A new table with relocated columns.\n   * @example table.relocate(['colY', 'colZ'], { after: 'colX' })\n   * @example table.relocate(not('colB', 'colC'), { before: 'colA' })\n   * @example table.relocate({ colA: 'newA', colB: 'newB' }, { after: 'colC' })\n   */\n  relocate(columns, options) {\n    return relocate(this, toArray(columns), options);\n  }\n\n  /**\n   * Rename one or more columns, preserving column order.\n   * @param {...import('./types.js').Select} columns\n   *  One or more rename objects with current column names as keys and new\n   *  column names as values.\n   * @return {this} A new table with renamed columns.\n   * @example table.rename({ oldName: 'newName' })\n   * @example table.rename({ a: 'a2', b: 'b2' })\n   */\n  rename(...columns) {\n    return rename(this, ...columns);\n  }\n\n  /**\n   * Reduce a table, processing all rows to produce a new table.\n   * To produce standard aggregate summaries, use the rollup verb.\n   * This method allows the use of custom reducer implementations,\n   * for example to produce multiple rows for an aggregate.\n   * @param {import('../verbs/reduce/reducer.js').Reducer} reducer\n   *  The reducer to apply.\n   * @return {this} A new table of reducer outputs.\n   */\n  reduce(reducer) {\n    return reduce(this, reducer);\n  }\n\n  /**\n   * Rollup a table to produce an aggregate summary.\n   * Often used in conjunction with *groupby*.\n   * To produce counts only, *count* is a shortcut.\n   * @param {import('./types.js').ExprObject} [values]\n   *  Object of name-value pairs defining aggregate output columns. The input\n   *  object should have output column names for keys and table expressions\n   *  for values. The expressions must be valid aggregate expressions: window\n   *  functions are not allowed and column references must be arguments to\n   *  aggregate functions.\n   * @return {this} A new table of aggregate summary values.\n   * @example table.groupby('colA').rollup({ mean: d => mean(d.colB) })\n   * @example table.groupby('colA').rollup({ mean: op.median('colB') })\n   */\n  rollup(values) {\n    return rollup(this, values);\n  }\n\n  /**\n   * Generate a table from a random sample of rows.\n   * If the table is grouped, performs a stratified sample by\n   * sampling from each group separately.\n   * @param {number | import('./types.js').TableExpr} size\n   *  The number of samples to draw per group.\n   *  If number-valued, the same sample size is used for each group.\n   *  If function-valued, the input should be an aggregate table\n   *  expression compatible with *rollup*.\n   * @param {import('./types.js').SampleOptions} [options]\n   *  Options for sampling.\n   * @return {this} A new table with sampled rows.\n   * @example table.sample(50)\n   * @example table.sample(100, { replace: true })\n   * @example table.groupby('colA').sample(() => op.floor(0.5 * op.count()))\n   */\n  sample(size, options) {\n    return sample(this, size, options);\n  }\n\n  /**\n   * Select a subset of columns into a new table, potentially renaming them.\n   * @param {...import('./types.js').Select} columns\n   *  An ordered selection of columns.\n   *  The input may consist of column name strings, column integer indices,\n   *  rename objects with current column names as keys and new column names\n   *  as values, or functions that take a table as input and returns a valid\n   *  selection parameter (typically the output of selection helper functions\n   *  such as *all*, *not*, or *range*.).\n   * @return {this} A new table of selected columns.\n   * @example table.select('colA', 'colB')\n   * @example table.select(not('colB', 'colC'))\n   * @example table.select({ colA: 'newA', colB: 'newB' })\n   */\n  select(...columns) {\n    return select(this, ...columns);\n  }\n\n  /**\n   * Ungroup a table, removing any grouping criteria.\n   * Undoes the effects of *groupby*.\n   * @return {this} A new ungrouped table, or this table if not grouped.\n   * @example table.ungroup()\n   */\n  ungroup() {\n    return ungroup(this);\n  }\n\n  /**\n   * Unorder a table, removing any sorting criteria.\n   * Undoes the effects of *orderby*.\n   * @return {this} A new unordered table, or this table if not ordered.\n   * @example table.unorder()\n   */\n  unorder() {\n    return unorder(this);\n  }\n\n  // -- Cleaning Verbs ------------------------------------------------------\n\n  /**\n   * De-duplicate table rows by removing repeated row values.\n   * @param {...import('./types.js').ExprList} keys\n   *  Key columns to check for duplicates.\n   *  Two rows are considered duplicates if they have matching values for\n   *  all keys. If keys are unspecified, all columns are used.\n   *  The keys may be specified using column name strings, column index\n   *  numbers, value objects with output column names for keys and table\n   *  expressions for values, or selection helper functions.\n   * @return {this} A new de-duplicated table.\n   * @example table.dedupe()\n   * @example table.dedupe('a', 'b')\n   * @example table.dedupe({ abs: d => op.abs(d.a) })\n   */\n  dedupe(...keys) {\n    return dedupe(this, ...keys);\n  }\n\n  /**\n   * Impute missing values or rows. Accepts a set of column-expression pairs\n   * and evaluates the expressions to replace any missing (null, undefined,\n   * or NaN) values in the original column.\n   * If the expand option is specified, imputes new rows for missing\n   * combinations of values. All combinations of key values (a full cross\n   * product) are considered for each level of grouping (specified by\n   * *groupby*). New rows will be added for any combination\n   * of key and groupby values not already contained in the table. For all\n   * non-key and non-group columns the new rows are populated with imputation\n   * values (first argument) if specified, otherwise undefined.\n   * If the expand option is specified, any filter or orderby settings are\n   * removed from the output table, but groupby settings persist.\n   * @param {import('./types.js').ExprObject} values\n   *  Object of name-value pairs for the column values to impute. The input\n   *  object should have existing column names for keys and table expressions\n   *  for values. The expressions will be evaluated to determine replacements\n   *  for any missing values.\n   * @param {import('./types.js').ImputeOptions} [options] Imputation options.\n   *  The expand property specifies a set of column values to consider for\n   *  imputing missing rows. All combinations of expanded values are\n   *  considered, and new rows are added for each combination that does not\n   *  appear in the input table.\n   * @return {this} A new table with imputed values and/or rows.\n   * @example table.impute({ v: () => 0 })\n   * @example table.impute({ v: d => op.mean(d.v) })\n   * @example table.impute({ v: () => 0 }, { expand: ['x', 'y'] })\n   */\n  impute(values, options) {\n    return impute(this, values, options);\n  }\n\n  // -- Reshaping Verbs -----------------------------------------------------\n\n  /**\n   * Fold one or more columns into two key-value pair columns.\n   * The fold transform is an inverse of the *pivot* transform.\n   * The resulting table has two new columns, one containing the column\n   * names (named \"key\") and the other the column values (named \"value\").\n   * The number of output rows equals the original row count multiplied\n   * by the number of folded columns.\n   * @param {import('./types.js').ExprList} values The columns to fold.\n   *  The columns may be specified using column name strings, column index\n   *  numbers, value objects with output column names for keys and table\n   *  expressions for values, or selection helper functions.\n   * @param {import('./types.js').FoldOptions} [options] Options for folding.\n   * @return {this} A new folded table.\n   * @example table.fold('colA')\n   * @example table.fold(['colA', 'colB'])\n   * @example table.fold(range(5, 8))\n   */\n  fold(values, options) {\n    return fold(this, values, options);\n  }\n\n  /**\n   * Pivot columns into a cross-tabulation.\n   * The pivot transform is an inverse of the *fold* transform.\n   * The resulting table has new columns for each unique combination\n   * of the provided *keys*, populated with the provided *values*.\n   * The provided *values* must be aggregates, as a single set of keys may\n   * include more than one row. If string-valued, the *any* aggregate is used.\n   * If only one *values* column is defined, the new pivoted columns will\n   * be named using key values directly. Otherwise, input value column names\n   * will be included as a component of the output column names.\n   * @param {import('./types.js').ExprList} keys\n   *  Key values to map to new column names. The keys may be specified using\n   *  column name strings, column index numbers, value objects with output\n   *  column names for keys and table expressions for values, or selection\n   *  helper functions.\n   * @param {import('./types.js').ExprList} values Output values for pivoted\n   *  columns. Column references will be wrapped in an *any* aggregate. If\n   *  object-valued, the input object should have output value names for keys\n   *  and aggregate table expressions for values.\n   * @param {import('./types.js').PivotOptions} [options]\n   *  Options for pivoting.\n   * @return {this} A new pivoted table.\n   * @example table.pivot('key', 'value')\n   * @example table.pivot(['keyA', 'keyB'], ['valueA', 'valueB'])\n   * @example table.pivot({ key: d => d.key }, { value: d => op.sum(d.value) })\n   */\n  pivot(keys, values, options) {\n    return pivot(this, keys, values, options);\n  }\n\n  /**\n   * Spread array elements into a set of new columns.\n   * Output columns are named based on the value key and array index.\n   * @param {import('./types.js').ExprList} values\n   *  The column values to spread. The values may be specified using column\n   *  name strings, column index numbers, value objects with output column\n   *  names for keys and table expressions for values, or selection helper\n   *  functions.\n   * @param {import('./types.js').SpreadOptions } [options]\n   *  Options for spreading.\n   * @return {this} A new table with the spread columns added.\n   * @example table.spread({ a: d => op.split(d.text, '') })\n   * @example table.spread('arrayCol', { limit: 100 })\n   */\n  spread(values, options) {\n    return spread(this, values, options);\n  }\n\n  /**\n   * Unroll one or more array-valued columns into new rows.\n   * If more than one array value is used, the number of new rows\n   * is the smaller of the limit and the largest length.\n   * Values for all other columns are copied over.\n   * @param {import('./types.js').ExprList} values\n   *  The column values to unroll. The values may be specified using column\n   *  name strings, column index numbers, value objects with output column\n   *  names for keys and table expressions for values, or selection helper\n   *  functions.\n   * @param {import('./types.js').UnrollOptions} [options]\n   *  Options for unrolling.\n   * @return {this} A new unrolled table.\n   * @example table.unroll('colA', { limit: 1000 })\n   */\n  unroll(values, options) {\n    return unroll(this, values, options);\n  }\n\n  // -- Joins ---------------------------------------------------------------\n\n  /**\n   * Lookup values from a secondary table and add them as new columns.\n   * A lookup occurs upon matching key values for rows in both tables.\n   * If the secondary table has multiple rows with the same key, only\n   * the last observed instance will be considered in the lookup.\n   * Lookup is similar to *join_left*, but with a simpler\n   * syntax and the added constraint of allowing at most one match only.\n   * @param {import('./types.js').TableRef} other\n   *  The secondary table to look up values from.\n   * @param {import('./types.js').JoinKeys} [on]\n   *  Lookup keys (column name strings or table expressions) for this table\n   *  and the secondary table, respectively. If unspecified, the values of\n   *  all columns with matching names are compared.\n   * @param {...import('./types.js').ExprList} [values]\n   *  The column values to add from the secondary table. Can be column name\n   *  strings or objects with column names as keys and table expressions as\n   *  values. If unspecified, includes all columns from the secondary table\n   *  whose names do no match any column in the primary table.\n   * @return {this} A new table with lookup values added.\n   * @example table.lookup(other, ['key1', 'key2'], 'value1', 'value2')\n   */\n  lookup(other, on, ...values) {\n    return lookup(this, other, on, ...values);\n  }\n\n  /**\n   * Join two tables, extending the columns of one table with\n   * values from the other table. The current table is considered\n   * the \"left\" table in the join, and the new table input is\n   * considered the \"right\" table in the join. By default an inner\n   * join is performed, removing all rows that do not match the\n   * join criteria. To perform left, right, or full outer joins, use\n   * the *join_left*, *join_right*, or *join_full* methods, or provide\n   * an options argument.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows. If unspecified, the values of\n   *  all columns with matching names are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join.\n   * @return {this} A new joined table.\n   * @example table.join(other, ['keyL', 'keyR'])\n   * @example table.join(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join(other, on, values, options) {\n    return join(this, other, on, values, options);\n  }\n\n  /**\n   * Perform a left outer join on two tables. Rows in the left table\n   * that do not match a row in the right table will be preserved.\n   * This is a convenience method with fixed options for *join*.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  he columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join. With this method, any options will be\n   *  overridden with `{left: true, right: false}`.\n   * @return {this} A new joined table.\n   * @example table.join_left(other, ['keyL', 'keyR'])\n   * @example table.join_left(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join_left(other, on, values, options) {\n    const opt = { ...options, left: true, right: false };\n    return join(this, other, on, values, opt);\n  }\n\n  /**\n   * Perform a right outer join on two tables. Rows in the right table\n   * that do not match a row in the left table will be preserved.\n   * This is a convenience method with fixed options for *join*.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join. With this method, any options will be overridden\n   *  with `{left: false, right: true}`.\n   * @return {this} A new joined table.\n   * @example table.join_right(other, ['keyL', 'keyR'])\n   * @example table.join_right(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join_right(other, on, values, options) {\n    const opt = { ...options, left: false, right: true };\n    return join(this, other, on, values, opt);\n  }\n\n  /**\n   * Perform a full outer join on two tables. Rows in either the left or\n   * right table that do not match a row in the other will be preserved.\n   * This is a convenience method with fixed options for *join*.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join. With this method, any options will be overridden\n   *  with `{left: true, right: true}`.\n   * @return {this} A new joined table.\n   * @example table.join_full(other, ['keyL', 'keyR'])\n   * @example table.join_full(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join_full(other, on, values, options) {\n    const opt = { ...options, left: true, right: true };\n    return join(this, other, on, values, opt);\n  }\n\n  /**\n   * Produce the Cartesian cross product of two tables. The output table\n   * has one row for every pair of input table rows. Beware that outputs\n   * may be quite large, as the number of output rows is the product of\n   * the input row counts.\n   * This is a convenience method for *join* in which the\n   * join criteria is always true.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the output.\n   *  If unspecified, all columns from both tables are included.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join.\n   * @return {this} A new joined table.\n   * @example table.cross(other)\n   * @example table.cross(other, [['leftKey', 'leftVal'], ['rightVal']])\n   */\n  cross(other, values, options) {\n    return cross(this, other, values, options);\n  }\n\n  /**\n   * Perform a semi-join, filtering the left table to only rows that\n   * match a row in the right table.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @return {this} A new filtered table.\n   * @example table.semijoin(other)\n   * @example table.semijoin(other, ['keyL', 'keyR'])\n   * @example table.semijoin(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  semijoin(other, on) {\n    return semijoin(this, other, on);\n  }\n\n  /**\n   * Perform an anti-join, filtering the left table to only rows that\n   * do *not* match a row in the right table.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @return {this} A new filtered table.\n   * @example table.antijoin(other)\n   * @example table.antijoin(other, ['keyL', 'keyR'])\n   * @example table.antijoin(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  antijoin(other, on) {\n    return antijoin(this, other, on);\n  }\n\n  // -- Set Operations ------------------------------------------------------\n\n  /**\n   * Concatenate multiple tables into a single table, preserving all rows.\n   * This transformation mirrors the UNION_ALL operation in SQL.\n   * Only named columns in this table are included in the output.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to concatenate.\n   * @return {this} A new concatenated table.\n   * @example table.concat(other)\n   * @example table.concat(other1, other2)\n   * @example table.concat([other1, other2])\n   */\n  concat(...tables) {\n    return concat(this, ...tables);\n  }\n\n  /**\n   * Union multiple tables into a single table, deduplicating all rows.\n   * This transformation mirrors the UNION operation in SQL. It is\n   * similar to *concat* but suppresses duplicate rows with\n   * values identical to another row.\n   * Only named columns in this table are included in the output.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to union.\n   * @return {this} A new unioned table.\n   * @example table.union(other)\n   * @example table.union(other1, other2)\n   * @example table.union([other1, other2])\n   */\n  union(...tables) {\n    return union(this, ...tables);\n  }\n\n  /**\n   * Intersect multiple tables, keeping only rows whose with identical\n   * values for all columns in all tables, and deduplicates the rows.\n   * This transformation is similar to a series of *semijoin*.\n   * calls, but additionally suppresses duplicate rows.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to intersect.\n   * @return {this} A new filtered table.\n   * @example table.intersect(other)\n   * @example table.intersect(other1, other2)\n   * @example table.intersect([other1, other2])\n   */\n  intersect(...tables) {\n    return intersect(this, ...tables);\n  }\n\n  /**\n   * Compute the set difference with multiple tables, keeping only rows in\n   * this table that whose values do not occur in the other tables.\n   * This transformation is similar to a series of *anitjoin*\n   * calls, but additionally suppresses duplicate rows.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to difference.\n   * @return {this} A new filtered table.\n   * @example table.except(other)\n   * @example table.except(other1, other2)\n   * @example table.except([other1, other2])\n   */\n  except(...tables) {\n    return except(this, ...tables);\n  }\n\n  // -- Table Output Formats ------------------------------------------------\n\n  /**\n   * Format this table as a Flechette Arrow table.\n   * @param {import('../format/types.js').ArrowFormatOptions} [options]\n   *  The Arrow formatting options.\n   * @return {import('@uwdata/flechette').Table} A Flechette Arrow table.\n   */\n  toArrow(options) {\n    return toArrow(this, options);\n  }\n\n  /**\n   * Format this table as binary data in the Apache Arrow IPC format.\n   * @param {import('../format/types.js').ArrowIPCFormatOptions} [options]\n   *  The Arrow IPC formatting options.\n   * @return {Uint8Array} A new Uint8Array of Arrow-encoded binary data.\n   */\n  toArrowIPC(options) {\n    return toArrowIPC(this, options);\n  }\n\n  /**\n   * Format this table as a comma-separated values (CSV) string. Other\n   * delimiters, such as tabs or pipes ('|'), can be specified using\n   * the options argument.\n   * @param {import('../format/to-csv.js').CSVFormatOptions} [options]\n   *   The CSV formatting options.\n   * @return {string} A delimited value string.\n   */\n  toCSV(options) {\n    return toCSV(this, options);\n  }\n\n  /**\n   * Format this table as an HTML table string.\n   * @param {import('../format/to-html.js').HTMLFormatOptions} [options]\n   *  The HTML formatting options.\n   * @return {string} An HTML table string.\n   */\n  toHTML(options) {\n    return toHTML(this, options);\n  }\n\n  /**\n   * Format this table as a JavaScript Object Notation (JSON) string.\n   * @param {import('../format/to-json.js').JSONFormatOptions} [options]\n   *  The JSON formatting options.\n   * @return {string} A JSON string.\n   */\n  toJSON(options) {\n    return toJSON(this, options);\n  }\n\n  /**\n   * Format this table as a GitHub-Flavored Markdown table string.\n   * @param {import('../format/to-markdown.js').MarkdownFormatOptions} [options]\n   *  The Markdown formatting options.\n   * @return {string} A GitHub-Flavored Markdown table string.\n   */\n  toMarkdown(options) {\n    return toMarkdown(this, options);\n  }\n}\n","import { tableFromIPC } from '@uwdata/flechette';\nimport { all, resolve } from '../helpers/selection.js';\nimport { sequence } from '../op/functions/sequence.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { ColumnTable } from '../table/ColumnTable.js';\nimport { byteStream } from './stream/byte-stream.js';\nimport { collectBytes } from './stream/collect.js';\n\n/**\n * Create a new table backed by an Apache Arrow table instance.\n * @param {import('./types.js').ArrowInput} input\n *  An Apache Arrow data table or Arrow IPC byte buffer.\n * @param {import('./types.js').ArrowOptions} [options]\n *  Options for Arrow import.\n * @return {ColumnTable} A new table containing the imported values.\n */\nexport function fromArrow(input, options) {\n  const { columns = all(), ...rest } = options || {};\n  const arrow = input instanceof ArrayBuffer || input instanceof Uint8Array\n    ? tableFromIPC(input, { useDate: true, ...rest })\n    : input;\n\n  const { fields } = arrow.schema;\n\n  // resolve column selection\n  const names = fields.map(f => f.name);\n  const sel = resolve({\n    columnNames: test => test ? names.filter(test) : names.slice(),\n    columnIndex: name => names.indexOf(name)\n  }, columns);\n\n  // build Arquero columns for backing Arrow columns\n  const cols = columnSet();\n  sel.forEach((name, key) => {\n    const col = /** @type {import('./types.js').ArrowColumn} */ (arrow.getChild(key));\n    cols.add(name, col.type.typeId === -1 ? dictionary(col) : col);\n  });\n\n  return new ColumnTable(cols.data, cols.names);\n}\n\n/**\n * Parse Arrow data and return a Promise for an Arquero table.\n * @param {ReadableStream<Uint8Array>} stream\n *  An input byte stream, Apache Arrow data table, or Arrow IPC byte buffer.\n * @param {import('./types.js').ArrowOptions} [options]\n *  Options for Arrow import.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n */\nexport async function fromArrowStream(stream, options) {\n  return fromArrow(await collectBytes(stream), options);\n}\n\n/**\n * Load an Arrow file from a URL and return a Promise for an Arquero table.\n * @param {string} path The URL or file path to load.\n * @param {import('./types.js').LoadOptions\n *  & import('./types.js').ArrowOptions} [options] Arrow parse options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n * @example aq.loadArrow('data/table.arrow')\n */\nexport async function loadArrow(path, options) {\n  return fromArrowStream(await byteStream(path, options), options);\n}\n\nfunction dictionary(column) {\n  const { data, length, nullCount } = column;\n  const batch = data[data.length - 1];\n  // support both flechette and arrow-js\n  const cache = batch.cache ?? batch.dictionary.toArray();\n  const size = cache.length;\n  const keys = dictKeys(data, length, nullCount, size);\n\n  const get = nullCount\n    ? (k => k === size ? null : cache[k])\n    : (k => cache[k]);\n\n  return {\n    length,\n    nullCount,\n    at: row => get(keys[row]),\n    key: row => keys[row],\n    keyFor(value) {\n      if (value === null) return nullCount ? size : -1;\n      for (let i = 0; i < size; ++i) {\n        if (cache[i] === value) return i;\n      }\n      return -1;\n    },\n    groups(names) {\n      const s = size + (nullCount ? 1 : 0);\n      return {\n        keys,\n        get: [get],\n        names,\n        rows: sequence(0, s),\n        size: s\n      };\n    },\n    [Symbol.iterator]: () => column[Symbol.iterator](),\n    toArray: () => column.toArray()\n  };\n}\n\n/**\n * Generate a dictionary key array.\n * @param {readonly any[]} data Arrow column batches\n * @param {number} length The length of the Arrow column\n * @param {number} nulls The count of column null values\n * @param {number} size The backing dictionary size\n */\nfunction dictKeys(data, length, nulls, size) {\n  const v = data.length > 1 || nulls\n    ? flatten(data, length)\n    : data[0].values;\n  return nulls ? nullKeys(data, v, size) : v;\n}\n\n/**\n * Flatten Arrow column chunks into a single array.\n */\nfunction flatten(data, length) {\n  const type = data[0].values.constructor;\n  const array = new type(length);\n  const n = data.length;\n  for (let i = 0, idx = 0, len; i < n; ++i) {\n    len = data[i].length;\n    array.set(data[i].values.subarray(0, len), idx);\n    idx += len;\n  }\n  return array;\n}\n\n/**\n * Encode null values as an additional dictionary key.\n * Returns a new key array with null values added.\n * TODO: safeguard against integer overflow?\n */\nfunction nullKeys(data, keys, key) {\n  // iterate over null bitmaps, encode null values as key\n  const n = data.length;\n  for (let i = 0, idx = 0, byte; i < n; ++i) {\n    const batch = data[i];\n    const { length } = batch;\n    // support both flechette and arrow-js\n    const validity = batch.validity ?? batch.nullBitmap;\n    const m = length >> 3;\n    if (validity && validity.length) {\n      for (let j = 0; j <= m; ++j) {\n        if ((byte = validity[j]) !== 255) {\n          const base = idx + (j << 3);\n          if ((byte & (1 << 0)) === 0) keys[base + 0] = key;\n          if ((byte & (1 << 1)) === 0) keys[base + 1] = key;\n          if ((byte & (1 << 2)) === 0) keys[base + 2] = key;\n          if ((byte & (1 << 3)) === 0) keys[base + 3] = key;\n          if ((byte & (1 << 4)) === 0) keys[base + 4] = key;\n          if ((byte & (1 << 5)) === 0) keys[base + 5] = key;\n          if ((byte & (1 << 6)) === 0) keys[base + 6] = key;\n          if ((byte & (1 << 7)) === 0) keys[base + 7] = key;\n        }\n      }\n    }\n    idx += length;\n  }\n  return keys;\n}\n","import { wrap } from './wrap.js';\nimport { error } from '../util/error.js';\n\n/**\n * Escape a function or value to prevent it from being parsed and recompiled.\n * This helper can be used in lieu of single-table table expressions (which\n * are internally parsed and rewritten) to apply a JavaScript function as-is,\n * including support for closures. It can also be used to pass a constant,\n * literal value as a table expression, bypassing the parser.\n * @param {*} value A function or value to escape.\n * @return {object} A wrapper object representing the escaped value.\n * @example escape(d => d.a.toFixed(2))\n * @example escape(d => d.a * -d.b)\n */\nexport function escape(value) {\n  return wrap(value, {\n    escape: true,\n    toString() { error('Escaped values can not be serialized.'); }\n  });\n}\n","import { error } from '../util/error.js';\nimport { isArray } from '../util/is-array.js';\nimport { isDate } from '../util/is-date.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isObject } from '../util/is-object.js';\nimport { isRegExp } from '../util/is-regexp.js';\nimport { isString } from '../util/is-string.js';\n\n/**\n * @return {import('./types.js').ColumnData}\n */\nexport function columnsFrom(values, names) {\n  const raise = type => {\n    error(`Illegal argument type: ${type || typeof values}`);\n    return /** @type {import('./types.js').ColumnData} */({});\n  };\n  // @ts-ignore\n  return values instanceof Map ? fromKeyValuePairs(values.entries(), names)\n    : isDate(values) ? raise('Date')\n    : isRegExp(values) ? raise('RegExp')\n    : isString(values) ? raise()\n    : isArray(values) ? fromArray(values, names)\n    : isFunction(values[Symbol.iterator]) ? fromIterable(values, names)\n    : isObject(values) ? fromKeyValuePairs(Object.entries(values), names)\n    : raise();\n}\n\n/**\n * @param {Iterable<[any, any]>} entries\n * @param {string[]} names\n * @return {import('./types.js').ColumnData}\n */\nfunction fromKeyValuePairs(entries, names = ['key', 'value']) {\n  const keys = [];\n  const vals = [];\n\n  for (const [key, val] of entries) {\n    keys.push(key);\n    vals.push(val);\n  }\n\n  /** @type {import('./types.js').ColumnData} */\n  const columns = {};\n  if (names[0]) columns[names[0]] = keys;\n  if (names[1]) columns[names[1]] = vals;\n  return columns;\n}\n\n/**\n * @param {any[]} values\n * @param {string[]} names\n * @return {import('./types.js').ColumnData}\n */\nfunction fromArray(values, names) {\n  const len = values.length;\n  /** @type {import('./types.js').ColumnData} */\n  const columns = {};\n  const add = name => columns[name] = Array(len);\n\n  if (len) {\n    names = names || Object.keys(values[0]);\n    const cols = names.map(add);\n    const n = cols.length;\n    for (let idx = 0; idx < len; ++idx) {\n      const row = values[idx];\n      for (let i = 0; i < n; ++i) {\n        cols[i][idx] = row[names[i]];\n      }\n    }\n  } else if (names) {\n    names.forEach(add);\n  }\n\n  return columns;\n}\n\n/**\n * @param {Iterable<any>} values\n * @param {string[]} names\n * @return {import('./types.js').ColumnData}\n */\nfunction fromIterable(values, names) {\n  /** @type {import('./types.js').ColumnData} */\n  const columns = {};\n  const add = name => columns[name] = [];\n\n  let cols;\n  let n;\n  for (const row of values) {\n    if (!cols) {\n      names = names || Object.keys(row);\n      cols = names.map(add);\n      n = cols.length;\n    }\n    for (let i = 0; i < n; ++i) {\n      cols[i].push(row[names[i]]);\n    }\n  }\n\n  if (!cols && names) {\n    names.forEach(add);\n  }\n\n  return columns;\n}\n","import { entries } from '../util/entries.js';\nimport { ColumnTable } from './ColumnTable.js';\nimport { columnsFrom } from './columns-from.js';\n\n/**\n * Create a new table for a set of named columns.\n * @param {object|Map} columns\n *  The set of named column arrays. Keys are column names.\n *  The enumeration order of the keys determines the column indices,\n *  unless the names parameter is specified.\n *  Values must be arrays (or array-like values) of identical length.\n * @param {string[]} [names] Ordered list of column names. If specified,\n *  this array determines the column indices. If not specified, the\n *  key enumeration order of the columns object is used.\n * @return {ColumnTable} the instantiated table\n * @example table({ colA: ['a', 'b', 'c'], colB: [3, 4, 5] })\n */\nexport function table(columns, names) {\n  if (columns instanceof ColumnTable) return columns;\n  /** @type {import('./types.js').ColumnData} */\n  const data = {};\n  const keys = [];\n  for (const [key, value] of entries(columns)) {\n    data[key] = value;\n    keys.push(key);\n  }\n  return new ColumnTable(data, names || keys);\n}\n\n/**\n * Create a new table from an existing object, such as an array of\n * objects or a set of key-value pairs.\n * @param {object|Array|Map} values Data values to populate the table.\n *  If array-valued or iterable, imports rows for each non-null value,\n *  using the provided column names as keys for each row object. If no\n *  names are provided, the first non-null object's own keys are used.\n *  If object- or Map-valued, create columns for the keys and values.\n * @param {string[]} [names] Column names to include.\n *  For object or Map values, specifies the key and value column names.\n *  Otherwise, specifies the keys to look up on each row object.\n * @return {ColumnTable} the instantiated table.\n * @example from([ { colA: 1, colB: 2 }, { colA: 3, colB: 4 } ])\n */\nexport function from(values, names) {\n  return new ColumnTable(columnsFrom(values, names), names);\n}\n","// Simple hash function, from: http://burtleburtle.net/bob/hash/integer.html.\n// Chosen because it doesn't use multiply and achieves full avalanche.\nexports.hashU32 = function hashU32 (a) {\n  a = a | 0;\n  a = a + 2127912214 + (a << 12) | 0;\n  a = a ^ -949894596 ^ a >>> 19;\n  a = a + 374761393 + (a << 5) | 0;\n  a = a + -744332180 ^ a << 9;\n  a = a + -42973499 + (a << 3) | 0;\n  return a ^ -1252372727 ^ a >>> 16 | 0;\n};\n\n// Reads a 64-bit little-endian integer from an array.\nexports.readU64 = function readU64 (b, n) {\n  var x = 0;\n  x |= b[n++] << 0;\n  x |= b[n++] << 8;\n  x |= b[n++] << 16;\n  x |= b[n++] << 24;\n  x |= b[n++] << 32;\n  x |= b[n++] << 40;\n  x |= b[n++] << 48;\n  x |= b[n++] << 56;\n  return x;\n};\n\n// Reads a 32-bit little-endian integer from an array.\nexports.readU32 = function readU32 (b, n) {\n  var x = 0;\n  x |= b[n++] << 0;\n  x |= b[n++] << 8;\n  x |= b[n++] << 16;\n  x |= b[n++] << 24;\n  return x;\n};\n\n// Writes a 32-bit little-endian integer from an array.\nexports.writeU32 = function writeU32 (b, n, x) {\n  b[n++] = (x >> 0) & 0xff;\n  b[n++] = (x >> 8) & 0xff;\n  b[n++] = (x >> 16) & 0xff;\n  b[n++] = (x >> 24) & 0xff;\n};\n\n// Multiplies two numbers using 32-bit integer multiplication.\n// Algorithm from Emscripten.\nexports.imul = function imul (a, b) {\n  var ah = a >>> 16;\n  var al = a & 65535;\n  var bh = b >>> 16;\n  var bl = b & 65535;\n\n  return al * bl + (ah * bl + al * bh << 16) | 0;\n};\n","// xxh32.js - implementation of xxhash32 in plain JavaScript\nvar util = require('./util.js');\n\n// xxhash32 primes\nvar prime1 = 0x9e3779b1;\nvar prime2 = 0x85ebca77;\nvar prime3 = 0xc2b2ae3d;\nvar prime4 = 0x27d4eb2f;\nvar prime5 = 0x165667b1;\n\n// Utility functions/primitives\n// --\n\nfunction rotl32 (x, r) {\n  x = x | 0;\n  r = r | 0;\n\n  return x >>> (32 - r | 0) | x << r | 0;\n}\n\nfunction rotmul32 (h, r, m) {\n  h = h | 0;\n  r = r | 0;\n  m = m | 0;\n\n  return util.imul(h >>> (32 - r | 0) | h << r, m) | 0;\n}\n\nfunction shiftxor32 (h, s) {\n  h = h | 0;\n  s = s | 0;\n\n  return h >>> s ^ h | 0;\n}\n\n// Implementation\n// --\n\nfunction xxhapply (h, src, m0, s, m1) {\n  return rotmul32(util.imul(src, m0) + h, s, m1);\n}\n\nfunction xxh1 (h, src, index) {\n  return rotmul32((h + util.imul(src[index], prime5)), 11, prime1);\n}\n\nfunction xxh4 (h, src, index) {\n  return xxhapply(h, util.readU32(src, index), prime3, 17, prime4);\n}\n\nfunction xxh16 (h, src, index) {\n  return [\n    xxhapply(h[0], util.readU32(src, index + 0), prime2, 13, prime1),\n    xxhapply(h[1], util.readU32(src, index + 4), prime2, 13, prime1),\n    xxhapply(h[2], util.readU32(src, index + 8), prime2, 13, prime1),\n    xxhapply(h[3], util.readU32(src, index + 12), prime2, 13, prime1)\n  ];\n}\n\nfunction xxh32 (seed, src, index, len) {\n  var h, l;\n  l = len;\n  if (len >= 16) {\n    h = [\n      seed + prime1 + prime2,\n      seed + prime2,\n      seed,\n      seed - prime1\n    ];\n\n    while (len >= 16) {\n      h = xxh16(h, src, index);\n\n      index += 16;\n      len -= 16;\n    }\n\n    h = rotl32(h[0], 1) + rotl32(h[1], 7) + rotl32(h[2], 12) + rotl32(h[3], 18) + l;\n  } else {\n    h = (seed + prime5 + len) >>> 0;\n  }\n\n  while (len >= 4) {\n    h = xxh4(h, src, index);\n\n    index += 4;\n    len -= 4;\n  }\n\n  while (len > 0) {\n    h = xxh1(h, src, index);\n\n    index++;\n    len--;\n  }\n\n  h = shiftxor32(util.imul(shiftxor32(util.imul(shiftxor32(h, 15), prime2), 13), prime3), 16);\n\n  return h >>> 0;\n}\n\nexports.hash = xxh32;\n","// lz4.js - An implementation of Lz4 in plain JavaScript.\n//\n// TODO:\n// - Unify header parsing/writing.\n// - Support options (block size, checksums)\n// - Support streams\n// - Better error handling (handle bad offset, etc.)\n// - HC support (better search algorithm)\n// - Tests/benchmarking\n\nvar xxhash = require('./xxh32.js');\nvar util = require('./util.js');\n\n// Constants\n// --\n\n// Compression format parameters/constants.\nvar minMatch = 4;\nvar minLength = 13;\nvar searchLimit = 5;\nvar skipTrigger = 6;\nvar hashSize = 1 << 16;\n\n// Token constants.\nvar mlBits = 4;\nvar mlMask = (1 << mlBits) - 1;\nvar runBits = 4;\nvar runMask = (1 << runBits) - 1;\n\n// Shared buffers\nvar blockBuf = makeBuffer(5 << 20);\nvar hashTable = makeHashTable();\n\n// Frame constants.\nvar magicNum = 0x184D2204;\n\n// Frame descriptor flags.\nvar fdContentChksum = 0x4;\nvar fdContentSize = 0x8;\nvar fdBlockChksum = 0x10;\n// var fdBlockIndep = 0x20;\nvar fdVersion = 0x40;\nvar fdVersionMask = 0xC0;\n\n// Block sizes.\nvar bsUncompressed = 0x80000000;\nvar bsDefault = 7;\nvar bsShift = 4;\nvar bsMask = 7;\nvar bsMap = {\n  4: 0x10000,\n  5: 0x40000,\n  6: 0x100000,\n  7: 0x400000\n};\n\n// Utility functions/primitives\n// --\n\n// Makes our hashtable. On older browsers, may return a plain array.\nfunction makeHashTable () {\n  try {\n    return new Uint32Array(hashSize);\n  } catch (error) {\n    var hashTable = new Array(hashSize);\n\n    for (var i = 0; i < hashSize; i++) {\n      hashTable[i] = 0;\n    }\n\n    return hashTable;\n  }\n}\n\n// Clear hashtable.\nfunction clearHashTable (table) {\n  for (var i = 0; i < hashSize; i++) {\n    hashTable[i] = 0;\n  }\n}\n\n// Makes a byte buffer. On older browsers, may return a plain array.\nfunction makeBuffer (size) {\n  try {\n    return new Uint8Array(size);\n  } catch (error) {\n    var buf = new Array(size);\n\n    for (var i = 0; i < size; i++) {\n      buf[i] = 0;\n    }\n\n    return buf;\n  }\n}\n\nfunction sliceArray (array, start, end) {\n  if (typeof array.buffer !== undefined) {\n    if (Uint8Array.prototype.slice) {\n      return array.slice(start, end);\n    } else {\n      // Uint8Array#slice polyfill.\n      var len = array.length;\n\n      // Calculate start.\n      start = start | 0;\n      start = (start < 0) ? Math.max(len + start, 0) : Math.min(start, len);\n\n      // Calculate end.\n      end = (end === undefined) ? len : end | 0;\n      end = (end < 0) ? Math.max(len + end, 0) : Math.min(end, len);\n\n      // Copy into new array.\n      var arraySlice = new Uint8Array(end - start);\n      for (var i = start, n = 0; i < end;) {\n        arraySlice[n++] = array[i++];\n      }\n\n      return arraySlice;\n    }\n  } else {\n    // Assume normal array.\n    return array.slice(start, end);\n  }\n}\n\n// Implementation\n// --\n\n// Calculates an upper bound for lz4 compression.\nexports.compressBound = function compressBound (n) {\n  return (n + (n / 255) + 16) | 0;\n};\n\n// Calculates an upper bound for lz4 decompression, by reading the data.\nexports.decompressBound = function decompressBound (src) {\n  var sIndex = 0;\n\n  // Read magic number\n  if (util.readU32(src, sIndex) !== magicNum) {\n    throw new Error('invalid magic number');\n  }\n\n  sIndex += 4;\n\n  // Read descriptor\n  var descriptor = src[sIndex++];\n\n  // Check version\n  if ((descriptor & fdVersionMask) !== fdVersion) {\n    throw new Error('incompatible descriptor version ' + (descriptor & fdVersionMask));\n  }\n\n  // Read flags\n  var useBlockSum = (descriptor & fdBlockChksum) !== 0;\n  var useContentSize = (descriptor & fdContentSize) !== 0;\n\n  // Read block size\n  var bsIdx = (src[sIndex++] >> bsShift) & bsMask;\n\n  if (bsMap[bsIdx] === undefined) {\n    throw new Error('invalid block size ' + bsIdx);\n  }\n\n  var maxBlockSize = bsMap[bsIdx];\n\n  // Get content size\n  if (useContentSize) {\n    return util.readU64(src, sIndex);\n  }\n\n  // Checksum\n  sIndex++;\n\n  // Read blocks.\n  var maxSize = 0;\n  while (true) {\n    var blockSize = util.readU32(src, sIndex);\n    sIndex += 4;\n\n    if (blockSize & bsUncompressed) {\n      blockSize &= ~bsUncompressed;\n      maxSize += blockSize;\n    } else {\n      maxSize += maxBlockSize;\n    }\n\n    if (blockSize === 0) {\n      return maxSize;\n    }\n\n    if (useBlockSum) {\n      sIndex += 4;\n    }\n\n    sIndex += blockSize;\n  }\n};\n\n// Creates a buffer of a given byte-size, falling back to plain arrays.\nexports.makeBuffer = makeBuffer;\n\n// Decompresses a block of Lz4.\nexports.decompressBlock = function decompressBlock (src, dst, sIndex, sLength, dIndex) {\n  var mLength, mOffset, sEnd, n, i;\n\n  // Setup initial state.\n  sEnd = sIndex + sLength;\n\n  // Consume entire input block.\n  while (sIndex < sEnd) {\n    var token = src[sIndex++];\n\n    // Copy literals.\n    var literalCount = (token >> 4);\n    if (literalCount > 0) {\n      // Parse length.\n      if (literalCount === 0xf) {\n        while (true) {\n          literalCount += src[sIndex];\n          if (src[sIndex++] !== 0xff) {\n            break;\n          }\n        }\n      }\n\n      // Copy literals\n      for (n = sIndex + literalCount; sIndex < n;) {\n        dst[dIndex++] = src[sIndex++];\n      }\n    }\n\n    if (sIndex >= sEnd) {\n      break;\n    }\n\n    // Copy match.\n    mLength = (token & 0xf);\n\n    // Parse offset.\n    mOffset = src[sIndex++] | (src[sIndex++] << 8);\n\n    // Parse length.\n    if (mLength === 0xf) {\n      while (true) {\n        mLength += src[sIndex];\n        if (src[sIndex++] !== 0xff) {\n          break;\n        }\n      }\n    }\n\n    mLength += minMatch;\n\n    // Copy match.\n    for (i = dIndex - mOffset, n = i + mLength; i < n;) {\n      dst[dIndex++] = dst[i++] | 0;\n    }\n  }\n\n  return dIndex;\n};\n\n// Compresses a block with Lz4.\nexports.compressBlock = function compressBlock (src, dst, sIndex, sLength, hashTable) {\n  var mIndex, mAnchor, mLength, mOffset, mStep;\n  var literalCount, dIndex, sEnd, n;\n\n  // Setup initial state.\n  dIndex = 0;\n  sEnd = sLength + sIndex;\n  mAnchor = sIndex;\n\n  // Process only if block is large enough.\n  if (sLength >= minLength) {\n    var searchMatchCount = (1 << skipTrigger) + 3;\n\n    // Consume until last n literals (Lz4 spec limitation.)\n    while (sIndex + minMatch < sEnd - searchLimit) {\n      var seq = util.readU32(src, sIndex);\n      var hash = util.hashU32(seq) >>> 0;\n\n      // Crush hash to 16 bits.\n      hash = ((hash >> 16) ^ hash) >>> 0 & 0xffff;\n\n      // Look for a match in the hashtable. NOTE: remove one; see below.\n      mIndex = hashTable[hash] - 1;\n\n      // Put pos in hash table. NOTE: add one so that zero = invalid.\n      hashTable[hash] = sIndex + 1;\n\n      // Determine if there is a match (within range.)\n      if (mIndex < 0 || ((sIndex - mIndex) >>> 16) > 0 || util.readU32(src, mIndex) !== seq) {\n        mStep = searchMatchCount++ >> skipTrigger;\n        sIndex += mStep;\n        continue;\n      }\n\n      searchMatchCount = (1 << skipTrigger) + 3;\n\n      // Calculate literal count and offset.\n      literalCount = sIndex - mAnchor;\n      mOffset = sIndex - mIndex;\n\n      // We've already matched one word, so get that out of the way.\n      sIndex += minMatch;\n      mIndex += minMatch;\n\n      // Determine match length.\n      // N.B.: mLength does not include minMatch, Lz4 adds it back\n      // in decoding.\n      mLength = sIndex;\n      while (sIndex < sEnd - searchLimit && src[sIndex] === src[mIndex]) {\n        sIndex++;\n        mIndex++;\n      }\n      mLength = sIndex - mLength;\n\n      // Write token + literal count.\n      var token = mLength < mlMask ? mLength : mlMask;\n      if (literalCount >= runMask) {\n        dst[dIndex++] = (runMask << mlBits) + token;\n        for (n = literalCount - runMask; n >= 0xff; n -= 0xff) {\n          dst[dIndex++] = 0xff;\n        }\n        dst[dIndex++] = n;\n      } else {\n        dst[dIndex++] = (literalCount << mlBits) + token;\n      }\n\n      // Write literals.\n      for (var i = 0; i < literalCount; i++) {\n        dst[dIndex++] = src[mAnchor + i];\n      }\n\n      // Write offset.\n      dst[dIndex++] = mOffset;\n      dst[dIndex++] = (mOffset >> 8);\n\n      // Write match length.\n      if (mLength >= mlMask) {\n        for (n = mLength - mlMask; n >= 0xff; n -= 0xff) {\n          dst[dIndex++] = 0xff;\n        }\n        dst[dIndex++] = n;\n      }\n\n      // Move the anchor.\n      mAnchor = sIndex;\n    }\n  }\n\n  // Nothing was encoded.\n  if (mAnchor === 0) {\n    return 0;\n  }\n\n  // Write remaining literals.\n  // Write literal token+count.\n  literalCount = sEnd - mAnchor;\n  if (literalCount >= runMask) {\n    dst[dIndex++] = (runMask << mlBits);\n    for (n = literalCount - runMask; n >= 0xff; n -= 0xff) {\n      dst[dIndex++] = 0xff;\n    }\n    dst[dIndex++] = n;\n  } else {\n    dst[dIndex++] = (literalCount << mlBits);\n  }\n\n  // Write literals.\n  sIndex = mAnchor;\n  while (sIndex < sEnd) {\n    dst[dIndex++] = src[sIndex++];\n  }\n\n  return dIndex;\n};\n\n// Decompresses a frame of Lz4 data.\nexports.decompressFrame = function decompressFrame (src, dst) {\n  var useBlockSum, useContentSum, useContentSize, descriptor;\n  var sIndex = 0;\n  var dIndex = 0;\n\n  // Read magic number\n  if (util.readU32(src, sIndex) !== magicNum) {\n    throw new Error('invalid magic number');\n  }\n\n  sIndex += 4;\n\n  // Read descriptor\n  descriptor = src[sIndex++];\n\n  // Check version\n  if ((descriptor & fdVersionMask) !== fdVersion) {\n    throw new Error('incompatible descriptor version');\n  }\n\n  // Read flags\n  useBlockSum = (descriptor & fdBlockChksum) !== 0;\n  useContentSum = (descriptor & fdContentChksum) !== 0;\n  useContentSize = (descriptor & fdContentSize) !== 0;\n\n  // Read block size\n  var bsIdx = (src[sIndex++] >> bsShift) & bsMask;\n\n  if (bsMap[bsIdx] === undefined) {\n    throw new Error('invalid block size');\n  }\n\n  if (useContentSize) {\n    // TODO: read content size\n    sIndex += 8;\n  }\n\n  sIndex++;\n\n  // Read blocks.\n  while (true) {\n    var compSize;\n\n    compSize = util.readU32(src, sIndex);\n    sIndex += 4;\n\n    if (compSize === 0) {\n      break;\n    }\n\n    if (useBlockSum) {\n      // TODO: read block checksum\n      sIndex += 4;\n    }\n\n    // Check if block is compressed\n    if ((compSize & bsUncompressed) !== 0) {\n      // Mask off the 'uncompressed' bit\n      compSize &= ~bsUncompressed;\n\n      // Copy uncompressed data into destination buffer.\n      for (var j = 0; j < compSize; j++) {\n        dst[dIndex++] = src[sIndex++];\n      }\n    } else {\n      // Decompress into blockBuf\n      dIndex = exports.decompressBlock(src, dst, sIndex, compSize, dIndex);\n      sIndex += compSize;\n    }\n  }\n\n  if (useContentSum) {\n    // TODO: read content checksum\n    sIndex += 4;\n  }\n\n  return dIndex;\n};\n\n// Compresses data to an Lz4 frame.\nexports.compressFrame = function compressFrame (src, dst) {\n  var dIndex = 0;\n\n  // Write magic number.\n  util.writeU32(dst, dIndex, magicNum);\n  dIndex += 4;\n\n  // Descriptor flags.\n  dst[dIndex++] = fdVersion;\n  dst[dIndex++] = bsDefault << bsShift;\n\n  // Descriptor checksum.\n  dst[dIndex] = xxhash.hash(0, dst, 4, dIndex - 4) >> 8;\n  dIndex++;\n\n  // Write blocks.\n  var maxBlockSize = bsMap[bsDefault];\n  var remaining = src.length;\n  var sIndex = 0;\n\n  // Clear the hashtable.\n  clearHashTable(hashTable);\n\n  // Split input into blocks and write.\n  while (remaining > 0) {\n    var compSize = 0;\n    var blockSize = remaining > maxBlockSize ? maxBlockSize : remaining;\n\n    compSize = exports.compressBlock(src, blockBuf, sIndex, blockSize, hashTable);\n\n    if (compSize > blockSize || compSize === 0) {\n      // Output uncompressed.\n      util.writeU32(dst, dIndex, 0x80000000 | blockSize);\n      dIndex += 4;\n\n      for (var z = sIndex + blockSize; sIndex < z;) {\n        dst[dIndex++] = src[sIndex++];\n      }\n\n      remaining -= blockSize;\n    } else {\n      // Output compressed.\n      util.writeU32(dst, dIndex, compSize);\n      dIndex += 4;\n\n      for (var j = 0; j < compSize;) {\n        dst[dIndex++] = blockBuf[j++];\n      }\n\n      sIndex += blockSize;\n      remaining -= blockSize;\n    }\n  }\n\n  // Write blank end block.\n  util.writeU32(dst, dIndex, 0);\n  dIndex += 4;\n\n  return dIndex;\n};\n\n// Decompresses a buffer containing an Lz4 frame. maxSize is optional; if not\n// provided, a maximum size will be determined by examining the data. The\n// buffer returned will always be perfectly-sized.\nexports.decompress = function decompress (src, maxSize) {\n  var dst, size;\n\n  if (maxSize === undefined) {\n    maxSize = exports.decompressBound(src);\n  }\n\n  dst = exports.makeBuffer(maxSize);\n  size = exports.decompressFrame(src, dst);\n\n  if (size !== maxSize) {\n    dst = sliceArray(dst, 0, size);\n  }\n\n  return dst;\n};\n\n// Compresses a buffer to an Lz4 frame. maxSize is optional; if not provided,\n// a buffer will be created based on the theoretical worst output size for a\n// given input size. The buffer returned will always be perfectly-sized.\nexports.compress = function compress (src, maxSize) {\n  var dst, size;\n\n  if (maxSize === undefined) {\n    maxSize = exports.compressBound(src.length);\n  }\n\n  dst = exports.makeBuffer(maxSize);\n  size = exports.compressFrame(src, dst);\n\n  if (size !== maxSize) {\n    dst = sliceArray(dst, 0, size);\n  }\n\n  return dst;\n};\n","import {\n  tableFromIPC,\n  tableToIPC,\n  Codec,\n  compressionRegistry,\n  CompressionType,\n} from \"apache-arrow\";\nimport type { ColumnTable } from \"arquero\";\nimport { escape, fromArrow, table as arqueroTable } from \"arquero\";\nimport * as lz4js from \"lz4js\";\n\nexport const decodeArrowBase64 = (base64: string) => {\n  // Decode base64 string to Uint8Array\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  // Delegate to decodeArrowBytes\n  return decodeArrowBytes(bytes);\n};\n\nexport const decodeArrowBytes = (bytes: ArrayBuffer | Uint8Array) => {\n  // Register LZ4 codec before first use\n  ensureLZ4CodecRegistered();\n\n  // Use Apache Arrow to parse and decompress the data\n  // We do this as `fromArrow` doesn't support compressed\n  // codecs, which is _extremely_ space inefficient over\n  // the wire\n  const arrowTable = tableFromIPC(bytes);\n\n  // Convert to uncompressed Arrow IPC format\n  const uncompressedBytes = tableToIPC(arrowTable);\n\n  // Now Arquero can read the uncompressed Arrow data\n  let table = fromArrow(uncompressedBytes);\n\n  // Cast columns to appropriate types\n  // (Mixed-type columns get converted to strings by Arrow/Pandas)\n  table = castColumns(table);\n\n  // Eagerly materialize the table to prevent Safari from\n  // detaching the underlying ArrayBuffer during navigation.\n  // The Arquero table holds lazy references to the Arrow buffers,\n  // and Safari's aggressive memory management can detach these buffers\n  // when navigating, causing \"Bad value\" errors in LZ4 decompression.\n  const columns: Record<string, unknown[]> = {};\n  const columnNames = table.columnNames();\n\n  // Convert to column-oriented format (arrays) which forces\n  // immediate materialization and doesn't hold references to Arrow buffers.\n  for (const colName of columnNames) {\n    // Get the column as an array - this forces materialization\n    // Convert TypedArray to regular array to ensure no buffer references\n    const colData = table.array(colName);\n    columns[colName] = Array.isArray(colData)\n      ? colData\n      : Array.from(colData as Iterable<unknown>);\n  }\n\n  // Recreate the table from the materialized column arrays\n  // This ensures the table no longer has any references to detachable buffers\n  return arqueroTable(columns);\n};\n\n// Register LZ4 codec (only needs to be done once)\nlet codecRegistered = false;\nfunction ensureLZ4CodecRegistered(): void {\n  if (!codecRegistered) {\n    const lz4Codec: Codec = {\n      encode(data: Uint8Array): Uint8Array {\n        return lz4js.compress(data);\n      },\n      decode(data: Uint8Array): Uint8Array {\n        return lz4js.decompress(data);\n      },\n    };\n    compressionRegistry.set(CompressionType.LZ4_FRAME, lz4Codec);\n    codecRegistered = true;\n  }\n}\n\n// When Arrow/Pandas encounters mixed-type columns (e.g., numbers and nulls),\n// it converts everything to strings for safety. This function restores the\n// original types based on the value_type column (or a known type).\nfunction castColumns(table: ColumnTable): ColumnTable {\n  const columnNames = table.columnNames();\n  const hasValue =\n    columnNames.includes(\"value\") && columnNames.includes(\"value_type\");\n  const hasScanRefusal = columnNames.includes(\"scan_error_refusal\");\n\n  // If neither column needs casting, return as-is\n  if (!hasValue && !hasScanRefusal) {\n    return table;\n  }\n\n  // Helper function to cast a single value based on its type\n  const castValue = (\n    value: unknown,\n    valueType: string\n  ): string | number | boolean | null => {\n    if (value === null || value === undefined) {\n      return null;\n    }\n\n    if (valueType === \"boolean\") {\n      // Already boolean\n      if (typeof value === \"boolean\") {\n        return value;\n      }\n      // Cast string to boolean\n      const strVal = String(value).toLowerCase();\n      if (strVal === \"true\") {\n        return true;\n      }\n      if (strVal === \"false\") {\n        return false;\n      }\n      return null;\n    } else if (valueType === \"number\") {\n      // Already a number\n      if (typeof value === \"number\") {\n        return value;\n      }\n\n      const strVal = String(value).trim();\n      if (strVal === \"\") {\n        // Empty values should be null\n        return null;\n      }\n      const num = Number(strVal);\n      return isNaN(num) ? null : num;\n    } else {\n      // For string, null, array, object - keep as-is\n      return value as string | number | boolean | null;\n    }\n  };\n\n  // Build derivation object for all columns that need casting\n  const derivations: {\n    value?: ReturnType<typeof escape>;\n    scan_error_refusal?: ReturnType<typeof escape>;\n  } = {};\n\n  if (hasValue) {\n    derivations.value = escape((d: { value: unknown; value_type: string }) => {\n      return castValue(d.value, d.value_type);\n    });\n  }\n\n  if (hasScanRefusal) {\n    derivations.scan_error_refusal = escape(\n      (d: { scan_error_refusal: string }) => {\n        if (typeof d.scan_error_refusal === \"string\") {\n          return d.scan_error_refusal?.toLowerCase() === \"true\";\n        }\n\n        return !!d.scan_error_refusal;\n      }\n    );\n  }\n\n  // Apply all derivations in a single pass\n  return table.derive(derivations);\n}\n","import { ColumnTable, from } from \"arquero\";\nimport JSON5 from \"json5\";\n\nimport { asyncJsonParse } from \"../../utils/json-worker\";\nimport { ScanResultReference, ValueType } from \"../types\";\n\ninterface Result {\n  uuid?: string | null;\n  label?: string | null;\n  value: unknown;\n  type?: ValueType | null;\n  answer?: string | null;\n  explanation?: string | null;\n  metadata?: Record<string, unknown> | null;\n  references?: ScanResultReference[];\n}\n\n// Expand rows where value_type == \"resultset\" into multiple rows.\n//\n// For rows with value_type == \"resultset\", the value field contains a JSON-encoded\n// list of Result objects. This function:\n// 1. Parses the JSON value into a list\n// 2. Explodes each list element into its own row using Arquero's unroll()\n// 3. Normalizes the Result fields into columns (uuid, label, value, etc.)\n// 4. Applies type casting to the expanded value column\n//\n// I tested an alternative approach to this using Arquero's unroll() function\n// directly in a derive() expression, but it wasn't faster (was actually a\n// touch slower anecdotally) and was a much more complex set of operations.\n// I omit that function and instead just operate on the rows directly.\nexport async function expandResultsetRows(\n  columnTable: ColumnTable\n): Promise<ColumnTable> {\n  // Ensure that each row in the table has an \"identifier\" column (this is used as a unique key for\n  // referencing rows since code below may expand one row with a resultset into multiple rows.\n  // We use the existing \"uuid\" column if it exists, otherwise we generate a random UUID. It is expected that the resultset expansion\n  // will overwrite this value for expanded rows\n  const colNames = columnTable.columnNames();\n  if (!colNames.includes(\"identifier\")) {\n    const numRows = columnTable.numRows();\n    const identifiers = new Array<string>(numRows);\n    if (colNames.includes(\"uuid\")) {\n      const uuids = columnTable.array(\"uuid\") as (string | null | undefined)[];\n      for (let i = 0; i < numRows; i++) {\n        identifiers[i] = uuids[i] ?? crypto.randomUUID();\n      }\n    } else {\n      for (let i = 0; i < numRows; i++) {\n        identifiers[i] = crypto.randomUUID();\n      }\n    }\n    columnTable = columnTable.assign({ identifier: identifiers });\n  }\n\n  // Check if we have any resultset rows\n  if (\n    !colNames.includes(\"value_type\") ||\n    !colNames.includes(\"value\") ||\n    columnTable.numRows() === 0\n  ) {\n    return columnTable;\n  }\n\n  // Are there any results sets to explode?\n  const resultsetCount = columnTable\n    .filter((d: { value_type: string }) => d.value_type === \"resultset\")\n    .numRows();\n  if (resultsetCount === 0) {\n    // No result sets\n    return columnTable;\n  }\n\n  // Split into resultset and non-resultset rows\n  const resultsetRows = columnTable.filter(\n    (d: { value_type: string }) => d.value_type === \"resultset\"\n  );\n  const otherRows = columnTable.filter(\n    (d: { value_type: string }) => d.value_type !== \"resultset\"\n  );\n\n  // Parse JSON value strings and expand into multiple rows\n  // (Arquero doesn't support try-catch in derive expressions, so we do this in plain JS)\n  const resultObjs = resultsetRows.objects() as Record<string, unknown>[];\n  const explodedResultsetRows: Record<string, unknown>[] = [];\n\n  for (const row of resultObjs) {\n    try {\n      // Get the result set value\n      const valueStr = row.value as string;\n      const results = valueStr ? JSON5.parse<Result[]>(valueStr) : [];\n\n      // If the row has an empty result set, just leave it\n      // intact\n      if (!results || results.length === 0) {\n        const expandedRow = { ...row };\n        expandedRow.value = null;\n        expandedRow.value_type = \"null\";\n        explodedResultsetRows.push(expandedRow);\n        continue;\n      }\n\n      for (const result of results) {\n        const expandedRow = { ...row };\n\n        // Record the source identifier\n        expandedRow.identifier = result.uuid ?? crypto.randomUUID();\n\n        // Override values\n\n        expandedRow.label = result.label ?? null;\n        expandedRow.answer = result.answer ?? null;\n        expandedRow.explanation = result.explanation ?? null;\n\n        // Extract label-based validation, if present\n        if (\n          row.validation_result &&\n          typeof row.validation_result === \"string\"\n        ) {\n          expandedRow.validation_result = await extractLabelValidation(\n            expandedRow,\n            row.validation_result\n          );\n        }\n\n        // Handle metadata\n        const metadata = result.metadata ?? {};\n        expandedRow.metadata = maybeSerializeValue(metadata);\n\n        // Determine value_type\n        const valueType = result.type ?? inferType(result.value);\n        expandedRow.value_type = valueType;\n\n        // Cast the value based on its type\n        const value = maybeSerializeValue(result.value);\n        expandedRow.value = value;\n\n        // Split into message_references and event_references\n        const references = result.references ?? [];\n        const messageRefs = references.filter((ref) => ref.type === \"message\");\n        const eventRefs = references.filter((ref) => ref.type === \"event\");\n        expandedRow.message_references = maybeSerializeValue(messageRefs);\n        expandedRow.event_references = maybeSerializeValue(eventRefs);\n\n        // don't clear out scan execution fields to avoid incorrect aggregation\n        // (these represent the scan execution, not individual results)\n        // (since these aren't for computation, we're keeping them for display)\n        // expandedRow.scan_total_tokens = null;\n        // expandedRow.scan_model_usage = null;\n\n        explodedResultsetRows.push(expandedRow);\n      }\n    } catch (error) {\n      console.error(\"Failed to parse resultset value:\", error);\n      continue;\n    }\n  }\n\n  // Create synthetic rows for missing labels with negative expected values\n  const syntheticRows = await createSyntheticRows(\n    explodedResultsetRows,\n    resultObjs\n  );\n\n  // Combine with non-resultset rows\n  if (explodedResultsetRows.length === 0) {\n    return otherRows;\n  } else {\n    // Create an array merging all the rows and convert back to a column table\n    const otherRowsArray = otherRows.objects() as Record<string, unknown>[];\n\n    const allRowsArray = [\n      ...otherRowsArray,\n      ...explodedResultsetRows,\n      ...syntheticRows,\n    ];\n\n    // Create new table from combined array\n    return from(allRowsArray);\n  }\n}\n\nasync function extractLabelValidation(\n  row: Record<string, unknown>,\n  validationResultStr: string\n): Promise<boolean | string | null | unknown> {\n  if (!row.label || typeof row.label !== \"string\") {\n    return validationResultStr;\n  }\n\n  try {\n    const parsedValidation = await asyncJsonParse<unknown>(validationResultStr);\n\n    // Check if this is label-based validation (dict of label -> bool)\n    if (\n      typeof parsedValidation === \"object\" &&\n      parsedValidation !== null &&\n      !Array.isArray(parsedValidation)\n    ) {\n      // Extract the validation result for this specific label\n      const validationDict = parsedValidation as Record<string, boolean>;\n      const labelValidation = validationDict[row.label];\n      return labelValidation ?? null;\n    }\n\n    // Not label-based, return as-is\n    return parsedValidation;\n  } catch (error) {\n    // If parsing fails, return original string\n    return validationResultStr;\n  }\n}\n\n/**\n * Create synthetic rows for missing labels with negative expected values.\n *\n * When validation_target contains expected labels that are not present in the\n * expanded results, and the expected value is \"negative\" (false, null, etc.),\n * this creates synthetic rows for those missing labels.\n *\n * @param expandedRows - The expanded result rows\n * @param resultsetRows - The original resultset rows (used as template)\n * @returns Array of synthetic rows to add\n */\nasync function createSyntheticRows(\n  expandedRows: Record<string, unknown>[],\n  resultsetRows: Record<string, unknown>[]\n): Promise<Record<string, unknown>[]> {\n  if (resultsetRows.length === 0 || expandedRows.length === 0) {\n    return [];\n  }\n\n  // Check if we have validation_target in the first row\n  const firstRow = expandedRows[0];\n  if (\n    !firstRow ||\n    !firstRow.validation_target ||\n    typeof firstRow.validation_target !== \"string\"\n  ) {\n    return [];\n  }\n\n  try {\n    // Parse validation_target to check if it's label-based (a dict)\n    const parsedTarget = await asyncJsonParse<unknown>(\n      firstRow.validation_target\n    );\n    if (\n      typeof parsedTarget !== \"object\" ||\n      parsedTarget === null ||\n      Array.isArray(parsedTarget)\n    ) {\n      return [];\n    }\n\n    const validationTarget = parsedTarget as Record<string, unknown>;\n\n    // Parse validation_result\n    const parsedResult = firstRow.validation_result\n      ? await asyncJsonParse<unknown>(\n          typeof firstRow.validation_result === \"string\"\n            ? firstRow.validation_result\n            : JSON.stringify(firstRow.validation_result)\n        )\n      : {};\n    const validationResults =\n      typeof parsedResult === \"object\" && !Array.isArray(parsedResult)\n        ? (parsedResult as Record<string, unknown>)\n        : {};\n\n    // Get all labels present in expanded rows\n    const presentLabels = new Set(\n      expandedRows\n        .map((row) => row.label)\n        .filter((label) => label !== null && label !== undefined)\n    );\n\n    // Get expected labels from validation_target\n    const expectedLabels = Object.keys(validationTarget);\n\n    // Missing labels = expected but not present\n    const missingLabels = expectedLabels.filter(\n      (label) => !presentLabels.has(label)\n    );\n\n    // Create synthetic rows for missing labels with negative expected values\n    const syntheticRows: Record<string, unknown>[] = [];\n    const negativeValues = [false, null, \"NONE\", \"none\", 0, \"\"];\n\n    for (const label of missingLabels) {\n      const expectedValue = validationTarget[label];\n\n      // Only create synthetic row if expected value is negative\n      if (!negativeValues.includes(expectedValue as never)) {\n        continue;\n      }\n\n      // Get a template row from the first resultset row\n      const templateRow = { ...resultsetRows[0] };\n\n      // Set result-specific fields for the synthetic row\n      templateRow.label = label;\n      templateRow.value = expectedValue;\n      templateRow.value_type =\n        typeof expectedValue === \"boolean\" ? \"boolean\" : \"null\";\n      templateRow.answer = null;\n      templateRow.explanation = null;\n      templateRow.metadata = maybeSerializeValue({});\n      templateRow.message_references = maybeSerializeValue([]);\n      templateRow.event_references = maybeSerializeValue([]);\n      templateRow.uuid = null;\n      templateRow.identifier = crypto.randomUUID();\n\n      // Set validation result for this synthetic row\n      templateRow.validation_result = validationResults[label] ?? null;\n\n      // NULL out error fields\n      templateRow.scan_error = null;\n      templateRow.scan_error_traceback = null;\n      templateRow.scan_error_type = null;\n\n      // NULL out scan execution fields\n      templateRow.scan_total_tokens = null;\n      templateRow.scan_model_usage = null;\n\n      syntheticRows.push(templateRow);\n    }\n\n    return syntheticRows;\n  } catch (error) {\n    // If parsing fails, no synthetic rows\n    return [];\n  }\n}\n\nfunction inferType(value: unknown): ValueType {\n  if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (typeof value === \"number\") {\n    return \"number\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (Array.isArray(value)) {\n    return \"array\";\n  } else if (value !== null && typeof value === \"object\") {\n    return \"object\";\n  }\n  return \"null\";\n}\n\nconst maybeSerializeValue = (\n  value: unknown\n): string | number | boolean | null => {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  if (\n    typeof value === \"string\" ||\n    typeof value === \"number\" ||\n    typeof value === \"boolean\"\n  ) {\n    return value;\n  }\n  // Convert complex types (arrays, objects) to JSON strings\n  return JSON5.stringify(value);\n};\n","import { skipToken } from \"@tanstack/react-query\";\nimport { ColumnTable } from \"arquero\";\n\nimport { useApi } from \"../../state/store\";\nimport { decodeArrowBytes } from \"../../utils/arrow\";\nimport { AsyncData } from \"../../utils/asyncData\";\nimport { useAsyncDataFromQuery } from \"../../utils/asyncDataFromQuery\";\nimport { expandResultsetRows } from \"../utils/arrow\";\n\ntype ScanDataframeParams = {\n  scansDir: string;\n  scanPath: string;\n  scanner: string;\n};\n\n// Fetches scanner dataframe from the server by location and scanner\nexport const useScanDataframe = (\n  params: ScanDataframeParams | typeof skipToken\n): AsyncData<ColumnTable> => {\n  const api = useApi();\n\n  return useAsyncDataFromQuery({\n    queryKey:\n      params === skipToken\n        ? [skipToken]\n        : [\n            \"scanDataframe\",\n            params.scansDir,\n            params.scanPath,\n            params.scanner,\n            \"scans-inv\",\n          ],\n    queryFn:\n      params === skipToken\n        ? skipToken\n        : async () =>\n            expandResultsetRows(\n              decodeArrowBytes(\n                await api.getScannerDataframe(\n                  params.scansDir,\n                  params.scanPath,\n                  params.scanner\n                )\n              )\n            ),\n    staleTime: Infinity,\n  });\n};\n","import { useMemo } from \"react\";\n\nimport { useMapAsyncData } from \"../../hooks/useMapAsyncData\";\nimport { useStore } from \"../../state/store\";\nimport { Status } from \"../../types/api-types\";\nimport { AsyncData, data } from \"../../utils/asyncData\";\n\nimport { useSelectedScan } from \"./useSelectedScan\";\n\nexport const useSelectedScanner = (): AsyncData<string> => {\n  const selectedScanner = useStore((state) => state.selectedScanner);\n  // TODO: This is a little bogus since we really don't need to do the server fetch\n  // if we found the selectedScanner from zustand. Alas, the rules of hooks.\n  const defaultScanner = useMapAsyncData(\n    useSelectedScan(),\n    _get_default_scanner\n  );\n\n  const selectedScannerAsyncData = useMemo(\n    () => (selectedScanner ? data(selectedScanner) : undefined),\n    [selectedScanner]\n  );\n\n  return selectedScannerAsyncData ?? defaultScanner;\n};\n\nconst _get_default_scanner = (s: Status): string => {\n  const result = s.summary.scanners\n    ? Object.keys(s.summary.scanners)[0]\n    : undefined;\n  if (!result) {\n    throw new Error(\"Scan must have a scanner\");\n  }\n  return result;\n};\n","import { skipToken } from \"@tanstack/react-query\";\nimport { ColumnTable } from \"arquero\";\n\nimport { AsyncData } from \"../../utils/asyncData\";\nimport { useScanDataframe } from \"../server/useScanDataframe\";\n\nimport { useScanRoute } from \"./useScanRoute\";\nimport { useSelectedScanner } from \"./useSelectedScanner\";\n\nexport const useSelectedScanDataframe = (): AsyncData<ColumnTable> => {\n  const { resolvedScansDir, scanPath } = useScanRoute();\n  const scanner = useSelectedScanner();\n\n  return useScanDataframe(\n    resolvedScansDir && scanPath && scanner.data\n      ? { scansDir: resolvedScansDir, scanPath, scanner: scanner.data }\n      : skipToken\n  );\n};\n","import { ColumnTable } from \"arquero\";\n\nimport { Event, JsonValue, ModelUsage } from \"../../types/api-types\";\nimport { isJson } from \"../../utils/json\";\nimport { asyncJsonParse } from \"../../utils/json-worker\";\nimport {\n  ScanResultData,\n  ScanResultReference,\n  ScanResultSummary,\n} from \"../types\";\n\nexport const parseScanResultData = async (\n  filtered: ColumnTable\n): Promise<ScanResultData> => {\n  const valueType = filtered.get(\"value_type\", 0) as ValueType;\n\n  const transcript_agent_args_raw = getOptionalColumn<string>(\n    filtered,\n    \"transcript_agent_args\",\n    0\n  );\n  const transcript_score_raw = getOptionalColumn<string>(\n    filtered,\n    \"transcript_score\",\n    0\n  );\n\n  // Note that validation_result and validation_target will always a JSON deserializable string as of Jan 7 2026, but prior to this it could be stored as a boolean directly. This conditionality deals with that.\n  const [\n    eventReferences,\n    inputIds,\n    messageReferences,\n    metadata,\n    scanEvents,\n    scanMetadata,\n    scanModelUsage,\n    scanTags,\n    scannerParams,\n    transcriptMetadata,\n    validationResult,\n    validationTarget,\n    value,\n    transcriptAgentArgs,\n    transcriptScore,\n  ] = await Promise.all([\n    parseJson(filtered.get(\"event_references\", 0) as string),\n    parseJson(filtered.get(\"input_ids\", 0) as string),\n    parseJson(filtered.get(\"message_references\", 0) as string),\n    parseJson(filtered.get(\"metadata\", 0) as string),\n    parseJson(filtered.get(\"scan_events\", 0) as string),\n    parseJson(filtered.get(\"scan_metadata\", 0) as string),\n    parseJson(filtered.get(\"scan_model_usage\", 0) as string),\n    parseJson(filtered.get(\"scan_tags\", 0) as string),\n    parseJson(filtered.get(\"scanner_params\", 0) as string),\n    parseJson(filtered.get(\"transcript_metadata\", 0) as string),\n    tryParseJson<boolean | Record<string, boolean>>(\n      filtered.get(\"validation_result\", 0)\n    ),\n    tryParseJson<JsonValue>(filtered.get(\"validation_target\", 0)),\n    parseSimpleValue(filtered.get(\"value\", 0), valueType),\n    transcript_agent_args_raw\n      ? parseJson(transcript_agent_args_raw)\n      : Promise.resolve(undefined),\n    transcript_score_raw !== null && transcript_score_raw !== undefined\n      ? parseJsonValue(transcript_score_raw)\n      : Promise.resolve(undefined),\n  ]);\n\n  const identifier = filtered.get(\"identifier\", 0) as string;\n  const uuid = filtered.get(\"uuid\", 0) as string | undefined;\n  const timestamp = getOptionalColumn<string>(filtered, \"timestamp\");\n  const answer = filtered.get(\"answer\", 0) as string | undefined;\n  const label = getOptionalColumn<string>(filtered, \"label\");\n  const explanation = filtered.get(\"explanation\", 0) as string | undefined;\n  const inputType = filtered.get(\"input_type\", 0) as\n    | \"transcript\"\n    | \"message\"\n    | \"messages\"\n    | \"event\"\n    | \"events\";\n  const scanError = filtered.get(\"scan_error\", 0) as string | undefined;\n  const scanErrorTraceback = filtered.get(\"scan_error_traceback\", 0) as\n    | string\n    | undefined;\n  const scanErrorRefusal =\n    getOptionalColumn<boolean>(filtered, \"scan_error_refusal\") ?? false;\n  const scanId = filtered.get(\"scan_id\", 0) as string;\n  const scanTotalTokens = filtered.get(\"scan_total_tokens\", 0) as number;\n  const scannerFile = filtered.get(\"scanner_file\", 0) as string;\n  const scannerKey = filtered.get(\"scanner_key\", 0) as string;\n  const scannerName = filtered.get(\"scanner_name\", 0) as string;\n  const transcriptId = filtered.get(\"transcript_id\", 0) as string;\n  const transcriptSourceId = filtered.get(\"transcript_source_id\", 0) as string;\n  const transcriptSourceUri = filtered.get(\n    \"transcript_source_uri\",\n    0\n  ) as string;\n\n  const transcriptTaskSet = getOptionalColumn<string>(\n    filtered,\n    \"transcript_task_set\"\n  );\n  const transcriptTaskId = getOptionalColumn<string | number>(\n    filtered,\n    \"transcript_task_id\"\n  );\n  const transcriptTaskRepeat = getOptionalColumn<number>(\n    filtered,\n    \"transcript_task_repeat\"\n  );\n  const transcriptDate = getOptionalColumn<string>(filtered, \"transcript_date\");\n  const transcriptAgent = getOptionalColumn<string>(\n    filtered,\n    \"transcript_agent\"\n  );\n  const transcriptModel = getOptionalColumn<string>(\n    filtered,\n    \"transcript_model\"\n  );\n  const transcriptSuccess = getOptionalColumn<boolean>(\n    filtered,\n    \"transcript_success\"\n  );\n  const transcriptTotalTime = getOptionalColumn<number>(\n    filtered,\n    \"transcript_total_time\"\n  );\n  const transcriptTotalTokens = getOptionalColumn<number>(\n    filtered,\n    \"transcript_total_tokens\"\n  );\n  const transcriptMessageCount = getOptionalColumn<number>(\n    filtered,\n    \"transcript_message_count\"\n  );\n  const transcriptError = getOptionalColumn<string>(\n    filtered,\n    \"transcript_error\"\n  );\n  const transcriptLimit = getOptionalColumn<string>(\n    filtered,\n    \"transcript_limit\"\n  );\n\n  const baseData = {\n    identifier,\n    uuid,\n    timestamp,\n    answer,\n    label,\n    eventReferences: eventReferences as ScanResultReference[],\n    explanation,\n    inputIds: inputIds as string[],\n    messageReferences: messageReferences as ScanResultReference[],\n    metadata: metadata as Record<string, JsonValue>,\n    scanError,\n    scanErrorTraceback,\n    scanErrorRefusal,\n    scanEvents: scanEvents as Event[],\n    scanId,\n    scanMetadata: scanMetadata as Record<string, JsonValue>,\n    scanModelUsage: scanModelUsage as Record<string, ModelUsage>,\n    scanTags: scanTags as string[],\n    scanTotalTokens,\n    scannerFile,\n    scannerKey,\n    scannerName,\n    scannerParams: scannerParams as Record<string, JsonValue>,\n    transcriptId,\n    transcriptMetadata: (transcriptMetadata ?? {}) as Record<string, JsonValue>,\n    transcriptSourceId,\n    transcriptSourceUri,\n    transcriptTaskSet,\n    transcriptTaskId,\n    transcriptTaskRepeat,\n    transcriptAgent,\n    transcriptAgentArgs: transcriptAgentArgs as Record<string, unknown>,\n    transcriptDate,\n    transcriptModel,\n    transcriptScore,\n    transcriptSuccess,\n    transcriptTotalTime,\n    transcriptTotalTokens,\n    transcriptMessageCount,\n    transcriptError,\n    transcriptLimit,\n    validationResult,\n    validationTarget,\n    value: value ?? null,\n    valueType,\n  };\n\n  // Resolve old values from the metadata if not present directly\n  // this should only be hit if the scan was old enough to not have\n  // these fields\n  resolveTranscriptPropertiesFromMetadata(baseData);\n\n  return { ...baseData, inputType };\n};\n\nexport const parseScanResultSummaries = async (\n  rowData: object[]\n): Promise<ScanResultSummary[]> =>\n  Promise.all(\n    rowData.map(async (row) => {\n      const r = row as Record<string, unknown>;\n\n      const valueType = r.value_type as ValueType;\n\n      // Note that validation_result and validation_target will always a JSON deserializable string as of Jan 7 2026, but prior to this it could be stored as a boolean directly. This conditionality deals with that.\n      const [\n        validationResult,\n        validationTarget,\n        transcriptMetadata,\n        eventReferences,\n        messageReferences,\n        value,\n      ] = await Promise.all([\n        tryParseJson<boolean | Record<string, boolean>>(r.validation_result),\n        tryParseJson<JsonValue>(r.validation_target),\n        parseJson<Record<string, JsonValue>>(r.transcript_metadata as string),\n        parseJson(r.event_references as string),\n        parseJson(r.message_references as string),\n        parseSimpleValue(r.value, valueType),\n      ]);\n\n      const baseSummary = {\n        identifier: r.identifier as string,\n        uuid: r.uuid as string | undefined,\n        label: r.label as string | undefined,\n        explanation: r.explanation as string,\n        eventReferences: eventReferences as ScanResultReference[],\n        messageReferences: messageReferences as ScanResultReference[],\n        validationResult: validationResult,\n        validationTarget: validationTarget,\n        value: value ?? null,\n        valueType,\n        transcriptTaskSet: r.transcript_task_set as string | undefined,\n        transcriptTaskId: r.transcript_task_id as string | number | undefined,\n        transcriptTaskRepeat: r.transcript_task_repeat as number | undefined,\n        transcriptModel: r.transcript_model as string | undefined,\n        transcriptMetadata: transcriptMetadata ?? {},\n        transcriptSourceId: r.transcript_source_id as string,\n        scanError: r.scan_error as string,\n        scanErrorRefusal: r.scan_error_refusal as boolean,\n        timestamp: r.timestamp ? (r.timestamp as string) : undefined,\n      };\n\n      resolveTranscriptPropertiesFromMetadata(baseSummary);\n\n      const inputType = r.input_type as\n        | \"transcript\"\n        | \"message\"\n        | \"messages\"\n        | \"event\"\n        | \"events\";\n\n      return { ...baseSummary, inputType };\n    })\n  );\n\nfunction resolveTranscriptPropertiesFromMetadata<\n  T extends {\n    transcriptModel?: string;\n    transcriptTaskSet?: string;\n    transcriptTaskId?: string | number;\n    transcriptTaskRepeat?: number;\n    transcriptMetadata: Record<string, unknown>;\n  },\n>(data: T): void {\n  if (data.transcriptModel === undefined) {\n    data.transcriptModel = data.transcriptMetadata[\"model\"] as string;\n  }\n\n  if (data.transcriptTaskSet === undefined) {\n    data.transcriptTaskSet = data.transcriptMetadata[\"task_name\"] as string;\n  }\n\n  if (data.transcriptTaskId === undefined) {\n    data.transcriptTaskId = data.transcriptMetadata[\"id\"] as string | number;\n  }\n\n  if (data.transcriptTaskRepeat === undefined) {\n    data.transcriptTaskRepeat = data.transcriptMetadata[\"epoch\"] as number;\n  }\n}\n\nconst parseJson = async <T>(text: string | null): Promise<T | undefined> =>\n  text !== null ? asyncJsonParse<T>(text) : undefined;\n\nconst tryParseJson = async <T>(text: unknown): Promise<T> => {\n  try {\n    return await asyncJsonParse<T>(text as string);\n  } catch {\n    return text as T;\n  }\n};\n\ntype ValueType = \"string\" | \"number\" | \"boolean\" | \"null\" | \"array\" | \"object\";\n\nconst parseSimpleValue = (\n  val: unknown,\n  valueType: ValueType\n): Promise<\n  string | number | boolean | null | unknown[] | object | undefined\n> =>\n  valueType === \"object\" || valueType === \"array\"\n    ? parseJson<object | unknown[]>(val as string)\n    : Promise.resolve(val as string | number | boolean | null);\n\nconst parseJsonValue = (val?: unknown): Promise<JsonValue | undefined> => {\n  if (!val) {\n    return Promise.resolve(undefined);\n  }\n\n  if (typeof val === \"string\" && isJson(val)) {\n    return parseJson<JsonValue>(val).then((parsed) => parsed as JsonValue);\n  } else {\n    return Promise.resolve(val as JsonValue);\n  }\n};\n\nfunction getOptionalColumn<T>(\n  table: ColumnTable,\n  columnName: string,\n  rowIndex: number = 0\n): T | undefined {\n  return table.columnNames().includes(columnName)\n    ? (table.get(columnName, rowIndex) as T)\n    : undefined;\n}\n","import { EventType } from \"../components/transcript/types\";\nimport {\n  ModelUsage,\n  JsonValue,\n  ChatMessageSystem,\n  ChatMessageUser,\n  ChatMessageAssistant,\n  ChatMessageTool,\n  Event,\n  ChatMessage,\n  Transcript,\n} from \"../types/api-types\";\n\nexport interface ScanResultInputData {\n  input: Input;\n  inputType: InputType;\n}\n\nexport type Input =\n  | Transcript\n  | ChatMessage[]\n  | Event[]\n  | MessageType\n  | EventType;\n\nexport type InputType =\n  | \"transcript\"\n  | \"message\"\n  | \"messages\"\n  | \"event\"\n  | \"events\";\n\nexport interface ScanResultSummary {\n  // Basic Info\n  identifier: string;\n  // The original DB result UUID. Shared across expanded resultset rows (e.g.\n  // multiple labels from one scan result will have the same uuid but different\n  // identifiers). Used to fetch the shared input data for the result.\n  uuid?: string;\n  explanation?: string;\n  label?: string;\n  timestamp?: string;\n\n  // Input\n  inputType: InputType;\n\n  // Refs\n  eventReferences: ScanResultReference[];\n  messageReferences: ScanResultReference[];\n\n  // Validation\n  validationResult: boolean | Record<string, boolean>;\n  validationTarget: JsonValue;\n\n  // Value\n  value: string | boolean | number | null | unknown[] | object;\n  valueType: ValueType;\n\n  // Scan metadata\n  scanError?: string;\n  scanErrorRefusal?: boolean;\n\n  // Transcript info\n  transcriptSourceId: string;\n  transcriptTaskSet?: string;\n  transcriptTaskId?: string | number;\n  transcriptTaskRepeat?: number;\n  transcriptModel?: string;\n  transcriptMetadata: Record<string, JsonValue>;\n}\n\n// Base interface with common properties\nexport interface ScanResultData extends ScanResultSummary {\n  answer?: string;\n  inputIds: string[];\n  metadata: Record<string, JsonValue>;\n  scanError?: string;\n  scanErrorTraceback?: string;\n  scanErrorRefusal?: boolean;\n  scanEvents: Event[];\n  scanId: string;\n  scanMetadata: Record<string, JsonValue>;\n  scanModelUsage: Record<string, ModelUsage>;\n  scanTags: string[];\n  scanTotalTokens: number;\n  scannerFile: string;\n  scannerKey: string;\n  scannerName: string;\n  scannerParams: Record<string, JsonValue>;\n  transcriptId: string;\n  transcriptSourceUri: string;\n\n  transcriptDate?: string;\n  transcriptAgent?: string;\n  transcriptAgentArgs?: Record<string, unknown>;\n  transcriptScore?: JsonValue;\n  transcriptSuccess?: boolean;\n  transcriptMessageCount?: number;\n  transcriptTotalTime?: number;\n  transcriptTotalTokens?: number;\n  transcriptError?: string;\n  transcriptLimit?: string;\n}\n\nexport interface ScanResultReference {\n  type: \"message\" | \"event\";\n  id: string;\n  cite?: string;\n}\n\nexport type MessageType =\n  | ChatMessageSystem\n  | ChatMessageUser\n  | ChatMessageAssistant\n  | ChatMessageTool;\n\nexport interface SortColumn {\n  column: string;\n  direction: \"asc\" | \"desc\";\n}\n\nexport type ErrorScope =\n  | \"scans\"\n  | \"scanner\"\n  | \"dataframe\"\n  | \"dataframe_input\"\n  | \"transcripts\";\n\nexport type ResultGroup =\n  | \"source\"\n  | \"label\"\n  | \"id\"\n  | \"epoch\"\n  | \"model\"\n  | \"none\";\n\nexport type ValueType =\n  | \"boolean\"\n  | \"number\"\n  | \"string\"\n  | \"array\"\n  | \"object\"\n  | \"null\";\n\n// Type guard functions for value types\nexport function isStringValue(\n  result: ScanResultSummary\n): result is ScanResultSummary & { valueType: \"string\"; value: string } {\n  return result.valueType === \"string\";\n}\n\nexport function isNumberValue(\n  result: ScanResultSummary\n): result is ScanResultSummary & { valueType: \"number\"; value: number } {\n  return result.valueType === \"number\";\n}\n\nexport function isBooleanValue(\n  result: ScanResultSummary\n): result is ScanResultSummary & { valueType: \"boolean\"; value: boolean } {\n  return result.valueType === \"boolean\";\n}\n\nexport function isNullValue(\n  result: ScanResultSummary\n): result is ScanResultSummary & { valueType: \"null\"; value: null } {\n  return result.valueType === \"null\";\n}\n\nexport function isArrayValue(\n  result: ScanResultSummary\n): result is ScanResultSummary & { valueType: \"array\"; value: unknown[] } {\n  return result.valueType === \"array\";\n}\n\nexport function isObjectValue(\n  result: ScanResultSummary\n): result is ScanResultSummary & { valueType: \"object\"; value: object } {\n  return result.valueType === \"object\";\n}\n\n// Type guard functions for DataFrameInput\nexport function isTranscriptInput(\n  input: ScanResultInputData\n): input is ScanResultInputData & {\n  inputType: \"transcript\";\n  input: Transcript;\n} {\n  return input.inputType === \"transcript\";\n}\n\nexport function isMessageInput(\n  input: ScanResultInputData\n): input is ScanResultInputData & { inputType: \"message\"; input: MessageType } {\n  return input.inputType === \"message\";\n}\n\nexport function isMessagesInput(\n  input: ScanResultInputData\n): input is ScanResultInputData & {\n  inputType: \"messages\";\n  input: ChatMessage[];\n} {\n  return input.inputType === \"messages\";\n}\n\nexport function isEventInput(\n  input: ScanResultInputData\n): input is ScanResultInputData & { inputType: \"event\"; input: EventType } {\n  return input.inputType === \"event\";\n}\n\nexport function isEventsInput(\n  input: ScanResultInputData\n): input is ScanResultInputData & { inputType: \"events\"; input: Event[] } {\n  return input.inputType === \"events\";\n}\n","import { FC, ReactNode } from \"react\";\n\nimport {\n  MarkdownDivWithReferences,\n  MarkdownReference,\n} from \"../../components/MarkdownDivWithReferences\";\nimport { ScanResultSummary } from \"../types\";\n\ninterface ExplanationProps {\n  summary?: ScanResultSummary;\n  references?: MarkdownReference[];\n  options?: {\n    previewRefsOnHover?: boolean;\n  };\n}\n\nexport const Explanation: FC<ExplanationProps> = ({\n  summary,\n  references,\n  options,\n}): ReactNode => {\n  return (\n    <MarkdownDivWithReferences\n      markdown={summary?.explanation || \"\"}\n      references={references}\n      options={options}\n    />\n  );\n};\n","import clsx from \"clsx\";\nimport { FC } from \"react\";\n\nimport { ApplicationIcons } from \"../../components/icons\";\nimport { JsonValue } from \"../../types/json-value\";\n\nimport styles from \"./ValidationResult.module.css\";\n\ninterface ValidationResultProps {\n  result: boolean | Record<string, boolean>;\n  target?: JsonValue;\n  label?: string;\n}\n\nexport const ValidationResult: FC<ValidationResultProps> = ({\n  result,\n  target,\n  label,\n}) => {\n  // TODO: stringify the target value properly\n  if (typeof result === \"boolean\") {\n    return (\n      <Result\n        value={result}\n        targetValue={valueStr(resolveTargetValue(target, label))}\n      />\n    );\n  } else if (result !== null && typeof result === \"object\") {\n    const entries = Object.entries(result);\n\n    return (\n      <div className={clsx(styles.validationTable)}>\n        {entries.map(([key, value]) => (\n          <div key={`validation-result-${key}`}>\n            <Result\n              value={value}\n              targetValue={valueStr(resolveTargetValue(target, key))}\n            />\n          </div>\n        ))}\n      </div>\n    );\n  }\n};\n\nconst Result: FC<{ value: boolean; targetValue?: string }> = ({\n  value,\n  targetValue,\n}) => {\n  return (\n    <div>\n      <div className={clsx(value ? styles.true : styles.false, styles.result)}>\n        {value ? (\n          <i className={clsx(ApplicationIcons.check)} />\n        ) : (\n          <i className={clsx(ApplicationIcons.x)} />\n        )}\n      </div>\n      <span\n        className={clsx(\n          styles.targetValue,\n          \"text-size-smallestest\",\n          \"text-style-secondary\"\n        )}\n        title={targetValue}\n      >\n        {targetValue}\n      </span>\n    </div>\n  );\n};\n\nconst resolveTargetValue = (target?: JsonValue, key?: string): JsonValue => {\n  if (target === undefined) {\n    return \"\";\n  }\n\n  if (key === undefined) {\n    return target;\n  }\n\n  if (target && typeof target === \"object\" && !Array.isArray(target)) {\n    return (target as Record<string, JsonValue>)[key] || false;\n  }\n  return target;\n};\n\nconst valueStr = (target?: JsonValue): string => {\n  if (target === null) {\n    return \"null\";\n  } else if (typeof target === \"string\") {\n    return target;\n  } else if (typeof target === \"number\" || typeof target === \"boolean\") {\n    return target.toString();\n  } else if (Array.isArray(target)) {\n    return `[Array(${target.length})]`;\n  } else if (typeof target === \"object\") {\n    return \"{Object}\";\n  } else {\n    return \"undefined\";\n  }\n};\n","import clsx from \"clsx\";\nimport { FC, Fragment, ReactNode } from \"react\";\n\nimport { RecordTree } from \"../../components/content/RecordTree\";\nimport {\n  MarkdownDivWithReferences,\n  MarkdownReference,\n} from \"../../components/MarkdownDivWithReferences\";\nimport { printArray } from \"../../utils/array\";\nimport { formatPrettyDecimal } from \"../../utils/format\";\nimport { printObject } from \"../../utils/object\";\nimport {\n  ScanResultSummary,\n  isStringValue,\n  isNumberValue,\n  isBooleanValue,\n  isNullValue,\n  isArrayValue,\n  isObjectValue,\n} from \"../types\";\n\nimport styles from \"./Value.module.css\";\n\ninterface ValueProps {\n  summary: ScanResultSummary;\n  references: MarkdownReference[];\n  style: \"inline\" | \"block\";\n  maxTableSize?: number;\n  interactive?: boolean;\n  options?: {\n    previewRefsOnHover?: boolean;\n  };\n}\n\n// TODO: Implement popover viewer for object and list values\nexport const Value: FC<ValueProps> = ({\n  summary: result,\n  references,\n  style,\n  maxTableSize = 5,\n  interactive = false,\n  options,\n}): ReactNode => {\n  if (isStringValue(result)) {\n    return (\n      <MarkdownDivWithReferences\n        markdown={result.value}\n        references={references}\n        options={options}\n      />\n    );\n  } else if (isNumberValue(result) && result.value !== null) {\n    return formatPrettyDecimal(result.value);\n  } else if (isBooleanValue(result)) {\n    return (\n      <div\n        className={clsx(\n          styles.boolean,\n          result.value ? styles.true : styles.false\n        )}\n      >\n        {String(result.value)}\n      </div>\n    );\n  } else if (isNullValue(result)) {\n    return <code>null</code>;\n  } else if (isArrayValue(result)) {\n    return (\n      <ValueList\n        value={result.value}\n        summary={result}\n        references={references}\n        style={style}\n        maxListSize={maxTableSize}\n        interactive={interactive}\n      />\n    );\n  } else if (isObjectValue(result)) {\n    return (\n      <ValueTable\n        value={result.value}\n        summary={result}\n        references={references}\n        style={style}\n        maxTableSize={maxTableSize}\n        interactive={interactive}\n      />\n    );\n  } else {\n    return \"Unknown value type\";\n  }\n};\n\nconst ValueList: FC<{\n  value: unknown[];\n  summary: ScanResultSummary;\n  maxListSize: number;\n  interactive: boolean;\n  references: MarkdownReference[];\n  style: \"inline\" | \"block\";\n}> = ({\n  value,\n  summary: result,\n  maxListSize,\n  interactive,\n  references,\n  style,\n}) => {\n  // Display only maxListSize rows\n  const itemsToDisplay = value.slice(0, maxListSize);\n\n  // Display the rows\n  return (\n    <div\n      className={clsx(\n        styles.valueTable,\n        style === \"inline\" ? styles.inline : styles.block\n      )}\n    >\n      {itemsToDisplay.map((item, index) => {\n        const displayValue = renderValue(\n          index,\n          item,\n          result,\n          references,\n          interactive\n        );\n        return (\n          <Fragment key={`value-table-row-${index}`}>\n            <div\n              className={clsx(\n                styles.valueKey,\n                \"text-style-label\",\n                \"text-style-secondary\",\n                \"text-size-smallest\"\n              )}\n            >\n              [{index}]\n            </div>\n            <div className={clsx(styles.valueValue)}>{displayValue}</div>\n          </Fragment>\n        );\n      })}\n    </div>\n  );\n};\n\nconst ValueTable: FC<{\n  value: object;\n  summary: ScanResultSummary;\n  maxTableSize: number;\n  interactive: boolean;\n  references: MarkdownReference[];\n  style: \"inline\" | \"block\";\n}> = ({\n  value,\n  summary: result,\n  maxTableSize,\n  interactive,\n  references,\n  style,\n}) => {\n  // Sort keys by the value (desc, so true to false), then slice 5 keys to display\n  const sortedKeys = Object.keys(value).sort((a, b) => {\n    const aVal = (value as Record<string, unknown>)[a];\n    const bVal = (value as Record<string, unknown>)[b];\n    if (typeof aVal === \"boolean\" && typeof bVal === \"boolean\") {\n      return Number(bVal) - Number(aVal);\n    } else if (typeof aVal === \"number\" && typeof bVal === \"number\") {\n      return bVal - aVal;\n    } else {\n      // Keep original order if not boolean\n      return 0;\n    }\n  });\n\n  // Display only 5 rows\n  const keysToDisplay = sortedKeys.slice(0, maxTableSize);\n  const notShown = Object.keys(value).length - maxTableSize;\n\n  // Display the rows\n  return (\n    <div\n      className={clsx(\n        styles.valueTable,\n        style === \"inline\" ? styles.inline : styles.block\n      )}\n    >\n      {keysToDisplay.map((key, index) => {\n        const displayValue = renderValue(\n          index,\n          (value as Record<string, unknown>)[key],\n          result,\n          references,\n          interactive\n        );\n        return (\n          <Fragment key={`value-table-row-${key}`}>\n            <div\n              className={clsx(\n                styles.valueKey,\n                \"text-style-label\",\n                \"text-style-secondary\",\n                \"text-size-smallest\"\n              )}\n            >\n              {key}\n            </div>\n            <div className={clsx(styles.valueValue)}>{displayValue}</div>\n          </Fragment>\n        );\n      })}\n      {notShown > 0 && (\n        <Fragment key={`value-table-row-more`}>\n          <div\n            className={clsx(\n              styles.valueKey,\n              \"text-style-label\",\n              \"text-style-secondary\",\n              \"text-size-smallest\"\n            )}\n          >\n            {notShown} more\n          </div>\n          <div className={clsx(styles.valueValue)}></div>\n        </Fragment>\n      )}\n    </div>\n  );\n};\n\n// Renders a simple value (don't further render objects or lists here)\nconst renderValue = (\n  index: number,\n  val: unknown,\n  summary: ScanResultSummary,\n  references: MarkdownReference[],\n  interactive: boolean\n): ReactNode => {\n  if (typeof val === \"string\") {\n    return <MarkdownDivWithReferences markdown={val} references={references} />;\n  } else if (typeof val === \"number\") {\n    return formatPrettyDecimal(val);\n  } else if (typeof val === \"boolean\") {\n    return (\n      <div className={clsx(styles.boolean, val ? styles.true : styles.false)}>\n        {String(val)}\n      </div>\n    );\n  } else if (val === null) {\n    return <pre className={clsx(styles.value)}>null</pre>;\n  } else if (Array.isArray(val)) {\n    return printArray(val, 25);\n  } else if (typeof val === \"object\") {\n    return !interactive ? (\n      printObject(val, 35)\n    ) : (\n      <RecordTree\n        id={`value-record-${summary.identifier}-${index}`}\n        record={val as Record<string, unknown>}\n      />\n    );\n  } else {\n    return \"Unknown value type\";\n  }\n};\n","import { FC } from \"react\";\n\nimport { Event } from \"../../types/api-types\";\n\nimport { useEventNodes } from \"./hooks/useEventNodes\";\nimport { TranscriptViewNodes } from \"./TranscriptViewNodes\";\nimport { EventNode, EventType } from \"./types\";\n\ninterface TranscriptViewProps {\n  id: string;\n  events?: Event[];\n  nodeFilter?: (node: EventNode<EventType>[]) => EventNode<EventType>[];\n  scrollRef?: React.RefObject<HTMLDivElement | null>;\n  initialEventId?: string | null;\n  className?: string | string[];\n}\n\nexport const TranscriptView: FC<TranscriptViewProps> = ({\n  id,\n  events,\n  nodeFilter,\n  scrollRef,\n  initialEventId,\n  className,\n}) => {\n  // The list of events that have been collapsed\n  const { eventNodes, defaultCollapsedIds } = useEventNodes(\n    events || [],\n    false\n  );\n\n  return (\n    <TranscriptViewNodes\n      id={id}\n      eventNodes={eventNodes}\n      defaultCollapsedIds={defaultCollapsedIds}\n      nodeFilter={nodeFilter}\n      scrollRef={scrollRef}\n      initialEventId={initialEventId}\n      className={className}\n    />\n  );\n};\n","import { ReactNode, useMemo } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\nimport { ChatView } from \"../../components/chat/ChatView\";\nimport { MarkdownReference } from \"../../components/MarkdownDivWithReferences\";\nimport { TranscriptView } from \"../../components/transcript/TranscriptView\";\nimport { scanResultRoute } from \"../../router/url\";\nimport { useScanRoute } from \"../hooks/useScanRoute\";\nimport {\n  ScanResultInputData,\n  isEventInput,\n  isEventsInput,\n  isMessageInput,\n  isMessagesInput,\n  isTranscriptInput,\n  ScanResultSummary,\n} from \"../types\";\n\nexport type MakeReferenceUrl = (\n  ref: string,\n  type: \"message\" | \"event\"\n) => string | undefined;\n\nexport const useMarkdownRefs = (\n  summary?: ScanResultSummary,\n  inputData?: ScanResultInputData\n) => {\n  const { scansDir, scanPath } = useScanRoute();\n  const [currentSearchParams] = useSearchParams();\n\n  // Build URL to the scan result with the appropriate query parameters\n  // TODO: lint react-hooks/preserve-manual-memoization - the lint seems to be a bug in the rule that doesn't account for the ?\n  // eslint-disable-next-line react-hooks/preserve-manual-memoization\n  const buildUrl = useMemo(() => {\n    if (!summary?.identifier) {\n      return (queryParams: string) => `?${queryParams}`;\n    }\n\n    return (queryParams: string) => {\n      if (!scansDir) {\n        return `?${queryParams}`;\n      }\n      // Start with current search params to preserve validation, etc.\n      const mergedParams = new URLSearchParams(currentSearchParams);\n      // Add/override with new params\n      const newParams = new URLSearchParams(queryParams);\n      for (const [key, value] of newParams) {\n        mergedParams.set(key, value);\n      }\n      return `#${scanResultRoute(scansDir, scanPath, summary.identifier, mergedParams)}`;\n    };\n    // Use .toString() for currentSearchParams since URLSearchParams object reference\n    // may not change when URL changes, causing stale closures\n  }, [summary?.identifier, scanPath, scansDir, currentSearchParams]);\n\n  const refs: MarkdownReference[] = summary\n    ? toMarkdownRefs(\n        summary,\n        (refId: string, type: \"message\" | \"event\") => {\n          if (type === \"message\") {\n            return buildUrl(`tab=Result&message=${encodeURIComponent(refId)}`);\n          } else {\n            return buildUrl(`tab=Result&event=${encodeURIComponent(refId)}`);\n          }\n        },\n        inputData\n      )\n    : [];\n  return refs;\n};\n\nexport const toMarkdownRefs = (\n  summary: ScanResultSummary,\n  makeReferenceUrl: MakeReferenceUrl,\n  inputData?: ScanResultInputData\n) => {\n  const refLookup = referenceTable(inputData);\n\n  const refs: MarkdownReference[] = [];\n  for (const ref of summary.messageReferences) {\n    const renderPreview = refLookup[ref.id];\n    const refUrl = makeReferenceUrl(ref.id, \"message\");\n    if (ref.cite && (renderPreview || refUrl)) {\n      refs.push({\n        id: ref.id,\n        cite: ref.cite,\n        citePreview: renderPreview,\n        citeUrl: refUrl,\n      });\n    }\n  }\n\n  for (const ref of summary.eventReferences) {\n    const renderPreview = refLookup[ref.id];\n    const refUrl = makeReferenceUrl(ref.id, \"event\");\n    if (ref.cite && (renderPreview || refUrl)) {\n      refs.push({\n        id: ref.id,\n        cite: ref.cite,\n        citePreview: renderPreview,\n        citeUrl: refUrl,\n      });\n    }\n  }\n  return refs;\n};\n\nconst referenceTable = (\n  inputData?: ScanResultInputData\n): Record<string, () => ReactNode> => {\n  if (!inputData) {\n    return {};\n  }\n\n  if (isMessageInput(inputData)) {\n    if (!inputData.input.id) {\n      return {};\n    }\n    return {\n      [inputData.input.id]: () => {\n        return (\n          <ChatView\n            messages={[inputData.input]}\n            resolveToolCallsIntoPreviousMessage={false}\n          />\n        );\n      },\n    };\n  } else if (isMessagesInput(inputData)) {\n    return inputData.input.reduce<Record<string, () => ReactNode>>(\n      (acc, msg) => {\n        if (msg.id) {\n          acc[msg.id] = () => {\n            return (\n              <ChatView\n                messages={[msg]}\n                resolveToolCallsIntoPreviousMessage={false}\n              />\n            );\n          };\n        }\n        return acc;\n      },\n      {}\n    );\n  } else if (isEventInput(inputData)) {\n    if (!inputData.input.uuid) {\n      return {};\n    }\n\n    return {\n      [inputData.input.uuid]: () => {\n        return (\n          <TranscriptView\n            id={\"input-event-preview\"}\n            events={[inputData.input]}\n          />\n        );\n      },\n    };\n  } else if (isEventsInput(inputData)) {\n    return inputData.input.reduce<Record<string, () => ReactNode>>(\n      (acc, event, index) => {\n        if (event.uuid) {\n          acc[event.uuid] = () => {\n            return (\n              <TranscriptView\n                id={`input-event-preview-${index}`}\n                events={inputData.input}\n              />\n            );\n          };\n        }\n        return acc;\n      },\n      {}\n    );\n  } else if (isTranscriptInput(inputData)) {\n    const eventRefs = (inputData.input.events || []).reduce<\n      Record<string, () => ReactNode>\n    >((acc, event) => {\n      if (event.uuid) {\n        acc[event.uuid] = () => {\n          return <TranscriptView id={\"input-event-preview\"} events={[event]} />;\n        };\n      }\n      return acc;\n    }, {});\n\n    const messageRefs = (inputData.input.messages || []).reduce<\n      Record<string, () => ReactNode>\n    >((acc, msg) => {\n      if (msg.id) {\n        acc[msg.id] = () => {\n          return (\n            <ChatView\n              messages={[msg]}\n              resolveToolCallsIntoPreviousMessage={false}\n            />\n          );\n        };\n      }\n      return acc;\n    }, {});\n    return { ...eventRefs, ...messageRefs };\n  } else {\n    return {};\n  }\n};\n"],"names":["useEffect","scan","result","jsxs","jsx","value","resolve","v","error","decodeUtf8","encodeUtf8","isNumber","isFunction","isObject","isIterable","source","buffer","offset","length","pump","wrap","fromIterable","events","err","MetadataVersion","UnionMode","Precision","DateUnit","TimeUnit","IntervalUnit","SIZEOF_SHORT","SIZEOF_INT","int32","float32","float64","isLittleEndian","Encoding","t","ByteBuffer","table","field","utf8","list","BodyCompressionMethod","CompressionType","flatbuffers.SIZE_PREFIX_LENGTH","builder","FieldNode","Buffer","BodyCompression","RecordBatch","Endianness","DictionaryKind","Date","Map","data","Type","Field","MessageHeader","BufferType","x","sign","array","_a","Null","Binary","LargeBinary","Utf8","LargeUtf8","Bool","Decimal","Duration","List","FixedSizeBinary","FixedSizeList","entries","key","dictionary","Dictionary","f64","u32","values","instance","keys","json","getVisitor","setVisitor","getBool","slice","interval","bitmap","get","uint32","byteLength","nullCount","union","from","isValid","compare","_b","_c","_d","iteratorVisitor","begin","end","name","newData","indexOfVisitor","Schema","version","Builder","flatbuffers.Builder","flatbuffers.ByteBuffer","buf","_Footer","_Block","Struct","Map_","DictionaryBatch","Int","Time","Timestamp","Interval","Union","Message","_Message","_BodyCompressionMethod","_Schema","_RecordBatch","_DictionaryBatch","encodeField","decodeField","encodeSchema","decodeSchema","encodeRecordBatch","decodeRecordBatch","encodeDictionaryBatch","decodeDictionaryBatch","decodeSchemaFields","decodeFieldChildren","_Int","_FloatingPoint","_Decimal","_Date","_Time","_Timestamp","_Interval","_Duration","_Union","_FixedSizeBinary","_FixedSizeList","_Map","_KeyValue","_Endianness","typeAssembler","_Field","_BodyCompression","_FieldNode","_Buffer","_e","_f","product","columns","batches","empty","indices","oldToNew","Table","max","invalidMessageType","invalidMessageMetadata","invalidMessageBodyLength","MAGIC","metadata.RecordBatch","metadata.DictionaryBatch","types","metadata.BufferRegion","Footer","metadata.BodyCompression","tableFromIPC","reader","tableToIPC","count","min","isDate","a","b","isArray","TypedArray","isTypedArray","concat","sequence","join","year","month","date","hours","parse","timestamp","minutes","seconds","milliseconds","t0","random","_random","radians","degrees","object","repeat","toString","Op","objectKey","op","rank","unroll","output","expand","has","ValueList","Column","Function","visitors","visit","binary","func","call","opt","ref","fn","TokenType","Position","SourceLocation","Parser","match","DestructuringErrors","TokContext","update","Scope","Node","BranchID","RegExpValidationState","current","Token","check","node","assign","pairs","toObject","filter","sum","arrayType","objectBuilder","select","bisect","intersect","preparse","pad","vec","parseValues","rename","sample","replace","shuffle","sampleIndices","shuffleIndices","prep","_slice","map","identity","index","all","decoder","dict","batch","inferType","toOffset","lookup","batchType","formatValue","align","styles","escape","tag","raise","util","require$$0","xxh32","xxh32_1","require$$1","hashTable","arqueroTable","lz4js.compress","lz4js.decompress","valueStr","JSON5","useMemo","targetValue","Fragment"],"mappings":"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AAG,MAAM,EAAC;AACtE;ACbA,IAAI,wBAAwB,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,KAAK,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,MAAM,GAAG,GAAG,IAAI,OAAO,IAAI,MAAM,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,OAAO,GAAG,MAAM,GAAG,KAAK,IAAI,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,GAAG,MAAM,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG,GAAG,MAAM,GAAG,QAAQ,GAAG;AAGzoC,IAAI,6BAA6B,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,KAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,KAAK,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,MAAM,IAAI,IAAI,MAAM,IAAI,GAAG,IAAI,MAAM,GAAG,KAAK,MAAM,IAAI,MAAM,KAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,MAAM,GAAG,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,KAAK,MAAM,KAAK,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,MAAM,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,MAAM,IAAI,GAAG,GAAG,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,MAAM,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,MAAM,OAAO,IAAI,MAAM,GAAG,KAAK,GAAG,MAAM,IAAI,MAAM,IAAI,KAAK,MAAM,KAAK,MAAM,MAAM,GAAG,IAAI;AAGnpE,IAAI,0BAA0B;AAG9B,IAAI,+BAA+B;AASnC,IAAI,gBAAgB;AAAA,EAClB,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,QAAQ;AAAA,EACR,YAAY;AACd;AAIA,IAAI,uBAAuB;AAE3B,IAAI,aAAa;AAAA,EACf,GAAG;AAAA,EACH,WAAW,uBAAuB;AAAA,EAClC,GAAG,uBAAuB;AAC5B;AAEA,IAAI,4BAA4B;AAIhC,IAAI,0BAA0B,IAAI,OAAO,MAAM,+BAA+B,GAAG;AACjF,IAAI,qBAAqB,IAAI,OAAO,MAAM,+BAA+B,0BAA0B,GAAG;AAKtG,SAAS,cAAc,MAAM,KAAK;AAChC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,GAAG;AACtC,WAAO,IAAI,CAAC;AACZ,QAAI,MAAM,MAAM;AAAE,aAAO;AAAA,IAAM;AAC/B,WAAO,IAAI,IAAI,CAAC;AAChB,QAAI,OAAO,MAAM;AAAE,aAAO;AAAA,IAAK;AAAA,EACjC;AACA,SAAO;AACT;AAIA,SAAS,kBAAkB,MAAM,QAAQ;AACvC,MAAI,OAAO,IAAI;AAAE,WAAO,SAAS;AAAA,EAAG;AACpC,MAAI,OAAO,IAAI;AAAE,WAAO;AAAA,EAAK;AAC7B,MAAI,OAAO,IAAI;AAAE,WAAO,SAAS;AAAA,EAAG;AACpC,MAAI,OAAO,KAAK;AAAE,WAAO;AAAA,EAAK;AAC9B,MAAI,QAAQ,OAAQ;AAAE,WAAO,QAAQ,OAAQ,wBAAwB,KAAK,OAAO,aAAa,IAAI,CAAC;AAAA,EAAE;AACrG,MAAI,WAAW,OAAO;AAAE,WAAO;AAAA,EAAM;AACrC,SAAO,cAAc,MAAM,0BAA0B;AACvD;AAIA,SAAS,iBAAiB,MAAM,QAAQ;AACtC,MAAI,OAAO,IAAI;AAAE,WAAO,SAAS;AAAA,EAAG;AACpC,MAAI,OAAO,IAAI;AAAE,WAAO;AAAA,EAAK;AAC7B,MAAI,OAAO,IAAI;AAAE,WAAO;AAAA,EAAM;AAC9B,MAAI,OAAO,IAAI;AAAE,WAAO;AAAA,EAAK;AAC7B,MAAI,OAAO,IAAI;AAAE,WAAO,SAAS;AAAA,EAAG;AACpC,MAAI,OAAO,KAAK;AAAE,WAAO;AAAA,EAAK;AAC9B,MAAI,QAAQ,OAAQ;AAAE,WAAO,QAAQ,OAAQ,mBAAmB,KAAK,OAAO,aAAa,IAAI,CAAC;AAAA,EAAE;AAChG,MAAI,WAAW,OAAO;AAAE,WAAO;AAAA,EAAM;AACrC,SAAO,cAAc,MAAM,0BAA0B,KAAK,cAAc,MAAM,qBAAqB;AACrG;AAyBA,IAAI,YAAY,SAASgO,WAAU,OAAO,MAAM;AAC9C,MAAK,SAAS,OAAS,QAAO,CAAA;AAE9B,OAAK,QAAQ;AACb,OAAK,UAAU,KAAK;AACpB,OAAK,aAAa,CAAC,CAAC,KAAK;AACzB,OAAK,aAAa,CAAC,CAAC,KAAK;AACzB,OAAK,SAAS,CAAC,CAAC,KAAK;AACrB,OAAK,WAAW,CAAC,CAAC,KAAK;AACvB,OAAK,SAAS,CAAC,CAAC,KAAK;AACrB,OAAK,UAAU,CAAC,CAAC,KAAK;AACtB,OAAK,QAAQ,KAAK,SAAS;AAC3B,OAAK,gBAAgB;AACvB;AAEA,SAAS,MAAM5H,OAAM,MAAM;AACzB,SAAO,IAAI,UAAUA,OAAM,EAAC,YAAY,MAAM,OAAO,KAAI,CAAC;AAC5D;AACA,IAAI,aAAa,EAAC,YAAY,KAAI,GAAG,aAAa,EAAC,YAAY,KAAI;AAInE,IAAI,WAAW,CAAA;AAGf,SAAS,GAAGA,OAAM,SAAS;AACzB,MAAK,YAAY,OAAS,WAAU,CAAA;AAEpC,UAAQ,UAAUA;AAClB,SAAO,SAASA,KAAI,IAAI,IAAI,UAAUA,OAAM,OAAO;AACrD;AAEA,IAAI,UAAU;AAAA,EACZ,KAAK,IAAI,UAAU,OAAO,UAAU;AAAA,EACpC,QAAQ,IAAI,UAAU,UAAU,UAAU;AAAA,EAC1C,QAAQ,IAAI,UAAU,UAAU,UAAU;AAAA,EAC1C,MAAM,IAAI,UAAU,QAAQ,UAAU;AAAA,EACtC,WAAW,IAAI,UAAU,aAAa,UAAU;AAAA,EAChD,KAAK,IAAI,UAAU,KAAK;AAAA;AAAA,EAGxB,UAAU,IAAI,UAAU,KAAK,EAAC,YAAY,MAAM,YAAY,KAAI,CAAC;AAAA,EACjE,UAAU,IAAI,UAAU,GAAG;AAAA,EAC3B,QAAQ,IAAI,UAAU,KAAK,EAAC,YAAY,MAAM,YAAY,KAAI,CAAC;AAAA,EAC/D,QAAQ,IAAI,UAAU,GAAG;AAAA,EACzB,QAAQ,IAAI,UAAU,KAAK,EAAC,YAAY,MAAM,YAAY,KAAI,CAAC;AAAA,EAC/D,QAAQ,IAAI,UAAU,GAAG;AAAA,EACzB,OAAO,IAAI,UAAU,KAAK,UAAU;AAAA,EACpC,MAAM,IAAI,UAAU,KAAK,UAAU;AAAA,EACnC,OAAO,IAAI,UAAU,KAAK,UAAU;AAAA,EACpC,KAAK,IAAI,UAAU,GAAG;AAAA,EACtB,UAAU,IAAI,UAAU,KAAK,UAAU;AAAA,EACvC,aAAa,IAAI,UAAU,IAAI;AAAA,EAC/B,OAAO,IAAI,UAAU,MAAM,UAAU;AAAA,EACrC,UAAU,IAAI,UAAU,UAAU;AAAA,EAClC,iBAAiB,IAAI,UAAU,iBAAiB;AAAA,EAChD,UAAU,IAAI,UAAU,OAAO,UAAU;AAAA,EACzC,WAAW,IAAI,UAAU,KAAK,UAAU;AAAA,EACxC,cAAc,IAAI,UAAU,MAAM,EAAC,YAAY,MAAM,YAAY,KAAI,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBtE,IAAI,IAAI,UAAU,KAAK,EAAC,YAAY,MAAM,UAAU,KAAI,CAAC;AAAA,EACzD,QAAQ,IAAI,UAAU,MAAM,EAAC,YAAY,MAAM,UAAU,KAAI,CAAC;AAAA,EAC9D,QAAQ,IAAI,UAAU,SAAS,EAAC,QAAQ,MAAM,SAAS,MAAM,YAAY,KAAI,CAAC;AAAA,EAC9E,QAAQ,IAAI,UAAU,OAAO,EAAC,YAAY,MAAM,QAAQ,MAAM,YAAY,KAAI,CAAC;AAAA,EAC/E,WAAW,MAAM,MAAM,CAAC;AAAA,EACxB,YAAY,MAAM,MAAM,CAAC;AAAA,EACzB,WAAW,MAAM,KAAK,CAAC;AAAA,EACvB,YAAY,MAAM,KAAK,CAAC;AAAA,EACxB,YAAY,MAAM,KAAK,CAAC;AAAA,EACxB,UAAU,MAAM,iBAAiB,CAAC;AAAA,EAClC,YAAY,MAAM,aAAa,CAAC;AAAA,EAChC,UAAU,MAAM,aAAa,CAAC;AAAA,EAC9B,SAAS,IAAI,UAAU,OAAO,EAAC,YAAY,MAAM,OAAO,GAAG,QAAQ,MAAM,YAAY,KAAI,CAAC;AAAA,EAC1F,QAAQ,MAAM,KAAK,EAAE;AAAA,EACrB,MAAM,MAAM,KAAK,EAAE;AAAA,EACnB,OAAO,MAAM,KAAK,EAAE;AAAA,EACpB,UAAU,IAAI,UAAU,MAAM,EAAC,YAAY,KAAI,CAAC;AAAA,EAChD,UAAU,MAAM,MAAM,CAAC;AAAA;AAAA,EAGvB,QAAQ,GAAG,OAAO;AAAA,EAClB,OAAO,GAAG,QAAQ,UAAU;AAAA,EAC5B,QAAQ,GAAG,OAAO;AAAA,EAClB,WAAW,GAAG,UAAU;AAAA,EACxB,WAAW,GAAG,UAAU;AAAA,EACxB,UAAU,GAAG,WAAW,UAAU;AAAA,EAClC,KAAK,GAAG,MAAM,EAAC,QAAQ,MAAM,YAAY,KAAI,CAAC;AAAA,EAC9C,OAAO,GAAG,QAAQ,UAAU;AAAA,EAC5B,UAAU,GAAG,SAAS;AAAA,EACtB,MAAM,GAAG,OAAO,EAAC,QAAQ,KAAI,CAAC;AAAA,EAC9B,WAAW,GAAG,YAAY,UAAU;AAAA,EACpC,KAAK,GAAG,IAAI;AAAA,EACZ,SAAS,GAAG,UAAU,UAAU;AAAA,EAChC,SAAS,GAAG,QAAQ;AAAA,EACpB,QAAQ,GAAG,SAAS,UAAU;AAAA,EAC9B,MAAM,GAAG,KAAK;AAAA,EACd,MAAM,GAAG,KAAK;AAAA,EACd,QAAQ,GAAG,OAAO;AAAA,EAClB,QAAQ,GAAG,SAAS,EAAC,QAAQ,KAAI,CAAC;AAAA,EAClC,OAAO,GAAG,MAAM;AAAA,EAChB,MAAM,GAAG,OAAO,EAAC,YAAY,MAAM,YAAY,KAAI,CAAC;AAAA,EACpD,OAAO,GAAG,QAAQ,UAAU;AAAA,EAC5B,QAAQ,GAAG,SAAS,UAAU;AAAA,EAC9B,QAAQ,GAAG,SAAS,UAAU;AAAA,EAC9B,UAAU,GAAG,WAAW,UAAU;AAAA,EAClC,SAAS,GAAG,QAAQ;AAAA,EACpB,SAAS,GAAG,UAAU,UAAU;AAAA,EAChC,OAAO,GAAG,QAAQ,UAAU;AAAA,EAC5B,OAAO,GAAG,QAAQ,UAAU;AAAA,EAC5B,QAAQ,GAAG,SAAS,UAAU;AAAA,EAC9B,KAAK,GAAG,MAAM,EAAC,YAAY,MAAM,OAAO,EAAC,CAAC;AAAA,EAC1C,aAAa,GAAG,cAAc,EAAC,YAAY,MAAM,OAAO,EAAC,CAAC;AAAA,EAC1D,SAAS,GAAG,UAAU,EAAC,YAAY,MAAM,QAAQ,MAAM,YAAY,KAAI,CAAC;AAAA,EACxE,OAAO,GAAG,QAAQ,EAAC,YAAY,MAAM,QAAQ,MAAM,YAAY,KAAI,CAAC;AAAA,EACpE,SAAS,GAAG,UAAU,EAAC,YAAY,MAAM,QAAQ,MAAM,YAAY,KAAI,CAAC;AAC1E;AAKA,IAAI,YAAY;AAChB,IAAI,aAAa,IAAI,OAAO,UAAU,QAAQ,GAAG;AAEjD,SAAS,UAAU,MAAM;AACvB,SAAO,SAAS,MAAM,SAAS,MAAM,SAAS,QAAU,SAAS;AACnE;AAEA,SAAS,cAAc,MAAMT,OAAM,KAAK;AACtC,MAAK,QAAQ,OAAS,OAAM,KAAK;AAEjC,WAAS,IAAIA,OAAM,IAAI,KAAK,KAAK;AAC/B,QAAI,OAAO,KAAK,WAAW,CAAC;AAC5B,QAAI,UAAU,IAAI,GAChB;AAAE,aAAO,IAAI,MAAM,KAAK,SAAS,MAAM,KAAK,WAAW,IAAI,CAAC,MAAM,KAAK,IAAI,IAAI,IAAI;AAAA,IAAE;AAAA,EACzF;AACA,SAAO;AACT;AAEA,IAAI,qBAAqB;AAEzB,IAAI,iBAAiB;AAErB,IAAI,MAAM,OAAO;AACjB,IAAI,iBAAiB,IAAI;AACzB,IAAI,WAAW,IAAI;AAEnB,IAAI,SAAS,OAAO,WAAW,SAAU,KAAK,UAAU;AAAE,SACxD,eAAe,KAAK,KAAK,QAAQ;AAChC;AAEH,IAAI2F,YAAU,MAAM,YAAY,SAAU,KAAK;AAAE,SAC/C,SAAS,KAAK,GAAG,MAAM;AACtB;AAEH,IAAI,cAAc,uBAAO,OAAO,IAAI;AAEpC,SAAS,YAAY,OAAO;AAC1B,SAAO,YAAY,KAAK,MAAM,YAAY,KAAK,IAAI,IAAI,OAAO,SAAS,MAAM,QAAQ,MAAM,GAAG,IAAI,IAAI;AACxG;AAEA,SAAS,kBAAkB,MAAM;AAE/B,MAAI,QAAQ,OAAQ;AAAE,WAAO,OAAO,aAAa,IAAI;AAAA,EAAE;AACvD,UAAQ;AACR,SAAO,OAAO,cAAc,QAAQ,MAAM,QAAS,OAAO,QAAQ,KAAM;AAC1E;AAEA,IAAI,gBAAgB;AAKpB,IAAI,WAAW,SAAS2C,UAAS,MAAM,KAAK;AAC1C,OAAK,OAAO;AACZ,OAAK,SAAS;AAChB;AAEA,SAAS,UAAU,SAAS,SAAS,OAAQ,GAAG;AAC9C,SAAO,IAAI,SAAS,KAAK,MAAM,KAAK,SAAS,CAAC;AAChD;AAEA,IAAI,iBAAiB,SAASC,gBAAe,GAAG,OAAO,KAAK;AAC1D,OAAK,QAAQ;AACb,OAAK,MAAM;AACX,MAAI,EAAE,eAAe,MAAM;AAAE,SAAK,SAAS,EAAE;AAAA,EAAY;AAC3D;AAQA,SAAS,YAAY,OAAOtN,SAAQ;AAClC,WAAS,OAAO,GAAG,MAAM,OAAK;AAC5B,QAAI,YAAY,cAAc,OAAO,KAAKA,OAAM;AAChD,QAAI,YAAY,GAAG;AAAE,aAAO,IAAI,SAAS,MAAMA,UAAS,GAAG;AAAA,IAAE;AAC7D,MAAE;AACF,UAAM;AAAA,EACR;AACF;AAKA,IAAI,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOnB,aAAa;AAAA;AAAA;AAAA;AAAA,EAIb,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMZ,qBAAqB;AAAA;AAAA;AAAA,EAGrB,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjB,eAAe;AAAA;AAAA;AAAA,EAGf,4BAA4B;AAAA;AAAA;AAAA;AAAA,EAI5B,6BAA6B;AAAA;AAAA;AAAA;AAAA,EAI7B,2BAA2B;AAAA;AAAA;AAAA,EAG3B,yBAAyB;AAAA;AAAA;AAAA;AAAA,EAIzB,eAAe;AAAA;AAAA;AAAA;AAAA,EAIf,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKpB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMX,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaT,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASX,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMR,SAAS;AAAA;AAAA;AAAA,EAGT,YAAY;AAAA;AAAA;AAAA,EAGZ,kBAAkB;AAAA;AAAA;AAAA,EAGlB,gBAAgB;AAClB;AAIA,IAAI,yBAAyB;AAE7B,SAAS,WAAW,MAAM;AACxB,MAAI,UAAU,CAAA;AAEd,WAASiN,QAAO,gBACd;AAAE,YAAQA,IAAG,IAAI,QAAQ,OAAO,MAAMA,IAAG,IAAI,KAAKA,IAAG,IAAI,eAAeA,IAAG;AAAA,EAAG;AAEhF,MAAI,QAAQ,gBAAgB,UAAU;AACpC,YAAQ,cAAc;AAAA,EACxB,WAAW,QAAQ,eAAe,MAAM;AACtC,QAAI,CAAC,0BAA0B,OAAO,YAAY,YAAY,QAAQ,MAAM;AAC1E,+BAAyB;AACzB,cAAQ,KAAK,oHAAoH;AAAA,IACnI;AACA,YAAQ,cAAc;AAAA,EACxB,WAAW,QAAQ,eAAe,MAAM;AACtC,YAAQ,eAAe;AAAA,EACzB;AAEA,MAAI,QAAQ,iBAAiB,MAC3B;AAAE,YAAQ,gBAAgB,QAAQ,cAAc;AAAA,EAAG;AAErD,MAAI,CAAC,QAAQ,KAAK,iBAAiB,MACjC;AAAE,YAAQ,gBAAgB,QAAQ,eAAe;AAAA,EAAI;AAEvD,MAAIvC,UAAQ,QAAQ,OAAO,GAAG;AAC5B,QAAI,SAAS,QAAQ;AACrB,YAAQ,UAAU,SAAU,OAAO;AAAE,aAAO,OAAO,KAAK,KAAK;AAAA,IAAG;AAAA,EAClE;AACA,MAAIA,UAAQ,QAAQ,SAAS,GAC3B;AAAE,YAAQ,YAAY,YAAY,SAAS,QAAQ,SAAS;AAAA,EAAG;AAEjE,SAAO;AACT;AAEA,SAAS,YAAY,SAAS7H,QAAO;AACnC,SAAO,SAAS,OAAO,MAAM,OAAO,KAAK,UAAU,QAAQ;AACzD,QAAI,UAAU;AAAA,MACZ,MAAM,QAAQ,UAAU;AAAA,MACxB,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACN;AACI,QAAI,QAAQ,WACV;AAAE,cAAQ,MAAM,IAAI,eAAe,MAAM,UAAU,MAAM;AAAA,IAAG;AAC9D,QAAI,QAAQ,QACV;AAAE,cAAQ,QAAQ,CAAC,OAAO,GAAG;AAAA,IAAG;AAClC,IAAAA,OAAM,KAAK,OAAO;AAAA,EACpB;AACF;AAGA,IACI,YAAY,GACZ,iBAAiB,GACjB,cAAc,GACd,kBAAkB,GAClB,cAAc,IACd,qBAAqB,IACrB,cAAc,IACd,qBAAqB,KACrB,2BAA2B,KAC3B,yBAAyB,KACzB,YAAY,YAAY,iBAAiB;AAE7C,SAAS,cAAc,OAAO,WAAW;AACvC,SAAO,kBAAkB,QAAQ,cAAc,MAAM,YAAY,kBAAkB;AACrF;AAGA,IACI,YAAY,GACZ,WAAW,GACX,eAAe,GACf,gBAAgB,GAChB,oBAAoB,GACpB,eAAe;AAEnB,IAAI,SAAS,SAAS0K,QAAO,SAAS,OAAO,UAAU;AACrD,OAAK,UAAU,UAAU,WAAW,OAAO;AAC3C,OAAK,aAAa,QAAQ;AAC1B,OAAK,WAAW,YAAY,WAAW,QAAQ,eAAe,IAAI,IAAI,QAAQ,eAAe,WAAW,YAAY,CAAC,CAAC;AACtH,MAAI,WAAW;AACf,MAAI,QAAQ,kBAAkB,MAAM;AAClC,eAAW,cAAc,QAAQ,eAAe,IAAI,IAAI,QAAQ,gBAAgB,IAAI,IAAI,CAAC;AACzF,QAAI,QAAQ,eAAe,UAAU;AAAE,kBAAY;AAAA,IAAU;AAAA,EAC/D;AACA,OAAK,gBAAgB,YAAY,QAAQ;AACzC,MAAI,kBAAkB,WAAW,WAAW,MAAM,MAAM,cAAc;AACtE,OAAK,sBAAsB,YAAY,cAAc;AACrD,OAAK,0BAA0B,YAAY,iBAAiB,MAAM,cAAc,UAAU;AAC1F,OAAK,QAAQ,OAAO,KAAK;AAKzB,OAAK,cAAc;AAKnB,MAAI,UAAU;AACZ,SAAK,MAAM;AACX,SAAK,YAAY,KAAK,MAAM,YAAY,MAAM,WAAW,CAAC,IAAI;AAC9D,SAAK,UAAU,KAAK,MAAM,MAAM,GAAG,KAAK,SAAS,EAAE,MAAM,SAAS,EAAE;AAAA,EACtE,OAAO;AACL,SAAK,MAAM,KAAK,YAAY;AAC5B,SAAK,UAAU;AAAA,EACjB;AAIA,OAAK,OAAO,QAAQ;AAEpB,OAAK,QAAQ;AAEb,OAAK,QAAQ,KAAK,MAAM,KAAK;AAG7B,OAAK,WAAW,KAAK,SAAS,KAAK,YAAW;AAG9C,OAAK,gBAAgB,KAAK,kBAAkB;AAC5C,OAAK,eAAe,KAAK,aAAa,KAAK;AAK3C,OAAK,UAAU,KAAK,eAAc;AAClC,OAAK,cAAc;AAGnB,OAAK,WAAW,QAAQ,eAAe;AACvC,OAAK,SAAS,KAAK,YAAY,KAAK,gBAAgB,KAAK,GAAG;AAG5D,OAAK,mBAAmB;AACxB,OAAK,2BAA2B;AAGhC,OAAK,WAAW,KAAK,WAAW,KAAK,gBAAgB;AAErD,OAAK,SAAS,CAAA;AAEd,OAAK,mBAAmB,uBAAO,OAAO,IAAI;AAG1C,MAAI,KAAK,QAAQ,KAAK,QAAQ,iBAAiB,KAAK,MAAM,MAAM,GAAG,CAAC,MAAM,MACxE;AAAE,SAAK,gBAAgB,CAAC;AAAA,EAAG;AAG7B,OAAK,aAAa,CAAA;AAClB,OAAK,WAAW,SAAS;AAGzB,OAAK,cAAc;AAKnB,OAAK,mBAAmB,CAAA;AAC1B;AAEA,IAAI,qBAAqB,EAAE,YAAY,EAAE,cAAc,QAAO,aAAa,EAAE,cAAc,KAAI,GAAG,SAAS,EAAE,cAAc,KAAI,GAAG,UAAU,EAAE,cAAc,KAAI,GAAG,YAAY,EAAE,cAAc,KAAI,GAAG,kBAAkB,EAAE,cAAc,KAAI,GAAG,qBAAqB,EAAE,cAAc,KAAI,GAAG,mBAAmB,EAAE,cAAc,KAAI,GAAG,oBAAoB,EAAE,cAAc,OAAM;AAE/W,OAAO,UAAU,QAAQ,SAAS,QAAS;AACzC,MAAI,OAAO,KAAK,QAAQ,WAAW,KAAK,UAAS;AACjD,OAAK,UAAS;AACd,SAAO,KAAK,cAAc,IAAI;AAChC;AAEA,mBAAmB,WAAW,MAAM,WAAY;AAAE,UAAQ,KAAK,gBAAe,EAAG,QAAQ,kBAAkB;AAAE;AAE7G,mBAAmB,YAAY,MAAM,WAAY;AAAE,UAAQ,KAAK,gBAAe,EAAG,QAAQ,mBAAmB;AAAE;AAE/G,mBAAmB,QAAQ,MAAM,WAAY;AAAE,UAAQ,KAAK,gBAAe,EAAG,QAAQ,eAAe;AAAE;AAEvG,mBAAmB,SAAS,MAAM,WAAY;AAC5C,WAAS,IAAI,KAAK,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AACpD,QAAIL,OAAM,KAAK,WAAW,CAAC;AACzB,QAAI,QAAQA,KAAI;AAClB,QAAI,SAAS,2BAA2B,yBAAyB;AAAE,aAAO;AAAA,IAAM;AAChF,QAAI,QAAQ,gBAAgB;AAAE,cAAQ,QAAQ,eAAe;AAAA,IAAE;AAAA,EACjE;AACA,SAAQ,KAAK,YAAY,KAAK,QAAQ,eAAe,MAAO,KAAK,QAAQ;AAC3E;AAEA,mBAAmB,WAAW,MAAM,WAAY;AAC9C,MAAIA,OAAM,KAAK,iBAAgB;AAC7B,MAAI,QAAQA,KAAI;AAClB,UAAQ,QAAQ,eAAe,KAAK,KAAK,QAAQ;AACnD;AAEA,mBAAmB,iBAAiB,MAAM,WAAY;AAAE,UAAQ,KAAK,iBAAgB,EAAG,QAAQ,sBAAsB;AAAE;AAExH,mBAAmB,oBAAoB,MAAM,WAAY;AAAE,SAAO,KAAK,2BAA2B,KAAK,aAAY,CAAE;AAAE;AAEvH,mBAAmB,kBAAkB,MAAM,WAAY;AACrD,WAAS,IAAI,KAAK,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AACpD,QAAIA,OAAM,KAAK,WAAW,CAAC;AACzB,QAAI,QAAQA,KAAI;AAClB,QAAI,SAAS,2BAA2B,2BAClC,QAAQ,kBAAmB,EAAE,QAAQ,cAAe;AAAE,aAAO;AAAA,IAAK;AAAA,EAC1E;AACA,SAAO;AACT;AAEA,mBAAmB,mBAAmB,MAAM,WAAY;AACtD,UAAQ,KAAK,kBAAkB,QAAQ,4BAA4B;AACrE;AAEA,OAAO,SAAS,SAAS,SAAU;AAC/B,MAAI,UAAU,CAAA,GAAI,MAAM,UAAU;AAClC,SAAQ,MAAQ,SAAS,GAAG,IAAK,UAAW,GAAG;AAEjD,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AAAE,UAAM,QAAQ,CAAC,EAAE,GAAG;AAAA,EAAG;AAClE,SAAO;AACT;AAEA,OAAO,QAAQ,SAAS9B,OAAO,OAAO,SAAS;AAC7C,SAAO,IAAI,KAAK,SAAS,KAAK,EAAE,MAAK;AACvC;AAEA,OAAO,oBAAoB,SAAS,kBAAmB,OAAO,KAAK,SAAS;AAC1E,MAAI,SAAS,IAAI,KAAK,SAAS,OAAO,GAAG;AACzC,SAAO,UAAS;AAChB,SAAO,OAAO,gBAAe;AAC/B;AAEA,OAAO,YAAY,SAAS,UAAW,OAAO,SAAS;AACrD,SAAO,IAAI,KAAK,SAAS,KAAK;AAChC;AAEA,OAAO,iBAAkB,OAAO,WAAW,kBAAkB;AAE7D,IAAI,OAAO,OAAO;AAIlB,IAAI,UAAU;AACd,KAAK,kBAAkB,SAAS,OAAO;AACrC,MAAI,KAAK,QAAQ,cAAc,GAAG;AAAE,WAAO;AAAA,EAAM;AACjD,aAAS;AAEP,mBAAe,YAAY;AAC3B,aAAS,eAAe,KAAK,KAAK,KAAK,EAAE,CAAC,EAAE;AAC5C,QAAIoC,SAAQ,QAAQ,KAAK,KAAK,MAAM,MAAM,KAAK,CAAC;AAChD,QAAI,CAACA,QAAO;AAAE,aAAO;AAAA,IAAM;AAC3B,SAAKA,OAAM,CAAC,KAAKA,OAAM,CAAC,OAAO,cAAc;AAC3C,qBAAe,YAAY,QAAQA,OAAM,CAAC,EAAE;AAC5C,UAAI,aAAa,eAAe,KAAK,KAAK,KAAK,GAAG,MAAM,WAAW,QAAQ,WAAW,CAAC,EAAE;AACzF,UAAI,OAAO,KAAK,MAAM,OAAO,GAAG;AAChC,aAAO,SAAS,OAAO,SAAS,OAC7B,UAAU,KAAK,WAAW,CAAC,CAAC,KAC5B,EAAE,sBAAsB,KAAK,IAAI,KAAK,SAAS,OAAO,KAAK,MAAM,OAAO,MAAM,CAAC,MAAM;AAAA,IAC1F;AACA,aAASA,OAAM,CAAC,EAAE;AAGlB,mBAAe,YAAY;AAC3B,aAAS,eAAe,KAAK,KAAK,KAAK,EAAE,CAAC,EAAE;AAC5C,QAAI,KAAK,MAAM,KAAK,MAAM,KACxB;AAAE;AAAA,IAAS;AAAA,EACf;AACF;AAKA,KAAK,MAAM,SAAS,MAAM;AACxB,MAAI,KAAK,SAAS,MAAM;AACtB,SAAK,KAAI;AACT,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAIA,KAAK,eAAe,SAAShI,OAAM;AACjC,SAAO,KAAK,SAAS,QAAQ,QAAQ,KAAK,UAAUA,SAAQ,CAAC,KAAK;AACpE;AAIA,KAAK,gBAAgB,SAASA,OAAM;AAClC,MAAI,CAAC,KAAK,aAAaA,KAAI,GAAG;AAAE,WAAO;AAAA,EAAM;AAC7C,OAAK,KAAI;AACT,SAAO;AACT;AAIA,KAAK,mBAAmB,SAASA,OAAM;AACrC,MAAI,CAAC,KAAK,cAAcA,KAAI,GAAG;AAAE,SAAK,WAAU;AAAA,EAAI;AACtD;AAIA,KAAK,qBAAqB,WAAW;AACnC,SAAO,KAAK,SAAS,QAAQ,OAC3B,KAAK,SAAS,QAAQ,UACtB,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC;AAChE;AAEA,KAAK,kBAAkB,WAAW;AAChC,MAAI,KAAK,sBAAsB;AAC7B,QAAI,KAAK,QAAQ,qBACf;AAAE,WAAK,QAAQ,oBAAoB,KAAK,YAAY,KAAK,aAAa;AAAA,IAAG;AAC3E,WAAO;AAAA,EACT;AACF;AAKA,KAAK,YAAY,WAAW;AAC1B,MAAI,CAAC,KAAK,IAAI,QAAQ,IAAI,KAAK,CAAC,KAAK,gBAAe,GAAI;AAAE,SAAK,WAAU;AAAA,EAAI;AAC/E;AAEA,KAAK,qBAAqB,SAAS,SAAS,SAAS;AACnD,MAAI,KAAK,SAAS,SAAS;AACzB,QAAI,KAAK,QAAQ,iBACf;AAAE,WAAK,QAAQ,gBAAgB,KAAK,cAAc,KAAK,eAAe;AAAA,IAAG;AAC3E,QAAI,CAAC,SACH;AAAE,WAAK,KAAI;AAAA,IAAI;AACjB,WAAO;AAAA,EACT;AACF;AAKA,KAAK,SAAS,SAAS,MAAM;AAC3B,OAAK,IAAI,IAAI,KAAK,KAAK,WAAU;AACnC;AAIA,KAAK,aAAa,SAAS,KAAK;AAC9B,OAAK,MAAM,OAAO,OAAO,MAAM,KAAK,OAAO,kBAAkB;AAC/D;AAEA,IAAI,sBAAsB,SAASiI,uBAAsB;AACvD,OAAK,kBACL,KAAK,gBACL,KAAK,sBACL,KAAK,oBACL,KAAK,cACH;AACJ;AAEA,KAAK,qBAAqB,SAAS,wBAAwB,UAAU;AACnE,MAAI,CAAC,wBAAwB;AAAE;AAAA,EAAO;AACtC,MAAI,uBAAuB,gBAAgB,IACzC;AAAE,SAAK,iBAAiB,uBAAuB,eAAe,+CAA+C;AAAA,EAAG;AAClH,MAAI,SAAS,WAAW,uBAAuB,sBAAsB,uBAAuB;AAC5F,MAAI,SAAS,IAAI;AAAE,SAAK,iBAAiB,QAAQ,WAAW,wBAAwB,uBAAuB;AAAA,EAAG;AAChH;AAEA,KAAK,wBAAwB,SAAS,wBAAwB,UAAU;AACtE,MAAI,CAAC,wBAAwB;AAAE,WAAO;AAAA,EAAM;AAC5C,MAAI,kBAAkB,uBAAuB;AAC7C,MAAI,cAAc,uBAAuB;AACzC,MAAI,CAAC,UAAU;AAAE,WAAO,mBAAmB,KAAK,eAAe;AAAA,EAAE;AACjE,MAAI,mBAAmB,GACrB;AAAE,SAAK,MAAM,iBAAiB,yEAAyE;AAAA,EAAG;AAC5G,MAAI,eAAe,GACjB;AAAE,SAAK,iBAAiB,aAAa,oCAAoC;AAAA,EAAG;AAChF;AAEA,KAAK,iCAAiC,WAAW;AAC/C,MAAI,KAAK,aAAa,CAAC,KAAK,YAAY,KAAK,WAAW,KAAK,WAC3D;AAAE,SAAK,MAAM,KAAK,UAAU,4CAA4C;AAAA,EAAG;AAC7E,MAAI,KAAK,UACP;AAAE,SAAK,MAAM,KAAK,UAAU,4CAA4C;AAAA,EAAG;AAC/E;AAEA,KAAK,uBAAuB,SAAS,MAAM;AACzC,MAAI,KAAK,SAAS,2BAChB;AAAE,WAAO,KAAK,qBAAqB,KAAK,UAAU;AAAA,EAAE;AACtD,SAAO,KAAK,SAAS,gBAAgB,KAAK,SAAS;AACrD;AAEA,IAAI,OAAO,OAAO;AASlB,KAAK,gBAAgB,SAAS,MAAM;AAClC,MAAI,UAAU,uBAAO,OAAO,IAAI;AAChC,MAAI,CAAC,KAAK,MAAM;AAAE,SAAK,OAAO,CAAA;AAAA,EAAI;AAClC,SAAO,KAAK,SAAS,QAAQ,KAAK;AAChC,QAAI,OAAO,KAAK,eAAe,MAAM,MAAM,OAAO;AAClD,SAAK,KAAK,KAAK,IAAI;AAAA,EACrB;AACA,MAAI,KAAK,UACP;AAAE,aAAS,IAAI,GAAGhM,QAAO,OAAO,KAAK,KAAK,gBAAgB,GAAG,IAAIA,MAAK,QAAQ,KAAK,GACjF;AACE,UAAI+D,QAAO/D,MAAK,CAAC;AAEjB,WAAK,iBAAiB,KAAK,iBAAiB+D,KAAI,EAAE,OAAQ,aAAaA,QAAO,kBAAkB;AAAA,IAClG;AAAA,EAAE;AACN,OAAK,uBAAuB,KAAK,IAAI;AACrC,OAAK,KAAI;AACT,OAAK,aAAa,KAAK,QAAQ;AAC/B,SAAO,KAAK,WAAW,MAAM,SAAS;AACxC;AAEA,IAAI,YAAY,EAAC,MAAM,OAAM,GAAG,cAAc,EAAC,MAAM,SAAQ;AAE7D,KAAK,QAAQ,SAAS,SAAS;AAC7B,MAAI,KAAK,QAAQ,cAAc,KAAK,CAAC,KAAK,aAAa,KAAK,GAAG;AAAE,WAAO;AAAA,EAAM;AAC9E,iBAAe,YAAY,KAAK;AAChC,MAAI,OAAO,eAAe,KAAK,KAAK,KAAK;AACzC,MAAI,OAAO,KAAK,MAAM,KAAK,CAAC,EAAE,QAAQ,SAAS,KAAK,MAAM,WAAW,IAAI;AAKzE,MAAI,WAAW,MAAM,WAAW,IAAI;AAAE,WAAO;AAAA,EAAK;AAClD,MAAI,SAAS;AAAE,WAAO;AAAA,EAAM;AAE5B,MAAI,WAAW,OAAO,SAAS,SAAU,SAAS,OAAQ;AAAE,WAAO;AAAA,EAAK;AACxE,MAAI,kBAAkB,QAAQ,IAAI,GAAG;AACnC,QAAI,MAAM,OAAO;AACjB,WAAO,iBAAiB,SAAS,KAAK,MAAM,WAAW,GAAG,GAAG,IAAI,GAAG;AAAE,QAAE;AAAA,IAAK;AAC7E,QAAI,WAAW,MAAM,SAAS,SAAU,SAAS,OAAQ;AAAE,aAAO;AAAA,IAAK;AACvE,QAAI,QAAQ,KAAK,MAAM,MAAM,MAAM,GAAG;AACtC,QAAI,CAAC,0BAA0B,KAAK,KAAK,GAAG;AAAE,aAAO;AAAA,IAAK;AAAA,EAC5D;AACA,SAAO;AACT;AAKA,KAAK,kBAAkB,WAAW;AAChC,MAAI,KAAK,QAAQ,cAAc,KAAK,CAAC,KAAK,aAAa,OAAO,GAC5D;AAAE,WAAO;AAAA,EAAM;AAEjB,iBAAe,YAAY,KAAK;AAChC,MAAI,OAAO,eAAe,KAAK,KAAK,KAAK;AACzC,MAAI,OAAO,KAAK,MAAM,KAAK,CAAC,EAAE,QAAQ;AACtC,SAAO,CAAC,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,IAAI,CAAC,KACrD,KAAK,MAAM,MAAM,MAAM,OAAO,CAAC,MAAM,eACpC,OAAO,MAAM,KAAK,MAAM,UACxB,EAAE,iBAAiB,QAAQ,KAAK,MAAM,WAAW,OAAO,CAAC,CAAC,KAAK,QAAQ,SAAU,QAAQ;AAC9F;AAEA,KAAK,iBAAiB,SAAS,cAAc,OAAO;AAClD,MAAI,KAAK,QAAQ,cAAc,MAAM,CAAC,KAAK,aAAa,eAAe,UAAU,OAAO,GACtF;AAAE,WAAO;AAAA,EAAM;AAEjB,iBAAe,YAAY,KAAK;AAChC,MAAI,OAAO,eAAe,KAAK,KAAK,KAAK;AACzC,MAAI,OAAO,KAAK,MAAM,KAAK,CAAC,EAAE;AAE9B,MAAI,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,IAAI,CAAC,GAAG;AAAE,WAAO;AAAA,EAAM;AAErE,MAAI,cAAc;AAChB,QAAI,cAAc,OAAO,GAAe;AACxC,QAAI,KAAK,MAAM,MAAM,MAAM,WAAW,MAAM,WAC1C,gBAAgB,KAAK,MAAM,UAC3B,iBAAiB,QAAQ,KAAK,MAAM,WAAW,WAAW,CAAC,KAC1D,QAAQ,SAAU,QAAQ,OAC3B;AAAE,aAAO;AAAA,IAAM;AAEjB,mBAAe,YAAY;AAC3B,QAAI,iBAAiB,eAAe,KAAK,KAAK,KAAK;AACnD,QAAI,kBAAkB,UAAU,KAAK,KAAK,MAAM,MAAM,aAAa,cAAc,eAAe,CAAC,EAAE,MAAM,CAAC,GAAG;AAAE,aAAO;AAAA,IAAM;AAAA,EAC9H;AAEA,MAAI,OAAO;AACT,QAAI,WAAW,OAAO,GAAY;AAClC,QAAI,KAAK,MAAM,MAAM,MAAM,QAAQ,MAAM,MAAM;AAC7C,UAAI,aAAa,KAAK,MAAM,UACzB,CAAC,iBAAiB,UAAU,KAAK,MAAM,WAAW,QAAQ,CAAC,KAAK,EAAE,UAAU,SAAU,UAAU,QAAU;AAAE,eAAO;AAAA,MAAM;AAAA,IAC9H;AAAA,EACF;AAEA,MAAI,KAAK,KAAK,MAAM,WAAW,IAAI;AACnC,SAAO,kBAAkB,IAAI,IAAI,KAAK,OAAO;AAC/C;AAEA,KAAK,eAAe,SAAS,OAAO;AAClC,SAAO,KAAK,eAAe,MAAM,KAAK;AACxC;AAEA,KAAK,UAAU,SAAS,OAAO;AAC7B,SAAO,KAAK,eAAe,OAAO,KAAK;AACzC;AASA,KAAK,iBAAiB,SAAS,SAAS,UAAU,SAAS;AACzD,MAAI,YAAY,KAAK,MAAM,OAAO,KAAK,UAAS,GAAI;AAEpD,MAAI,KAAK,MAAM,OAAO,GAAG;AACvB,gBAAY,QAAQ;AACpB,WAAO;AAAA,EACT;AAMA,UAAQ,WAAS;AAAA,IACjB,KAAK,QAAQ;AAAA,IAAQ,KAAK,QAAQ;AAAW,aAAO,KAAK,4BAA4B,MAAM,UAAU,OAAO;AAAA,IAC5G,KAAK,QAAQ;AAAW,aAAO,KAAK,uBAAuB,IAAI;AAAA,IAC/D,KAAK,QAAQ;AAAK,aAAO,KAAK,iBAAiB,IAAI;AAAA,IACnD,KAAK,QAAQ;AAAM,aAAO,KAAK,kBAAkB,IAAI;AAAA,IACrD,KAAK,QAAQ;AAIX,UAAK,YAAY,KAAK,UAAU,YAAY,QAAQ,YAAY,YAAa,KAAK,QAAQ,eAAe,GAAG;AAAE,aAAK,WAAU;AAAA,MAAI;AACjI,aAAO,KAAK,uBAAuB,MAAM,OAAO,CAAC,OAAO;AAAA,IAC1D,KAAK,QAAQ;AACX,UAAI,SAAS;AAAE,aAAK,WAAU;AAAA,MAAI;AAClC,aAAO,KAAK,WAAW,MAAM,IAAI;AAAA,IACnC,KAAK,QAAQ;AAAK,aAAO,KAAK,iBAAiB,IAAI;AAAA,IACnD,KAAK,QAAQ;AAAS,aAAO,KAAK,qBAAqB,IAAI;AAAA,IAC3D,KAAK,QAAQ;AAAS,aAAO,KAAK,qBAAqB,IAAI;AAAA,IAC3D,KAAK,QAAQ;AAAQ,aAAO,KAAK,oBAAoB,IAAI;AAAA,IACzD,KAAK,QAAQ;AAAM,aAAO,KAAK,kBAAkB,IAAI;AAAA,IACrD,KAAK,QAAQ;AAAA,IAAQ,KAAK,QAAQ;AAChC,aAAO,QAAQ,KAAK;AACpB,UAAI,WAAW,SAAS,OAAO;AAAE,aAAK,WAAU;AAAA,MAAI;AACpD,aAAO,KAAK,kBAAkB,MAAM,IAAI;AAAA,IAC1C,KAAK,QAAQ;AAAQ,aAAO,KAAK,oBAAoB,IAAI;AAAA,IACzD,KAAK,QAAQ;AAAO,aAAO,KAAK,mBAAmB,IAAI;AAAA,IACvD,KAAK,QAAQ;AAAQ,aAAO,KAAK,WAAW,MAAM,IAAI;AAAA,IACtD,KAAK,QAAQ;AAAM,aAAO,KAAK,oBAAoB,IAAI;AAAA,IACvD,KAAK,QAAQ;AAAA,IACb,KAAK,QAAQ;AACX,UAAI,KAAK,QAAQ,cAAc,MAAM,cAAc,QAAQ,SAAS;AAClE,uBAAe,YAAY,KAAK;AAChC,YAAI,OAAO,eAAe,KAAK,KAAK,KAAK;AACzC,YAAI,OAAO,KAAK,MAAM,KAAK,CAAC,EAAE,QAAQ,SAAS,KAAK,MAAM,WAAW,IAAI;AACzE,YAAI,WAAW,MAAM,WAAW,IAC9B;AAAE,iBAAO,KAAK,yBAAyB,MAAM,KAAK,gBAAe,CAAE;AAAA,QAAE;AAAA,MACzE;AAEA,UAAI,CAAC,KAAK,QAAQ,6BAA6B;AAC7C,YAAI,CAAC,UACH;AAAE,eAAK,MAAM,KAAK,OAAO,wDAAwD;AAAA,QAAG;AACtF,YAAI,CAAC,KAAK,UACR;AAAE,eAAK,MAAM,KAAK,OAAO,iEAAiE;AAAA,QAAG;AAAA,MACjG;AACA,aAAO,cAAc,QAAQ,UAAU,KAAK,YAAY,IAAI,IAAI,KAAK,YAAY,MAAM,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOhG;AACE,UAAI,KAAK,mBAAmB;AAC1B,YAAI,SAAS;AAAE,eAAK,WAAU;AAAA,QAAI;AAClC,aAAK,KAAI;AACT,eAAO,KAAK,uBAAuB,MAAM,MAAM,CAAC,OAAO;AAAA,MACzD;AAEA,UAAI,YAAY,KAAK,aAAa,KAAK,IAAI,gBAAgB,KAAK,QAAQ,KAAK,IAAI,UAAU;AAC3F,UAAI,WAAW;AACb,YAAI,YAAY,KAAK,QAAQ,eAAe,UAAU;AACpD,eAAK,MAAM,KAAK,OAAO,+EAA+E;AAAA,QACxG;AACA,YAAI,cAAc,eAAe;AAC/B,cAAI,CAAC,KAAK,UAAU;AAClB,iBAAK,MAAM,KAAK,OAAO,qDAAqD;AAAA,UAC9E;AACA,eAAK,KAAI;AAAA,QACX;AACA,aAAK,KAAI;AACT,aAAK,SAAS,MAAM,OAAO,SAAS;AACpC,aAAK,UAAS;AACd,eAAO,KAAK,WAAW,MAAM,qBAAqB;AAAA,MACpD;AAEA,UAAI,YAAY,KAAK,OAAO,OAAO,KAAK,gBAAe;AACvD,UAAI,cAAc,QAAQ,QAAQ,KAAK,SAAS,gBAAgB,KAAK,IAAI,QAAQ,KAAK,GACpF;AAAE,eAAO,KAAK,sBAAsB,MAAM,WAAW,MAAM,OAAO;AAAA,MAAE,OACjE;AAAE,eAAO,KAAK,yBAAyB,MAAM,IAAI;AAAA,MAAE;AAAA,EAC5D;AACA;AAEA,KAAK,8BAA8B,SAAS,MAAM,SAAS;AACzD,MAAI,UAAU,YAAY;AAC1B,OAAK,KAAI;AACT,MAAI,KAAK,IAAI,QAAQ,IAAI,KAAK,KAAK,gBAAe,GAAI;AAAE,SAAK,QAAQ;AAAA,EAAM,WAClE,KAAK,SAAS,QAAQ,MAAM;AAAE,SAAK,WAAU;AAAA,EAAI,OACrD;AACH,SAAK,QAAQ,KAAK,WAAU;AAC5B,SAAK,UAAS;AAAA,EAChB;AAIA,MAAI,IAAI;AACR,SAAO,IAAI,KAAK,OAAO,QAAQ,EAAE,GAAG;AAClC,QAAI,MAAM,KAAK,OAAO,CAAC;AACvB,QAAI,KAAK,SAAS,QAAQ,IAAI,SAAS,KAAK,MAAM,MAAM;AACtD,UAAI,IAAI,QAAQ,SAAS,WAAW,IAAI,SAAS,SAAS;AAAE;AAAA,MAAM;AAClE,UAAI,KAAK,SAAS,SAAS;AAAE;AAAA,MAAM;AAAA,IACrC;AAAA,EACF;AACA,MAAI,MAAM,KAAK,OAAO,QAAQ;AAAE,SAAK,MAAM,KAAK,OAAO,iBAAiB,OAAO;AAAA,EAAG;AAClF,SAAO,KAAK,WAAW,MAAM,UAAU,mBAAmB,mBAAmB;AAC/E;AAEA,KAAK,yBAAyB,SAAS,MAAM;AAC3C,OAAK,KAAI;AACT,OAAK,UAAS;AACd,SAAO,KAAK,WAAW,MAAM,mBAAmB;AAClD;AAEA,KAAK,mBAAmB,SAAS,MAAM;AACrC,OAAK,KAAI;AACT,OAAK,OAAO,KAAK,SAAS;AAC1B,OAAK,OAAO,KAAK,eAAe,IAAI;AACpC,OAAK,OAAO,IAAG;AACf,OAAK,OAAO,QAAQ,MAAM;AAC1B,OAAK,OAAO,KAAK,qBAAoB;AACrC,MAAI,KAAK,QAAQ,eAAe,GAC9B;AAAE,SAAK,IAAI,QAAQ,IAAI;AAAA,EAAG,OAE1B;AAAE,SAAK,UAAS;AAAA,EAAI;AACtB,SAAO,KAAK,WAAW,MAAM,kBAAkB;AACjD;AAUA,KAAK,oBAAoB,SAAS,MAAM;AACtC,OAAK,KAAI;AACT,MAAI,UAAW,KAAK,QAAQ,eAAe,KAAK,KAAK,YAAY,KAAK,cAAc,OAAO,IAAK,KAAK,eAAe;AACpH,OAAK,OAAO,KAAK,SAAS;AAC1B,OAAK,WAAW,CAAC;AACjB,OAAK,OAAO,QAAQ,MAAM;AAC1B,MAAI,KAAK,SAAS,QAAQ,MAAM;AAC9B,QAAI,UAAU,IAAI;AAAE,WAAK,WAAW,OAAO;AAAA,IAAG;AAC9C,WAAO,KAAK,SAAS,MAAM,IAAI;AAAA,EACjC;AACA,MAAI,QAAQ,KAAK,MAAK;AACtB,MAAI,KAAK,SAAS,QAAQ,QAAQ,KAAK,SAAS,QAAQ,UAAU,OAAO;AACvE,QAAI,SAAS,KAAK,UAAS,GAAI,OAAO,QAAQ,QAAQ,KAAK;AAC3D,SAAK,KAAI;AACT,SAAK,SAAS,QAAQ,MAAM,IAAI;AAChC,SAAK,WAAW,QAAQ,qBAAqB;AAC7C,WAAO,KAAK,kBAAkB,MAAM,QAAQ,OAAO;AAAA,EACrD;AACA,MAAI,gBAAgB,KAAK,aAAa,KAAK,GAAG,UAAU;AAExD,MAAI,YAAY,KAAK,QAAQ,IAAI,IAAI,UAAU,KAAK,aAAa,IAAI,IAAI,gBAAgB;AACzF,MAAI,WAAW;AACb,QAAI,SAAS,KAAK,UAAS;AAC3B,SAAK,KAAI;AACT,QAAI,cAAc,eAAe;AAAE,WAAK,KAAI;AAAA,IAAI;AAChD,SAAK,SAAS,QAAQ,MAAM,SAAS;AACrC,SAAK,WAAW,QAAQ,qBAAqB;AAC7C,WAAO,KAAK,kBAAkB,MAAM,QAAQ,OAAO;AAAA,EACrD;AACA,MAAI,cAAc,KAAK;AACvB,MAAI,yBAAyB,IAAI;AACjC,MAAI,UAAU,KAAK;AACnB,MAAI,OAAO,UAAU,KACjB,KAAK,oBAAoB,wBAAwB,OAAO,IACxD,KAAK,gBAAgB,MAAM,sBAAsB;AACrD,MAAI,KAAK,SAAS,QAAQ,QAAQ,UAAU,KAAK,QAAQ,eAAe,KAAK,KAAK,aAAa,IAAI,IAAI;AACrG,QAAI,UAAU,IAAI;AAChB,UAAI,KAAK,SAAS,QAAQ,KAAK;AAAE,aAAK,WAAW,OAAO;AAAA,MAAG;AAC3D,WAAK,QAAQ;AAAA,IACf,WAAW,WAAW,KAAK,QAAQ,eAAe,GAAG;AACnD,UAAI,KAAK,UAAU,WAAW,CAAC,eAAe,KAAK,SAAS,gBAAgB,KAAK,SAAS,SAAS;AAAE,aAAK,WAAU;AAAA,MAAI,WAC/G,KAAK,QAAQ,eAAe,GAAG;AAAE,aAAK,QAAQ;AAAA,MAAO;AAAA,IAChE;AACA,QAAI,iBAAiB,SAAS;AAAE,WAAK,MAAM,KAAK,OAAO,+DAA+D;AAAA,IAAG;AACzH,SAAK,aAAa,MAAM,OAAO,sBAAsB;AACrD,SAAK,iBAAiB,IAAI;AAC1B,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC,OAAO;AACL,SAAK,sBAAsB,wBAAwB,IAAI;AAAA,EACzD;AACA,MAAI,UAAU,IAAI;AAAE,SAAK,WAAW,OAAO;AAAA,EAAG;AAC9C,SAAO,KAAK,SAAS,MAAM,IAAI;AACjC;AAGA,KAAK,oBAAoB,SAAS,MAAM,MAAM,SAAS;AACrD,OAAK,KAAK,SAAS,QAAQ,OAAQ,KAAK,QAAQ,eAAe,KAAK,KAAK,aAAa,IAAI,MAAO,KAAK,aAAa,WAAW,GAAG;AAC/H,QAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,UAAI,KAAK,SAAS,QAAQ,KAAK;AAC7B,YAAI,UAAU,IAAI;AAAE,eAAK,WAAW,OAAO;AAAA,QAAG;AAAA,MAChD,OAAO;AAAE,aAAK,QAAQ,UAAU;AAAA,MAAI;AAAA,IACtC;AACA,WAAO,KAAK,WAAW,MAAM,IAAI;AAAA,EACnC;AACA,MAAI,UAAU,IAAI;AAAE,SAAK,WAAW,OAAO;AAAA,EAAG;AAC9C,SAAO,KAAK,SAAS,MAAM,IAAI;AACjC;AAEA,KAAK,yBAAyB,SAAS,MAAM,SAAS,qBAAqB;AACzE,OAAK,KAAI;AACT,SAAO,KAAK,cAAc,MAAM,kBAAkB,sBAAsB,IAAI,yBAAyB,OAAO,OAAO;AACrH;AAEA,KAAK,mBAAmB,SAAS,MAAM;AACrC,OAAK,KAAI;AACT,OAAK,OAAO,KAAK,qBAAoB;AAErC,OAAK,aAAa,KAAK,eAAe,IAAI;AAC1C,OAAK,YAAY,KAAK,IAAI,QAAQ,KAAK,IAAI,KAAK,eAAe,IAAI,IAAI;AACvE,SAAO,KAAK,WAAW,MAAM,aAAa;AAC5C;AAEA,KAAK,uBAAuB,SAAS,MAAM;AACzC,MAAI,CAAC,KAAK,cAAc,CAAC,KAAK,QAAQ,4BACpC;AAAE,SAAK,MAAM,KAAK,OAAO,8BAA8B;AAAA,EAAG;AAC5D,OAAK,KAAI;AAMT,MAAI,KAAK,IAAI,QAAQ,IAAI,KAAK,KAAK,gBAAe,GAAI;AAAE,SAAK,WAAW;AAAA,EAAM,OACzE;AAAE,SAAK,WAAW,KAAK,gBAAe;AAAI,SAAK,UAAS;AAAA,EAAI;AACjE,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,uBAAuB,SAAS,MAAM;AACzC,OAAK,KAAI;AACT,OAAK,eAAe,KAAK,qBAAoB;AAC7C,OAAK,QAAQ,CAAA;AACb,OAAK,OAAO,QAAQ,MAAM;AAC1B,OAAK,OAAO,KAAK,WAAW;AAC5B,OAAK,WAAW,CAAC;AAMjB,MAAI;AACJ,WAAS,aAAa,OAAO,KAAK,SAAS,QAAQ,UAAS;AAC1D,QAAI,KAAK,SAAS,QAAQ,SAAS,KAAK,SAAS,QAAQ,UAAU;AACjE,UAAI,SAAS,KAAK,SAAS,QAAQ;AACnC,UAAI,KAAK;AAAE,aAAK,WAAW,KAAK,YAAY;AAAA,MAAG;AAC/C,WAAK,MAAM,KAAK,MAAM,KAAK,UAAS,CAAE;AACtC,UAAI,aAAa,CAAA;AACjB,WAAK,KAAI;AACT,UAAI,QAAQ;AACV,YAAI,OAAO,KAAK,gBAAe;AAAA,MACjC,OAAO;AACL,YAAI,YAAY;AAAE,eAAK,iBAAiB,KAAK,cAAc,0BAA0B;AAAA,QAAG;AACxF,qBAAa;AACb,YAAI,OAAO;AAAA,MACb;AACA,WAAK,OAAO,QAAQ,KAAK;AAAA,IAC3B,OAAO;AACL,UAAI,CAAC,KAAK;AAAE,aAAK,WAAU;AAAA,MAAI;AAC/B,UAAI,WAAW,KAAK,KAAK,eAAe,IAAI,CAAC;AAAA,IAC/C;AAAA,EACF;AACA,OAAK,UAAS;AACd,MAAI,KAAK;AAAE,SAAK,WAAW,KAAK,YAAY;AAAA,EAAG;AAC/C,OAAK,KAAI;AACT,OAAK,OAAO,IAAG;AACf,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,sBAAsB,SAAS,MAAM;AACxC,OAAK,KAAI;AACT,MAAI,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC,GAC9D;AAAE,SAAK,MAAM,KAAK,YAAY,6BAA6B;AAAA,EAAG;AAChE,OAAK,WAAW,KAAK,gBAAe;AACpC,OAAK,UAAS;AACd,SAAO,KAAK,WAAW,MAAM,gBAAgB;AAC/C;AAIA,IAAI,UAAU,CAAA;AAEd,KAAK,wBAAwB,WAAW;AACtC,MAAI,QAAQ,KAAK,iBAAgB;AACjC,MAAI,SAAS,MAAM,SAAS;AAC5B,OAAK,WAAW,SAAS,qBAAqB,CAAC;AAC/C,OAAK,iBAAiB,OAAO,SAAS,oBAAoB,YAAY;AACtE,OAAK,OAAO,QAAQ,MAAM;AAE1B,SAAO;AACT;AAEA,KAAK,oBAAoB,SAAS,MAAM;AACtC,OAAK,KAAI;AACT,OAAK,QAAQ,KAAK,WAAU;AAC5B,OAAK,UAAU;AACf,MAAI,KAAK,SAAS,QAAQ,QAAQ;AAChC,QAAI,SAAS,KAAK,UAAS;AAC3B,SAAK,KAAI;AACT,QAAI,KAAK,IAAI,QAAQ,MAAM,GAAG;AAC5B,aAAO,QAAQ,KAAK,sBAAqB;AAAA,IAC3C,OAAO;AACL,UAAI,KAAK,QAAQ,cAAc,IAAI;AAAE,aAAK,WAAU;AAAA,MAAI;AACxD,aAAO,QAAQ;AACf,WAAK,WAAW,CAAC;AAAA,IACnB;AACA,WAAO,OAAO,KAAK,WAAW,KAAK;AACnC,SAAK,UAAS;AACd,SAAK,UAAU,KAAK,WAAW,QAAQ,aAAa;AAAA,EACtD;AACA,OAAK,YAAY,KAAK,IAAI,QAAQ,QAAQ,IAAI,KAAK,WAAU,IAAK;AAClE,MAAI,CAAC,KAAK,WAAW,CAAC,KAAK,WACzB;AAAE,SAAK,MAAM,KAAK,OAAO,iCAAiC;AAAA,EAAG;AAC/D,SAAO,KAAK,WAAW,MAAM,cAAc;AAC7C;AAEA,KAAK,oBAAoB,SAAS,MAAM,MAAM,yBAAyB;AACrE,OAAK,KAAI;AACT,OAAK,SAAS,MAAM,OAAO,MAAM,uBAAuB;AACxD,OAAK,UAAS;AACd,SAAO,KAAK,WAAW,MAAM,qBAAqB;AACpD;AAEA,KAAK,sBAAsB,SAAS,MAAM;AACxC,OAAK,KAAI;AACT,OAAK,OAAO,KAAK,qBAAoB;AACrC,OAAK,OAAO,KAAK,SAAS;AAC1B,OAAK,OAAO,KAAK,eAAe,OAAO;AACvC,OAAK,OAAO,IAAG;AACf,SAAO,KAAK,WAAW,MAAM,gBAAgB;AAC/C;AAEA,KAAK,qBAAqB,SAAS,MAAM;AACvC,MAAI,KAAK,QAAQ;AAAE,SAAK,MAAM,KAAK,OAAO,uBAAuB;AAAA,EAAG;AACpE,OAAK,KAAI;AACT,OAAK,SAAS,KAAK,qBAAoB;AACvC,OAAK,OAAO,KAAK,eAAe,MAAM;AACtC,SAAO,KAAK,WAAW,MAAM,eAAe;AAC9C;AAEA,KAAK,sBAAsB,SAAS,MAAM;AACxC,OAAK,KAAI;AACT,SAAO,KAAK,WAAW,MAAM,gBAAgB;AAC/C;AAEA,KAAK,wBAAwB,SAAS,MAAM,WAAW,MAAM,SAAS;AACpE,WAAS,MAAM,GAAG/D,QAAO,KAAK,QAAQ,MAAMA,MAAK,QAAQ,OAAO,GAC9D;AACA,QAAI,QAAQA,MAAK,GAAG;AAEpB,QAAI,MAAM,SAAS,WACjB;AAAE,WAAK,MAAM,KAAK,OAAO,YAAY,YAAY,uBAAuB;AAAA,IAC5E;AAAA,EAAE;AACF,MAAI,OAAO,KAAK,KAAK,SAAS,SAAS,KAAK,SAAS,QAAQ,UAAU,WAAW;AAClF,WAAS,IAAI,KAAK,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AAChD,QAAI,UAAU,KAAK,OAAO,CAAC;AAC3B,QAAI,QAAQ,mBAAmB,KAAK,OAAO;AAEzC,cAAQ,iBAAiB,KAAK;AAC9B,cAAQ,OAAO;AAAA,IACjB,OAAO;AAAE;AAAA,IAAM;AAAA,EACjB;AACA,OAAK,OAAO,KAAK,EAAC,MAAM,WAAW,MAAY,gBAAgB,KAAK,MAAK,CAAC;AAC1E,OAAK,OAAO,KAAK,eAAe,UAAU,QAAQ,QAAQ,OAAO,MAAM,KAAK,UAAU,UAAU,UAAU,OAAO;AACjH,OAAK,OAAO,IAAG;AACf,OAAK,QAAQ;AACb,SAAO,KAAK,WAAW,MAAM,kBAAkB;AACjD;AAEA,KAAK,2BAA2B,SAAS,MAAM,MAAM;AACnD,OAAK,aAAa;AAClB,OAAK,UAAS;AACd,SAAO,KAAK,WAAW,MAAM,qBAAqB;AACpD;AAMA,KAAK,aAAa,SAAS,uBAAuB,MAAM,YAAY;AAClE,MAAK,0BAA0B,OAAS,yBAAwB;AAChE,MAAK,SAAS,OAAS,QAAO,KAAK,UAAS;AAE5C,OAAK,OAAO,CAAA;AACZ,OAAK,OAAO,QAAQ,MAAM;AAC1B,MAAI,uBAAuB;AAAE,SAAK,WAAW,CAAC;AAAA,EAAG;AACjD,SAAO,KAAK,SAAS,QAAQ,QAAQ;AACnC,QAAI,OAAO,KAAK,eAAe,IAAI;AACnC,SAAK,KAAK,KAAK,IAAI;AAAA,EACrB;AACA,MAAI,YAAY;AAAE,SAAK,SAAS;AAAA,EAAO;AACvC,OAAK,KAAI;AACT,MAAI,uBAAuB;AAAE,SAAK,UAAS;AAAA,EAAI;AAC/C,SAAO,KAAK,WAAW,MAAM,gBAAgB;AAC/C;AAMA,KAAK,WAAW,SAAS,MAAM,MAAM;AACnC,OAAK,OAAO;AACZ,OAAK,OAAO,QAAQ,IAAI;AACxB,OAAK,OAAO,KAAK,SAAS,QAAQ,OAAO,OAAO,KAAK,gBAAe;AACpE,OAAK,OAAO,QAAQ,IAAI;AACxB,OAAK,SAAS,KAAK,SAAS,QAAQ,SAAS,OAAO,KAAK,gBAAe;AACxE,OAAK,OAAO,QAAQ,MAAM;AAC1B,OAAK,OAAO,KAAK,eAAe,KAAK;AACrC,OAAK,UAAS;AACd,OAAK,OAAO,IAAG;AACf,SAAO,KAAK,WAAW,MAAM,cAAc;AAC7C;AAKA,KAAK,aAAa,SAAS,MAAM,MAAM;AACrC,MAAI,UAAU,KAAK,SAAS,QAAQ;AACpC,OAAK,KAAI;AAET,MACE,KAAK,SAAS,yBACd,KAAK,aAAa,CAAC,EAAE,QAAQ,SAE3B,CAAC,WACD,KAAK,QAAQ,cAAc,KAC3B,KAAK,UACL,KAAK,SAAS,SACd,KAAK,aAAa,CAAC,EAAE,GAAG,SAAS,eAEnC;AACA,SAAK;AAAA,MACH,KAAK;AAAA,OACH,UAAU,WAAW,YAAY;AAAA,IACzC;AAAA,EACE;AACA,OAAK,OAAO;AACZ,OAAK,QAAQ,UAAU,KAAK,gBAAe,IAAK,KAAK,iBAAgB;AACrE,OAAK,OAAO,QAAQ,MAAM;AAC1B,OAAK,OAAO,KAAK,eAAe,KAAK;AACrC,OAAK,UAAS;AACd,OAAK,OAAO,IAAG;AACf,SAAO,KAAK,WAAW,MAAM,UAAU,mBAAmB,gBAAgB;AAC5E;AAIA,KAAK,WAAW,SAAS,MAAM,OAAO,MAAM,yBAAyB;AACnE,OAAK,eAAe,CAAA;AACpB,OAAK,OAAO;AACZ,aAAS;AACP,QAAI,OAAO,KAAK,UAAS;AACzB,SAAK,WAAW,MAAM,IAAI;AAC1B,QAAI,KAAK,IAAI,QAAQ,EAAE,GAAG;AACxB,WAAK,OAAO,KAAK,iBAAiB,KAAK;AAAA,IACzC,WAAW,CAAC,2BAA2B,SAAS,WAAW,EAAE,KAAK,SAAS,QAAQ,OAAQ,KAAK,QAAQ,eAAe,KAAK,KAAK,aAAa,IAAI,IAAK;AACrJ,WAAK,WAAU;AAAA,IACjB,WAAW,CAAC,4BAA4B,SAAS,WAAW,SAAS,kBAAkB,KAAK,QAAQ,eAAe,MAAM,KAAK,SAAS,QAAQ,OAAO,CAAC,KAAK,aAAa,IAAI,GAAG;AAC9K,WAAK,MAAM,KAAK,YAAa,4BAA4B,OAAO,cAAc;AAAA,IAChF,WAAW,CAAC,2BAA2B,KAAK,GAAG,SAAS,gBAAgB,EAAE,UAAU,KAAK,SAAS,QAAQ,OAAO,KAAK,aAAa,IAAI,KAAK;AAC1I,WAAK,MAAM,KAAK,YAAY,0DAA0D;AAAA,IACxF,OAAO;AACL,WAAK,OAAO;AAAA,IACd;AACA,SAAK,aAAa,KAAK,KAAK,WAAW,MAAM,oBAAoB,CAAC;AAClE,QAAI,CAAC,KAAK,IAAI,QAAQ,KAAK,GAAG;AAAE;AAAA,IAAM;AAAA,EACxC;AACA,SAAO;AACT;AAEA,KAAK,aAAa,SAAS,MAAM,MAAM;AACrC,OAAK,KAAK,SAAS,WAAW,SAAS,gBACnC,KAAK,WAAU,IACf,KAAK,iBAAgB;AAEzB,OAAK,iBAAiB,KAAK,IAAI,SAAS,QAAQ,WAAW,cAAc,KAAK;AAChF;AAEA,IAAI,iBAAiB,GAAG,yBAAyB,GAAG,mBAAmB;AAMvE,KAAK,gBAAgB,SAAS,MAAM,WAAW,qBAAqB,SAAS,SAAS;AACpF,OAAK,aAAa,IAAI;AACtB,MAAI,KAAK,QAAQ,eAAe,KAAK,KAAK,QAAQ,eAAe,KAAK,CAAC,SAAS;AAC9E,QAAI,KAAK,SAAS,QAAQ,QAAS,YAAY,wBAC7C;AAAE,WAAK,WAAU;AAAA,IAAI;AACvB,SAAK,YAAY,KAAK,IAAI,QAAQ,IAAI;AAAA,EACxC;AACA,MAAI,KAAK,QAAQ,eAAe,GAC9B;AAAE,SAAK,QAAQ,CAAC,CAAC;AAAA,EAAS;AAE5B,MAAI,YAAY,gBAAgB;AAC9B,SAAK,KAAM,YAAY,oBAAqB,KAAK,SAAS,QAAQ,OAAO,OAAO,KAAK,WAAU;AAC/F,QAAI,KAAK,MAAM,EAAE,YAAY,yBAK3B;AAAE,WAAK,gBAAgB,KAAK,IAAK,KAAK,UAAU,KAAK,aAAa,KAAK,QAAS,KAAK,sBAAsB,WAAW,eAAe,aAAa;AAAA,IAAG;AAAA,EACzJ;AAEA,MAAI,cAAc,KAAK,UAAU,cAAc,KAAK,UAAU,mBAAmB,KAAK;AACtF,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,gBAAgB;AACrB,OAAK,WAAW,cAAc,KAAK,OAAO,KAAK,SAAS,CAAC;AAEzD,MAAI,EAAE,YAAY,iBAChB;AAAE,SAAK,KAAK,KAAK,SAAS,QAAQ,OAAO,KAAK,eAAe;AAAA,EAAM;AAErE,OAAK,oBAAoB,IAAI;AAC7B,OAAK,kBAAkB,MAAM,qBAAqB,OAAO,OAAO;AAEhE,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,gBAAgB;AACrB,SAAO,KAAK,WAAW,MAAO,YAAY,iBAAkB,wBAAwB,oBAAoB;AAC1G;AAEA,KAAK,sBAAsB,SAAS,MAAM;AACxC,OAAK,OAAO,QAAQ,MAAM;AAC1B,OAAK,SAAS,KAAK,iBAAiB,QAAQ,QAAQ,OAAO,KAAK,QAAQ,eAAe,CAAC;AACxF,OAAK,+BAA8B;AACrC;AAKA,KAAK,aAAa,SAAS,MAAM,aAAa;AAC5C,OAAK,KAAI;AAIT,MAAI,YAAY,KAAK;AACrB,OAAK,SAAS;AAEd,OAAK,aAAa,MAAM,WAAW;AACnC,OAAK,gBAAgB,IAAI;AACzB,MAAI,iBAAiB,KAAK,eAAc;AACxC,MAAI,YAAY,KAAK,UAAS;AAC9B,MAAI,iBAAiB;AACrB,YAAU,OAAO,CAAA;AACjB,OAAK,OAAO,QAAQ,MAAM;AAC1B,SAAO,KAAK,SAAS,QAAQ,QAAQ;AACnC,QAAI,UAAU,KAAK,kBAAkB,KAAK,eAAe,IAAI;AAC7D,QAAI,SAAS;AACX,gBAAU,KAAK,KAAK,OAAO;AAC3B,UAAI,QAAQ,SAAS,sBAAsB,QAAQ,SAAS,eAAe;AACzE,YAAI,gBAAgB;AAAE,eAAK,iBAAiB,QAAQ,OAAO,yCAAyC;AAAA,QAAG;AACvG,yBAAiB;AAAA,MACnB,WAAW,QAAQ,OAAO,QAAQ,IAAI,SAAS,uBAAuB,wBAAwB,gBAAgB,OAAO,GAAG;AACtH,aAAK,iBAAiB,QAAQ,IAAI,OAAQ,kBAAmB,QAAQ,IAAI,OAAQ,6BAA6B;AAAA,MAChH;AAAA,IACF;AAAA,EACF;AACA,OAAK,SAAS;AACd,OAAK,KAAI;AACT,OAAK,OAAO,KAAK,WAAW,WAAW,WAAW;AAClD,OAAK,cAAa;AAClB,SAAO,KAAK,WAAW,MAAM,cAAc,qBAAqB,iBAAiB;AACnF;AAEA,KAAK,oBAAoB,SAAS,wBAAwB;AACxD,MAAI,KAAK,IAAI,QAAQ,IAAI,GAAG;AAAE,WAAO;AAAA,EAAK;AAE1C,MAAI,cAAc,KAAK,QAAQ;AAC/B,MAAI,OAAO,KAAK,UAAS;AACzB,MAAI,UAAU;AACd,MAAI,cAAc;AAClB,MAAI,UAAU;AACd,MAAI,OAAO;AACX,MAAI,WAAW;AAEf,MAAI,KAAK,cAAc,QAAQ,GAAG;AAEhC,QAAI,eAAe,MAAM,KAAK,IAAI,QAAQ,MAAM,GAAG;AACjD,WAAK,sBAAsB,IAAI;AAC/B,aAAO;AAAA,IACT;AACA,QAAI,KAAK,wBAAuB,KAAM,KAAK,SAAS,QAAQ,MAAM;AAChE,iBAAW;AAAA,IACb,OAAO;AACL,gBAAU;AAAA,IACZ;AAAA,EACF;AACA,OAAK,SAAS;AACd,MAAI,CAAC,WAAW,eAAe,KAAK,KAAK,cAAc,OAAO,GAAG;AAC/D,SAAK,KAAK,wBAAuB,KAAM,KAAK,SAAS,QAAQ,SAAS,CAAC,KAAK,sBAAsB;AAChG,gBAAU;AAAA,IACZ,OAAO;AACL,gBAAU;AAAA,IACZ;AAAA,EACF;AACA,MAAI,CAAC,YAAY,eAAe,KAAK,CAAC,YAAY,KAAK,IAAI,QAAQ,IAAI,GAAG;AACxE,kBAAc;AAAA,EAChB;AACA,MAAI,CAAC,WAAW,CAAC,WAAW,CAAC,aAAa;AACxC,QAAI,YAAY,KAAK;AACrB,QAAI,KAAK,cAAc,KAAK,KAAK,KAAK,cAAc,KAAK,GAAG;AAC1D,UAAI,KAAK,2BAA2B;AAClC,eAAO;AAAA,MACT,OAAO;AACL,kBAAU;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AAGA,MAAI,SAAS;AAGX,SAAK,WAAW;AAChB,SAAK,MAAM,KAAK,YAAY,KAAK,cAAc,KAAK,eAAe;AACnE,SAAK,IAAI,OAAO;AAChB,SAAK,WAAW,KAAK,KAAK,YAAY;AAAA,EACxC,OAAO;AACL,SAAK,sBAAsB,IAAI;AAAA,EACjC;AAGA,MAAI,cAAc,MAAM,KAAK,SAAS,QAAQ,UAAU,SAAS,YAAY,eAAe,SAAS;AACnG,QAAI,gBAAgB,CAAC,KAAK,UAAU,aAAa,MAAM,aAAa;AACpE,QAAI,oBAAoB,iBAAiB;AAEzC,QAAI,iBAAiB,SAAS,UAAU;AAAE,WAAK,MAAM,KAAK,IAAI,OAAO,yCAAyC;AAAA,IAAG;AACjH,SAAK,OAAO,gBAAgB,gBAAgB;AAC5C,SAAK,iBAAiB,MAAM,aAAa,SAAS,iBAAiB;AAAA,EACrE,OAAO;AACL,SAAK,gBAAgB,IAAI;AAAA,EAC3B;AAEA,SAAO;AACT;AAEA,KAAK,0BAA0B,WAAW;AACxC,SACE,KAAK,SAAS,QAAQ,QACtB,KAAK,SAAS,QAAQ,aACtB,KAAK,SAAS,QAAQ,OACtB,KAAK,SAAS,QAAQ,UACtB,KAAK,SAAS,QAAQ,YACtB,KAAK,KAAK;AAEd;AAEA,KAAK,wBAAwB,SAAS,SAAS;AAC7C,MAAI,KAAK,SAAS,QAAQ,WAAW;AACnC,QAAI,KAAK,UAAU,eAAe;AAChC,WAAK,MAAM,KAAK,OAAO,oDAAoD;AAAA,IAC7E;AACA,YAAQ,WAAW;AACnB,YAAQ,MAAM,KAAK,kBAAiB;AAAA,EACtC,OAAO;AACL,SAAK,kBAAkB,OAAO;AAAA,EAChC;AACF;AAEA,KAAK,mBAAmB,SAAS,QAAQ,aAAa,SAAS,mBAAmB;AAEhF,MAAIkC,OAAM,OAAO;AACjB,MAAI,OAAO,SAAS,eAAe;AACjC,QAAI,aAAa;AAAE,WAAK,MAAMA,KAAI,OAAO,kCAAkC;AAAA,IAAG;AAC9E,QAAI,SAAS;AAAE,WAAK,MAAMA,KAAI,OAAO,sCAAsC;AAAA,IAAG;AAAA,EAChF,WAAW,OAAO,UAAU,aAAa,QAAQ,WAAW,GAAG;AAC7D,SAAK,MAAMA,KAAI,OAAO,wDAAwD;AAAA,EAChF;AAGA,MAAIvE,SAAQ,OAAO,QAAQ,KAAK,YAAY,aAAa,SAAS,iBAAiB;AAGnF,MAAI,OAAO,SAAS,SAASA,OAAM,OAAO,WAAW,GACnD;AAAE,SAAK,iBAAiBA,OAAM,OAAO,8BAA8B;AAAA,EAAG;AACxE,MAAI,OAAO,SAAS,SAASA,OAAM,OAAO,WAAW,GACnD;AAAE,SAAK,iBAAiBA,OAAM,OAAO,sCAAsC;AAAA,EAAG;AAChF,MAAI,OAAO,SAAS,SAASA,OAAM,OAAO,CAAC,EAAE,SAAS,eACpD;AAAE,SAAK,iBAAiBA,OAAM,OAAO,CAAC,EAAE,OAAO,+BAA+B;AAAA,EAAG;AAEnF,SAAO,KAAK,WAAW,QAAQ,kBAAkB;AACnD;AAEA,KAAK,kBAAkB,SAASmC,QAAO;AACrC,MAAI,aAAaA,QAAO,aAAa,GAAG;AACtC,SAAK,MAAMA,OAAM,IAAI,OAAO,gDAAgD;AAAA,EAC9E,WAAWA,OAAM,UAAU,aAAaA,QAAO,WAAW,GAAG;AAC3D,SAAK,MAAMA,OAAM,IAAI,OAAO,qDAAqD;AAAA,EACnF;AAEA,MAAI,KAAK,IAAI,QAAQ,EAAE,GAAG;AAExB,SAAK,WAAW,yBAAyB,WAAW;AACpD,IAAAA,OAAM,QAAQ,KAAK,iBAAgB;AACnC,SAAK,UAAS;AAAA,EAChB,OAAO;AACL,IAAAA,OAAM,QAAQ;AAAA,EAChB;AACA,OAAK,UAAS;AAEd,SAAO,KAAK,WAAWA,QAAO,oBAAoB;AACpD;AAEA,KAAK,wBAAwB,SAAS,MAAM;AAC1C,OAAK,OAAO,CAAA;AAEZ,MAAI,YAAY,KAAK;AACrB,OAAK,SAAS,CAAA;AACd,OAAK,WAAW,2BAA2B,WAAW;AACtD,SAAO,KAAK,SAAS,QAAQ,QAAQ;AACnC,QAAI,OAAO,KAAK,eAAe,IAAI;AACnC,SAAK,KAAK,KAAK,IAAI;AAAA,EACrB;AACA,OAAK,KAAI;AACT,OAAK,UAAS;AACd,OAAK,SAAS;AAEd,SAAO,KAAK,WAAW,MAAM,aAAa;AAC5C;AAEA,KAAK,eAAe,SAAS,MAAM,aAAa;AAC9C,MAAI,KAAK,SAAS,QAAQ,MAAM;AAC9B,SAAK,KAAK,KAAK,WAAU;AACzB,QAAI,aACF;AAAE,WAAK,gBAAgB,KAAK,IAAI,cAAc,KAAK;AAAA,IAAG;AAAA,EAC1D,OAAO;AACL,QAAI,gBAAgB,MAClB;AAAE,WAAK,WAAU;AAAA,IAAI;AACvB,SAAK,KAAK;AAAA,EACZ;AACF;AAEA,KAAK,kBAAkB,SAAS,MAAM;AACpC,OAAK,aAAa,KAAK,IAAI,QAAQ,QAAQ,IAAI,KAAK,oBAAoB,MAAM,KAAK,IAAI;AACzF;AAEA,KAAK,iBAAiB,WAAW;AAC/B,MAAI,UAAU,EAAC,UAAU,uBAAO,OAAO,IAAI,GAAG,MAAM,GAAE;AACtD,OAAK,iBAAiB,KAAK,OAAO;AAClC,SAAO,QAAQ;AACjB;AAEA,KAAK,gBAAgB,WAAW;AAC9B,MAAI2L,OAAM,KAAK,iBAAiB,IAAG;AACnC,MAAI,WAAWA,KAAI;AACnB,MAAI,OAAOA,KAAI;AACf,MAAI,CAAC,KAAK,QAAQ,oBAAoB;AAAE;AAAA,EAAO;AAC/C,MAAI,MAAM,KAAK,iBAAiB;AAChC,MAAI,SAAS,QAAQ,IAAI,OAAO,KAAK,iBAAiB,MAAM,CAAC;AAC7D,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,EAAE,GAAG;AACpC,QAAI,KAAK,KAAK,CAAC;AACf,QAAI,CAAC,OAAO,UAAU,GAAG,IAAI,GAAG;AAC9B,UAAI,QAAQ;AACV,eAAO,KAAK,KAAK,EAAE;AAAA,MACrB,OAAO;AACL,aAAK,iBAAiB,GAAG,OAAQ,qBAAsB,GAAG,OAAQ,0CAA0C;AAAA,MAC9G;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,wBAAwB,gBAAgB,SAAS;AACxD,MAAI1H,QAAO,QAAQ,IAAI;AACvB,MAAI,OAAO,eAAeA,KAAI;AAE9B,MAAI,OAAO;AACX,MAAI,QAAQ,SAAS,uBAAuB,QAAQ,SAAS,SAAS,QAAQ,SAAS,QAAQ;AAC7F,YAAQ,QAAQ,SAAS,MAAM,OAAO,QAAQ;AAAA,EAChD;AAGA,MACE,SAAS,UAAU,SAAS,UAC5B,SAAS,UAAU,SAAS,UAC5B,SAAS,UAAU,SAAS,UAC5B,SAAS,UAAU,SAAS,QAC5B;AACA,mBAAeA,KAAI,IAAI;AACvB,WAAO;AAAA,EACT,WAAW,CAAC,MAAM;AAChB,mBAAeA,KAAI,IAAI;AACvB,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,SAAS,aAAa,MAAMA,OAAM;AAChC,MAAI,WAAW,KAAK;AACpB,MAAI7B,OAAM,KAAK;AACf,SAAO,CAAC,aACNA,KAAI,SAAS,gBAAgBA,KAAI,SAAS6B,SAC1C7B,KAAI,SAAS,aAAaA,KAAI,UAAU6B;AAE5C;AAIA,KAAK,4BAA4B,SAAS,MAAM,SAAS;AACvD,MAAI,KAAK,QAAQ,eAAe,IAAI;AAClC,QAAI,KAAK,cAAc,IAAI,GAAG;AAC5B,WAAK,WAAW,KAAK,sBAAqB;AAC1C,WAAK,YAAY,SAAS,KAAK,UAAU,KAAK,YAAY;AAAA,IAC5D,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AACA,OAAK,iBAAiB,MAAM;AAC5B,MAAI,KAAK,SAAS,QAAQ,QAAQ;AAAE,SAAK,WAAU;AAAA,EAAI;AACvD,OAAK,SAAS,KAAK,cAAa;AAChC,MAAI,KAAK,QAAQ,eAAe,IAC9B;AAAE,SAAK,aAAa,KAAK,gBAAe;AAAA,EAAI;AAC9C,OAAK,UAAS;AACd,SAAO,KAAK,WAAW,MAAM,sBAAsB;AACrD;AAEA,KAAK,cAAc,SAAS,MAAM,SAAS;AACzC,OAAK,KAAI;AAET,MAAI,KAAK,IAAI,QAAQ,IAAI,GAAG;AAC1B,WAAO,KAAK,0BAA0B,MAAM,OAAO;AAAA,EACrD;AACA,MAAI,KAAK,IAAI,QAAQ,QAAQ,GAAG;AAC9B,SAAK,YAAY,SAAS,WAAW,KAAK,YAAY;AACtD,SAAK,cAAc,KAAK,8BAA6B;AACrD,WAAO,KAAK,WAAW,MAAM,0BAA0B;AAAA,EACzD;AAEA,MAAI,KAAK,8BAA8B;AACrC,SAAK,cAAc,KAAK,uBAAuB,IAAI;AACnD,QAAI,KAAK,YAAY,SAAS,uBAC5B;AAAE,WAAK,oBAAoB,SAAS,KAAK,YAAY,YAAY;AAAA,IAAG,OAEpE;AAAE,WAAK,YAAY,SAAS,KAAK,YAAY,IAAI,KAAK,YAAY,GAAG,KAAK;AAAA,IAAG;AAC/E,SAAK,aAAa,CAAA;AAClB,SAAK,SAAS;AACd,QAAI,KAAK,QAAQ,eAAe,IAC9B;AAAE,WAAK,aAAa,CAAA;AAAA,IAAI;AAAA,EAC5B,OAAO;AACL,SAAK,cAAc;AACnB,SAAK,aAAa,KAAK,sBAAsB,OAAO;AACpD,QAAI,KAAK,cAAc,MAAM,GAAG;AAC9B,UAAI,KAAK,SAAS,QAAQ,QAAQ;AAAE,aAAK,WAAU;AAAA,MAAI;AACvD,WAAK,SAAS,KAAK,cAAa;AAChC,UAAI,KAAK,QAAQ,eAAe,IAC9B;AAAE,aAAK,aAAa,KAAK,gBAAe;AAAA,MAAI;AAAA,IAChD,OAAO;AACL,eAAS,IAAI,GAAG/D,QAAO,KAAK,YAAY,IAAIA,MAAK,QAAQ,KAAK,GAAG;AAE/D,YAAI,OAAOA,MAAK,CAAC;AAEjB,aAAK,gBAAgB,KAAK,KAAK;AAE/B,aAAK,iBAAiB,KAAK,KAAK;AAEhC,YAAI,KAAK,MAAM,SAAS,WAAW;AACjC,eAAK,MAAM,KAAK,MAAM,OAAO,wEAAwE;AAAA,QACvG;AAAA,MACF;AAEA,WAAK,SAAS;AACd,UAAI,KAAK,QAAQ,eAAe,IAC9B;AAAE,aAAK,aAAa,CAAA;AAAA,MAAI;AAAA,IAC5B;AACA,SAAK,UAAS;AAAA,EAChB;AACA,SAAO,KAAK,WAAW,MAAM,wBAAwB;AACvD;AAEA,KAAK,yBAAyB,SAAS,MAAM;AAC3C,SAAO,KAAK,eAAe,IAAI;AACjC;AAEA,KAAK,gCAAgC,WAAW;AAC9C,MAAI;AACJ,MAAI,KAAK,SAAS,QAAQ,cAAc,UAAU,KAAK,gBAAe,IAAK;AACzE,QAAI,QAAQ,KAAK,UAAS;AAC1B,SAAK,KAAI;AACT,QAAI,SAAS;AAAE,WAAK,KAAI;AAAA,IAAI;AAC5B,WAAO,KAAK,cAAc,OAAO,iBAAiB,kBAAkB,OAAO,OAAO;AAAA,EACpF,WAAW,KAAK,SAAS,QAAQ,QAAQ;AACvC,QAAI,QAAQ,KAAK,UAAS;AAC1B,WAAO,KAAK,WAAW,OAAO,YAAY;AAAA,EAC5C,OAAO;AACL,QAAI,cAAc,KAAK,iBAAgB;AACvC,SAAK,UAAS;AACd,WAAO;AAAA,EACT;AACF;AAEA,KAAK,cAAc,SAAS,SAAS+D,OAAM,KAAK;AAC9C,MAAI,CAAC,SAAS;AAAE;AAAA,EAAO;AACvB,MAAI,OAAOA,UAAS,UAClB;AAAE,IAAAA,QAAOA,MAAK,SAAS,eAAeA,MAAK,OAAOA,MAAK;AAAA,EAAO;AAChE,MAAI,OAAO,SAASA,KAAI,GACtB;AAAE,SAAK,iBAAiB,KAAK,uBAAuBA,QAAO,GAAG;AAAA,EAAG;AACnE,UAAQA,KAAI,IAAI;AAClB;AAEA,KAAK,qBAAqB,SAAS,SAAS,KAAK;AAC/C,MAAI,OAAO,IAAI;AACf,MAAI,SAAS,cACX;AAAE,SAAK,YAAY,SAAS,KAAK,IAAI,KAAK;AAAA,EAAG,WACtC,SAAS,iBAChB;AAAE,aAAS,IAAI,GAAG/D,QAAO,IAAI,YAAY,IAAIA,MAAK,QAAQ,KAAK,GAC7D;AACE,UAAI,OAAOA,MAAK,CAAC;AAEjB,WAAK,mBAAmB,SAAS,IAAI;AAAA,IACvC;AAAA,EAAE,WACG,SAAS,gBAChB;AAAE,aAAS,MAAM,GAAG,SAAS,IAAI,UAAU,MAAM,OAAO,QAAQ,OAAO,GAAG;AACxE,UAAI,MAAM,OAAO,GAAG;AAElB,UAAI,KAAK;AAAE,aAAK,mBAAmB,SAAS,GAAG;AAAA,MAAG;AAAA,IACtD;AAAA,EAAE,WACK,SAAS,YAChB;AAAE,SAAK,mBAAmB,SAAS,IAAI,KAAK;AAAA,EAAG,WACxC,SAAS,qBAChB;AAAE,SAAK,mBAAmB,SAAS,IAAI,IAAI;AAAA,EAAG,WACvC,SAAS,eAChB;AAAE,SAAK,mBAAmB,SAAS,IAAI,QAAQ;AAAA,EAAG;AACtD;AAEA,KAAK,sBAAsB,SAAS,SAAS,OAAO;AAClD,MAAI,CAAC,SAAS;AAAE;AAAA,EAAO;AACvB,WAAS,IAAI,GAAGA,QAAO,OAAO,IAAIA,MAAK,QAAQ,KAAK,GAClD;AACA,QAAI,OAAOA,MAAK,CAAC;AAEjB,SAAK,mBAAmB,SAAS,KAAK,EAAE;AAAA,EAC1C;AACF;AAEA,KAAK,6BAA6B,WAAW;AAC3C,SAAO,KAAK,KAAK,YAAY,SAC3B,KAAK,KAAK,YAAY,WACtB,KAAK,KAAK,YAAY,WACtB,KAAK,KAAK,YAAY,cACtB,KAAK,MAAK,KACV,KAAK,gBAAe;AACxB;AAIA,KAAK,uBAAuB,SAAS,SAAS;AAC5C,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,QAAQ,KAAK,sBAAqB;AAEvC,OAAK,WAAW,KAAK,cAAc,IAAI,IAAI,KAAK,0BAA0B,KAAK;AAC/E,OAAK;AAAA,IACH;AAAA,IACA,KAAK;AAAA,IACL,KAAK,SAAS;AAAA,EAClB;AAEE,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,wBAAwB,SAAS,SAAS;AAC7C,MAAI,QAAQ,IAAI,QAAQ;AAExB,OAAK,OAAO,QAAQ,MAAM;AAC1B,SAAO,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAChC,QAAI,CAAC,OAAO;AACV,WAAK,OAAO,QAAQ,KAAK;AACzB,UAAI,KAAK,mBAAmB,QAAQ,MAAM,GAAG;AAAE;AAAA,MAAM;AAAA,IACvD,OAAO;AAAE,cAAQ;AAAA,IAAO;AAExB,UAAM,KAAK,KAAK,qBAAqB,OAAO,CAAC;AAAA,EAC/C;AACA,SAAO;AACT;AAIA,KAAK,cAAc,SAAS,MAAM;AAChC,OAAK,KAAI;AAGT,MAAI,KAAK,SAAS,QAAQ,QAAQ;AAChC,SAAK,aAAa;AAClB,SAAK,SAAS,KAAK,cAAa;AAAA,EAClC,OAAO;AACL,SAAK,aAAa,KAAK,sBAAqB;AAC5C,SAAK,iBAAiB,MAAM;AAC5B,SAAK,SAAS,KAAK,SAAS,QAAQ,SAAS,KAAK,cAAa,IAAK,KAAK,WAAU;AAAA,EACrF;AACA,MAAI,KAAK,QAAQ,eAAe,IAC9B;AAAE,SAAK,aAAa,KAAK,gBAAe;AAAA,EAAI;AAC9C,OAAK,UAAS;AACd,SAAO,KAAK,WAAW,MAAM,mBAAmB;AAClD;AAIA,KAAK,uBAAuB,WAAW;AACrC,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,WAAW,KAAK,sBAAqB;AAE1C,MAAI,KAAK,cAAc,IAAI,GAAG;AAC5B,SAAK,QAAQ,KAAK,WAAU;AAAA,EAC9B,OAAO;AACL,SAAK,gBAAgB,KAAK,QAAQ;AAClC,SAAK,QAAQ,KAAK;AAAA,EACpB;AACA,OAAK,gBAAgB,KAAK,OAAO,YAAY;AAE7C,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,8BAA8B,WAAW;AAE5C,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,QAAQ,KAAK,WAAU;AAC5B,OAAK,gBAAgB,KAAK,OAAO,YAAY;AAC7C,SAAO,KAAK,WAAW,MAAM,wBAAwB;AACvD;AAEA,KAAK,gCAAgC,WAAW;AAC9C,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AACT,OAAK,iBAAiB,IAAI;AAC1B,OAAK,QAAQ,KAAK,WAAU;AAC5B,OAAK,gBAAgB,KAAK,OAAO,YAAY;AAC7C,SAAO,KAAK,WAAW,MAAM,0BAA0B;AACzD;AAEA,KAAK,wBAAwB,WAAW;AACtC,MAAI,QAAQ,IAAI,QAAQ;AACxB,MAAI,KAAK,SAAS,QAAQ,MAAM;AAC9B,UAAM,KAAK,KAAK,6BAA6B;AAC7C,QAAI,CAAC,KAAK,IAAI,QAAQ,KAAK,GAAG;AAAE,aAAO;AAAA,IAAM;AAAA,EAC/C;AACA,MAAI,KAAK,SAAS,QAAQ,MAAM;AAC9B,UAAM,KAAK,KAAK,+BAA+B;AAC/C,WAAO;AAAA,EACT;AACA,OAAK,OAAO,QAAQ,MAAM;AAC1B,SAAO,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAChC,QAAI,CAAC,OAAO;AACV,WAAK,OAAO,QAAQ,KAAK;AACzB,UAAI,KAAK,mBAAmB,QAAQ,MAAM,GAAG;AAAE;AAAA,MAAM;AAAA,IACvD,OAAO;AAAE,cAAQ;AAAA,IAAO;AAExB,UAAM,KAAK,KAAK,sBAAsB;AAAA,EACxC;AACA,SAAO;AACT;AAEA,KAAK,kBAAkB,WAAW;AAChC,MAAI,QAAQ,CAAA;AACZ,MAAI,CAAC,KAAK,IAAI,QAAQ,KAAK,GAAG;AAC5B,WAAO;AAAA,EACT;AACA,OAAK,OAAO,QAAQ,MAAM;AAC1B,MAAI,gBAAgB,CAAA;AACpB,MAAI,QAAQ;AACZ,SAAO,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAChC,QAAI,CAAC,OAAO;AACV,WAAK,OAAO,QAAQ,KAAK;AACzB,UAAI,KAAK,mBAAmB,QAAQ,MAAM,GAAG;AAAE;AAAA,MAAM;AAAA,IACvD,OAAO;AAAE,cAAQ;AAAA,IAAO;AAExB,QAAI,OAAO,KAAK,qBAAoB;AACpC,QAAI,UAAU,KAAK,IAAI,SAAS,eAAe,KAAK,IAAI,OAAO,KAAK,IAAI;AACxE,QAAI,OAAO,eAAe,OAAO,GAC/B;AAAE,WAAK,iBAAiB,KAAK,IAAI,OAAO,8BAA8B,UAAU,GAAG;AAAA,IAAG;AACxF,kBAAc,OAAO,IAAI;AACzB,UAAM,KAAK,IAAI;AAAA,EACjB;AACA,SAAO;AACT;AAEA,KAAK,uBAAuB,WAAW;AACrC,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,MAAM,KAAK,SAAS,QAAQ,SAAS,KAAK,cAAa,IAAK,KAAK,WAAW,KAAK,QAAQ,kBAAkB,OAAO;AACvH,OAAK,OAAO,QAAQ,KAAK;AACzB,MAAI,KAAK,SAAS,QAAQ,QAAQ;AAChC,SAAK,WAAU;AAAA,EACjB;AACA,OAAK,QAAQ,KAAK,cAAa;AAC/B,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,wBAAwB,WAAW;AACtC,MAAI,KAAK,QAAQ,eAAe,MAAM,KAAK,SAAS,QAAQ,QAAQ;AAClE,QAAI,gBAAgB,KAAK,aAAa,KAAK,KAAK;AAChD,QAAI,cAAc,KAAK,cAAc,KAAK,GAAG;AAC3C,WAAK,MAAM,cAAc,OAAO,iDAAiD;AAAA,IACnF;AACA,WAAO;AAAA,EACT;AACA,SAAO,KAAK,WAAW,IAAI;AAC7B;AAGA,KAAK,yBAAyB,SAAS,YAAY;AACjD,WAAS,IAAI,GAAG,IAAI,WAAW,UAAU,KAAK,qBAAqB,WAAW,CAAC,CAAC,GAAG,EAAE,GAAG;AACtF,eAAW,CAAC,EAAE,YAAY,WAAW,CAAC,EAAE,WAAW,IAAI,MAAM,GAAG,EAAE;AAAA,EACpE;AACF;AACA,KAAK,uBAAuB,SAAS,WAAW;AAC9C,SACE,KAAK,QAAQ,eAAe,KAC5B,UAAU,SAAS,yBACnB,UAAU,WAAW,SAAS,aAC9B,OAAO,UAAU,WAAW,UAAU;AAAA,GAErC,KAAK,MAAM,UAAU,KAAK,MAAM,OAAQ,KAAK,MAAM,UAAU,KAAK,MAAM;AAE7E;AAEA,IAAI,OAAO,OAAO;AAKlB,KAAK,eAAe,SAAS,MAAM,WAAW,wBAAwB;AACpE,MAAI,KAAK,QAAQ,eAAe,KAAK,MAAM;AACzC,YAAQ,KAAK,MAAI;AAAA,MACjB,KAAK;AACH,YAAI,KAAK,WAAW,KAAK,SAAS,SAChC;AAAE,eAAK,MAAM,KAAK,OAAO,2DAA2D;AAAA,QAAG;AACzF;AAAA,MAEF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH;AAAA,MAEF,KAAK;AACH,aAAK,OAAO;AACZ,YAAI,wBAAwB;AAAE,eAAK,mBAAmB,wBAAwB,IAAI;AAAA,QAAG;AACrF,iBAAS,IAAI,GAAGA,QAAO,KAAK,YAAY,IAAIA,MAAK,QAAQ,KAAK,GAAG;AAC/D,cAAI,OAAOA,MAAK,CAAC;AAEnB,eAAK,aAAa,MAAM,SAAS;AAM/B,cACE,KAAK,SAAS,kBACb,KAAK,SAAS,SAAS,kBAAkB,KAAK,SAAS,SAAS,kBACjE;AACA,iBAAK,MAAM,KAAK,SAAS,OAAO,kBAAkB;AAAA,UACpD;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AAEH,YAAI,KAAK,SAAS,QAAQ;AAAE,eAAK,MAAM,KAAK,IAAI,OAAO,+CAA+C;AAAA,QAAG;AACzG,aAAK,aAAa,KAAK,OAAO,SAAS;AACvC;AAAA,MAEF,KAAK;AACH,aAAK,OAAO;AACZ,YAAI,wBAAwB;AAAE,eAAK,mBAAmB,wBAAwB,IAAI;AAAA,QAAG;AACrF,aAAK,iBAAiB,KAAK,UAAU,SAAS;AAC9C;AAAA,MAEF,KAAK;AACH,aAAK,OAAO;AACZ,aAAK,aAAa,KAAK,UAAU,SAAS;AAC1C,YAAI,KAAK,SAAS,SAAS,qBACzB;AAAE,eAAK,MAAM,KAAK,SAAS,OAAO,2CAA2C;AAAA,QAAG;AAClF;AAAA,MAEF,KAAK;AACH,YAAI,KAAK,aAAa,KAAK;AAAE,eAAK,MAAM,KAAK,KAAK,KAAK,6DAA6D;AAAA,QAAG;AACvH,aAAK,OAAO;AACZ,eAAO,KAAK;AACZ,aAAK,aAAa,KAAK,MAAM,SAAS;AACtC;AAAA,MAEF,KAAK;AACH,aAAK,aAAa,KAAK,YAAY,WAAW,sBAAsB;AACpE;AAAA,MAEF,KAAK;AACH,aAAK,iBAAiB,KAAK,OAAO,mDAAmD;AACrF;AAAA,MAEF,KAAK;AACH,YAAI,CAAC,WAAW;AAAE;AAAA,QAAM;AAAA,MAE1B;AACE,aAAK,MAAM,KAAK,OAAO,qBAAqB;AAAA,IAClD;AAAA,EACE,WAAW,wBAAwB;AAAE,SAAK,mBAAmB,wBAAwB,IAAI;AAAA,EAAG;AAC5F,SAAO;AACT;AAIA,KAAK,mBAAmB,SAAS,UAAU,WAAW;AACpD,MAAI,MAAM,SAAS;AACnB,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,QAAI,MAAM,SAAS,CAAC;AACpB,QAAI,KAAK;AAAE,WAAK,aAAa,KAAK,SAAS;AAAA,IAAG;AAAA,EAChD;AACA,MAAI,KAAK;AACP,QAAI,OAAO,SAAS,MAAM,CAAC;AAC3B,QAAI,KAAK,QAAQ,gBAAgB,KAAK,aAAa,QAAQ,KAAK,SAAS,iBAAiB,KAAK,SAAS,SAAS,cAC/G;AAAE,WAAK,WAAW,KAAK,SAAS,KAAK;AAAA,IAAG;AAAA,EAC5C;AACA,SAAO;AACT;AAIA,KAAK,cAAc,SAAS,wBAAwB;AAClD,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AACT,OAAK,WAAW,KAAK,iBAAiB,OAAO,sBAAsB;AACnE,SAAO,KAAK,WAAW,MAAM,eAAe;AAC9C;AAEA,KAAK,mBAAmB,WAAW;AACjC,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AAGT,MAAI,KAAK,QAAQ,gBAAgB,KAAK,KAAK,SAAS,QAAQ,MAC1D;AAAE,SAAK,WAAU;AAAA,EAAI;AAEvB,OAAK,WAAW,KAAK,iBAAgB;AAErC,SAAO,KAAK,WAAW,MAAM,aAAa;AAC5C;AAIA,KAAK,mBAAmB,WAAW;AACjC,MAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,YAAQ,KAAK,MAAI;AAAA,MACjB,KAAK,QAAQ;AACX,YAAI,OAAO,KAAK,UAAS;AACzB,aAAK,KAAI;AACT,aAAK,WAAW,KAAK,iBAAiB,QAAQ,UAAU,MAAM,IAAI;AAClE,eAAO,KAAK,WAAW,MAAM,cAAc;AAAA,MAE7C,KAAK,QAAQ;AACX,eAAO,KAAK,SAAS,IAAI;AAAA,IAC/B;AAAA,EACE;AACA,SAAO,KAAK,WAAU;AACxB;AAEA,KAAK,mBAAmB,SAAS,OAAO,YAAY,oBAAoB,gBAAgB;AACtF,MAAI,OAAO,IAAI,QAAQ;AACvB,SAAO,CAAC,KAAK,IAAI,KAAK,GAAG;AACvB,QAAI,OAAO;AAAE,cAAQ;AAAA,IAAO,OACvB;AAAE,WAAK,OAAO,QAAQ,KAAK;AAAA,IAAG;AACnC,QAAI,cAAc,KAAK,SAAS,QAAQ,OAAO;AAC7C,WAAK,KAAK,IAAI;AAAA,IAChB,WAAW,sBAAsB,KAAK,mBAAmB,KAAK,GAAG;AAC/D;AAAA,IACF,WAAW,KAAK,SAAS,QAAQ,UAAU;AACzC,UAAI,OAAO,KAAK,iBAAgB;AAChC,WAAK,qBAAqB,IAAI;AAC9B,WAAK,KAAK,IAAI;AACd,UAAI,KAAK,SAAS,QAAQ,OAAO;AAAE,aAAK,iBAAiB,KAAK,OAAO,+CAA+C;AAAA,MAAG;AACvH,WAAK,OAAO,KAAK;AACjB;AAAA,IACF,OAAO;AACL,WAAK,KAAK,KAAK,wBAAwB,cAAc,CAAC;AAAA,IACxD;AAAA,EACF;AACA,SAAO;AACT;AAEA,KAAK,0BAA0B,SAAS,gBAAgB;AACtD,MAAI,OAAO,KAAK,kBAAkB,KAAK,OAAO,KAAK,QAAQ;AAC3D,OAAK,qBAAqB,IAAI;AAC9B,SAAO;AACT;AAEA,KAAK,uBAAuB,SAAS,OAAO;AAC1C,SAAO;AACT;AAIA,KAAK,oBAAoB,SAAS,UAAU,UAAU,MAAM;AAC1D,SAAO,QAAQ,KAAK,iBAAgB;AACpC,MAAI,KAAK,QAAQ,cAAc,KAAK,CAAC,KAAK,IAAI,QAAQ,EAAE,GAAG;AAAE,WAAO;AAAA,EAAK;AACzE,MAAI,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,OAAK,OAAO;AACZ,OAAK,QAAQ,KAAK,iBAAgB;AAClC,SAAO,KAAK,WAAW,MAAM,mBAAmB;AAClD;AAkEA,KAAK,kBAAkB,SAAS,MAAM,aAAa,cAAc;AAC/D,MAAK,gBAAgB,OAAS,eAAc;AAE5C,MAAI,SAAS,gBAAgB;AAE7B,UAAQ,KAAK,MAAI;AAAA,IACjB,KAAK;AACH,UAAI,KAAK,UAAU,KAAK,wBAAwB,KAAK,KAAK,IAAI,GAC5D;AAAE,aAAK,iBAAiB,KAAK,QAAQ,SAAS,aAAa,mBAAmB,KAAK,OAAO,iBAAiB;AAAA,MAAG;AAChH,UAAI,QAAQ;AACV,YAAI,gBAAgB,gBAAgB,KAAK,SAAS,OAChD;AAAE,eAAK,iBAAiB,KAAK,OAAO,6CAA6C;AAAA,QAAG;AACtF,YAAI,cAAc;AAChB,cAAI,OAAO,cAAc,KAAK,IAAI,GAChC;AAAE,iBAAK,iBAAiB,KAAK,OAAO,qBAAqB;AAAA,UAAG;AAC9D,uBAAa,KAAK,IAAI,IAAI;AAAA,QAC5B;AACA,YAAI,gBAAgB,cAAc;AAAE,eAAK,YAAY,KAAK,MAAM,aAAa,KAAK,KAAK;AAAA,QAAG;AAAA,MAC5F;AACA;AAAA,IAEF,KAAK;AACH,WAAK,iBAAiB,KAAK,OAAO,mDAAmD;AACrF;AAAA,IAEF,KAAK;AACH,UAAI,QAAQ;AAAE,aAAK,iBAAiB,KAAK,OAAO,2BAA2B;AAAA,MAAG;AAC9E;AAAA,IAEF,KAAK;AACH,UAAI,QAAQ;AAAE,aAAK,iBAAiB,KAAK,OAAO,kCAAkC;AAAA,MAAG;AACrF,aAAO,KAAK,gBAAgB,KAAK,YAAY,aAAa,YAAY;AAAA,IAExE;AACE,WAAK,MAAM,KAAK,QAAQ,SAAS,YAAY,kBAAkB,SAAS;AAAA,EAC5E;AACA;AAEA,KAAK,mBAAmB,SAAS,MAAM,aAAa,cAAc;AAChE,MAAK,gBAAgB,OAAS,eAAc;AAE5C,UAAQ,KAAK,MAAI;AAAA,IACjB,KAAK;AACH,eAAS,IAAI,GAAGA,QAAO,KAAK,YAAY,IAAIA,MAAK,QAAQ,KAAK,GAAG;AAC/D,YAAI,OAAOA,MAAK,CAAC;AAEnB,aAAK,sBAAsB,MAAM,aAAa,YAAY;AAAA,MAC1D;AACA;AAAA,IAEF,KAAK;AACH,eAAS,MAAM,GAAG,SAAS,KAAK,UAAU,MAAM,OAAO,QAAQ,OAAO,GAAG;AACvE,YAAI,OAAO,OAAO,GAAG;AAEvB,YAAI,MAAM;AAAE,eAAK,sBAAsB,MAAM,aAAa,YAAY;AAAA,QAAG;AAAA,MACzE;AACA;AAAA,IAEF;AACE,WAAK,gBAAgB,MAAM,aAAa,YAAY;AAAA,EACxD;AACA;AAEA,KAAK,wBAAwB,SAAS,MAAM,aAAa,cAAc;AACrE,MAAK,gBAAgB,OAAS,eAAc;AAE5C,UAAQ,KAAK,MAAI;AAAA,IACjB,KAAK;AAEH,WAAK,sBAAsB,KAAK,OAAO,aAAa,YAAY;AAChE;AAAA,IAEF,KAAK;AACH,WAAK,iBAAiB,KAAK,MAAM,aAAa,YAAY;AAC1D;AAAA,IAEF,KAAK;AACH,WAAK,iBAAiB,KAAK,UAAU,aAAa,YAAY;AAC9D;AAAA,IAEF;AACE,WAAK,iBAAiB,MAAM,aAAa,YAAY;AAAA,EACzD;AACA;AAOA,IAAI,aAAa,SAASiM,YAAW,OAAO,QAAQ,eAAe,UAAU,WAAW;AACtF,OAAK,QAAQ;AACb,OAAK,SAAS,CAAC,CAAC;AAChB,OAAK,gBAAgB,CAAC,CAAC;AACvB,OAAK,WAAW;AAChB,OAAK,YAAY,CAAC,CAAC;AACrB;AAEA,IAAI,QAAQ;AAAA,EACV,QAAQ,IAAI,WAAW,KAAK,KAAK;AAAA,EACjC,QAAQ,IAAI,WAAW,KAAK,IAAI;AAAA,EAChC,QAAQ,IAAI,WAAW,MAAM,KAAK;AAAA,EAClC,QAAQ,IAAI,WAAW,KAAK,KAAK;AAAA,EACjC,QAAQ,IAAI,WAAW,KAAK,IAAI;AAAA,EAChC,QAAQ,IAAI,WAAW,KAAK,MAAM,MAAM,SAAU,GAAG;AAAE,WAAO,EAAE,qBAAoB;AAAA,EAAI,CAAC;AAAA,EACzF,QAAQ,IAAI,WAAW,YAAY,KAAK;AAAA,EACxC,QAAQ,IAAI,WAAW,YAAY,IAAI;AAAA,EACvC,YAAY,IAAI,WAAW,YAAY,MAAM,OAAO,MAAM,IAAI;AAAA,EAC9D,OAAO,IAAI,WAAW,YAAY,OAAO,OAAO,MAAM,IAAI;AAC5D;AAEA,IAAI,OAAO,OAAO;AAElB,KAAK,iBAAiB,WAAW;AAC/B,SAAO,CAAC,MAAM,MAAM;AACtB;AAEA,KAAK,aAAa,WAAW;AAC3B,SAAO,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC;AAC7C;AAEA,KAAK,eAAe,SAAS,UAAU;AACrC,MAAI,SAAS,KAAK,WAAU;AAC5B,MAAI,WAAW,MAAM,UAAU,WAAW,MAAM,QAC9C;AAAE,WAAO;AAAA,EAAK;AAChB,MAAI,aAAa,QAAQ,UAAU,WAAW,MAAM,UAAU,WAAW,MAAM,SAC7E;AAAE,WAAO,CAAC,OAAO;AAAA,EAAO;AAK1B,MAAI,aAAa,QAAQ,WAAW,aAAa,QAAQ,QAAQ,KAAK,aACpE;AAAE,WAAO,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC;AAAA,EAAE;AACzE,MAAI,aAAa,QAAQ,SAAS,aAAa,QAAQ,QAAQ,aAAa,QAAQ,OAAO,aAAa,QAAQ,UAAU,aAAa,QAAQ,OAC7I;AAAE,WAAO;AAAA,EAAK;AAChB,MAAI,aAAa,QAAQ,QACvB;AAAE,WAAO,WAAW,MAAM;AAAA,EAAO;AACnC,MAAI,aAAa,QAAQ,QAAQ,aAAa,QAAQ,UAAU,aAAa,QAAQ,MACnF;AAAE,WAAO;AAAA,EAAM;AACjB,SAAO,CAAC,KAAK;AACf;AAEA,KAAK,qBAAqB,WAAW;AACnC,WAAS,IAAI,KAAK,QAAQ,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,QAAI,UAAU,KAAK,QAAQ,CAAC;AAC5B,QAAI,QAAQ,UAAU,YACpB;AAAE,aAAO,QAAQ;AAAA,IAAU;AAAA,EAC/B;AACA,SAAO;AACT;AAEA,KAAK,gBAAgB,SAAS,UAAU;AACtC,MAAIC,SAAQ,OAAO,KAAK;AACxB,MAAI,KAAK,WAAW,aAAa,QAAQ,KACvC;AAAE,SAAK,cAAc;AAAA,EAAO,WACrBA,UAAS,KAAK,eACrB;AAAE,IAAAA,QAAO,KAAK,MAAM,QAAQ;AAAA,EAAG,OAE/B;AAAE,SAAK,cAAc,KAAK;AAAA,EAAY;AAC1C;AAIA,KAAK,kBAAkB,SAAS,UAAU;AACxC,MAAI,KAAK,WAAU,MAAO,UAAU;AAClC,SAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC,IAAI;AAAA,EAC1C;AACF;AAIA,QAAQ,OAAO,gBAAgB,QAAQ,OAAO,gBAAgB,WAAW;AACvE,MAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,SAAK,cAAc;AACnB;AAAA,EACF;AACA,MAAI,MAAM,KAAK,QAAQ,IAAG;AAC1B,MAAI,QAAQ,MAAM,UAAU,KAAK,WAAU,EAAG,UAAU,YAAY;AAClE,UAAM,KAAK,QAAQ,IAAG;AAAA,EACxB;AACA,OAAK,cAAc,CAAC,IAAI;AAC1B;AAEA,QAAQ,OAAO,gBAAgB,SAAS,UAAU;AAChD,OAAK,QAAQ,KAAK,KAAK,aAAa,QAAQ,IAAI,MAAM,SAAS,MAAM,MAAM;AAC3E,OAAK,cAAc;AACrB;AAEA,QAAQ,aAAa,gBAAgB,WAAW;AAC9C,OAAK,QAAQ,KAAK,MAAM,MAAM;AAC9B,OAAK,cAAc;AACrB;AAEA,QAAQ,OAAO,gBAAgB,SAAS,UAAU;AAChD,MAAI,kBAAkB,aAAa,QAAQ,OAAO,aAAa,QAAQ,QAAQ,aAAa,QAAQ,SAAS,aAAa,QAAQ;AAClI,OAAK,QAAQ,KAAK,kBAAkB,MAAM,SAAS,MAAM,MAAM;AAC/D,OAAK,cAAc;AACrB;AAEA,QAAQ,OAAO,gBAAgB,WAAW;AAE1C;AAEA,QAAQ,UAAU,gBAAgB,QAAQ,OAAO,gBAAgB,SAAS,UAAU;AAClF,MAAI,SAAS,cAAc,aAAa,QAAQ,SAC5C,EAAE,aAAa,QAAQ,QAAQ,KAAK,WAAU,MAAO,MAAM,WAC3D,EAAE,aAAa,QAAQ,WAAW,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC,MAC9F,GAAG,aAAa,QAAQ,SAAS,aAAa,QAAQ,WAAW,KAAK,iBAAiB,MAAM,SAC/F;AAAE,SAAK,QAAQ,KAAK,MAAM,MAAM;AAAA,EAAG,OAEnC;AAAE,SAAK,QAAQ,KAAK,MAAM,MAAM;AAAA,EAAG;AACrC,OAAK,cAAc;AACrB;AAEA,QAAQ,MAAM,gBAAgB,WAAW;AACvC,MAAI,KAAK,WAAU,EAAG,UAAU,YAAY;AAAE,SAAK,QAAQ,IAAG;AAAA,EAAI;AAClE,OAAK,cAAc;AACrB;AAEA,QAAQ,UAAU,gBAAgB,WAAW;AAC3C,MAAI,KAAK,iBAAiB,MAAM,QAC9B;AAAE,SAAK,QAAQ,IAAG;AAAA,EAAI,OAEtB;AAAE,SAAK,QAAQ,KAAK,MAAM,MAAM;AAAA,EAAG;AACrC,OAAK,cAAc;AACrB;AAEA,QAAQ,KAAK,gBAAgB,SAAS,UAAU;AAC9C,MAAI,aAAa,QAAQ,WAAW;AAClC,QAAI,QAAQ,KAAK,QAAQ,SAAS;AAClC,QAAI,KAAK,QAAQ,KAAK,MAAM,MAAM,QAChC;AAAE,WAAK,QAAQ,KAAK,IAAI,MAAM;AAAA,IAAY,OAE1C;AAAE,WAAK,QAAQ,KAAK,IAAI,MAAM;AAAA,IAAO;AAAA,EACzC;AACA,OAAK,cAAc;AACrB;AAEA,QAAQ,KAAK,gBAAgB,SAAS,UAAU;AAC9C,MAAI,UAAU;AACd,MAAI,KAAK,QAAQ,eAAe,KAAK,aAAa,QAAQ,KAAK;AAC7D,QAAI,KAAK,UAAU,QAAQ,CAAC,KAAK,eAC7B,KAAK,UAAU,WAAW,KAAK,mBAAkB,GACnD;AAAE,gBAAU;AAAA,IAAM;AAAA,EACtB;AACA,OAAK,cAAc;AACrB;AAqBA,IAAI,OAAO,OAAO;AAOlB,KAAK,iBAAiB,SAAS,MAAM,UAAU,wBAAwB;AACrE,MAAI,KAAK,QAAQ,eAAe,KAAK,KAAK,SAAS,iBACjD;AAAE;AAAA,EAAO;AACX,MAAI,KAAK,QAAQ,eAAe,MAAM,KAAK,YAAY,KAAK,UAAU,KAAK,YACzE;AAAE;AAAA,EAAO;AACX,MAAIhK,OAAM,KAAK;AACf,MAAI6B;AACJ,UAAQ7B,KAAI,MAAI;AAAA,IAChB,KAAK;AAAc,MAAA6B,QAAO7B,KAAI;AAAM;AAAA,IACpC,KAAK;AAAW,MAAA6B,QAAO,OAAO7B,KAAI,KAAK;AAAG;AAAA,IAC1C;AAAS;AAAA,EACX;AACE,MAAI,OAAO,KAAK;AAChB,MAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,QAAI6B,UAAS,eAAe,SAAS,QAAQ;AAC3C,UAAI,SAAS,OAAO;AAClB,YAAI,wBAAwB;AAC1B,cAAI,uBAAuB,cAAc,GAAG;AAC1C,mCAAuB,cAAc7B,KAAI;AAAA,UAC3C;AAAA,QACF,OAAO;AACL,eAAK,iBAAiBA,KAAI,OAAO,oCAAoC;AAAA,QACvE;AAAA,MACF;AACA,eAAS,QAAQ;AAAA,IACnB;AACA;AAAA,EACF;AACA,EAAA6B,QAAO,MAAMA;AACb,MAAI,QAAQ,SAASA,KAAI;AACzB,MAAI,OAAO;AACT,QAAI;AACJ,QAAI,SAAS,QAAQ;AACnB,qBAAe,KAAK,UAAU,MAAM,QAAQ,MAAM,OAAO,MAAM;AAAA,IACjE,OAAO;AACL,qBAAe,MAAM,QAAQ,MAAM,IAAI;AAAA,IACzC;AACA,QAAI,cACF;AAAE,WAAK,iBAAiB7B,KAAI,OAAO,0BAA0B;AAAA,IAAG;AAAA,EACpE,OAAO;AACL,YAAQ,SAAS6B,KAAI,IAAI;AAAA,MACvB,MAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,IACX;AAAA,EACE;AACA,QAAM,IAAI,IAAI;AAChB;AAiBA,KAAK,kBAAkB,SAAS,SAAS,wBAAwB;AAC/D,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,MAAI,OAAO,KAAK,iBAAiB,SAAS,sBAAsB;AAChE,MAAI,KAAK,SAAS,QAAQ,OAAO;AAC/B,QAAI,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,SAAK,cAAc,CAAC,IAAI;AACxB,WAAO,KAAK,IAAI,QAAQ,KAAK,GAAG;AAAE,WAAK,YAAY,KAAK,KAAK,iBAAiB,SAAS,sBAAsB,CAAC;AAAA,IAAG;AACjH,WAAO,KAAK,WAAW,MAAM,oBAAoB;AAAA,EACnD;AACA,SAAO;AACT;AAKA,KAAK,mBAAmB,SAAS,SAAS,wBAAwB,gBAAgB;AAChF,MAAI,KAAK,aAAa,OAAO,GAAG;AAC9B,QAAI,KAAK,aAAa;AAAE,aAAO,KAAK,WAAW,OAAO;AAAA,IAAE,OAGnD;AAAE,WAAK,cAAc;AAAA,IAAO;AAAA,EACnC;AAEA,MAAI,yBAAyB,OAAO,iBAAiB,IAAI,mBAAmB,IAAI,iBAAiB;AACjG,MAAI,wBAAwB;AAC1B,qBAAiB,uBAAuB;AACxC,uBAAmB,uBAAuB;AAC1C,qBAAiB,uBAAuB;AACxC,2BAAuB,sBAAsB,uBAAuB,gBAAgB;AAAA,EACtF,OAAO;AACL,6BAAyB,IAAI;AAC7B,6BAAyB;AAAA,EAC3B;AAEA,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,MAAI,KAAK,SAAS,QAAQ,UAAU,KAAK,SAAS,QAAQ,MAAM;AAC9D,SAAK,mBAAmB,KAAK;AAC7B,SAAK,2BAA2B,YAAY;AAAA,EAC9C;AACA,MAAI,OAAO,KAAK,sBAAsB,SAAS,sBAAsB;AACrE,MAAI,gBAAgB;AAAE,WAAO,eAAe,KAAK,MAAM,MAAM,UAAU,QAAQ;AAAA,EAAG;AAClF,MAAI,KAAK,KAAK,UAAU;AACtB,QAAI,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,SAAK,WAAW,KAAK;AACrB,QAAI,KAAK,SAAS,QAAQ,IACxB;AAAE,aAAO,KAAK,aAAa,MAAM,OAAO,sBAAsB;AAAA,IAAG;AACnE,QAAI,CAAC,wBAAwB;AAC3B,6BAAuB,sBAAsB,uBAAuB,gBAAgB,uBAAuB,cAAc;AAAA,IAC3H;AACA,QAAI,uBAAuB,mBAAmB,KAAK,OACjD;AAAE,6BAAuB,kBAAkB;AAAA,IAAI;AACjD,QAAI,KAAK,SAAS,QAAQ,IACxB;AAAE,WAAK,iBAAiB,IAAI;AAAA,IAAG,OAE/B;AAAE,WAAK,gBAAgB,IAAI;AAAA,IAAG;AAChC,SAAK,OAAO;AACZ,SAAK,KAAI;AACT,SAAK,QAAQ,KAAK,iBAAiB,OAAO;AAC1C,QAAI,iBAAiB,IAAI;AAAE,6BAAuB,cAAc;AAAA,IAAgB;AAChF,WAAO,KAAK,WAAW,MAAM,sBAAsB;AAAA,EACrD,OAAO;AACL,QAAI,wBAAwB;AAAE,WAAK,sBAAsB,wBAAwB,IAAI;AAAA,IAAG;AAAA,EAC1F;AACA,MAAI,iBAAiB,IAAI;AAAE,2BAAuB,sBAAsB;AAAA,EAAgB;AACxF,MAAI,mBAAmB,IAAI;AAAE,2BAAuB,gBAAgB;AAAA,EAAkB;AACtF,SAAO;AACT;AAIA,KAAK,wBAAwB,SAAS,SAAS,wBAAwB;AACrE,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,MAAI,OAAO,KAAK,aAAa,SAAS,sBAAsB;AAC5D,MAAI,KAAK,sBAAsB,sBAAsB,GAAG;AAAE,WAAO;AAAA,EAAK;AACtE,MAAI,KAAK,IAAI,QAAQ,QAAQ,GAAG;AAC9B,QAAI,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,SAAK,OAAO;AACZ,SAAK,aAAa,KAAK,iBAAgB;AACvC,SAAK,OAAO,QAAQ,KAAK;AACzB,SAAK,YAAY,KAAK,iBAAiB,OAAO;AAC9C,WAAO,KAAK,WAAW,MAAM,uBAAuB;AAAA,EACtD;AACA,SAAO;AACT;AAIA,KAAK,eAAe,SAAS,SAAS,wBAAwB;AAC5D,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,MAAI,OAAO,KAAK,gBAAgB,wBAAwB,OAAO,OAAO,OAAO;AAC7E,MAAI,KAAK,sBAAsB,sBAAsB,GAAG;AAAE,WAAO;AAAA,EAAK;AACtE,SAAO,KAAK,UAAU,YAAY,KAAK,SAAS,4BAA4B,OAAO,KAAK,YAAY,MAAM,UAAU,UAAU,IAAI,OAAO;AAC3I;AAQA,KAAK,cAAc,SAAS,MAAM,cAAc,cAAc,SAAS,SAAS;AAC9E,MAAI,OAAO,KAAK,KAAK;AACrB,MAAI,QAAQ,SAAS,CAAC,WAAW,KAAK,SAAS,QAAQ,MAAM;AAC3D,QAAI,OAAO,SAAS;AAClB,UAAI,UAAU,KAAK,SAAS,QAAQ,aAAa,KAAK,SAAS,QAAQ;AACvE,UAAI,WAAW,KAAK,SAAS,QAAQ;AACrC,UAAI,UAAU;AAGZ,eAAO,QAAQ,WAAW;AAAA,MAC5B;AACA,UAAI2G,MAAK,KAAK;AACd,WAAK,KAAI;AACT,UAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,UAAI,QAAQ,KAAK,YAAY,KAAK,gBAAgB,MAAM,OAAO,OAAO,OAAO,GAAG,UAAU,UAAU,MAAM,OAAO;AACjH,UAAI,OAAO,KAAK,YAAY,cAAc,cAAc,MAAM,OAAOA,KAAI,WAAW,QAAQ;AAC5F,UAAK,WAAW,KAAK,SAAS,QAAQ,YAAc,aAAa,KAAK,SAAS,QAAQ,aAAa,KAAK,SAAS,QAAQ,aAAc;AACtI,aAAK,iBAAiB,KAAK,OAAO,0FAA0F;AAAA,MAC9H;AACA,aAAO,KAAK,YAAY,MAAM,cAAc,cAAc,SAAS,OAAO;AAAA,IAC5E;AAAA,EACF;AACA,SAAO;AACT;AAEA,KAAK,cAAc,SAAS,UAAU,UAAU,MAAM,OAAOA,KAAI,SAAS;AACxE,MAAI,MAAM,SAAS,qBAAqB;AAAE,SAAK,MAAM,MAAM,OAAO,+DAA+D;AAAA,EAAG;AACpI,MAAI,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,OAAK,OAAO;AACZ,OAAK,WAAWA;AAChB,OAAK,QAAQ;AACb,SAAO,KAAK,WAAW,MAAM,UAAU,sBAAsB,kBAAkB;AACjF;AAIA,KAAK,kBAAkB,SAAS,wBAAwB,UAAU,QAAQ,SAAS;AACjF,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK,UAAU;AACrD,MAAI,KAAK,aAAa,OAAO,KAAK,KAAK,UAAU;AAC/C,WAAO,KAAK,WAAW,OAAO;AAC9B,eAAW;AAAA,EACb,WAAW,KAAK,KAAK,QAAQ;AAC3B,QAAI,OAAO,KAAK,UAAS,GAAIwB,UAAS,KAAK,SAAS,QAAQ;AAC5D,SAAK,WAAW,KAAK;AACrB,SAAK,SAAS;AACd,SAAK,KAAI;AACT,SAAK,WAAW,KAAK,gBAAgB,MAAM,MAAMA,SAAQ,OAAO;AAChE,SAAK,sBAAsB,wBAAwB,IAAI;AACvD,QAAIA,SAAQ;AAAE,WAAK,gBAAgB,KAAK,QAAQ;AAAA,IAAG,WAC1C,KAAK,UAAU,KAAK,aAAa,YAAY,sBAAsB,KAAK,QAAQ,GACvF;AAAE,WAAK,iBAAiB,KAAK,OAAO,wCAAwC;AAAA,IAAG,WACxE,KAAK,aAAa,YAAY,qBAAqB,KAAK,QAAQ,GACvE;AAAE,WAAK,iBAAiB,KAAK,OAAO,mCAAmC;AAAA,IAAG,OACvE;AAAE,iBAAW;AAAA,IAAM;AACxB,WAAO,KAAK,WAAW,MAAMA,UAAS,qBAAqB,iBAAiB;AAAA,EAC9E,WAAW,CAAC,YAAY,KAAK,SAAS,QAAQ,WAAW;AACvD,SAAK,WAAW,KAAK,iBAAiB,WAAW,MAAM,KAAK,QAAQ,oBAAoB;AAAE,WAAK,WAAU;AAAA,IAAI;AAC7G,WAAO,KAAK,kBAAiB;AAE7B,QAAI,KAAK,SAAS,QAAQ,KAAK;AAAE,WAAK,WAAU;AAAA,IAAI;AAAA,EACtD,OAAO;AACL,WAAO,KAAK,oBAAoB,wBAAwB,OAAO;AAC/D,QAAI,KAAK,sBAAsB,sBAAsB,GAAG;AAAE,aAAO;AAAA,IAAK;AACtE,WAAO,KAAK,KAAK,WAAW,CAAC,KAAK,mBAAkB,GAAI;AACtD,UAAI,SAAS,KAAK,YAAY,UAAU,QAAQ;AAChD,aAAO,WAAW,KAAK;AACvB,aAAO,SAAS;AAChB,aAAO,WAAW;AAClB,WAAK,gBAAgB,IAAI;AACzB,WAAK,KAAI;AACT,aAAO,KAAK,WAAW,QAAQ,kBAAkB;AAAA,IACnD;AAAA,EACF;AAEA,MAAI,CAAC,UAAU,KAAK,IAAI,QAAQ,QAAQ,GAAG;AACzC,QAAI,UACF;AAAE,WAAK,WAAW,KAAK,YAAY;AAAA,IAAG,OAEtC;AAAE,aAAO,KAAK,YAAY,UAAU,UAAU,MAAM,KAAK,gBAAgB,MAAM,OAAO,OAAO,OAAO,GAAG,MAAM,KAAK;AAAA,IAAE;AAAA,EACxH,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,SAAS,sBAAsB,MAAM;AACnC,SACE,KAAK,SAAS,gBACd,KAAK,SAAS,6BAA6B,sBAAsB,KAAK,UAAU;AAEpF;AAEA,SAAS,qBAAqB,MAAM;AAClC,SACE,KAAK,SAAS,sBAAsB,KAAK,SAAS,SAAS,uBAC3D,KAAK,SAAS,qBAAqB,qBAAqB,KAAK,UAAU,KACvE,KAAK,SAAS,6BAA6B,qBAAqB,KAAK,UAAU;AAEnF;AAIA,KAAK,sBAAsB,SAAS,wBAAwB,SAAS;AACnE,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,MAAI,OAAO,KAAK,cAAc,wBAAwB,OAAO;AAC7D,MAAI,KAAK,SAAS,6BAA6B,KAAK,MAAM,MAAM,KAAK,cAAc,KAAK,UAAU,MAAM,KACtG;AAAE,WAAO;AAAA,EAAK;AAChB,MAAI1O,UAAS,KAAK,gBAAgB,MAAM,UAAU,UAAU,OAAO,OAAO;AAC1E,MAAI,0BAA0BA,QAAO,SAAS,oBAAoB;AAChE,QAAI,uBAAuB,uBAAuBA,QAAO,OAAO;AAAE,6BAAuB,sBAAsB;AAAA,IAAI;AACnH,QAAI,uBAAuB,qBAAqBA,QAAO,OAAO;AAAE,6BAAuB,oBAAoB;AAAA,IAAI;AAC/G,QAAI,uBAAuB,iBAAiBA,QAAO,OAAO;AAAE,6BAAuB,gBAAgB;AAAA,IAAI;AAAA,EACzG;AACA,SAAOA;AACT;AAEA,KAAK,kBAAkB,SAAS,MAAM,UAAU,UAAU,SAAS,SAAS;AAC1E,MAAI,kBAAkB,KAAK,QAAQ,eAAe,KAAK,KAAK,SAAS,gBAAgB,KAAK,SAAS,WAC/F,KAAK,eAAe,KAAK,OAAO,CAAC,KAAK,mBAAkB,KAAM,KAAK,MAAM,KAAK,UAAU,KACxF,KAAK,qBAAqB,KAAK;AACnC,MAAI,kBAAkB;AAEtB,SAAO,MAAM;AACX,QAAI,UAAU,KAAK,eAAe,MAAM,UAAU,UAAU,SAAS,iBAAiB,iBAAiB,OAAO;AAE9G,QAAI,QAAQ,UAAU;AAAE,wBAAkB;AAAA,IAAM;AAChD,QAAI,YAAY,QAAQ,QAAQ,SAAS,2BAA2B;AAClE,UAAI,iBAAiB;AACnB,YAAI,YAAY,KAAK,YAAY,UAAU,QAAQ;AACnD,kBAAU,aAAa;AACvB,kBAAU,KAAK,WAAW,WAAW,iBAAiB;AAAA,MACxD;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAEA,KAAK,wBAAwB,WAAW;AACtC,SAAO,CAAC,KAAK,mBAAkB,KAAM,KAAK,IAAI,QAAQ,KAAK;AAC7D;AAEA,KAAK,2BAA2B,SAAS,UAAU,UAAU,UAAU,SAAS;AAC9E,SAAO,KAAK,qBAAqB,KAAK,YAAY,UAAU,QAAQ,GAAG,UAAU,MAAM,OAAO;AAChG;AAEA,KAAK,iBAAiB,SAAS,MAAM,UAAU,UAAU,SAAS,iBAAiB,iBAAiB,SAAS;AAC3G,MAAI,oBAAoB,KAAK,QAAQ,eAAe;AACpD,MAAI,WAAW,qBAAqB,KAAK,IAAI,QAAQ,WAAW;AAChE,MAAI,WAAW,UAAU;AAAE,SAAK,MAAM,KAAK,cAAc,kEAAkE;AAAA,EAAG;AAE9H,MAAI,WAAW,KAAK,IAAI,QAAQ,QAAQ;AACxC,MAAI,YAAa,YAAY,KAAK,SAAS,QAAQ,UAAU,KAAK,SAAS,QAAQ,aAAc,KAAK,IAAI,QAAQ,GAAG,GAAG;AACtH,QAAI,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,SAAK,SAAS;AACd,QAAI,UAAU;AACZ,WAAK,WAAW,KAAK,gBAAe;AACpC,WAAK,OAAO,QAAQ,QAAQ;AAAA,IAC9B,WAAW,KAAK,SAAS,QAAQ,aAAa,KAAK,SAAS,SAAS;AACnE,WAAK,WAAW,KAAK,kBAAiB;AAAA,IACxC,OAAO;AACL,WAAK,WAAW,KAAK,WAAW,KAAK,QAAQ,kBAAkB,OAAO;AAAA,IACxE;AACA,SAAK,WAAW,CAAC,CAAC;AAClB,QAAI,mBAAmB;AACrB,WAAK,WAAW;AAAA,IAClB;AACA,WAAO,KAAK,WAAW,MAAM,kBAAkB;AAAA,EACjD,WAAW,CAAC,WAAW,KAAK,IAAI,QAAQ,MAAM,GAAG;AAC/C,QAAI,yBAAyB,IAAI,uBAAqB,cAAc,KAAK,UAAU,cAAc,KAAK,UAAU,mBAAmB,KAAK;AACxI,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,gBAAgB;AACrB,QAAI,WAAW,KAAK,cAAc,QAAQ,QAAQ,KAAK,QAAQ,eAAe,GAAG,OAAO,sBAAsB;AAC9G,QAAI,mBAAmB,CAAC,YAAY,KAAK,sBAAqB,GAAI;AAChE,WAAK,mBAAmB,wBAAwB,KAAK;AACrD,WAAK,+BAA8B;AACnC,UAAI,KAAK,gBAAgB,GACvB;AAAE,aAAK,MAAM,KAAK,eAAe,2DAA2D;AAAA,MAAG;AACjG,WAAK,WAAW;AAChB,WAAK,WAAW;AAChB,WAAK,gBAAgB;AACrB,aAAO,KAAK,yBAAyB,UAAU,UAAU,UAAU,OAAO;AAAA,IAC5E;AACA,SAAK,sBAAsB,wBAAwB,IAAI;AACvD,SAAK,WAAW,eAAe,KAAK;AACpC,SAAK,WAAW,eAAe,KAAK;AACpC,SAAK,gBAAgB,oBAAoB,KAAK;AAC9C,QAAI,SAAS,KAAK,YAAY,UAAU,QAAQ;AAChD,WAAO,SAAS;AAChB,WAAO,YAAY;AACnB,QAAI,mBAAmB;AACrB,aAAO,WAAW;AAAA,IACpB;AACA,WAAO,KAAK,WAAW,QAAQ,gBAAgB;AAAA,EACjD,WAAW,KAAK,SAAS,QAAQ,WAAW;AAC1C,QAAI,YAAY,iBAAiB;AAC/B,WAAK,MAAM,KAAK,OAAO,2EAA2E;AAAA,IACpG;AACA,QAAI,SAAS,KAAK,YAAY,UAAU,QAAQ;AAChD,WAAO,MAAM;AACb,WAAO,QAAQ,KAAK,cAAc,EAAC,UAAU,KAAI,CAAC;AAClD,WAAO,KAAK,WAAW,QAAQ,0BAA0B;AAAA,EAC3D;AACA,SAAO;AACT;AAOA,KAAK,gBAAgB,SAAS,wBAAwB,SAAS,QAAQ;AAGrE,MAAI,KAAK,SAAS,QAAQ,OAAO;AAAE,SAAK,WAAU;AAAA,EAAI;AAEtD,MAAI,MAAM,aAAa,KAAK,qBAAqB,KAAK;AACtD,UAAQ,KAAK,MAAI;AAAA,IACjB,KAAK,QAAQ;AACX,UAAI,CAAC,KAAK,YACR;AAAE,aAAK,MAAM,KAAK,OAAO,kCAAkC;AAAA,MAAG;AAChE,aAAO,KAAK,UAAS;AACrB,WAAK,KAAI;AACT,UAAI,KAAK,SAAS,QAAQ,UAAU,CAAC,KAAK,kBACxC;AAAE,aAAK,MAAM,KAAK,OAAO,gDAAgD;AAAA,MAAG;AAO9E,UAAI,KAAK,SAAS,QAAQ,OAAO,KAAK,SAAS,QAAQ,YAAY,KAAK,SAAS,QAAQ,QACvF;AAAE,aAAK,WAAU;AAAA,MAAI;AACvB,aAAO,KAAK,WAAW,MAAM,OAAO;AAAA,IAEtC,KAAK,QAAQ;AACX,aAAO,KAAK,UAAS;AACrB,WAAK,KAAI;AACT,aAAO,KAAK,WAAW,MAAM,gBAAgB;AAAA,IAE/C,KAAK,QAAQ;AACX,UAAI,WAAW,KAAK,OAAO,WAAW,KAAK,UAAU,cAAc,KAAK;AACxE,UAAI,KAAK,KAAK,WAAW,KAAK;AAC9B,UAAI,KAAK,QAAQ,eAAe,KAAK,CAAC,eAAe,GAAG,SAAS,WAAW,CAAC,KAAK,wBAAwB,KAAK,IAAI,QAAQ,SAAS,GAAG;AACrI,aAAK,gBAAgB,MAAM,MAAM;AACjC,eAAO,KAAK,cAAc,KAAK,YAAY,UAAU,QAAQ,GAAG,GAAG,OAAO,MAAM,OAAO;AAAA,MACzF;AACA,UAAI,cAAc,CAAC,KAAK,sBAAsB;AAC5C,YAAI,KAAK,IAAI,QAAQ,KAAK,GACxB;AAAE,iBAAO,KAAK,qBAAqB,KAAK,YAAY,UAAU,QAAQ,GAAG,CAAC,EAAE,GAAG,OAAO,OAAO;AAAA,QAAE;AACjG,YAAI,KAAK,QAAQ,eAAe,KAAK,GAAG,SAAS,WAAW,KAAK,SAAS,QAAQ,QAAQ,CAAC,gBACtF,CAAC,KAAK,4BAA4B,KAAK,UAAU,QAAQ,KAAK,cAAc;AAC/E,eAAK,KAAK,WAAW,KAAK;AAC1B,cAAI,KAAK,wBAAwB,CAAC,KAAK,IAAI,QAAQ,KAAK,GACtD;AAAE,iBAAK,WAAU;AAAA,UAAI;AACvB,iBAAO,KAAK,qBAAqB,KAAK,YAAY,UAAU,QAAQ,GAAG,CAAC,EAAE,GAAG,MAAM,OAAO;AAAA,QAC5F;AAAA,MACF;AACA,aAAO;AAAA,IAET,KAAK,QAAQ;AACX,UAAIG,SAAQ,KAAK;AACjB,aAAO,KAAK,aAAaA,OAAM,KAAK;AACpC,WAAK,QAAQ,EAAC,SAASA,OAAM,SAAS,OAAOA,OAAM,MAAK;AACxD,aAAO;AAAA,IAET,KAAK,QAAQ;AAAA,IAAK,KAAK,QAAQ;AAC7B,aAAO,KAAK,aAAa,KAAK,KAAK;AAAA,IAErC,KAAK,QAAQ;AAAA,IAAO,KAAK,QAAQ;AAAA,IAAO,KAAK,QAAQ;AACnD,aAAO,KAAK,UAAS;AACrB,WAAK,QAAQ,KAAK,SAAS,QAAQ,QAAQ,OAAO,KAAK,SAAS,QAAQ;AACxE,WAAK,MAAM,KAAK,KAAK;AACrB,WAAK,KAAI;AACT,aAAO,KAAK,WAAW,MAAM,SAAS;AAAA,IAExC,KAAK,QAAQ;AACX,UAAI,QAAQ,KAAK,OAAO,OAAO,KAAK,mCAAmC,YAAY,OAAO;AAC1F,UAAI,wBAAwB;AAC1B,YAAI,uBAAuB,sBAAsB,KAAK,CAAC,KAAK,qBAAqB,IAAI,GACnF;AAAE,iCAAuB,sBAAsB;AAAA,QAAO;AACxD,YAAI,uBAAuB,oBAAoB,GAC7C;AAAE,iCAAuB,oBAAoB;AAAA,QAAO;AAAA,MACxD;AACA,aAAO;AAAA,IAET,KAAK,QAAQ;AACX,aAAO,KAAK,UAAS;AACrB,WAAK,KAAI;AACT,WAAK,WAAW,KAAK,cAAc,QAAQ,UAAU,MAAM,MAAM,sBAAsB;AACvF,aAAO,KAAK,WAAW,MAAM,iBAAiB;AAAA,IAEhD,KAAK,QAAQ;AACX,WAAK,gBAAgB,MAAM,MAAM;AACjC,aAAO,KAAK,SAAS,OAAO,sBAAsB;AAAA,IAEpD,KAAK,QAAQ;AACX,aAAO,KAAK,UAAS;AACrB,WAAK,KAAI;AACT,aAAO,KAAK,cAAc,MAAM,CAAC;AAAA,IAEnC,KAAK,QAAQ;AACX,aAAO,KAAK,WAAW,KAAK,UAAS,GAAI,KAAK;AAAA,IAEhD,KAAK,QAAQ;AACX,aAAO,KAAK,SAAQ;AAAA,IAEtB,KAAK,QAAQ;AACX,aAAO,KAAK,cAAa;AAAA,IAE3B,KAAK,QAAQ;AACX,UAAI,KAAK,QAAQ,eAAe,IAAI;AAClC,eAAO,KAAK,gBAAgB,MAAM;AAAA,MACpC,OAAO;AACL,eAAO,KAAK,WAAU;AAAA,MACxB;AAAA,IAEF;AACE,aAAO,KAAK,qBAAoB;AAAA,EACpC;AACA;AAEA,KAAK,uBAAuB,WAAW;AACrC,OAAK,WAAU;AACjB;AAEA,KAAK,kBAAkB,SAAS,QAAQ;AACtC,MAAI,OAAO,KAAK,UAAS;AAIzB,MAAI,KAAK,aAAa;AAAE,SAAK,iBAAiB,KAAK,OAAO,mCAAmC;AAAA,EAAG;AAChG,OAAK,KAAI;AAET,MAAI,KAAK,SAAS,QAAQ,UAAU,CAAC,QAAQ;AAC3C,WAAO,KAAK,mBAAmB,IAAI;AAAA,EACrC,WAAW,KAAK,SAAS,QAAQ,KAAK;AACpC,QAAI,OAAO,KAAK,YAAY,KAAK,OAAO,KAAK,OAAO,KAAK,IAAI,KAAK;AAClE,SAAK,OAAO;AACZ,SAAK,OAAO,KAAK,WAAW,MAAM,YAAY;AAC9C,WAAO,KAAK,gBAAgB,IAAI;AAAA,EAClC,OAAO;AACL,SAAK,WAAU;AAAA,EACjB;AACF;AAEA,KAAK,qBAAqB,SAAS,MAAM;AACvC,OAAK,KAAI;AAGT,OAAK,SAAS,KAAK,iBAAgB;AAEnC,MAAI,KAAK,QAAQ,eAAe,IAAI;AAClC,QAAI,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAC7B,WAAK,OAAO,QAAQ,KAAK;AACzB,UAAI,CAAC,KAAK,mBAAmB,QAAQ,MAAM,GAAG;AAC5C,aAAK,UAAU,KAAK,iBAAgB;AACpC,YAAI,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAC7B,eAAK,OAAO,QAAQ,KAAK;AACzB,cAAI,CAAC,KAAK,mBAAmB,QAAQ,MAAM,GAAG;AAC5C,iBAAK,WAAU;AAAA,UACjB;AAAA,QACF;AAAA,MACF,OAAO;AACL,aAAK,UAAU;AAAA,MACjB;AAAA,IACF,OAAO;AACL,WAAK,UAAU;AAAA,IACjB;AAAA,EACF,OAAO;AAEL,QAAI,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAC7B,UAAI,WAAW,KAAK;AACpB,UAAI,KAAK,IAAI,QAAQ,KAAK,KAAK,KAAK,IAAI,QAAQ,MAAM,GAAG;AACvD,aAAK,iBAAiB,UAAU,2CAA2C;AAAA,MAC7E,OAAO;AACL,aAAK,WAAW,QAAQ;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AAEA,SAAO,KAAK,WAAW,MAAM,kBAAkB;AACjD;AAEA,KAAK,kBAAkB,SAAS,MAAM;AACpC,OAAK,KAAI;AAET,MAAI,cAAc,KAAK;AACvB,OAAK,WAAW,KAAK,WAAW,IAAI;AAEpC,MAAI,KAAK,SAAS,SAAS,QACzB;AAAE,SAAK,iBAAiB,KAAK,SAAS,OAAO,0DAA0D;AAAA,EAAG;AAC5G,MAAI,aACF;AAAE,SAAK,iBAAiB,KAAK,OAAO,mDAAmD;AAAA,EAAG;AAC5F,MAAI,KAAK,QAAQ,eAAe,YAAY,CAAC,KAAK,QAAQ,6BACxD;AAAE,SAAK,iBAAiB,KAAK,OAAO,2CAA2C;AAAA,EAAG;AAEpF,SAAO,KAAK,WAAW,MAAM,cAAc;AAC7C;AAEA,KAAK,eAAe,SAASA,QAAO;AAClC,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,QAAQA;AACb,OAAK,MAAM,KAAK,MAAM,MAAM,KAAK,OAAO,KAAK,GAAG;AAChD,MAAI,KAAK,IAAI,WAAW,KAAK,IAAI,SAAS,CAAC,MAAM,KAC/C;AAAE,SAAK,SAAS,KAAK,SAAS,OAAO,KAAK,MAAM,SAAQ,IAAK,KAAK,IAAI,MAAM,GAAG,EAAE,EAAE,QAAQ,MAAM,EAAE;AAAA,EAAG;AACxG,OAAK,KAAI;AACT,SAAO,KAAK,WAAW,MAAM,SAAS;AACxC;AAEA,KAAK,uBAAuB,WAAW;AACrC,OAAK,OAAO,QAAQ,MAAM;AAC1B,MAAI,MAAM,KAAK,gBAAe;AAC9B,OAAK,OAAO,QAAQ,MAAM;AAC1B,SAAO;AACT;AAEA,KAAK,mBAAmB,SAAS,UAAU;AACzC,SAAO,CAAC,KAAK,mBAAkB;AACjC;AAEA,KAAK,qCAAqC,SAAS,YAAY,SAAS;AACtE,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK,UAAU,KAAK,qBAAqB,KAAK,QAAQ,eAAe;AAC3G,MAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,SAAK,KAAI;AAET,QAAI,gBAAgB,KAAK,OAAO,gBAAgB,KAAK;AACrD,QAAI,WAAW,CAAA,GAAI,QAAQ,MAAM,cAAc;AAC/C,QAAI,yBAAyB,IAAI,uBAAqB,cAAc,KAAK,UAAU,cAAc,KAAK,UAAU;AAChH,SAAK,WAAW;AAChB,SAAK,WAAW;AAEhB,WAAO,KAAK,SAAS,QAAQ,QAAQ;AACnC,cAAQ,QAAQ,QAAQ,KAAK,OAAO,QAAQ,KAAK;AACjD,UAAI,sBAAsB,KAAK,mBAAmB,QAAQ,QAAQ,IAAI,GAAG;AACvE,sBAAc;AACd;AAAA,MACF,WAAW,KAAK,SAAS,QAAQ,UAAU;AACzC,sBAAc,KAAK;AACnB,iBAAS,KAAK,KAAK,eAAe,KAAK,iBAAgB,CAAE,CAAC;AAC1D,YAAI,KAAK,SAAS,QAAQ,OAAO;AAC/B,eAAK;AAAA,YACH,KAAK;AAAA,YACL;AAAA,UACZ;AAAA,QACQ;AACA;AAAA,MACF,OAAO;AACL,iBAAS,KAAK,KAAK,iBAAiB,OAAO,wBAAwB,KAAK,cAAc,CAAC;AAAA,MACzF;AAAA,IACF;AACA,QAAI,cAAc,KAAK,YAAY,cAAc,KAAK;AACtD,SAAK,OAAO,QAAQ,MAAM;AAE1B,QAAI,cAAc,KAAK,iBAAiB,QAAQ,KAAK,KAAK,IAAI,QAAQ,KAAK,GAAG;AAC5E,WAAK,mBAAmB,wBAAwB,KAAK;AACrD,WAAK,+BAA8B;AACnC,WAAK,WAAW;AAChB,WAAK,WAAW;AAChB,aAAO,KAAK,oBAAoB,UAAU,UAAU,UAAU,OAAO;AAAA,IACvE;AAEA,QAAI,CAAC,SAAS,UAAU,aAAa;AAAE,WAAK,WAAW,KAAK,YAAY;AAAA,IAAG;AAC3E,QAAI,aAAa;AAAE,WAAK,WAAW,WAAW;AAAA,IAAG;AACjD,SAAK,sBAAsB,wBAAwB,IAAI;AACvD,SAAK,WAAW,eAAe,KAAK;AACpC,SAAK,WAAW,eAAe,KAAK;AAEpC,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,KAAK,YAAY,eAAe,aAAa;AACnD,UAAI,cAAc;AAClB,WAAK,aAAa,KAAK,sBAAsB,aAAa,WAAW;AAAA,IACvE,OAAO;AACL,YAAM,SAAS,CAAC;AAAA,IAClB;AAAA,EACF,OAAO;AACL,UAAM,KAAK,qBAAoB;AAAA,EACjC;AAEA,MAAI,KAAK,QAAQ,gBAAgB;AAC/B,QAAI,MAAM,KAAK,YAAY,UAAU,QAAQ;AAC7C,QAAI,aAAa;AACjB,WAAO,KAAK,WAAW,KAAK,yBAAyB;AAAA,EACvD,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,KAAK,iBAAiB,SAAS,MAAM;AACnC,SAAO;AACT;AAEA,KAAK,sBAAsB,SAAS,UAAU,UAAU,UAAU,SAAS;AACzE,SAAO,KAAK,qBAAqB,KAAK,YAAY,UAAU,QAAQ,GAAG,UAAU,OAAO,OAAO;AACjG;AAQA,IAAI,QAAQ,CAAA;AAEZ,KAAK,WAAW,WAAW;AACzB,MAAI,KAAK,aAAa;AAAE,SAAK,iBAAiB,KAAK,OAAO,gCAAgC;AAAA,EAAG;AAC7F,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AACT,MAAI,KAAK,QAAQ,eAAe,KAAK,KAAK,SAAS,QAAQ,KAAK;AAC9D,QAAI,OAAO,KAAK,YAAY,KAAK,OAAO,KAAK,OAAO,KAAK,IAAI,KAAK;AAClE,SAAK,OAAO;AACZ,SAAK,OAAO,KAAK,WAAW,MAAM,YAAY;AAC9C,SAAK,KAAI;AACT,QAAI,cAAc,KAAK;AACvB,SAAK,WAAW,KAAK,WAAW,IAAI;AACpC,QAAI,KAAK,SAAS,SAAS,UACzB;AAAE,WAAK,iBAAiB,KAAK,SAAS,OAAO,sDAAsD;AAAA,IAAG;AACxG,QAAI,aACF;AAAE,WAAK,iBAAiB,KAAK,OAAO,kDAAkD;AAAA,IAAG;AAC3F,QAAI,CAAC,KAAK,mBACR;AAAE,WAAK,iBAAiB,KAAK,OAAO,mEAAmE;AAAA,IAAG;AAC5G,WAAO,KAAK,WAAW,MAAM,cAAc;AAAA,EAC7C;AACA,MAAI,WAAW,KAAK,OAAO,WAAW,KAAK;AAC3C,OAAK,SAAS,KAAK,gBAAgB,KAAK,cAAc,MAAM,OAAO,IAAI,GAAG,UAAU,UAAU,MAAM,KAAK;AACzG,MAAI,KAAK,IAAI,QAAQ,MAAM,GAAG;AAAE,SAAK,YAAY,KAAK,cAAc,QAAQ,QAAQ,KAAK,QAAQ,eAAe,GAAG,KAAK;AAAA,EAAG,OACtH;AAAE,SAAK,YAAY;AAAA,EAAO;AAC/B,SAAO,KAAK,WAAW,MAAM,eAAe;AAC9C;AAIA,KAAK,uBAAuB,SAAS8N,MAAK;AACxC,MAAI,WAAWA,KAAI;AAEnB,MAAI,OAAO,KAAK,UAAS;AACzB,MAAI,KAAK,SAAS,QAAQ,iBAAiB;AACzC,QAAI,CAAC,UAAU;AACb,WAAK,iBAAiB,KAAK,OAAO,kDAAkD;AAAA,IACtF;AACA,SAAK,QAAQ;AAAA,MACX,KAAK,KAAK,MAAM,QAAQ,UAAU,IAAI;AAAA,MACtC,QAAQ;AAAA,IACd;AAAA,EACE,OAAO;AACL,SAAK,QAAQ;AAAA,MACX,KAAK,KAAK,MAAM,MAAM,KAAK,OAAO,KAAK,GAAG,EAAE,QAAQ,UAAU,IAAI;AAAA,MAClE,QAAQ,KAAK;AAAA,IACnB;AAAA,EACE;AACA,OAAK,KAAI;AACT,OAAK,OAAO,KAAK,SAAS,QAAQ;AAClC,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,gBAAgB,SAASA,MAAK;AACjC,MAAKA,SAAQ,OAAS,CAAAA,OAAM,CAAA;AAC5B,MAAI,WAAWA,KAAI;AAAU,MAAK,aAAa,OAAS,YAAW;AAEnE,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AACT,OAAK,cAAc,CAAA;AACnB,MAAI,SAAS,KAAK,qBAAqB,EAAC,SAAkB,CAAC;AAC3D,OAAK,SAAS,CAAC,MAAM;AACrB,SAAO,CAAC,OAAO,MAAM;AACnB,QAAI,KAAK,SAAS,QAAQ,KAAK;AAAE,WAAK,MAAM,KAAK,KAAK,+BAA+B;AAAA,IAAG;AACxF,SAAK,OAAO,QAAQ,YAAY;AAChC,SAAK,YAAY,KAAK,KAAK,gBAAe,CAAE;AAC5C,SAAK,OAAO,QAAQ,MAAM;AAC1B,SAAK,OAAO,KAAK,SAAS,KAAK,qBAAqB,EAAC,SAAkB,CAAC,CAAC;AAAA,EAC3E;AACA,OAAK,KAAI;AACT,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,cAAc,SAAS,MAAM;AAChC,SAAO,CAAC,KAAK,YAAY,KAAK,IAAI,SAAS,gBAAgB,KAAK,IAAI,SAAS,YAC1E,KAAK,SAAS,QAAQ,QAAQ,KAAK,SAAS,QAAQ,OAAO,KAAK,SAAS,QAAQ,UAAU,KAAK,SAAS,QAAQ,YAAY,KAAK,KAAK,WAAY,KAAK,QAAQ,eAAe,KAAK,KAAK,SAAS,QAAQ,SAC3M,CAAC,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC;AACjE;AAIA,KAAK,WAAW,SAAS,WAAW,wBAAwB;AAC1D,MAAI,OAAO,KAAK,UAAS,GAAI,QAAQ,MAAM,WAAW,CAAA;AACtD,OAAK,aAAa,CAAA;AAClB,OAAK,KAAI;AACT,SAAO,CAAC,KAAK,IAAI,QAAQ,MAAM,GAAG;AAChC,QAAI,CAAC,OAAO;AACV,WAAK,OAAO,QAAQ,KAAK;AACzB,UAAI,KAAK,QAAQ,eAAe,KAAK,KAAK,mBAAmB,QAAQ,MAAM,GAAG;AAAE;AAAA,MAAM;AAAA,IACxF,OAAO;AAAE,cAAQ;AAAA,IAAO;AAExB,QAAI,OAAO,KAAK,cAAc,WAAW,sBAAsB;AAC/D,QAAI,CAAC,WAAW;AAAE,WAAK,eAAe,MAAM,UAAU,sBAAsB;AAAA,IAAG;AAC/E,SAAK,WAAW,KAAK,IAAI;AAAA,EAC3B;AACA,SAAO,KAAK,WAAW,MAAM,YAAY,kBAAkB,kBAAkB;AAC/E;AAEA,KAAK,gBAAgB,SAAS,WAAW,wBAAwB;AAC/D,MAAI,OAAO,KAAK,UAAS,GAAI,aAAa,SAAS,UAAU;AAC7D,MAAI,KAAK,QAAQ,eAAe,KAAK,KAAK,IAAI,QAAQ,QAAQ,GAAG;AAC/D,QAAI,WAAW;AACb,WAAK,WAAW,KAAK,WAAW,KAAK;AACrC,UAAI,KAAK,SAAS,QAAQ,OAAO;AAC/B,aAAK,iBAAiB,KAAK,OAAO,+CAA+C;AAAA,MACnF;AACA,aAAO,KAAK,WAAW,MAAM,aAAa;AAAA,IAC5C;AAEA,SAAK,WAAW,KAAK,iBAAiB,OAAO,sBAAsB;AAEnE,QAAI,KAAK,SAAS,QAAQ,SAAS,0BAA0B,uBAAuB,gBAAgB,GAAG;AACrG,6BAAuB,gBAAgB,KAAK;AAAA,IAC9C;AAEA,WAAO,KAAK,WAAW,MAAM,eAAe;AAAA,EAC9C;AACA,MAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,QAAI,aAAa,wBAAwB;AACvC,iBAAW,KAAK;AAChB,iBAAW,KAAK;AAAA,IAClB;AACA,QAAI,CAAC,WACH;AAAE,oBAAc,KAAK,IAAI,QAAQ,IAAI;AAAA,IAAG;AAAA,EAC5C;AACA,MAAI,cAAc,KAAK;AACvB,OAAK,kBAAkB,IAAI;AAC3B,MAAI,CAAC,aAAa,CAAC,eAAe,KAAK,QAAQ,eAAe,KAAK,CAAC,eAAe,KAAK,YAAY,IAAI,GAAG;AACzG,cAAU;AACV,kBAAc,KAAK,QAAQ,eAAe,KAAK,KAAK,IAAI,QAAQ,IAAI;AACpE,SAAK,kBAAkB,IAAI;AAAA,EAC7B,OAAO;AACL,cAAU;AAAA,EACZ;AACA,OAAK,mBAAmB,MAAM,WAAW,aAAa,SAAS,UAAU,UAAU,wBAAwB,WAAW;AACtH,SAAO,KAAK,WAAW,MAAM,UAAU;AACzC;AAEA,KAAK,oBAAoB,SAAS,MAAM;AACtC,MAAI,OAAO,KAAK,IAAI;AACpB,OAAK,kBAAkB,IAAI;AAC3B,OAAK,QAAQ,KAAK,YAAY,KAAK;AACnC,OAAK,OAAO;AACZ,MAAI,aAAa,KAAK,SAAS,QAAQ,IAAI;AAC3C,MAAI,KAAK,MAAM,OAAO,WAAW,YAAY;AAC3C,QAAI,QAAQ,KAAK,MAAM;AACvB,QAAI,KAAK,SAAS,OAChB;AAAE,WAAK,iBAAiB,OAAO,8BAA8B;AAAA,IAAG,OAEhE;AAAE,WAAK,iBAAiB,OAAO,sCAAsC;AAAA,IAAG;AAAA,EAC5E,OAAO;AACL,QAAI,KAAK,SAAS,SAAS,KAAK,MAAM,OAAO,CAAC,EAAE,SAAS,eACvD;AAAE,WAAK,iBAAiB,KAAK,MAAM,OAAO,CAAC,EAAE,OAAO,+BAA+B;AAAA,IAAG;AAAA,EAC1F;AACF;AAEA,KAAK,qBAAqB,SAAS,MAAM,WAAW,aAAa,SAAS,UAAU,UAAU,wBAAwB,aAAa;AACjI,OAAK,eAAe,YAAY,KAAK,SAAS,QAAQ,OACpD;AAAE,SAAK,WAAU;AAAA,EAAI;AAEvB,MAAI,KAAK,IAAI,QAAQ,KAAK,GAAG;AAC3B,SAAK,QAAQ,YAAY,KAAK,kBAAkB,KAAK,OAAO,KAAK,QAAQ,IAAI,KAAK,iBAAiB,OAAO,sBAAsB;AAChI,SAAK,OAAO;AAAA,EACd,WAAW,KAAK,QAAQ,eAAe,KAAK,KAAK,SAAS,QAAQ,QAAQ;AACxE,QAAI,WAAW;AAAE,WAAK,WAAU;AAAA,IAAI;AACpC,SAAK,SAAS;AACd,SAAK,QAAQ,KAAK,YAAY,aAAa,OAAO;AAClD,SAAK,OAAO;AAAA,EACd,WAAW,CAAC,aAAa,CAAC,eACf,KAAK,QAAQ,eAAe,KAAK,CAAC,KAAK,YAAY,KAAK,IAAI,SAAS,iBACpE,KAAK,IAAI,SAAS,SAAS,KAAK,IAAI,SAAS,WAC7C,KAAK,SAAS,QAAQ,SAAS,KAAK,SAAS,QAAQ,UAAU,KAAK,SAAS,QAAQ,KAAK;AACpG,QAAI,eAAe,SAAS;AAAE,WAAK,WAAU;AAAA,IAAI;AACjD,SAAK,kBAAkB,IAAI;AAAA,EAC7B,WAAW,KAAK,QAAQ,eAAe,KAAK,CAAC,KAAK,YAAY,KAAK,IAAI,SAAS,cAAc;AAC5F,QAAI,eAAe,SAAS;AAAE,WAAK,WAAU;AAAA,IAAI;AACjD,SAAK,gBAAgB,KAAK,GAAG;AAC7B,QAAI,KAAK,IAAI,SAAS,WAAW,CAAC,KAAK,eACrC;AAAE,WAAK,gBAAgB;AAAA,IAAU;AACnC,QAAI,WAAW;AACb,WAAK,QAAQ,KAAK,kBAAkB,UAAU,UAAU,KAAK,SAAS,KAAK,GAAG,CAAC;AAAA,IACjF,WAAW,KAAK,SAAS,QAAQ,MAAM,wBAAwB;AAC7D,UAAI,uBAAuB,kBAAkB,GAC3C;AAAE,+BAAuB,kBAAkB,KAAK;AAAA,MAAO;AACzD,WAAK,QAAQ,KAAK,kBAAkB,UAAU,UAAU,KAAK,SAAS,KAAK,GAAG,CAAC;AAAA,IACjF,OAAO;AACL,WAAK,QAAQ,KAAK,SAAS,KAAK,GAAG;AAAA,IACrC;AACA,SAAK,OAAO;AACZ,SAAK,YAAY;AAAA,EACnB,OAAO;AAAE,SAAK,WAAU;AAAA,EAAI;AAC9B;AAEA,KAAK,oBAAoB,SAAS,MAAM;AACtC,MAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,QAAI,KAAK,IAAI,QAAQ,QAAQ,GAAG;AAC9B,WAAK,WAAW;AAChB,WAAK,MAAM,KAAK,iBAAgB;AAChC,WAAK,OAAO,QAAQ,QAAQ;AAC5B,aAAO,KAAK;AAAA,IACd,OAAO;AACL,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AACA,SAAO,KAAK,MAAM,KAAK,SAAS,QAAQ,OAAO,KAAK,SAAS,QAAQ,SAAS,KAAK,cAAa,IAAK,KAAK,WAAW,KAAK,QAAQ,kBAAkB,OAAO;AAC7J;AAIA,KAAK,eAAe,SAAS,MAAM;AACjC,OAAK,KAAK;AACV,MAAI,KAAK,QAAQ,eAAe,GAAG;AAAE,SAAK,YAAY,KAAK,aAAa;AAAA,EAAO;AAC/E,MAAI,KAAK,QAAQ,eAAe,GAAG;AAAE,SAAK,QAAQ;AAAA,EAAO;AAC3D;AAIA,KAAK,cAAc,SAAS,aAAa,SAAS,kBAAkB;AAClE,MAAI,OAAO,KAAK,UAAS,GAAI,cAAc,KAAK,UAAU,cAAc,KAAK,UAAU,mBAAmB,KAAK;AAE/G,OAAK,aAAa,IAAI;AACtB,MAAI,KAAK,QAAQ,eAAe,GAC9B;AAAE,SAAK,YAAY;AAAA,EAAa;AAClC,MAAI,KAAK,QAAQ,eAAe,GAC9B;AAAE,SAAK,QAAQ,CAAC,CAAC;AAAA,EAAS;AAE5B,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,gBAAgB;AACrB,OAAK,WAAW,cAAc,SAAS,KAAK,SAAS,IAAI,eAAe,mBAAmB,qBAAqB,EAAE;AAElH,OAAK,OAAO,QAAQ,MAAM;AAC1B,OAAK,SAAS,KAAK,iBAAiB,QAAQ,QAAQ,OAAO,KAAK,QAAQ,eAAe,CAAC;AACxF,OAAK,+BAA8B;AACnC,OAAK,kBAAkB,MAAM,OAAO,MAAM,KAAK;AAE/C,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,gBAAgB;AACrB,SAAO,KAAK,WAAW,MAAM,oBAAoB;AACnD;AAIA,KAAK,uBAAuB,SAAS,MAAM,QAAQ,SAAS,SAAS;AACnE,MAAI,cAAc,KAAK,UAAU,cAAc,KAAK,UAAU,mBAAmB,KAAK;AAEtF,OAAK,WAAW,cAAc,SAAS,KAAK,IAAI,WAAW;AAC3D,OAAK,aAAa,IAAI;AACtB,MAAI,KAAK,QAAQ,eAAe,GAAG;AAAE,SAAK,QAAQ,CAAC,CAAC;AAAA,EAAS;AAE7D,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,gBAAgB;AAErB,OAAK,SAAS,KAAK,iBAAiB,QAAQ,IAAI;AAChD,OAAK,kBAAkB,MAAM,MAAM,OAAO,OAAO;AAEjD,OAAK,WAAW;AAChB,OAAK,WAAW;AAChB,OAAK,gBAAgB;AACrB,SAAO,KAAK,WAAW,MAAM,yBAAyB;AACxD;AAIA,KAAK,oBAAoB,SAAS,MAAM,iBAAiB,UAAU,SAAS;AAC1E,MAAI,eAAe,mBAAmB,KAAK,SAAS,QAAQ;AAC5D,MAAI,YAAY,KAAK,QAAQ,YAAY;AAEzC,MAAI,cAAc;AAChB,SAAK,OAAO,KAAK,iBAAiB,OAAO;AACzC,SAAK,aAAa;AAClB,SAAK,YAAY,MAAM,KAAK;AAAA,EAC9B,OAAO;AACL,QAAI,YAAY,KAAK,QAAQ,eAAe,KAAK,CAAC,KAAK,kBAAkB,KAAK,MAAM;AACpF,QAAI,CAAC,aAAa,WAAW;AAC3B,kBAAY,KAAK,gBAAgB,KAAK,GAAG;AAIzC,UAAI,aAAa,WACf;AAAE,aAAK,iBAAiB,KAAK,OAAO,2EAA2E;AAAA,MAAG;AAAA,IACtH;AAGA,QAAI,YAAY,KAAK;AACrB,SAAK,SAAS,CAAA;AACd,QAAI,WAAW;AAAE,WAAK,SAAS;AAAA,IAAM;AAIrC,SAAK,YAAY,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,mBAAmB,CAAC,YAAY,KAAK,kBAAkB,KAAK,MAAM,CAAC;AAEvH,QAAI,KAAK,UAAU,KAAK,IAAI;AAAE,WAAK,gBAAgB,KAAK,IAAI,YAAY;AAAA,IAAG;AAC3E,SAAK,OAAO,KAAK,WAAW,OAAO,QAAW,aAAa,CAAC,SAAS;AACrE,SAAK,aAAa;AAClB,SAAK,uBAAuB,KAAK,KAAK,IAAI;AAC1C,SAAK,SAAS;AAAA,EAChB;AACA,OAAK,UAAS;AAChB;AAEA,KAAK,oBAAoB,SAAS,QAAQ;AACxC,WAAS,IAAI,GAAGzL,QAAO,QAAQ,IAAIA,MAAK,QAAQ,KAAK,GACnD;AACA,QAAI,QAAQA,MAAK,CAAC;AAElB,QAAI,MAAM,SAAS,cAAc;AAAE,aAAO;AAAA,IAC5C;AAAA,EAAE;AACF,SAAO;AACT;AAKA,KAAK,cAAc,SAAS,MAAM,iBAAiB;AACjD,MAAI,WAAW,uBAAO,OAAO,IAAI;AACjC,WAAS,IAAI,GAAGA,QAAO,KAAK,QAAQ,IAAIA,MAAK,QAAQ,KAAK,GACxD;AACA,QAAI,QAAQA,MAAK,CAAC;AAElB,SAAK,sBAAsB,OAAO,UAAU,kBAAkB,OAAO,QAAQ;AAAA,EAC/E;AACF;AAQA,KAAK,gBAAgB,SAAS,OAAO,oBAAoB,YAAY,wBAAwB;AAC3F,MAAI,OAAO,IAAI,QAAQ;AACvB,SAAO,CAAC,KAAK,IAAI,KAAK,GAAG;AACvB,QAAI,CAAC,OAAO;AACV,WAAK,OAAO,QAAQ,KAAK;AACzB,UAAI,sBAAsB,KAAK,mBAAmB,KAAK,GAAG;AAAE;AAAA,MAAM;AAAA,IACpE,OAAO;AAAE,cAAQ;AAAA,IAAO;AAExB,QAAI,MAAO;AACX,QAAI,cAAc,KAAK,SAAS,QAAQ,OACtC;AAAE,YAAM;AAAA,IAAM,WACP,KAAK,SAAS,QAAQ,UAAU;AACvC,YAAM,KAAK,YAAY,sBAAsB;AAC7C,UAAI,0BAA0B,KAAK,SAAS,QAAQ,SAAS,uBAAuB,gBAAgB,GAClG;AAAE,+BAAuB,gBAAgB,KAAK;AAAA,MAAO;AAAA,IACzD,OAAO;AACL,YAAM,KAAK,iBAAiB,OAAO,sBAAsB;AAAA,IAC3D;AACA,SAAK,KAAK,GAAG;AAAA,EACf;AACA,SAAO;AACT;AAEA,KAAK,kBAAkB,SAASyL,MAAK;AACnC,MAAI,QAAQA,KAAI;AAChB,MAAI,MAAMA,KAAI;AACd,MAAI1H,QAAO0H,KAAI;AAEf,MAAI,KAAK,eAAe1H,UAAS,SAC/B;AAAE,SAAK,iBAAiB,OAAO,qDAAqD;AAAA,EAAG;AACzF,MAAI,KAAK,WAAWA,UAAS,SAC3B;AAAE,SAAK,iBAAiB,OAAO,2DAA2D;AAAA,EAAG;AAC/F,MAAI,EAAE,KAAK,iBAAgB,EAAG,QAAQ,cAAcA,UAAS,aAC3D;AAAE,SAAK,iBAAiB,OAAO,mDAAmD;AAAA,EAAG;AACvF,MAAI,KAAK,uBAAuBA,UAAS,eAAeA,UAAS,UAC/D;AAAE,SAAK,MAAM,OAAQ,gBAAgBA,QAAO,uCAAuC;AAAA,EAAI;AACzF,MAAI,KAAK,SAAS,KAAKA,KAAI,GACzB;AAAE,SAAK,MAAM,OAAQ,yBAAyBA,QAAO,GAAG;AAAA,EAAI;AAC9D,MAAI,KAAK,QAAQ,cAAc,KAC7B,KAAK,MAAM,MAAM,OAAO,GAAG,EAAE,QAAQ,IAAI,MAAM,IAAI;AAAE;AAAA,EAAO;AAC9D,MAAI,KAAK,KAAK,SAAS,KAAK,sBAAsB,KAAK;AACvD,MAAI,GAAG,KAAKA,KAAI,GAAG;AACjB,QAAI,CAAC,KAAK,WAAWA,UAAS,SAC5B;AAAE,WAAK,iBAAiB,OAAO,sDAAsD;AAAA,IAAG;AAC1F,SAAK,iBAAiB,OAAQ,kBAAkBA,QAAO,eAAe;AAAA,EACxE;AACF;AAMA,KAAK,aAAa,SAAS,SAAS;AAClC,MAAI,OAAO,KAAK,eAAc;AAC9B,OAAK,KAAK,CAAC,CAAC,OAAO;AACnB,OAAK,WAAW,MAAM,YAAY;AAClC,MAAI,CAAC,SAAS;AACZ,SAAK,gBAAgB,IAAI;AACzB,QAAI,KAAK,SAAS,WAAW,CAAC,KAAK,eACjC;AAAE,WAAK,gBAAgB,KAAK;AAAA,IAAO;AAAA,EACvC;AACA,SAAO;AACT;AAEA,KAAK,iBAAiB,WAAW;AAC/B,MAAI,OAAO,KAAK,UAAS;AACzB,MAAI,KAAK,SAAS,QAAQ,MAAM;AAC9B,SAAK,OAAO,KAAK;AAAA,EACnB,WAAW,KAAK,KAAK,SAAS;AAC5B,SAAK,OAAO,KAAK,KAAK;AAMtB,SAAK,KAAK,SAAS,WAAW,KAAK,SAAS,gBACzC,KAAK,eAAe,KAAK,eAAe,KAAK,KAAK,MAAM,WAAW,KAAK,YAAY,MAAM,KAAK;AAChG,WAAK,QAAQ,IAAG;AAAA,IAClB;AACA,SAAK,OAAO,QAAQ;AAAA,EACtB,OAAO;AACL,SAAK,WAAU;AAAA,EACjB;AACA,SAAO;AACT;AAEA,KAAK,oBAAoB,WAAW;AAClC,MAAI,OAAO,KAAK,UAAS;AACzB,MAAI,KAAK,SAAS,QAAQ,WAAW;AACnC,SAAK,OAAO,KAAK;AAAA,EACnB,OAAO;AACL,SAAK,WAAU;AAAA,EACjB;AACA,OAAK,KAAI;AACT,OAAK,WAAW,MAAM,mBAAmB;AAGzC,MAAI,KAAK,QAAQ,oBAAoB;AACnC,QAAI,KAAK,iBAAiB,WAAW,GAAG;AACtC,WAAK,MAAM,KAAK,OAAQ,qBAAsB,KAAK,OAAQ,0CAA0C;AAAA,IACvG,OAAO;AACL,WAAK,iBAAiB,KAAK,iBAAiB,SAAS,CAAC,EAAE,KAAK,KAAK,IAAI;AAAA,IACxE;AAAA,EACF;AAEA,SAAO;AACT;AAIA,KAAK,aAAa,SAAS,SAAS;AAClC,MAAI,CAAC,KAAK,UAAU;AAAE,SAAK,WAAW,KAAK;AAAA,EAAO;AAElD,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AACT,MAAI,KAAK,SAAS,QAAQ,QAAQ,KAAK,mBAAkB,KAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC,KAAK,KAAK,YAAa;AACpH,SAAK,WAAW;AAChB,SAAK,WAAW;AAAA,EAClB,OAAO;AACL,SAAK,WAAW,KAAK,IAAI,QAAQ,IAAI;AACrC,SAAK,WAAW,KAAK,iBAAiB,OAAO;AAAA,EAC/C;AACA,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,KAAK,aAAa,SAAS,SAAS;AAClC,MAAI,CAAC,KAAK,UAAU;AAAE,SAAK,WAAW,KAAK;AAAA,EAAO;AAElD,MAAI,OAAO,KAAK,UAAS;AACzB,OAAK,KAAI;AACT,OAAK,WAAW,KAAK,gBAAgB,MAAM,MAAM,OAAO,OAAO;AAC/D,SAAO,KAAK,WAAW,MAAM,iBAAiB;AAChD;AAEA,IAAI,OAAO,OAAO;AAQlB,KAAK,QAAQ,SAAS,KAAK,SAAS;AAClC,MAAI,MAAM,YAAY,KAAK,OAAO,GAAG;AACrC,aAAW,OAAO,IAAI,OAAO,MAAM,IAAI,SAAS;AAChD,MAAI,KAAK,YAAY;AACnB,eAAW,SAAS,KAAK;AAAA,EAC3B;AACA,MAAI,MAAM,IAAI,YAAY,OAAO;AACjC,MAAI,MAAM;AAAK,MAAI,MAAM;AAAK,MAAI,WAAW,KAAK;AAClD,QAAM;AACR;AAEA,KAAK,mBAAmB,KAAK;AAE7B,KAAK,cAAc,WAAW;AAC5B,MAAI,KAAK,QAAQ,WAAW;AAC1B,WAAO,IAAI,SAAS,KAAK,SAAS,KAAK,MAAM,KAAK,SAAS;AAAA,EAC7D;AACF;AAEA,IAAI,OAAO,OAAO;AAElB,IAAI,QAAQ,SAASoI,OAAM,OAAO;AAChC,OAAK,QAAQ;AAEb,OAAK,MAAM,CAAA;AAEX,OAAK,UAAU,CAAA;AAEf,OAAK,YAAY,CAAA;AACnB;AAIA,KAAK,aAAa,SAAS,OAAO;AAChC,OAAK,WAAW,KAAK,IAAI,MAAM,KAAK,CAAC;AACvC;AAEA,KAAK,YAAY,WAAW;AAC1B,OAAK,WAAW,IAAG;AACrB;AAKA,KAAK,6BAA6B,SAAS,OAAO;AAChD,SAAQ,MAAM,QAAQ,kBAAmB,CAAC,KAAK,YAAa,MAAM,QAAQ;AAC5E;AAEA,KAAK,cAAc,SAASpI,OAAM,aAAa,KAAK;AAClD,MAAI,aAAa;AACjB,MAAI,gBAAgB,cAAc;AAChC,QAAI,QAAQ,KAAK,aAAY;AAC7B,iBAAa,MAAM,QAAQ,QAAQA,KAAI,IAAI,MAAM,MAAM,UAAU,QAAQA,KAAI,IAAI,MAAM,MAAM,IAAI,QAAQA,KAAI,IAAI;AACjH,UAAM,QAAQ,KAAKA,KAAI;AACvB,QAAI,KAAK,YAAa,MAAM,QAAQ,WAClC;AAAE,aAAO,KAAK,iBAAiBA,KAAI;AAAA,IAAG;AAAA,EAC1C,WAAW,gBAAgB,mBAAmB;AAC5C,QAAI,UAAU,KAAK,aAAY;AAC/B,YAAQ,QAAQ,KAAKA,KAAI;AAAA,EAC3B,WAAW,gBAAgB,eAAe;AACxC,QAAI,UAAU,KAAK,aAAY;AAC/B,QAAI,KAAK,qBACP;AAAE,mBAAa,QAAQ,QAAQ,QAAQA,KAAI,IAAI;AAAA,IAAI,OAEnD;AAAE,mBAAa,QAAQ,QAAQ,QAAQA,KAAI,IAAI,MAAM,QAAQ,IAAI,QAAQA,KAAI,IAAI;AAAA,IAAI;AACvF,YAAQ,UAAU,KAAKA,KAAI;AAAA,EAC7B,OAAO;AACL,aAAS,IAAI,KAAK,WAAW,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACpD,UAAI,UAAU,KAAK,WAAW,CAAC;AAC/B,UAAI,QAAQ,QAAQ,QAAQA,KAAI,IAAI,MAAM,EAAG,QAAQ,QAAQ,sBAAuB,QAAQ,QAAQ,CAAC,MAAMA,UACvG,CAAC,KAAK,2BAA2B,OAAO,KAAK,QAAQ,UAAU,QAAQA,KAAI,IAAI,IAAI;AACrF,qBAAa;AACb;AAAA,MACF;AACA,cAAQ,IAAI,KAAKA,KAAI;AACrB,UAAI,KAAK,YAAa,QAAQ,QAAQ,WACpC;AAAE,eAAO,KAAK,iBAAiBA,KAAI;AAAA,MAAG;AACxC,UAAI,QAAQ,QAAQ,WAAW;AAAE;AAAA,MAAM;AAAA,IACzC;AAAA,EACF;AACA,MAAI,YAAY;AAAE,SAAK,iBAAiB,KAAM,iBAAiBA,QAAO,6BAA6B;AAAA,EAAI;AACzG;AAEA,KAAK,mBAAmB,SAAS,IAAI;AAEnC,MAAI,KAAK,WAAW,CAAC,EAAE,QAAQ,QAAQ,GAAG,IAAI,MAAM,MAChD,KAAK,WAAW,CAAC,EAAE,IAAI,QAAQ,GAAG,IAAI,MAAM,IAAI;AAClD,SAAK,iBAAiB,GAAG,IAAI,IAAI;AAAA,EACnC;AACF;AAEA,KAAK,eAAe,WAAW;AAC7B,SAAO,KAAK,WAAW,KAAK,WAAW,SAAS,CAAC;AACnD;AAEA,KAAK,kBAAkB,WAAW;AAChC,WAAS,IAAI,KAAK,WAAW,SAAS,KAAI,KAAK;AAC7C,QAAI,QAAQ,KAAK,WAAW,CAAC;AAC7B,QAAI,MAAM,SAAS,YAAY,yBAAyB,2BAA2B;AAAE,aAAO;AAAA,IAAM;AAAA,EACpG;AACF;AAGA,KAAK,mBAAmB,WAAW;AACjC,WAAS,IAAI,KAAK,WAAW,SAAS,KAAI,KAAK;AAC7C,QAAI,QAAQ,KAAK,WAAW,CAAC;AAC7B,QAAI,MAAM,SAAS,YAAY,yBAAyB,6BACpD,EAAE,MAAM,QAAQ,cAAc;AAAE,aAAO;AAAA,IAAM;AAAA,EACnD;AACF;AAEA,IAAI,OAAO,SAASqI,MAAK,QAAQ,KAAK,KAAK;AACzC,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,MAAM;AACX,MAAI,OAAO,QAAQ,WACjB;AAAE,SAAK,MAAM,IAAI,eAAe,QAAQ,GAAG;AAAA,EAAG;AAChD,MAAI,OAAO,QAAQ,kBACjB;AAAE,SAAK,aAAa,OAAO,QAAQ;AAAA,EAAkB;AACvD,MAAI,OAAO,QAAQ,QACjB;AAAE,SAAK,QAAQ,CAAC,KAAK,CAAC;AAAA,EAAG;AAC7B;AAIA,IAAI,OAAO,OAAO;AAElB,KAAK,YAAY,WAAW;AAC1B,SAAO,IAAI,KAAK,MAAM,KAAK,OAAO,KAAK,QAAQ;AACjD;AAEA,KAAK,cAAc,SAAS,KAAK,KAAK;AACpC,SAAO,IAAI,KAAK,MAAM,KAAK,GAAG;AAChC;AAIA,SAAS,aAAa,MAAM,MAAM,KAAK,KAAK;AAC1C,OAAK,OAAO;AACZ,OAAK,MAAM;AACX,MAAI,KAAK,QAAQ,WACf;AAAE,SAAK,IAAI,MAAM;AAAA,EAAK;AACxB,MAAI,KAAK,QAAQ,QACf;AAAE,SAAK,MAAM,CAAC,IAAI;AAAA,EAAK;AACzB,SAAO;AACT;AAEA,KAAK,aAAa,SAAS,MAAM,MAAM;AACrC,SAAO,aAAa,KAAK,MAAM,MAAM,MAAM,KAAK,YAAY,KAAK,aAAa;AAChF;AAIA,KAAK,eAAe,SAAS,MAAM,MAAM,KAAK,KAAK;AACjD,SAAO,aAAa,KAAK,MAAM,MAAM,MAAM,KAAK,GAAG;AACrD;AAEA,KAAK,WAAW,SAAS,MAAM;AAC7B,MAAI,UAAU,IAAI,KAAK,MAAM,KAAK,OAAO,KAAK,QAAQ;AACtD,WAAS,QAAQ,MAAM;AAAE,YAAQ,IAAI,IAAI,KAAK,IAAI;AAAA,EAAG;AACrD,SAAO;AACT;AAGA,IAAI,6BAA6B;AAOjC,IAAI,wBAAwB;AAC5B,IAAI,yBAAyB,wBAAwB;AACrD,IAAI,yBAAyB;AAC7B,IAAI,yBAAyB,yBAAyB;AACtD,IAAI,yBAAyB;AAC7B,IAAI,yBAAyB;AAE7B,IAAI,0BAA0B;AAAA,EAC5B,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AACN;AAGA,IAAI,kCAAkC;AAEtC,IAAI,mCAAmC;AAAA,EACrC,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AACN;AAGA,IAAI,+BAA+B;AAGnC,IAAI,oBAAoB;AACxB,IAAI,qBAAqB,oBAAoB;AAC7C,IAAI,qBAAqB,qBAAqB;AAC9C,IAAI,qBAAqB,qBAAqB;AAC9C,IAAI,qBAAqB,qBAAqB;AAC9C,IAAI,qBAAqB,qBAAqB,MAAM;AAEpD,IAAI,sBAAsB;AAAA,EACxB,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AACN;AAEA,IAAI,OAAO,CAAA;AACX,SAAS,iBAAiB,aAAa;AACrC,MAAI,IAAI,KAAK,WAAW,IAAI;AAAA,IAC1B,QAAQ,YAAY,wBAAwB,WAAW,IAAI,MAAM,4BAA4B;AAAA,IAC7F,iBAAiB,YAAY,iCAAiC,WAAW,CAAC;AAAA,IAC1E,WAAW;AAAA,MACT,kBAAkB,YAAY,4BAA4B;AAAA,MAC1D,QAAQ,YAAY,oBAAoB,WAAW,CAAC;AAAA,IAC1D;AAAA,EACA;AACE,IAAE,UAAU,oBAAoB,EAAE,UAAU;AAE5C,IAAE,UAAU,KAAK,EAAE,UAAU;AAC7B,IAAE,UAAU,KAAK,EAAE,UAAU;AAC7B,IAAE,UAAU,MAAM,EAAE,UAAU;AAChC;AAEA,SAAS,IAAI,GAAGpM,SAAO,CAAC,GAAG,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG,IAAIA,OAAK,QAAQ,KAAK,GAAG;AACvE,MAAI,cAAcA,OAAK,CAAC;AAExB,mBAAiB,WAAW;AAC9B;AAEA,IAAI,OAAO,OAAO;AAIlB,IAAI,WAAW,SAASqM,UAAS,QAAQ,MAAM;AAE7C,OAAK,SAAS;AAEd,OAAK,OAAO,QAAQ;AACtB;AAEA,SAAS,UAAU,gBAAgB,SAAS,cAAe,KAAK;AAG9D,WAAS,OAAO,MAAM,MAAM,OAAO,KAAK,QAAQ;AAC9C,aAAS,QAAQ,KAAK,OAAO,QAAQ,MAAM,QAAQ;AACjD,UAAI,KAAK,SAAS,MAAM,QAAQ,SAAS,OAAO;AAAE,eAAO;AAAA,MAAK;AAAA,IAChE;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,UAAU,UAAU,SAAS,UAAW;AAC/C,SAAO,IAAI,SAAS,KAAK,QAAQ,KAAK,IAAI;AAC5C;AAEA,IAAI,wBAAwB,SAASC,uBAAsB,QAAQ;AACjE,OAAK,SAAS;AACd,OAAK,aAAa,SAAS,OAAO,QAAQ,eAAe,IAAI,OAAO,OAAO,OAAO,QAAQ,eAAe,IAAI,MAAM,OAAO,OAAO,QAAQ,eAAe,KAAK,MAAM,OAAO,OAAO,QAAQ,eAAe,KAAK,MAAM;AACnN,OAAK,oBAAoB,KAAK,OAAO,QAAQ,eAAe,KAAK,KAAK,OAAO,QAAQ,WAAW;AAChG,OAAK,SAAS;AACd,OAAK,QAAQ;AACb,OAAK,QAAQ;AACb,OAAK,UAAU;AACf,OAAK,UAAU;AACf,OAAK,UAAU;AACf,OAAK,MAAM;AACX,OAAK,eAAe;AACpB,OAAK,kBAAkB;AACvB,OAAK,8BAA8B;AACnC,OAAK,qBAAqB;AAC1B,OAAK,mBAAmB;AACxB,OAAK,aAAa,uBAAO,OAAO,IAAI;AACpC,OAAK,qBAAqB,CAAA;AAC1B,OAAK,WAAW;AAClB;AAEA,sBAAsB,UAAU,QAAQ,SAAS,MAAO,OAAO,SAAS,OAAO;AAC7E,MAAI,cAAc,MAAM,QAAQ,GAAG,MAAM;AACzC,MAAI,UAAU,MAAM,QAAQ,GAAG,MAAM;AACrC,OAAK,QAAQ,QAAQ;AACrB,OAAK,SAAS,UAAU;AACxB,OAAK,QAAQ;AACb,MAAI,eAAe,KAAK,OAAO,QAAQ,eAAe,IAAI;AACxD,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,EACjB,OAAO;AACL,SAAK,UAAU,WAAW,KAAK,OAAO,QAAQ,eAAe;AAC7D,SAAK,UAAU;AACf,SAAK,UAAU,WAAW,KAAK,OAAO,QAAQ,eAAe;AAAA,EAC/D;AACF;AAEA,sBAAsB,UAAU,QAAQ,SAAS,MAAO,SAAS;AAC/D,OAAK,OAAO,iBAAiB,KAAK,OAAQ,kCAAmC,KAAK,SAAU,QAAQ,OAAO;AAC7G;AAIA,sBAAsB,UAAU,KAAK,SAAS,GAAI,GAAG,QAAQ;AACzD,MAAK,WAAW,OAAS,UAAS;AAEpC,MAAI,IAAI,KAAK;AACb,MAAI,IAAI,EAAE;AACV,MAAI,KAAK,GAAG;AACV,WAAO;AAAA,EACT;AACA,MAAI,IAAI,EAAE,WAAW,CAAC;AACtB,MAAI,EAAE,UAAU,KAAK,YAAY,KAAK,SAAU,KAAK,SAAU,IAAI,KAAK,GAAG;AACzE,WAAO;AAAA,EACT;AACA,MAAI,OAAO,EAAE,WAAW,IAAI,CAAC;AAC7B,SAAO,QAAQ,SAAU,QAAQ,SAAU,KAAK,MAAM,OAAO,WAAY;AAC3E;AAEA,sBAAsB,UAAU,YAAY,SAAS,UAAW,GAAG,QAAQ;AACvE,MAAK,WAAW,OAAS,UAAS;AAEpC,MAAI,IAAI,KAAK;AACb,MAAI,IAAI,EAAE;AACV,MAAI,KAAK,GAAG;AACV,WAAO;AAAA,EACT;AACA,MAAI,IAAI,EAAE,WAAW,CAAC,GAAG;AACzB,MAAI,EAAE,UAAU,KAAK,YAAY,KAAK,SAAU,KAAK,SAAU,IAAI,KAAK,MACnE,OAAO,EAAE,WAAW,IAAI,CAAC,KAAK,SAAU,OAAO,OAAQ;AAC1D,WAAO,IAAI;AAAA,EACb;AACA,SAAO,IAAI;AACb;AAEA,sBAAsB,UAAU,UAAU,SAAS,QAAS,QAAQ;AAChE,MAAK,WAAW,OAAS,UAAS;AAEpC,SAAO,KAAK,GAAG,KAAK,KAAK,MAAM;AACjC;AAEA,sBAAsB,UAAU,YAAY,SAAS,UAAW,QAAQ;AACpE,MAAK,WAAW,OAAS,UAAS;AAEpC,SAAO,KAAK,GAAG,KAAK,UAAU,KAAK,KAAK,MAAM,GAAG,MAAM;AACzD;AAEA,sBAAsB,UAAU,UAAU,SAAS,QAAS,QAAQ;AAChE,MAAK,WAAW,OAAS,UAAS;AAEpC,OAAK,MAAM,KAAK,UAAU,KAAK,KAAK,MAAM;AAC5C;AAEA,sBAAsB,UAAU,MAAM,SAAS,IAAK,IAAI,QAAQ;AAC5D,MAAK,WAAW,OAAS,UAAS;AAEpC,MAAI,KAAK,QAAQ,MAAM,MAAM,IAAI;AAC/B,SAAK,QAAQ,MAAM;AACnB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEA,sBAAsB,UAAU,WAAW,SAAS,SAAU,KAAK,QAAQ;AACvE,MAAK,WAAW,OAAS,UAAS;AAEpC,MAAI,MAAM,KAAK;AACf,WAAS,IAAI,GAAGtM,QAAO,KAAK,IAAIA,MAAK,QAAQ,KAAK,GAAG;AACnD,QAAI,KAAKA,MAAK,CAAC;AAEb,QAAIuM,WAAU,KAAK,GAAG,KAAK,MAAM;AACnC,QAAIA,aAAY,MAAMA,aAAY,IAAI;AACpC,aAAO;AAAA,IACT;AACA,UAAM,KAAK,UAAU,KAAK,MAAM;AAAA,EAClC;AACA,OAAK,MAAM;AACX,SAAO;AACT;AAQA,KAAK,sBAAsB,SAAS,OAAO;AACzC,MAAI,aAAa,MAAM;AACvB,MAAI,QAAQ,MAAM;AAElB,MAAI,IAAI;AACR,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QAAI,OAAO,MAAM,OAAO,CAAC;AACzB,QAAI,WAAW,QAAQ,IAAI,MAAM,IAAI;AACnC,WAAK,MAAM,MAAM,OAAO,iCAAiC;AAAA,IAC3D;AACA,QAAI,MAAM,QAAQ,MAAM,IAAI,CAAC,IAAI,IAAI;AACnC,WAAK,MAAM,MAAM,OAAO,mCAAmC;AAAA,IAC7D;AACA,QAAI,SAAS,KAAK;AAAE,UAAI;AAAA,IAAM;AAC9B,QAAI,SAAS,KAAK;AAAE,UAAI;AAAA,IAAM;AAAA,EAChC;AACA,MAAI,KAAK,QAAQ,eAAe,MAAM,KAAK,GAAG;AAC5C,SAAK,MAAM,MAAM,OAAO,iCAAiC;AAAA,EAC3D;AACF;AAEA,SAAS,QAAQ,KAAK;AACpB,WAAS,KAAK,KAAK;AAAE,WAAO;AAAA,EAAK;AACjC,SAAO;AACT;AAQA,KAAK,wBAAwB,SAAS,OAAO;AAC3C,OAAK,eAAe,KAAK;AAOzB,MAAI,CAAC,MAAM,WAAW,KAAK,QAAQ,eAAe,KAAK,QAAQ,MAAM,UAAU,GAAG;AAChF,UAAM,UAAU;AAChB,SAAK,eAAe,KAAK;AAAA,EAC3B;AACF;AAGA,KAAK,iBAAiB,SAAS,OAAO;AACpC,QAAM,MAAM;AACZ,QAAM,eAAe;AACrB,QAAM,kBAAkB;AACxB,QAAM,8BAA8B;AACpC,QAAM,qBAAqB;AAC3B,QAAM,mBAAmB;AACzB,QAAM,aAAa,uBAAO,OAAO,IAAI;AACrC,QAAM,mBAAmB,SAAS;AAClC,QAAM,WAAW;AAEjB,OAAK,mBAAmB,KAAK;AAE7B,MAAI,MAAM,QAAQ,MAAM,OAAO,QAAQ;AAErC,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,YAAM,MAAM,eAAe;AAAA,IAC7B;AACA,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KAAa,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AACtD,YAAM,MAAM,0BAA0B;AAAA,IACxC;AAAA,EACF;AACA,MAAI,MAAM,mBAAmB,MAAM,oBAAoB;AACrD,UAAM,MAAM,gBAAgB;AAAA,EAC9B;AACA,WAAS,IAAI,GAAGvM,QAAO,MAAM,oBAAoB,IAAIA,MAAK,QAAQ,KAAK,GAAG;AACxE,QAAI+D,QAAO/D,MAAK,CAAC;AAEjB,QAAI,CAAC,MAAM,WAAW+D,KAAI,GAAG;AAC3B,YAAM,MAAM,kCAAkC;AAAA,IAChD;AAAA,EACF;AACF;AAGA,KAAK,qBAAqB,SAAS,OAAO;AACxC,MAAI,mBAAmB,KAAK,QAAQ,eAAe;AACnD,MAAI,kBAAkB;AAAE,UAAM,WAAW,IAAI,SAAS,MAAM,UAAU,IAAI;AAAA,EAAG;AAC7E,OAAK,mBAAmB,KAAK;AAC7B,SAAO,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC9B,QAAI,kBAAkB;AAAE,YAAM,WAAW,MAAM,SAAS,QAAO;AAAA,IAAI;AACnE,SAAK,mBAAmB,KAAK;AAAA,EAC/B;AACA,MAAI,kBAAkB;AAAE,UAAM,WAAW,MAAM,SAAS;AAAA,EAAQ;AAGhE,MAAI,KAAK,qBAAqB,OAAO,IAAI,GAAG;AAC1C,UAAM,MAAM,mBAAmB;AAAA,EACjC;AACA,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,UAAM,MAAM,0BAA0B;AAAA,EACxC;AACF;AAGA,KAAK,qBAAqB,SAAS,OAAO;AACxC,SAAO,MAAM,MAAM,MAAM,OAAO,UAAU,KAAK,eAAe,KAAK,GAAG;AAAA,EAAC;AACzE;AAGA,KAAK,iBAAiB,SAAS,OAAO;AACpC,MAAI,KAAK,oBAAoB,KAAK,GAAG;AAInC,QAAI,MAAM,+BAA+B,KAAK,qBAAqB,KAAK,GAAG;AAEzE,UAAI,MAAM,SAAS;AACjB,cAAM,MAAM,oBAAoB;AAAA,MAClC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,UAAU,KAAK,eAAe,KAAK,IAAI,KAAK,uBAAuB,KAAK,GAAG;AACnF,SAAK,qBAAqB,KAAK;AAC/B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAGA,KAAK,sBAAsB,SAAS,OAAO;AACzC,MAAI,QAAQ,MAAM;AAClB,QAAM,8BAA8B;AAGpC,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KAAa,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AACtD,WAAO;AAAA,EACT;AAGA,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KAAa,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AACtD,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AAGA,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KAAa,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AACtD,QAAI,aAAa;AACjB,QAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,mBAAa,MAAM;AAAA,QAAI;AAAA;AAAA,MAAI;AAAA,IAC7B;AACA,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KAAa,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AACtD,WAAK,mBAAmB,KAAK;AAC7B,UAAI,CAAC,MAAM;AAAA,QAAI;AAAA;AAAA,SAAe;AAC5B,cAAM,MAAM,oBAAoB;AAAA,MAClC;AACA,YAAM,8BAA8B,CAAC;AACrC,aAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,MAAM;AACZ,SAAO;AACT;AAGA,KAAK,uBAAuB,SAAS,OAAO,SAAS;AACnD,MAAK,YAAY,OAAS,WAAU;AAEpC,MAAI,KAAK,2BAA2B,OAAO,OAAO,GAAG;AACnD,UAAM;AAAA,MAAI;AAAA;AAAA,IAAI;AACd,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,KAAK,6BAA6B,SAAS,OAAO,SAAS;AACzD,SACE,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KACd,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KACd,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KACd,KAAK,2BAA2B,OAAO,OAAO;AAElD;AACA,KAAK,6BAA6B,SAAS,OAAO,SAAS;AACzD,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI8E,OAAM,GAAGf,OAAM;AACnB,QAAI,KAAK,wBAAwB,KAAK,GAAG;AACvC,MAAAe,OAAM,MAAM;AACZ,UAAI,MAAM;AAAA,QAAI;AAAA;AAAA,MAAI,KAAa,KAAK,wBAAwB,KAAK,GAAG;AAClE,QAAAf,OAAM,MAAM;AAAA,MACd;AACA,UAAI,MAAM;AAAA,QAAI;AAAA;AAAA,SAAe;AAE3B,YAAIA,SAAQ,MAAMA,OAAMe,QAAO,CAAC,SAAS;AACvC,gBAAM,MAAM,uCAAuC;AAAA,QACrD;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI,MAAM,WAAW,CAAC,SAAS;AAC7B,YAAM,MAAM,uBAAuB;AAAA,IACrC;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AAGA,KAAK,iBAAiB,SAAS,OAAO;AACpC,SACE,KAAK,4BAA4B,KAAK,KACtC,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KACd,KAAK,mCAAmC,KAAK,KAC7C,KAAK,yBAAyB,KAAK,KACnC,KAAK,2BAA2B,KAAK,KACrC,KAAK,yBAAyB,KAAK;AAEvC;AACA,KAAK,qCAAqC,SAAS,OAAO;AACxD,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,qBAAqB,KAAK,GAAG;AACpC,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AACA,KAAK,6BAA6B,SAAS,OAAO;AAChD,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,UAAI,KAAK,QAAQ,eAAe,IAAI;AAClC,YAAI,eAAe,KAAK,oBAAoB,KAAK;AACjD,YAAI,YAAY,MAAM;AAAA,UAAI;AAAA;AAAA,QAAI;AAC9B,YAAI,gBAAgB,WAAW;AAC7B,mBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,gBAAI,WAAW,aAAa,OAAO,CAAC;AACpC,gBAAI,aAAa,QAAQ,UAAU,IAAI,CAAC,IAAI,IAAI;AAC9C,oBAAM,MAAM,wCAAwC;AAAA,YACtD;AAAA,UACF;AACA,cAAI,WAAW;AACb,gBAAI,kBAAkB,KAAK,oBAAoB,KAAK;AACpD,gBAAI,CAAC,gBAAgB,CAAC,mBAAmB,MAAM,QAAO,MAAO,IAAc;AACzE,oBAAM,MAAM,sCAAsC;AAAA,YACpD;AACA,qBAAS,MAAM,GAAG,MAAM,gBAAgB,QAAQ,OAAO;AACrD,kBAAI,aAAa,gBAAgB,OAAO,GAAG;AAC3C,kBACE,gBAAgB,QAAQ,YAAY,MAAM,CAAC,IAAI,MAC/C,aAAa,QAAQ,UAAU,IAAI,IACnC;AACA,sBAAM,MAAM,wCAAwC;AAAA,cACtD;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,MAAM;AAAA,QAAI;AAAA;AAAA,SAAe;AAC3B,aAAK,mBAAmB,KAAK;AAC7B,YAAI,MAAM;AAAA,UAAI;AAAA;AAAA,WAAe;AAC3B,iBAAO;AAAA,QACT;AACA,cAAM,MAAM,oBAAoB;AAAA,MAClC;AAAA,IACF;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AACA,KAAK,2BAA2B,SAAS,OAAO;AAC9C,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,WAAK,sBAAsB,KAAK;AAAA,IAClC,WAAW,MAAM,QAAO,MAAO,IAAc;AAC3C,YAAM,MAAM,eAAe;AAAA,IAC7B;AACA,SAAK,mBAAmB,KAAK;AAC7B,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,YAAM,sBAAsB;AAC5B,aAAO;AAAA,IACT;AACA,UAAM,MAAM,oBAAoB;AAAA,EAClC;AACA,SAAO;AACT;AAIA,KAAK,sBAAsB,SAAS,OAAO;AACzC,MAAI,YAAY;AAChB,MAAI,KAAK;AACT,UAAQ,KAAK,MAAM,QAAO,OAAQ,MAAM,4BAA4B,EAAE,GAAG;AACvE,iBAAa,kBAAkB,EAAE;AACjC,UAAM,QAAO;AAAA,EACf;AACA,SAAO;AACT;AAGA,SAAS,4BAA4B,IAAI;AACvC,SAAO,OAAO,OAAgB,OAAO,OAAgB,OAAO;AAC9D;AAGA,KAAK,yBAAyB,SAAS,OAAO;AAC5C,SACE,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,KACd,KAAK,mCAAmC,KAAK,KAC7C,KAAK,yBAAyB,KAAK,KACnC,KAAK,2BAA2B,KAAK,KACrC,KAAK,yBAAyB,KAAK,KACnC,KAAK,kCAAkC,KAAK,KAC5C,KAAK,mCAAmC,KAAK;AAEjD;AAGA,KAAK,oCAAoC,SAAS,OAAO;AACvD,MAAI,KAAK,2BAA2B,OAAO,IAAI,GAAG;AAChD,UAAM,MAAM,mBAAmB;AAAA,EACjC;AACA,SAAO;AACT;AAGA,KAAK,4BAA4B,SAAS,OAAO;AAC/C,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,kBAAkB,EAAE,GAAG;AACzB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AACA,SAAS,kBAAkB,IAAI;AAC7B,SACE,OAAO,MACP,MAAM,MAAgB,MAAM,MAC5B,OAAO,MACP,OAAO,MACP,MAAM,MAAgB,MAAM,MAC5B,MAAM,OAAgB,MAAM;AAEhC;AAIA,KAAK,8BAA8B,SAAS,OAAO;AACjD,MAAI,QAAQ,MAAM;AAClB,MAAI,KAAK;AACT,UAAQ,KAAK,MAAM,QAAO,OAAQ,MAAM,CAAC,kBAAkB,EAAE,GAAG;AAC9D,UAAM,QAAO;AAAA,EACf;AACA,SAAO,MAAM,QAAQ;AACvB;AAGA,KAAK,qCAAqC,SAAS,OAAO;AACxD,MAAI,KAAK,MAAM,QAAO;AACtB,MACE,OAAO,MACP,OAAO,MACP,EAAE,MAAM,MAAgB,MAAM,OAC9B,OAAO,MACP,OAAO,MACP,OAAO,MACP,OAAO,MACP,OAAO,KACP;AACA,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAKA,KAAK,wBAAwB,SAAS,OAAO;AAC3C,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,CAAC,KAAK,oBAAoB,KAAK,GAAG;AAAE,YAAM,MAAM,eAAe;AAAA,IAAG;AACtE,QAAI,mBAAmB,KAAK,QAAQ,eAAe;AACnD,QAAI,QAAQ,MAAM,WAAW,MAAM,eAAe;AAClD,QAAI,OAAO;AACT,UAAI,kBAAkB;AACpB,iBAAS,IAAI,GAAG7I,QAAO,OAAO,IAAIA,MAAK,QAAQ,KAAK,GAAG;AACrD,cAAI,QAAQA,MAAK,CAAC;AAElB,cAAI,CAAC,MAAM,cAAc,MAAM,QAAQ,GACrC;AAAE,kBAAM,MAAM,8BAA8B;AAAA,UAAG;AAAA,QACnD;AAAA,MACF,OAAO;AACL,cAAM,MAAM,8BAA8B;AAAA,MAC5C;AAAA,IACF;AACA,QAAI,kBAAkB;AACpB,OAAC,UAAU,MAAM,WAAW,MAAM,eAAe,IAAI,CAAA,IAAK,KAAK,MAAM,QAAQ;AAAA,IAC/E,OAAO;AACL,YAAM,WAAW,MAAM,eAAe,IAAI;AAAA,IAC5C;AAAA,EACF;AACF;AAKA,KAAK,sBAAsB,SAAS,OAAO;AACzC,QAAM,kBAAkB;AACxB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,+BAA+B,KAAK,KAAK,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AACzE,aAAO;AAAA,IACT;AACA,UAAM,MAAM,4BAA4B;AAAA,EAC1C;AACA,SAAO;AACT;AAMA,KAAK,iCAAiC,SAAS,OAAO;AACpD,QAAM,kBAAkB;AACxB,MAAI,KAAK,gCAAgC,KAAK,GAAG;AAC/C,UAAM,mBAAmB,kBAAkB,MAAM,YAAY;AAC7D,WAAO,KAAK,+BAA+B,KAAK,GAAG;AACjD,YAAM,mBAAmB,kBAAkB,MAAM,YAAY;AAAA,IAC/D;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAOA,KAAK,kCAAkC,SAAS,OAAO;AACrD,MAAI,QAAQ,MAAM;AAClB,MAAI,SAAS,KAAK,QAAQ,eAAe;AACzC,MAAI,KAAK,MAAM,QAAQ,MAAM;AAC7B,QAAM,QAAQ,MAAM;AAEpB,MAAI,OAAO,MAAgB,KAAK,sCAAsC,OAAO,MAAM,GAAG;AACpF,SAAK,MAAM;AAAA,EACb;AACA,MAAI,wBAAwB,EAAE,GAAG;AAC/B,UAAM,eAAe;AACrB,WAAO;AAAA,EACT;AAEA,QAAM,MAAM;AACZ,SAAO;AACT;AACA,SAAS,wBAAwB,IAAI;AACnC,SAAO,kBAAkB,IAAI,IAAI,KAAK,OAAO,MAAgB,OAAO;AACtE;AASA,KAAK,iCAAiC,SAAS,OAAO;AACpD,MAAI,QAAQ,MAAM;AAClB,MAAI,SAAS,KAAK,QAAQ,eAAe;AACzC,MAAI,KAAK,MAAM,QAAQ,MAAM;AAC7B,QAAM,QAAQ,MAAM;AAEpB,MAAI,OAAO,MAAgB,KAAK,sCAAsC,OAAO,MAAM,GAAG;AACpF,SAAK,MAAM;AAAA,EACb;AACA,MAAI,uBAAuB,EAAE,GAAG;AAC9B,UAAM,eAAe;AACrB,WAAO;AAAA,EACT;AAEA,QAAM,MAAM;AACZ,SAAO;AACT;AACA,SAAS,uBAAuB,IAAI;AAClC,SAAO,iBAAiB,IAAI,IAAI,KAAK,OAAO,MAAgB,OAAO,MAAgB,OAAO,QAAuB,OAAO;AAC1H;AAGA,KAAK,uBAAuB,SAAS,OAAO;AAC1C,MACE,KAAK,wBAAwB,KAAK,KAClC,KAAK,+BAA+B,KAAK,KACzC,KAAK,0BAA0B,KAAK,KACnC,MAAM,WAAW,KAAK,qBAAqB,KAAK,GACjD;AACA,WAAO;AAAA,EACT;AACA,MAAI,MAAM,SAAS;AAEjB,QAAI,MAAM,QAAO,MAAO,IAAc;AACpC,YAAM,MAAM,wBAAwB;AAAA,IACtC;AACA,UAAM,MAAM,gBAAgB;AAAA,EAC9B;AACA,SAAO;AACT;AACA,KAAK,0BAA0B,SAAS,OAAO;AAC7C,MAAI,QAAQ,MAAM;AAClB,MAAI,KAAK,wBAAwB,KAAK,GAAG;AACvC,QAAI,IAAI,MAAM;AACd,QAAI,MAAM,SAAS;AAEjB,UAAI,IAAI,MAAM,kBAAkB;AAC9B,cAAM,mBAAmB;AAAA,MAC3B;AACA,aAAO;AAAA,IACT;AACA,QAAI,KAAK,MAAM,oBAAoB;AACjC,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AACA,KAAK,uBAAuB,SAAS,OAAO;AAC1C,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,oBAAoB,KAAK,GAAG;AACnC,YAAM,mBAAmB,KAAK,MAAM,eAAe;AACnD,aAAO;AAAA,IACT;AACA,UAAM,MAAM,yBAAyB;AAAA,EACvC;AACA,SAAO;AACT;AAGA,KAAK,4BAA4B,SAAS,OAAO;AAC/C,SACE,KAAK,wBAAwB,KAAK,KAClC,KAAK,yBAAyB,KAAK,KACnC,KAAK,eAAe,KAAK,KACzB,KAAK,4BAA4B,KAAK,KACtC,KAAK,sCAAsC,OAAO,KAAK,KACtD,CAAC,MAAM,WAAW,KAAK,oCAAoC,KAAK,KACjE,KAAK,yBAAyB,KAAK;AAEvC;AACA,KAAK,2BAA2B,SAAS,OAAO;AAC9C,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,wBAAwB,KAAK,GAAG;AACvC,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AACA,KAAK,iBAAiB,SAAS,OAAO;AACpC,MAAI,MAAM,QAAO,MAAO,MAAgB,CAAC,eAAe,MAAM,UAAS,CAAE,GAAG;AAC1E,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,KAAK,0BAA0B,SAAS,OAAO;AAC7C,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,OAAO,KAAc;AACvB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAc;AACvB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAc;AACvB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAc;AACvB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAc;AACvB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,KAAK,0BAA0B,SAAS,OAAO;AAC7C,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,gBAAgB,EAAE,GAAG;AACvB,UAAM,eAAe,KAAK;AAC1B,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AACA,SAAS,gBAAgB,IAAI;AAC3B,SACG,MAAM,MAAgB,MAAM,MAC5B,MAAM,MAAgB,MAAM;AAEjC;AAGA,KAAK,wCAAwC,SAAS,OAAO,QAAQ;AACnE,MAAK,WAAW,OAAS,UAAS;AAElC,MAAI,QAAQ,MAAM;AAClB,MAAI,UAAU,UAAU,MAAM;AAE9B,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,yBAAyB,OAAO,CAAC,GAAG;AAC3C,UAAI,OAAO,MAAM;AACjB,UAAI,WAAW,QAAQ,SAAU,QAAQ,OAAQ;AAC/C,YAAI,mBAAmB,MAAM;AAC7B,YAAI,MAAM;AAAA,UAAI;AAAA;AAAA,QAAI,KAAa,MAAM;AAAA,UAAI;AAAA;AAAA,QAAI,KAAa,KAAK,yBAAyB,OAAO,CAAC,GAAG;AACjG,cAAI,QAAQ,MAAM;AAClB,cAAI,SAAS,SAAU,SAAS,OAAQ;AACtC,kBAAM,gBAAgB,OAAO,SAAU,QAAS,QAAQ,SAAU;AAClE,mBAAO;AAAA,UACT;AAAA,QACF;AACA,cAAM,MAAM;AACZ,cAAM,eAAe;AAAA,MACvB;AACA,aAAO;AAAA,IACT;AACA,QACE,WACA,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KACd,KAAK,oBAAoB,KAAK,KAC9B,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KACd,eAAe,MAAM,YAAY,GACjC;AACA,aAAO;AAAA,IACT;AACA,QAAI,SAAS;AACX,YAAM,MAAM,wBAAwB;AAAA,IACtC;AACA,UAAM,MAAM;AAAA,EACd;AAEA,SAAO;AACT;AACA,SAAS,eAAe,IAAI;AAC1B,SAAO,MAAM,KAAK,MAAM;AAC1B;AAGA,KAAK,2BAA2B,SAAS,OAAO;AAC9C,MAAI,MAAM,SAAS;AACjB,QAAI,KAAK,0BAA0B,KAAK,GAAG;AACzC,aAAO;AAAA,IACT;AACA,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,YAAM,eAAe;AACrB,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAEA,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,OAAO,OAAiB,CAAC,MAAM,WAAW,OAAO,MAAe;AAClE,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAGA,KAAK,0BAA0B,SAAS,OAAO;AAC7C,QAAM,eAAe;AACrB,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,MAAM,MAAgB,MAAM,IAAc;AAC5C,OAAG;AACD,YAAM,eAAe,KAAK,MAAM,gBAAgB,KAAK;AACrD,YAAM,QAAO;AAAA,IACf,UAAU,KAAK,MAAM,QAAO,MAAO,MAAgB,MAAM;AACzD,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAIA,IAAI,cAAc;AAClB,IAAI,YAAY;AAChB,IAAI,gBAAgB;AAGpB,KAAK,iCAAiC,SAAS,OAAO;AACpD,MAAI,KAAK,MAAM,QAAO;AAEtB,MAAI,uBAAuB,EAAE,GAAG;AAC9B,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AAEA,MAAI,SAAS;AACb,MACE,MAAM,WACN,KAAK,QAAQ,eAAe,OAC1B,SAAS,OAAO,OAAiB,OAAO,MAC1C;AACA,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,QAAIxC;AACJ,QACE,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,MACbA,UAAS,KAAK,yCAAyC,KAAK,MAC7D,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,GACd;AACA,UAAI,UAAUA,YAAW,eAAe;AAAE,cAAM,MAAM,uBAAuB;AAAA,MAAG;AAChF,aAAOA;AAAA,IACT;AACA,UAAM,MAAM,uBAAuB;AAAA,EACrC;AAEA,SAAO;AACT;AAEA,SAAS,uBAAuB,IAAI;AAClC,SACE,OAAO,OACP,OAAO,MACP,OAAO,OACP,OAAO,MACP,OAAO,OACP,OAAO;AAEX;AAKA,KAAK,2CAA2C,SAAS,OAAO;AAC9D,MAAI,QAAQ,MAAM;AAGlB,MAAI,KAAK,8BAA8B,KAAK,KAAK,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AACxE,QAAIuG,QAAO,MAAM;AACjB,QAAI,KAAK,+BAA+B,KAAK,GAAG;AAC9C,UAAIpG,SAAQ,MAAM;AAClB,WAAK,2CAA2C,OAAOoG,OAAMpG,MAAK;AAClE,aAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,MAAM;AAGZ,MAAI,KAAK,yCAAyC,KAAK,GAAG;AACxD,QAAI,cAAc,MAAM;AACxB,WAAO,KAAK,0CAA0C,OAAO,WAAW;AAAA,EAC1E;AACA,SAAO;AACT;AAEA,KAAK,6CAA6C,SAAS,OAAOoG,OAAMpG,QAAO;AAC7E,MAAI,CAAC,OAAO,MAAM,kBAAkB,WAAWoG,KAAI,GACjD;AAAE,UAAM,MAAM,uBAAuB;AAAA,EAAG;AAC1C,MAAI,CAAC,MAAM,kBAAkB,UAAUA,KAAI,EAAE,KAAKpG,MAAK,GACrD;AAAE,UAAM,MAAM,wBAAwB;AAAA,EAAG;AAC7C;AAEA,KAAK,4CAA4C,SAAS,OAAO,aAAa;AAC5E,MAAI,MAAM,kBAAkB,OAAO,KAAK,WAAW,GAAG;AAAE,WAAO;AAAA,EAAU;AACzE,MAAI,MAAM,WAAW,MAAM,kBAAkB,gBAAgB,KAAK,WAAW,GAAG;AAAE,WAAO;AAAA,EAAc;AACvG,QAAM,MAAM,uBAAuB;AACrC;AAIA,KAAK,gCAAgC,SAAS,OAAO;AACnD,MAAI,KAAK;AACT,QAAM,kBAAkB;AACxB,SAAO,+BAA+B,KAAK,MAAM,QAAO,CAAE,GAAG;AAC3D,UAAM,mBAAmB,kBAAkB,EAAE;AAC7C,UAAM,QAAO;AAAA,EACf;AACA,SAAO,MAAM,oBAAoB;AACnC;AAEA,SAAS,+BAA+B,IAAI;AAC1C,SAAO,gBAAgB,EAAE,KAAK,OAAO;AACvC;AAIA,KAAK,iCAAiC,SAAS,OAAO;AACpD,MAAI,KAAK;AACT,QAAM,kBAAkB;AACxB,SAAO,gCAAgC,KAAK,MAAM,QAAO,CAAE,GAAG;AAC5D,UAAM,mBAAmB,kBAAkB,EAAE;AAC7C,UAAM,QAAO;AAAA,EACf;AACA,SAAO,MAAM,oBAAoB;AACnC;AACA,SAAS,gCAAgC,IAAI;AAC3C,SAAO,+BAA+B,EAAE,KAAK,eAAe,EAAE;AAChE;AAIA,KAAK,2CAA2C,SAAS,OAAO;AAC9D,SAAO,KAAK,+BAA+B,KAAK;AAClD;AAGA,KAAK,2BAA2B,SAAS,OAAO;AAC9C,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,SAAS,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI;AAC3B,QAAIH,UAAS,KAAK,qBAAqB,KAAK;AAC5C,QAAI,CAAC,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,GACjB;AAAE,YAAM,MAAM,8BAA8B;AAAA,IAAG;AACjD,QAAI,UAAUA,YAAW,eACvB;AAAE,YAAM,MAAM,6CAA6C;AAAA,IAAG;AAChE,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAIA,KAAK,uBAAuB,SAAS,OAAO;AAC1C,MAAI,MAAM,QAAO,MAAO,IAAc;AAAE,WAAO;AAAA,EAAU;AACzD,MAAI,MAAM,SAAS;AAAE,WAAO,KAAK,0BAA0B,KAAK;AAAA,EAAE;AAClE,OAAK,2BAA2B,KAAK;AACrC,SAAO;AACT;AAIA,KAAK,6BAA6B,SAAS,OAAO;AAChD,SAAO,KAAK,oBAAoB,KAAK,GAAG;AACtC,QAAI,OAAO,MAAM;AACjB,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KAAa,KAAK,oBAAoB,KAAK,GAAG;AAC9D,UAAI,QAAQ,MAAM;AAClB,UAAI,MAAM,YAAY,SAAS,MAAM,UAAU,KAAK;AAClD,cAAM,MAAM,yBAAyB;AAAA,MACvC;AACA,UAAI,SAAS,MAAM,UAAU,MAAM,OAAO,OAAO;AAC/C,cAAM,MAAM,uCAAuC;AAAA,MACrD;AAAA,IACF;AAAA,EACF;AACF;AAIA,KAAK,sBAAsB,SAAS,OAAO;AACzC,MAAI,QAAQ,MAAM;AAElB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,sBAAsB,KAAK,GAAG;AACrC,aAAO;AAAA,IACT;AACA,QAAI,MAAM,SAAS;AAEjB,UAAI,OAAO,MAAM,QAAO;AACxB,UAAI,SAAS,MAAgB,aAAa,IAAI,GAAG;AAC/C,cAAM,MAAM,sBAAsB;AAAA,MACpC;AACA,YAAM,MAAM,gBAAgB;AAAA,IAC9B;AACA,UAAM,MAAM;AAAA,EACd;AAEA,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,OAAO,IAAc;AACvB,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAGA,KAAK,wBAAwB,SAAS,OAAO;AAC3C,MAAI,QAAQ,MAAM;AAElB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,UAAM,eAAe;AACrB,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,WAAW,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,GAAW;AAC5C,UAAM,eAAe;AACrB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,MAAM,WAAW,MAAM;AAAA,IAAI;AAAA;AAAA,EAAI,GAAW;AAC7C,QAAI,KAAK,6BAA6B,KAAK,GAAG;AAC5C,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AAEA,SACE,KAAK,+BAA+B,KAAK,KACzC,KAAK,0BAA0B,KAAK;AAExC;AAMA,KAAK,4BAA4B,SAAS,OAAO;AAC/C,MAAIA,UAAS,WAAW;AACxB,MAAI,KAAK,wBAAwB,KAAK,EAAG;AAAA,WAAW,YAAY,KAAK,0BAA0B,KAAK,GAAG;AACrG,QAAI,cAAc,eAAe;AAAE,MAAAA,UAAS;AAAA,IAAe;AAE3D,QAAI,QAAQ,MAAM;AAClB,WAAO,MAAM;AAAA,MAAS,CAAC,IAAM,EAAI;AAAA;AAAA,IAAC,GAAY;AAC5C,UACE,MAAM,QAAO,MAAO,OACnB,YAAY,KAAK,0BAA0B,KAAK,IACjD;AACA,YAAI,cAAc,eAAe;AAAE,UAAAA,UAAS;AAAA,QAAW;AACvD;AAAA,MACF;AACA,YAAM,MAAM,sCAAsC;AAAA,IACpD;AACA,QAAI,UAAU,MAAM,KAAK;AAAE,aAAOA;AAAA,IAAO;AAEzC,WAAO,MAAM;AAAA,MAAS,CAAC,IAAM,EAAI;AAAA;AAAA,IAAC,GAAY;AAC5C,UAAI,KAAK,0BAA0B,KAAK,GAAG;AAAE;AAAA,MAAS;AACtD,YAAM,MAAM,sCAAsC;AAAA,IACpD;AACA,QAAI,UAAU,MAAM,KAAK;AAAE,aAAOA;AAAA,IAAO;AAAA,EAC3C,OAAO;AACL,UAAM,MAAM,sCAAsC;AAAA,EACpD;AAEA,aAAS;AACP,QAAI,KAAK,wBAAwB,KAAK,GAAG;AAAE;AAAA,IAAS;AACpD,gBAAY,KAAK,0BAA0B,KAAK;AAChD,QAAI,CAAC,WAAW;AAAE,aAAOA;AAAA,IAAO;AAChC,QAAI,cAAc,eAAe;AAAE,MAAAA,UAAS;AAAA,IAAe;AAAA,EAC7D;AACF;AAGA,KAAK,0BAA0B,SAAS,OAAO;AAC7C,MAAI,QAAQ,MAAM;AAClB,MAAI,KAAK,4BAA4B,KAAK,GAAG;AAC3C,QAAI,OAAO,MAAM;AACjB,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI,KAAa,KAAK,4BAA4B,KAAK,GAAG;AACtE,UAAI,QAAQ,MAAM;AAClB,UAAI,SAAS,MAAM,UAAU,MAAM,OAAO,OAAO;AAC/C,cAAM,MAAM,uCAAuC;AAAA,MACrD;AACA,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AAGA,KAAK,4BAA4B,SAAS,OAAO;AAC/C,MAAI,KAAK,4BAA4B,KAAK,GAAG;AAAE,WAAO;AAAA,EAAU;AAChE,SAAO,KAAK,iCAAiC,KAAK,KAAK,KAAK,sBAAsB,KAAK;AACzF;AAGA,KAAK,wBAAwB,SAAS,OAAO;AAC3C,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,SAAS,MAAM;AAAA,MAAI;AAAA;AAAA,IAAI;AAC3B,QAAIA,UAAS,KAAK,qBAAqB,KAAK;AAC5C,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,UAAI,UAAUA,YAAW,eAAe;AACtC,cAAM,MAAM,6CAA6C;AAAA,MAC3D;AACA,aAAOA;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AACA,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,WAAW,KAAK,+BAA+B,KAAK;AACxD,QAAI,UAAU;AACZ,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AAGA,KAAK,mCAAmC,SAAS,OAAO;AACtD,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAS,CAAC,IAAM,GAAI;AAAA;AAAA,EAAC,GAAY;AACzC,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,UAAIA,UAAS,KAAK,sCAAsC,KAAK;AAC7D,UAAI,MAAM;AAAA,QAAI;AAAA;AAAA,SAAe;AAC3B,eAAOA;AAAA,MACT;AAAA,IACF,OAAO;AAEL,YAAM,MAAM,gBAAgB;AAAA,IAC9B;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AAGA,KAAK,wCAAwC,SAAS,OAAO;AAC3D,MAAIA,UAAS,KAAK,mBAAmB,KAAK;AAC1C,SAAO,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC9B,QAAI,KAAK,mBAAmB,KAAK,MAAM,eAAe;AAAE,MAAAA,UAAS;AAAA,IAAe;AAAA,EAClF;AACA,SAAOA;AACT;AAIA,KAAK,qBAAqB,SAAS,OAAO;AACxC,MAAIoL,SAAQ;AACZ,SAAO,KAAK,4BAA4B,KAAK,GAAG;AAAE,IAAAA;AAAA,EAAS;AAC3D,SAAOA,WAAU,IAAI,YAAY;AACnC;AAGA,KAAK,8BAA8B,SAAS,OAAO;AACjD,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QACE,KAAK,0BAA0B,KAAK,KACpC,KAAK,qCAAqC,KAAK,GAC/C;AACA,aAAO;AAAA,IACT;AACA,QAAI,MAAM;AAAA,MAAI;AAAA;AAAA,OAAe;AAC3B,YAAM,eAAe;AACrB,aAAO;AAAA,IACT;AACA,UAAM,MAAM;AACZ,WAAO;AAAA,EACT;AACA,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,KAAK,KAAK,OAAO,MAAM,eAAe,4CAA4C,EAAE,GAAG;AAAE,WAAO;AAAA,EAAM;AAC1G,MAAI,0BAA0B,EAAE,GAAG;AAAE,WAAO;AAAA,EAAM;AAClD,QAAM,QAAO;AACb,QAAM,eAAe;AACrB,SAAO;AACT;AAGA,SAAS,4CAA4C,IAAI;AACvD,SACE,OAAO,MACP,MAAM,MAAgB,MAAM,MAC5B,MAAM,MAAgB,MAAM,MAC5B,OAAO,MACP,MAAM,MAAgB,MAAM,MAC5B,OAAO,MACP,OAAO,MACP,OAAO;AAEX;AAGA,SAAS,0BAA0B,IAAI;AACrC,SACE,OAAO,MACP,OAAO,MACP,OAAO,MACP,OAAO,MACP,MAAM,MAAgB,MAAM,MAC5B,MAAM,OAAgB,MAAM;AAEhC;AAGA,KAAK,uCAAuC,SAAS,OAAO;AAC1D,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,6BAA6B,EAAE,GAAG;AACpC,UAAM,eAAe;AACrB,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,SAAS,6BAA6B,IAAI;AACxC,SACE,OAAO,MACP,OAAO,MACP,OAAO,MACP,OAAO,MACP,OAAO,MACP,OAAO,MACP,MAAM,MAAgB,MAAM,MAC5B,OAAO,MACP,OAAO,MACP,OAAO;AAEX;AAGA,KAAK,+BAA+B,SAAS,OAAO;AAClD,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,eAAe,EAAE,KAAK,OAAO,IAAc;AAC7C,UAAM,eAAe,KAAK;AAC1B,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,KAAK,8BAA8B,SAAS,OAAO;AACjD,MAAI,QAAQ,MAAM;AAClB,MAAI,MAAM;AAAA,IAAI;AAAA;AAAA,KAAe;AAC3B,QAAI,KAAK,yBAAyB,OAAO,CAAC,GAAG;AAC3C,aAAO;AAAA,IACT;AACA,QAAI,MAAM,SAAS;AACjB,YAAM,MAAM,gBAAgB;AAAA,IAC9B;AACA,UAAM,MAAM;AAAA,EACd;AACA,SAAO;AACT;AAGA,KAAK,0BAA0B,SAAS,OAAO;AAC7C,MAAI,QAAQ,MAAM;AAClB,MAAI,KAAK;AACT,QAAM,eAAe;AACrB,SAAO,eAAe,KAAK,MAAM,QAAO,CAAE,GAAG;AAC3C,UAAM,eAAe,KAAK,MAAM,gBAAgB,KAAK;AACrD,UAAM,QAAO;AAAA,EACf;AACA,SAAO,MAAM,QAAQ;AACvB;AACA,SAAS,eAAe,IAAI;AAC1B,SAAO,MAAM,MAAgB,MAAM;AACrC;AAGA,KAAK,sBAAsB,SAAS,OAAO;AACzC,MAAI,QAAQ,MAAM;AAClB,MAAI,KAAK;AACT,QAAM,eAAe;AACrB,SAAO,WAAW,KAAK,MAAM,QAAO,CAAE,GAAG;AACvC,UAAM,eAAe,KAAK,MAAM,eAAe,SAAS,EAAE;AAC1D,UAAM,QAAO;AAAA,EACf;AACA,SAAO,MAAM,QAAQ;AACvB;AACA,SAAS,WAAW,IAAI;AACtB,SACG,MAAM,MAAgB,MAAM,MAC5B,MAAM,MAAgB,MAAM,MAC5B,MAAM,MAAgB,MAAM;AAEjC;AACA,SAAS,SAAS,IAAI;AACpB,MAAI,MAAM,MAAgB,MAAM,IAAc;AAC5C,WAAO,MAAM,KAAK;AAAA,EACpB;AACA,MAAI,MAAM,MAAgB,MAAM,KAAc;AAC5C,WAAO,MAAM,KAAK;AAAA,EACpB;AACA,SAAO,KAAK;AACd;AAIA,KAAK,sCAAsC,SAAS,OAAO;AACzD,MAAI,KAAK,qBAAqB,KAAK,GAAG;AACpC,QAAI,KAAK,MAAM;AACf,QAAI,KAAK,qBAAqB,KAAK,GAAG;AACpC,UAAI,KAAK,MAAM;AACf,UAAI,MAAM,KAAK,KAAK,qBAAqB,KAAK,GAAG;AAC/C,cAAM,eAAe,KAAK,KAAK,KAAK,IAAI,MAAM;AAAA,MAChD,OAAO;AACL,cAAM,eAAe,KAAK,IAAI;AAAA,MAChC;AAAA,IACF,OAAO;AACL,YAAM,eAAe;AAAA,IACvB;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAGA,KAAK,uBAAuB,SAAS,OAAO;AAC1C,MAAI,KAAK,MAAM,QAAO;AACtB,MAAI,aAAa,EAAE,GAAG;AACpB,UAAM,eAAe,KAAK;AAC1B,UAAM,QAAO;AACb,WAAO;AAAA,EACT;AACA,QAAM,eAAe;AACrB,SAAO;AACT;AACA,SAAS,aAAa,IAAI;AACxB,SAAO,MAAM,MAAgB,MAAM;AACrC;AAKA,KAAK,2BAA2B,SAAS,OAAOpK,SAAQ;AACtD,MAAI,QAAQ,MAAM;AAClB,QAAM,eAAe;AACrB,WAAS,IAAI,GAAG,IAAIA,SAAQ,EAAE,GAAG;AAC/B,QAAI,KAAK,MAAM,QAAO;AACtB,QAAI,CAAC,WAAW,EAAE,GAAG;AACnB,YAAM,MAAM;AACZ,aAAO;AAAA,IACT;AACA,UAAM,eAAe,KAAK,MAAM,eAAe,SAAS,EAAE;AAC1D,UAAM,QAAO;AAAA,EACf;AACA,SAAO;AACT;AAMA,IAAI,QAAQ,SAASgO,OAAM,GAAG;AAC5B,OAAK,OAAO,EAAE;AACd,OAAK,QAAQ,EAAE;AACf,OAAK,QAAQ,EAAE;AACf,OAAK,MAAM,EAAE;AACb,MAAI,EAAE,QAAQ,WACZ;AAAE,SAAK,MAAM,IAAI,eAAe,GAAG,EAAE,UAAU,EAAE,MAAM;AAAA,EAAG;AAC5D,MAAI,EAAE,QAAQ,QACZ;AAAE,SAAK,QAAQ,CAAC,EAAE,OAAO,EAAE,GAAG;AAAA,EAAG;AACrC;AAIA,IAAI,KAAK,OAAO;AAIhB,GAAG,OAAO,SAAS,+BAA+B;AAChD,MAAI,CAAC,iCAAiC,KAAK,KAAK,WAAW,KAAK,aAC9D;AAAE,SAAK,iBAAiB,KAAK,OAAO,gCAAgC,KAAK,KAAK,OAAO;AAAA,EAAG;AAC1F,MAAI,KAAK,QAAQ,SACf;AAAE,SAAK,QAAQ,QAAQ,IAAI,MAAM,IAAI,CAAC;AAAA,EAAG;AAE3C,OAAK,aAAa,KAAK;AACvB,OAAK,eAAe,KAAK;AACzB,OAAK,gBAAgB,KAAK;AAC1B,OAAK,kBAAkB,KAAK;AAC5B,OAAK,UAAS;AAChB;AAEA,GAAG,WAAW,WAAW;AACvB,OAAK,KAAI;AACT,SAAO,IAAI,MAAM,IAAI;AACvB;AAGA,IAAI,OAAO,WAAW,aACpB;AAAE,KAAG,OAAO,QAAQ,IAAI,WAAW;AACjC,QAAI,WAAW;AAEf,WAAO;AAAA,MACL,MAAM,WAAY;AAChB,YAAI,QAAQ,SAAS,SAAQ;AAC7B,eAAO;AAAA,UACL,MAAM,MAAM,SAAS,QAAQ;AAAA,UAC7B,OAAO;AAAA,QACjB;AAAA,MACM;AAAA,IACN;AAAA,EACE;AAAG;AAQL,GAAG,YAAY,WAAW;AACxB,MAAI,aAAa,KAAK,WAAU;AAChC,MAAI,CAAC,cAAc,CAAC,WAAW,eAAe;AAAE,SAAK,UAAS;AAAA,EAAI;AAElE,OAAK,QAAQ,KAAK;AAClB,MAAI,KAAK,QAAQ,WAAW;AAAE,SAAK,WAAW,KAAK,YAAW;AAAA,EAAI;AAClE,MAAI,KAAK,OAAO,KAAK,MAAM,QAAQ;AAAE,WAAO,KAAK,YAAY,QAAQ,GAAG;AAAA,EAAE;AAE1E,MAAI,WAAW,UAAU;AAAE,WAAO,WAAW,SAAS,IAAI;AAAA,EAAE,OACvD;AAAE,SAAK,UAAU,KAAK,kBAAiB,CAAE;AAAA,EAAG;AACnD;AAEA,GAAG,YAAY,SAAS,MAAM;AAG5B,MAAI,kBAAkB,MAAM,KAAK,QAAQ,eAAe,CAAC,KAAK,SAAS,IACrE;AAAE,WAAO,KAAK;EAAW;AAE3B,SAAO,KAAK,iBAAiB,IAAI;AACnC;AAEA,GAAG,oBAAoB,WAAW;AAChC,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,GAAG;AACzC,MAAI,QAAQ,SAAU,QAAQ,OAAQ;AAAE,WAAO;AAAA,EAAK;AACpD,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,SAAO,QAAQ,SAAU,QAAQ,QAAS,QAAQ,QAAQ,MAAM,OAAO;AACzE;AAEA,GAAG,mBAAmB,WAAW;AAC/B,MAAI,WAAW,KAAK,QAAQ,aAAa,KAAK,YAAW;AACzD,MAAI,QAAQ,KAAK,KAAK,MAAM,KAAK,MAAM,QAAQ,MAAM,KAAK,OAAO,CAAC;AAClE,MAAI,QAAQ,IAAI;AAAE,SAAK,MAAM,KAAK,MAAM,GAAG,sBAAsB;AAAA,EAAG;AACpE,OAAK,MAAM,MAAM;AACjB,MAAI,KAAK,QAAQ,WAAW;AAC1B,aAAS,YAAa,QAAS,MAAM,QAAQ,YAAY,cAAc,KAAK,OAAO,KAAK,KAAK,GAAG,KAAK,MAAK;AACxG,QAAE,KAAK;AACP,YAAM,KAAK,YAAY;AAAA,IACzB;AAAA,EACF;AACA,MAAI,KAAK,QAAQ,WACf;AAAE,SAAK,QAAQ;AAAA,MAAU;AAAA,MAAM,KAAK,MAAM,MAAM,QAAQ,GAAG,GAAG;AAAA,MAAG;AAAA,MAAO,KAAK;AAAA,MACtD;AAAA,MAAU,KAAK,YAAW;AAAA,IAAE;AAAA,EAAG;AAC1D;AAEA,GAAG,kBAAkB,SAAS,WAAW;AACvC,MAAI,QAAQ,KAAK;AACjB,MAAI,WAAW,KAAK,QAAQ,aAAa,KAAK,YAAW;AACzD,MAAI,KAAK,KAAK,MAAM,WAAW,KAAK,OAAO,SAAS;AACpD,SAAO,KAAK,MAAM,KAAK,MAAM,UAAU,CAAC,UAAU,EAAE,GAAG;AACrD,SAAK,KAAK,MAAM,WAAW,EAAE,KAAK,GAAG;AAAA,EACvC;AACA,MAAI,KAAK,QAAQ,WACf;AAAE,SAAK,QAAQ;AAAA,MAAU;AAAA,MAAO,KAAK,MAAM,MAAM,QAAQ,WAAW,KAAK,GAAG;AAAA,MAAG;AAAA,MAAO,KAAK;AAAA,MACpE;AAAA,MAAU,KAAK,YAAW;AAAA,IAAE;AAAA,EAAG;AAC1D;AAKA,GAAG,YAAY,WAAW;AACxB,OAAM,QAAO,KAAK,MAAM,KAAK,MAAM,QAAQ;AACzC,QAAI,KAAK,KAAK,MAAM,WAAW,KAAK,GAAG;AACvC,YAAQ,IAAE;AAAA,MACV,KAAK;AAAA,MAAI,KAAK;AACZ,UAAE,KAAK;AACP;AAAA,MACF,KAAK;AACH,YAAI,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,IAAI;AAC9C,YAAE,KAAK;AAAA,QACT;AAAA,MACF,KAAK;AAAA,MAAI,KAAK;AAAA,MAAM,KAAK;AACvB,UAAE,KAAK;AACP,YAAI,KAAK,QAAQ,WAAW;AAC1B,YAAE,KAAK;AACP,eAAK,YAAY,KAAK;AAAA,QACxB;AACA;AAAA,MACF,KAAK;AACH,gBAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,GAAC;AAAA,UAC3C,KAAK;AACH,iBAAK,iBAAgB;AACrB;AAAA,UACF,KAAK;AACH,iBAAK,gBAAgB,CAAC;AACtB;AAAA,UACF;AACE,kBAAM;AAAA,QACd;AACM;AAAA,MACF;AACE,YAAI,KAAK,KAAK,KAAK,MAAM,MAAM,QAAQ,mBAAmB,KAAK,OAAO,aAAa,EAAE,CAAC,GAAG;AACvF,YAAE,KAAK;AAAA,QACT,OAAO;AACL,gBAAM;AAAA,QACR;AAAA,IACN;AAAA,EACE;AACF;AAOA,GAAG,cAAc,SAAS,MAAM,KAAK;AACnC,OAAK,MAAM,KAAK;AAChB,MAAI,KAAK,QAAQ,WAAW;AAAE,SAAK,SAAS,KAAK,YAAW;AAAA,EAAI;AAChE,MAAI,WAAW,KAAK;AACpB,OAAK,OAAO;AACZ,OAAK,QAAQ;AAEb,OAAK,cAAc,QAAQ;AAC7B;AAWA,GAAG,gBAAgB,WAAW;AAC5B,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,QAAQ,MAAM,QAAQ,IAAI;AAAE,WAAO,KAAK,WAAW,IAAI;AAAA,EAAE;AAC7D,MAAI,QAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC9C,MAAI,KAAK,QAAQ,eAAe,KAAK,SAAS,MAAM,UAAU,IAAI;AAChE,SAAK,OAAO;AACZ,WAAO,KAAK,YAAY,QAAQ,QAAQ;AAAA,EAC1C,OAAO;AACL,MAAE,KAAK;AACP,WAAO,KAAK,YAAY,QAAQ,GAAG;AAAA,EACrC;AACF;AAEA,GAAG,kBAAkB,WAAW;AAC9B,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,KAAK,aAAa;AAAE,MAAE,KAAK;AAAK,WAAO,KAAK;EAAa;AAC7D,MAAI,SAAS,IAAI;AAAE,WAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,EAAE;AAC3D,SAAO,KAAK,SAAS,QAAQ,OAAO,CAAC;AACvC;AAEA,GAAG,4BAA4B,SAAS,MAAM;AAC5C,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,OAAO;AACX,MAAI,YAAY,SAAS,KAAK,QAAQ,OAAO,QAAQ;AAGrD,MAAI,KAAK,QAAQ,eAAe,KAAK,SAAS,MAAM,SAAS,IAAI;AAC/D,MAAE;AACF,gBAAY,QAAQ;AACpB,WAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAAA,EAC3C;AAEA,MAAI,SAAS,IAAI;AAAE,WAAO,KAAK,SAAS,QAAQ,QAAQ,OAAO,CAAC;AAAA,EAAE;AAClE,SAAO,KAAK,SAAS,WAAW,IAAI;AACtC;AAEA,GAAG,qBAAqB,SAAS,MAAM;AACrC,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,SAAS,MAAM;AACjB,QAAI,KAAK,QAAQ,eAAe,IAAI;AAClC,UAAI,QAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC9C,UAAI,UAAU,IAAI;AAAE,eAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,MAAE;AAAA,IAC9D;AACA,WAAO,KAAK,SAAS,SAAS,MAAM,QAAQ,YAAY,QAAQ,YAAY,CAAC;AAAA,EAC/E;AACA,MAAI,SAAS,IAAI;AAAE,WAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,EAAE;AAC3D,SAAO,KAAK,SAAS,SAAS,MAAM,QAAQ,YAAY,QAAQ,YAAY,CAAC;AAC/E;AAEA,GAAG,kBAAkB,WAAW;AAC9B,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,SAAS,IAAI;AAAE,WAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,EAAE;AAC3D,SAAO,KAAK,SAAS,QAAQ,YAAY,CAAC;AAC5C;AAEA,GAAG,qBAAqB,SAAS,MAAM;AACrC,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,SAAS,MAAM;AACjB,QAAI,SAAS,MAAM,CAAC,KAAK,YAAY,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,OACxE,KAAK,eAAe,KAAK,UAAU,KAAK,KAAK,MAAM,MAAM,KAAK,YAAY,KAAK,GAAG,CAAC,IAAI;AAE1F,WAAK,gBAAgB,CAAC;AACtB,WAAK,UAAS;AACd,aAAO,KAAK,UAAS;AAAA,IACvB;AACA,WAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,EACxC;AACA,MAAI,SAAS,IAAI;AAAE,WAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,EAAE;AAC3D,SAAO,KAAK,SAAS,QAAQ,SAAS,CAAC;AACzC;AAEA,GAAG,kBAAkB,SAAS,MAAM;AAClC,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,OAAO;AACX,MAAI,SAAS,MAAM;AACjB,WAAO,SAAS,MAAM,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,KAAK,IAAI;AACvE,QAAI,KAAK,MAAM,WAAW,KAAK,MAAM,IAAI,MAAM,IAAI;AAAE,aAAO,KAAK,SAAS,QAAQ,QAAQ,OAAO,CAAC;AAAA,IAAE;AACpG,WAAO,KAAK,SAAS,QAAQ,UAAU,IAAI;AAAA,EAC7C;AACA,MAAI,SAAS,MAAM,SAAS,MAAM,CAAC,KAAK,YAAY,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,MACxF,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,IAAI;AAE9C,SAAK,gBAAgB,CAAC;AACtB,SAAK,UAAS;AACd,WAAO,KAAK,UAAS;AAAA,EACvB;AACA,MAAI,SAAS,IAAI;AAAE,WAAO;AAAA,EAAG;AAC7B,SAAO,KAAK,SAAS,QAAQ,YAAY,IAAI;AAC/C;AAEA,GAAG,oBAAoB,SAAS,MAAM;AACpC,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,MAAI,SAAS,IAAI;AAAE,WAAO,KAAK,SAAS,QAAQ,UAAU,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,KAAK,IAAI,CAAC;AAAA,EAAE;AAC9G,MAAI,SAAS,MAAM,SAAS,MAAM,KAAK,QAAQ,eAAe,GAAG;AAC/D,SAAK,OAAO;AACZ,WAAO,KAAK,YAAY,QAAQ,KAAK;AAAA,EACvC;AACA,SAAO,KAAK,SAAS,SAAS,KAAK,QAAQ,KAAK,QAAQ,QAAQ,CAAC;AACnE;AAEA,GAAG,qBAAqB,WAAW;AACjC,MAAI,cAAc,KAAK,QAAQ;AAC/B,MAAI,eAAe,IAAI;AACrB,QAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,QAAI,SAAS,IAAI;AACf,UAAI,QAAQ,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC9C,UAAI,QAAQ,MAAM,QAAQ,IAAI;AAAE,eAAO,KAAK,SAAS,QAAQ,aAAa,CAAC;AAAA,MAAE;AAAA,IAC/E;AACA,QAAI,SAAS,IAAI;AACf,UAAI,eAAe,IAAI;AACrB,YAAI,UAAU,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAChD,YAAI,YAAY,IAAI;AAAE,iBAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,QAAE;AAAA,MAChE;AACA,aAAO,KAAK,SAAS,QAAQ,UAAU,CAAC;AAAA,IAC1C;AAAA,EACF;AACA,SAAO,KAAK,SAAS,QAAQ,UAAU,CAAC;AAC1C;AAEA,GAAG,uBAAuB,WAAW;AACnC,MAAI,cAAc,KAAK,QAAQ;AAC/B,MAAI,OAAO;AACX,MAAI,eAAe,IAAI;AACrB,MAAE,KAAK;AACP,WAAO,KAAK,kBAAiB;AAC7B,QAAI,kBAAkB,MAAM,IAAI,KAAK,SAAS,IAAc;AAC1D,aAAO,KAAK,YAAY,QAAQ,WAAW,KAAK,UAAS,CAAE;AAAA,IAC7D;AAAA,EACF;AAEA,OAAK,MAAM,KAAK,KAAK,2BAA2B,kBAAkB,IAAI,IAAI,GAAG;AAC/E;AAEA,GAAG,mBAAmB,SAAS,MAAM;AACnC,UAAQ,MAAI;AAAA;AAAA;AAAA,IAGZ,KAAK;AACH,aAAO,KAAK,cAAa;AAAA;AAAA,IAG3B,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,MAAM;AAAA,IAC3D,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,MAAM;AAAA,IAC3D,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,IAAI;AAAA,IACzD,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,KAAK;AAAA,IAC1D,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,QAAQ;AAAA,IAC7D,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,QAAQ;AAAA,IAC7D,KAAK;AAAK,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,MAAM;AAAA,IAC5D,KAAK;AAAK,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,MAAM;AAAA,IAC5D,KAAK;AAAI,QAAE,KAAK;AAAK,aAAO,KAAK,YAAY,QAAQ,KAAK;AAAA,IAE1D,KAAK;AACH,UAAI,KAAK,QAAQ,cAAc,GAAG;AAAE;AAAA,MAAM;AAC1C,QAAE,KAAK;AACP,aAAO,KAAK,YAAY,QAAQ,SAAS;AAAA,IAE3C,KAAK;AACH,UAAI,OAAO,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC;AAC7C,UAAI,SAAS,OAAO,SAAS,IAAI;AAAE,eAAO,KAAK,gBAAgB,EAAE;AAAA,MAAE;AACnE,UAAI,KAAK,QAAQ,eAAe,GAAG;AACjC,YAAI,SAAS,OAAO,SAAS,IAAI;AAAE,iBAAO,KAAK,gBAAgB,CAAC;AAAA,QAAE;AAClE,YAAI,SAAS,MAAM,SAAS,IAAI;AAAE,iBAAO,KAAK,gBAAgB,CAAC;AAAA,QAAE;AAAA,MACnE;AAAA;AAAA;AAAA,IAIF,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAAA,IAAI,KAAK;AAC3E,aAAO,KAAK,WAAW,KAAK;AAAA;AAAA,IAG9B,KAAK;AAAA,IAAI,KAAK;AACZ,aAAO,KAAK,WAAW,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,IAM7B,KAAK;AACH,aAAO,KAAK,gBAAe;AAAA,IAE7B,KAAK;AAAA,IAAI,KAAK;AACZ,aAAO,KAAK,0BAA0B,IAAI;AAAA,IAE5C,KAAK;AAAA,IAAK,KAAK;AACb,aAAO,KAAK,mBAAmB,IAAI;AAAA,IAErC,KAAK;AACH,aAAO,KAAK,gBAAe;AAAA,IAE7B,KAAK;AAAA,IAAI,KAAK;AACZ,aAAO,KAAK,mBAAmB,IAAI;AAAA,IAErC,KAAK;AAAA,IAAI,KAAK;AACZ,aAAO,KAAK,gBAAgB,IAAI;AAAA,IAElC,KAAK;AAAA,IAAI,KAAK;AACZ,aAAO,KAAK,kBAAkB,IAAI;AAAA,IAEpC,KAAK;AACH,aAAO,KAAK,mBAAkB;AAAA,IAEhC,KAAK;AACH,aAAO,KAAK,SAAS,QAAQ,QAAQ,CAAC;AAAA,IAExC,KAAK;AACH,aAAO,KAAK,qBAAoB;AAAA,EACpC;AAEE,OAAK,MAAM,KAAK,KAAK,2BAA2B,kBAAkB,IAAI,IAAI,GAAG;AAC/E;AAEA,GAAG,WAAW,SAAS,MAAM,MAAM;AACjC,MAAI,MAAM,KAAK,MAAM,MAAM,KAAK,KAAK,KAAK,MAAM,IAAI;AACpD,OAAK,OAAO;AACZ,SAAO,KAAK,YAAY,MAAM,GAAG;AACnC;AAEA,GAAG,aAAa,WAAW;AACzB,MAAI,SAAS,SAAS,QAAQ,KAAK;AACnC,aAAS;AACP,QAAI,KAAK,OAAO,KAAK,MAAM,QAAQ;AAAE,WAAK,MAAM,OAAO,iCAAiC;AAAA,IAAG;AAC3F,QAAI,KAAK,KAAK,MAAM,OAAO,KAAK,GAAG;AACnC,QAAI,UAAU,KAAK,EAAE,GAAG;AAAE,WAAK,MAAM,OAAO,iCAAiC;AAAA,IAAG;AAChF,QAAI,CAAC,SAAS;AACZ,UAAI,OAAO,KAAK;AAAE,kBAAU;AAAA,MAAM,WACzB,OAAO,OAAO,SAAS;AAAE,kBAAU;AAAA,MAAO,WAC1C,OAAO,OAAO,CAAC,SAAS;AAAE;AAAA,MAAM;AACzC,gBAAU,OAAO;AAAA,IACnB,OAAO;AAAE,gBAAU;AAAA,IAAO;AAC1B,MAAE,KAAK;AAAA,EACT;AACA,MAAI,UAAU,KAAK,MAAM,MAAM,OAAO,KAAK,GAAG;AAC9C,IAAE,KAAK;AACP,MAAI,aAAa,KAAK;AACtB,MAAI,QAAQ,KAAK,UAAS;AAC1B,MAAI,KAAK,aAAa;AAAE,SAAK,WAAW,UAAU;AAAA,EAAG;AAGrD,MAAI,QAAQ,KAAK,gBAAgB,KAAK,cAAc,IAAI,sBAAsB,IAAI;AAClF,QAAM,MAAM,OAAO,SAAS,KAAK;AACjC,OAAK,oBAAoB,KAAK;AAC9B,OAAK,sBAAsB,KAAK;AAGhC,MAAI7O,SAAQ;AACZ,MAAI;AACF,IAAAA,SAAQ,IAAI,OAAO,SAAS,KAAK;AAAA,EACnC,SAAS,GAAG;AAAA,EAGZ;AAEA,SAAO,KAAK,YAAY,QAAQ,QAAQ,EAAC,SAAkB,OAAc,OAAOA,OAAK,CAAC;AACxF;AAMA,GAAG,UAAU,SAAS,OAAO,KAAK,gCAAgC;AAEhE,MAAI,kBAAkB,KAAK,QAAQ,eAAe,MAAM,QAAQ;AAKhE,MAAI,8BAA8B,kCAAkC,KAAK,MAAM,WAAW,KAAK,GAAG,MAAM;AAExG,MAAI,QAAQ,KAAK,KAAK,QAAQ,GAAG,WAAW;AAC5C,WAAS,IAAI,GAAG,IAAI,OAAO,OAAO,WAAW,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,KAAK,KAAK;AACxE,QAAI,OAAO,KAAK,MAAM,WAAW,KAAK,GAAG,GAAG,MAAO;AAEnD,QAAI,mBAAmB,SAAS,IAAI;AAClC,UAAI,6BAA6B;AAAE,aAAK,iBAAiB,KAAK,KAAK,mEAAmE;AAAA,MAAG;AACzI,UAAI,aAAa,IAAI;AAAE,aAAK,iBAAiB,KAAK,KAAK,kDAAkD;AAAA,MAAG;AAC5G,UAAI,MAAM,GAAG;AAAE,aAAK,iBAAiB,KAAK,KAAK,yDAAyD;AAAA,MAAG;AAC3G,iBAAW;AACX;AAAA,IACF;AAEA,QAAI,QAAQ,IAAI;AAAE,YAAM,OAAO,KAAK;AAAA,IAAI,WAC/B,QAAQ,IAAI;AAAE,YAAM,OAAO,KAAK;AAAA,IAAI,WACpC,QAAQ,MAAM,QAAQ,IAAI;AAAE,YAAM,OAAO;AAAA,IAAI,OACjD;AAAE,YAAM;AAAA,IAAU;AACvB,QAAI,OAAO,OAAO;AAAE;AAAA,IAAM;AAC1B,eAAW;AACX,YAAQ,QAAQ,QAAQ;AAAA,EAC1B;AAEA,MAAI,mBAAmB,aAAa,IAAI;AAAE,SAAK,iBAAiB,KAAK,MAAM,GAAG,wDAAwD;AAAA,EAAG;AACzI,MAAI,KAAK,QAAQ,SAAS,OAAO,QAAQ,KAAK,MAAM,UAAU,KAAK;AAAE,WAAO;AAAA,EAAK;AAEjF,SAAO;AACT;AAEA,SAAS,eAAe,KAAK,6BAA6B;AACxD,MAAI,6BAA6B;AAC/B,WAAO,SAAS,KAAK,CAAC;AAAA,EACxB;AAGA,SAAO,WAAW,IAAI,QAAQ,MAAM,EAAE,CAAC;AACzC;AAEA,SAAS,eAAe,KAAK;AAC3B,MAAI,OAAO,WAAW,YAAY;AAChC,WAAO;AAAA,EACT;AAGA,SAAO,OAAO,IAAI,QAAQ,MAAM,EAAE,CAAC;AACrC;AAEA,GAAG,kBAAkB,SAAS,OAAO;AACnC,MAAI,QAAQ,KAAK;AACjB,OAAK,OAAO;AACZ,MAAI,MAAM,KAAK,QAAQ,KAAK;AAC5B,MAAI,OAAO,MAAM;AAAE,SAAK,MAAM,KAAK,QAAQ,GAAG,8BAA8B,KAAK;AAAA,EAAG;AACpF,MAAI,KAAK,QAAQ,eAAe,MAAM,KAAK,MAAM,WAAW,KAAK,GAAG,MAAM,KAAK;AAC7E,UAAM,eAAe,KAAK,MAAM,MAAM,OAAO,KAAK,GAAG,CAAC;AACtD,MAAE,KAAK;AAAA,EACT,WAAW,kBAAkB,KAAK,kBAAiB,CAAE,GAAG;AAAE,SAAK,MAAM,KAAK,KAAK,kCAAkC;AAAA,EAAG;AACpH,SAAO,KAAK,YAAY,QAAQ,KAAK,GAAG;AAC1C;AAIA,GAAG,aAAa,SAAS,eAAe;AACtC,MAAI,QAAQ,KAAK;AACjB,MAAI,CAAC,iBAAiB,KAAK,QAAQ,IAAI,QAAW,IAAI,MAAM,MAAM;AAAE,SAAK,MAAM,OAAO,gBAAgB;AAAA,EAAG;AACzG,MAAI,QAAQ,KAAK,MAAM,SAAS,KAAK,KAAK,MAAM,WAAW,KAAK,MAAM;AACtE,MAAI,SAAS,KAAK,QAAQ;AAAE,SAAK,MAAM,OAAO,gBAAgB;AAAA,EAAG;AACjE,MAAI,OAAO,KAAK,MAAM,WAAW,KAAK,GAAG;AACzC,MAAI,CAAC,SAAS,CAAC,iBAAiB,KAAK,QAAQ,eAAe,MAAM,SAAS,KAAK;AAC9E,QAAI,QAAQ,eAAe,KAAK,MAAM,MAAM,OAAO,KAAK,GAAG,CAAC;AAC5D,MAAE,KAAK;AACP,QAAI,kBAAkB,KAAK,kBAAiB,CAAE,GAAG;AAAE,WAAK,MAAM,KAAK,KAAK,kCAAkC;AAAA,IAAG;AAC7G,WAAO,KAAK,YAAY,QAAQ,KAAK,KAAK;AAAA,EAC5C;AACA,MAAI,SAAS,OAAO,KAAK,KAAK,MAAM,MAAM,OAAO,KAAK,GAAG,CAAC,GAAG;AAAE,YAAQ;AAAA,EAAO;AAC9E,MAAI,SAAS,MAAM,CAAC,OAAO;AACzB,MAAE,KAAK;AACP,SAAK,QAAQ,EAAE;AACf,WAAO,KAAK,MAAM,WAAW,KAAK,GAAG;AAAA,EACvC;AACA,OAAK,SAAS,MAAM,SAAS,QAAQ,CAAC,OAAO;AAC3C,WAAO,KAAK,MAAM,WAAW,EAAE,KAAK,GAAG;AACvC,QAAI,SAAS,MAAM,SAAS,IAAI;AAAE,QAAE,KAAK;AAAA,IAAK;AAC9C,QAAI,KAAK,QAAQ,EAAE,MAAM,MAAM;AAAE,WAAK,MAAM,OAAO,gBAAgB;AAAA,IAAG;AAAA,EACxE;AACA,MAAI,kBAAkB,KAAK,kBAAiB,CAAE,GAAG;AAAE,SAAK,MAAM,KAAK,KAAK,kCAAkC;AAAA,EAAG;AAE7G,MAAI,MAAM,eAAe,KAAK,MAAM,MAAM,OAAO,KAAK,GAAG,GAAG,KAAK;AACjE,SAAO,KAAK,YAAY,QAAQ,KAAK,GAAG;AAC1C;AAIA,GAAG,gBAAgB,WAAW;AAC5B,MAAI,KAAK,KAAK,MAAM,WAAW,KAAK,GAAG,GAAG;AAE1C,MAAI,OAAO,KAAK;AACd,QAAI,KAAK,QAAQ,cAAc,GAAG;AAAE,WAAK,WAAU;AAAA,IAAI;AACvD,QAAI,UAAU,EAAE,KAAK;AACrB,WAAO,KAAK,YAAY,KAAK,MAAM,QAAQ,KAAK,KAAK,GAAG,IAAI,KAAK,GAAG;AACpE,MAAE,KAAK;AACP,QAAI,OAAO,SAAU;AAAE,WAAK,mBAAmB,SAAS,0BAA0B;AAAA,IAAG;AAAA,EACvF,OAAO;AACL,WAAO,KAAK,YAAY,CAAC;AAAA,EAC3B;AACA,SAAO;AACT;AAEA,GAAG,aAAa,SAAS,OAAO;AAC9B,MAAI,MAAM,IAAI,aAAa,EAAE,KAAK;AAClC,aAAS;AACP,QAAI,KAAK,OAAO,KAAK,MAAM,QAAQ;AAAE,WAAK,MAAM,KAAK,OAAO,8BAA8B;AAAA,IAAG;AAC7F,QAAI,KAAK,KAAK,MAAM,WAAW,KAAK,GAAG;AACvC,QAAI,OAAO,OAAO;AAAE;AAAA,IAAM;AAC1B,QAAI,OAAO,IAAI;AACb,aAAO,KAAK,MAAM,MAAM,YAAY,KAAK,GAAG;AAC5C,aAAO,KAAK,gBAAgB,KAAK;AACjC,mBAAa,KAAK;AAAA,IACpB,WAAW,OAAO,QAAU,OAAO,MAAQ;AACzC,UAAI,KAAK,QAAQ,cAAc,IAAI;AAAE,aAAK,MAAM,KAAK,OAAO,8BAA8B;AAAA,MAAG;AAC7F,QAAE,KAAK;AACP,UAAI,KAAK,QAAQ,WAAW;AAC1B,aAAK;AACL,aAAK,YAAY,KAAK;AAAA,MACxB;AAAA,IACF,OAAO;AACL,UAAI,UAAU,EAAE,GAAG;AAAE,aAAK,MAAM,KAAK,OAAO,8BAA8B;AAAA,MAAG;AAC7E,QAAE,KAAK;AAAA,IACT;AAAA,EACF;AACA,SAAO,KAAK,MAAM,MAAM,YAAY,KAAK,KAAK;AAC9C,SAAO,KAAK,YAAY,QAAQ,QAAQ,GAAG;AAC7C;AAIA,IAAI,gCAAgC,CAAA;AAEpC,GAAG,uBAAuB,WAAW;AACnC,OAAK,oBAAoB;AACzB,MAAI;AACF,SAAK,cAAa;AAAA,EACpB,SAAS,KAAK;AACZ,QAAI,QAAQ,+BAA+B;AACzC,WAAK,yBAAwB;AAAA,IAC/B,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AAEA,OAAK,oBAAoB;AAC3B;AAEA,GAAG,qBAAqB,SAAS,UAAU,SAAS;AAClD,MAAI,KAAK,qBAAqB,KAAK,QAAQ,eAAe,GAAG;AAC3D,UAAM;AAAA,EACR,OAAO;AACL,SAAK,MAAM,UAAU,OAAO;AAAA,EAC9B;AACF;AAEA,GAAG,gBAAgB,WAAW;AAC5B,MAAI,MAAM,IAAI,aAAa,KAAK;AAChC,aAAS;AACP,QAAI,KAAK,OAAO,KAAK,MAAM,QAAQ;AAAE,WAAK,MAAM,KAAK,OAAO,uBAAuB;AAAA,IAAG;AACtF,QAAI,KAAK,KAAK,MAAM,WAAW,KAAK,GAAG;AACvC,QAAI,OAAO,MAAM,OAAO,MAAM,KAAK,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,KAAK;AACzE,UAAI,KAAK,QAAQ,KAAK,UAAU,KAAK,SAAS,QAAQ,YAAY,KAAK,SAAS,QAAQ,kBAAkB;AACxG,YAAI,OAAO,IAAI;AACb,eAAK,OAAO;AACZ,iBAAO,KAAK,YAAY,QAAQ,YAAY;AAAA,QAC9C,OAAO;AACL,YAAE,KAAK;AACP,iBAAO,KAAK,YAAY,QAAQ,SAAS;AAAA,QAC3C;AAAA,MACF;AACA,aAAO,KAAK,MAAM,MAAM,YAAY,KAAK,GAAG;AAC5C,aAAO,KAAK,YAAY,QAAQ,UAAU,GAAG;AAAA,IAC/C;AACA,QAAI,OAAO,IAAI;AACb,aAAO,KAAK,MAAM,MAAM,YAAY,KAAK,GAAG;AAC5C,aAAO,KAAK,gBAAgB,IAAI;AAChC,mBAAa,KAAK;AAAA,IACpB,WAAW,UAAU,EAAE,GAAG;AACxB,aAAO,KAAK,MAAM,MAAM,YAAY,KAAK,GAAG;AAC5C,QAAE,KAAK;AACP,cAAQ,IAAE;AAAA,QACV,KAAK;AACH,cAAI,KAAK,MAAM,WAAW,KAAK,GAAG,MAAM,IAAI;AAAE,cAAE,KAAK;AAAA,UAAK;AAAA,QAC5D,KAAK;AACH,iBAAO;AACP;AAAA,QACF;AACE,iBAAO,OAAO,aAAa,EAAE;AAC7B;AAAA,MACR;AACM,UAAI,KAAK,QAAQ,WAAW;AAC1B,UAAE,KAAK;AACP,aAAK,YAAY,KAAK;AAAA,MACxB;AACA,mBAAa,KAAK;AAAA,IACpB,OAAO;AACL,QAAE,KAAK;AAAA,IACT;AAAA,EACF;AACF;AAGA,GAAG,2BAA2B,WAAW;AACvC,SAAO,KAAK,MAAM,KAAK,MAAM,QAAQ,KAAK,OAAO;AAC/C,YAAQ,KAAK,MAAM,KAAK,GAAG,GAAC;AAAA,MAC5B,KAAK;AACH,UAAE,KAAK;AACP;AAAA,MAEF,KAAK;AACH,YAAI,KAAK,MAAM,KAAK,MAAM,CAAC,MAAM,KAAK;AAAE;AAAA,QAAM;AAAA;AAAA,MAEhD,KAAK;AACH,eAAO,KAAK,YAAY,QAAQ,iBAAiB,KAAK,MAAM,MAAM,KAAK,OAAO,KAAK,GAAG,CAAC;AAAA,MAEzF,KAAK;AACH,YAAI,KAAK,MAAM,KAAK,MAAM,CAAC,MAAM,MAAM;AAAE,YAAE,KAAK;AAAA,QAAK;AAAA;AAAA,MAEvD,KAAK;AAAA,MAAM,KAAK;AAAA,MAAU,KAAK;AAC7B,UAAE,KAAK;AACP,aAAK,YAAY,KAAK,MAAM;AAC5B;AAAA,IACN;AAAA,EACE;AACA,OAAK,MAAM,KAAK,OAAO,uBAAuB;AAChD;AAIA,GAAG,kBAAkB,SAAS,YAAY;AACxC,MAAI,KAAK,KAAK,MAAM,WAAW,EAAE,KAAK,GAAG;AACzC,IAAE,KAAK;AACP,UAAQ,IAAE;AAAA,IACV,KAAK;AAAK,aAAO;AAAA;AAAA,IACjB,KAAK;AAAK,aAAO;AAAA;AAAA,IACjB,KAAK;AAAK,aAAO,OAAO,aAAa,KAAK,YAAY,CAAC,CAAC;AAAA;AAAA,IACxD,KAAK;AAAK,aAAO,kBAAkB,KAAK,cAAa,CAAE;AAAA;AAAA,IACvD,KAAK;AAAK,aAAO;AAAA;AAAA,IACjB,KAAK;AAAI,aAAO;AAAA;AAAA,IAChB,KAAK;AAAK,aAAO;AAAA;AAAA,IACjB,KAAK;AAAK,aAAO;AAAA;AAAA,IACjB,KAAK;AAAI,UAAI,KAAK,MAAM,WAAW,KAAK,GAAG,MAAM,IAAI;AAAE,UAAE,KAAK;AAAA,MAAK;AAAA;AAAA,IACnE,KAAK;AACH,UAAI,KAAK,QAAQ,WAAW;AAAE,aAAK,YAAY,KAAK;AAAK,UAAE,KAAK;AAAA,MAAS;AACzE,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AACH,UAAI,KAAK,QAAQ;AACf,aAAK;AAAA,UACH,KAAK,MAAM;AAAA,UACX;AAAA,QACR;AAAA,MACI;AACA,UAAI,YAAY;AACd,YAAI,UAAU,KAAK,MAAM;AAEzB,aAAK;AAAA,UACH;AAAA,UACA;AAAA,QACR;AAAA,MACI;AAAA,IACF;AACE,UAAI,MAAM,MAAM,MAAM,IAAI;AACxB,YAAI,WAAW,KAAK,MAAM,OAAO,KAAK,MAAM,GAAG,CAAC,EAAE,MAAM,SAAS,EAAE,CAAC;AACpE,YAAI,QAAQ,SAAS,UAAU,CAAC;AAChC,YAAI,QAAQ,KAAK;AACf,qBAAW,SAAS,MAAM,GAAG,EAAE;AAC/B,kBAAQ,SAAS,UAAU,CAAC;AAAA,QAC9B;AACA,aAAK,OAAO,SAAS,SAAS;AAC9B,aAAK,KAAK,MAAM,WAAW,KAAK,GAAG;AACnC,aAAK,aAAa,OAAO,OAAO,MAAM,OAAO,QAAQ,KAAK,UAAU,aAAa;AAC/E,eAAK;AAAA,YACH,KAAK,MAAM,IAAI,SAAS;AAAA,YACxB,aACI,qCACA;AAAA,UACd;AAAA,QACM;AACA,eAAO,OAAO,aAAa,KAAK;AAAA,MAClC;AACA,UAAI,UAAU,EAAE,GAAG;AAGjB,YAAI,KAAK,QAAQ,WAAW;AAAE,eAAK,YAAY,KAAK;AAAK,YAAE,KAAK;AAAA,QAAS;AACzE,eAAO;AAAA,MACT;AACA,aAAO,OAAO,aAAa,EAAE;AAAA,EACjC;AACA;AAIA,GAAG,cAAc,SAAS,KAAK;AAC7B,MAAI,UAAU,KAAK;AACnB,MAAI,IAAI,KAAK,QAAQ,IAAI,GAAG;AAC5B,MAAI,MAAM,MAAM;AAAE,SAAK,mBAAmB,SAAS,+BAA+B;AAAA,EAAG;AACrF,SAAO;AACT;AAQA,GAAG,YAAY,WAAW;AACxB,OAAK,cAAc;AACnB,MAAI,OAAO,IAAI,QAAQ,MAAM,aAAa,KAAK;AAC/C,MAAI,SAAS,KAAK,QAAQ,eAAe;AACzC,SAAO,KAAK,MAAM,KAAK,MAAM,QAAQ;AACnC,QAAI,KAAK,KAAK,kBAAiB;AAC/B,QAAI,iBAAiB,IAAI,MAAM,GAAG;AAChC,WAAK,OAAO,MAAM,QAAS,IAAI;AAAA,IACjC,WAAW,OAAO,IAAI;AACpB,WAAK,cAAc;AACnB,cAAQ,KAAK,MAAM,MAAM,YAAY,KAAK,GAAG;AAC7C,UAAI,WAAW,KAAK;AACpB,UAAI,KAAK,MAAM,WAAW,EAAE,KAAK,GAAG,MAAM,KACxC;AAAE,aAAK,mBAAmB,KAAK,KAAK,2CAA2C;AAAA,MAAG;AACpF,QAAE,KAAK;AACP,UAAI,MAAM,KAAK,cAAa;AAC5B,UAAI,EAAE,QAAQ,oBAAoB,kBAAkB,KAAK,MAAM,GAC7D;AAAE,aAAK,mBAAmB,UAAU,wBAAwB;AAAA,MAAG;AACjE,cAAQ,kBAAkB,GAAG;AAC7B,mBAAa,KAAK;AAAA,IACpB,OAAO;AACL;AAAA,IACF;AACA,YAAQ;AAAA,EACV;AACA,SAAO,OAAO,KAAK,MAAM,MAAM,YAAY,KAAK,GAAG;AACrD;AAKA,GAAG,WAAW,WAAW;AACvB,MAAI,OAAO,KAAK,UAAS;AACzB,MAAI,OAAO,QAAQ;AACnB,MAAI,KAAK,SAAS,KAAK,IAAI,GAAG;AAC5B,WAAO,SAAS,IAAI;AAAA,EACtB;AACA,SAAO,KAAK,YAAY,MAAM,IAAI;AACpC;AAiBA,IAAI,UAAU;AAEd,OAAO,QAAQ;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,EACV,cAAc;AAAA,EACd;AAAA,EACA,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAQA,SAASgM,QAAM,OAAO,SAAS;AAC7B,SAAO,OAAO,MAAM,OAAO,OAAO;AACpC;ACvkMO,MAAM,YAAY;AAAA,EACvB,WAAW;AAAA,EACX,UAAW;AAAA,EACX,KAAW;AAAA,EACX,GAAW;AAAA,EACX,KAAW;AAAA,EACX,MAAW;AAAA,EACX,OAAW;AAAA,EACX,QAAW;AAAA,EACX,IAAW;AAAA,EACX,SAAW;AAAA,EACX,OAAW;AACb;ACRO,SAAS,SAAShM,QAAO;AAC9B,SAAO,OAAOA,WAAU;AAC1B;ACsBA,MAAM,aAAa,EAAE,aAAa,GAAE;AACpC,MAAM,mBAAmB;AACzB,MAAM,mBAAmB;AACzB,MAAM,oBAAoB;AAC1B,MAAM,oBAAoB;AAE1B,MAAM,KAAK,SAAO,CAAC,MAAM,QAAQ,IAAI,MAAM,MAAM,MAAM,cAAc;AACrE,MAAM,kBAAkB,GAAG,oBAAoB;AAC/C,MAAM,eAAe,GAAG,iBAAiB;AACzC,MAAM,iBAAiB;AACvB,MAAM,eAAe;AACrB,MAAM,iBAAiB,eAAe;AACtC,MAAM,iBAAiB;AACvB,MAAM,eAAe;AACrB,MAAM,qBAAqB;AAC3B,MAAM,cAAc;AACpB,MAAM,iBAAiB;AACvB,MAAM,oBAAoB;AAC1B,MAAM,oBAAoB;AAC1B,MAAM,oBAAoB;AAC1B,MAAM,gBAAgB;AACtB,MAAM,eAAe;AACrB,MAAM,mBAAmB;AACzB,MAAM,qBAAqB;AAC3B,MAAM,sBAAsB;AAAA,QAAW,aAAa,KAAK,YAAY,QAAQ,gBAAgB;AAC7F,MAAM,sBAAsB;AAAA,QAAW,aAAa,KAAK,YAAY,QAAQ,kBAAkB;AAC/F,MAAM,mBAAmB,OAAO,UAAU;AAEnC,SAAS,gBAAgB,KAAK,MAAM;AACzC,QAAM,MAAM,SAAS,IAAI;AACzB,MAAI,OAAO,IAAI,OAAO;AACtB,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,MAAM;AACV,MAAI,QAAQ,oBAAI,IAAG;AACnB,MAAI,YAAY,oBAAI,IAAG;AACvB,MAAI,YAAY,oBAAI,IAAG;AAIvB,MAAI,qBAAqB,IAAI,GAAG;AAC9B,kBAAc,MAAM,GAAG;AACvB,WAAO,KAAK;AAAA,EACd,WAAW,IAAI,MAAM;AACnB,QAAI,MAAM,IAAI,IAAI,SAAS,iBAAiB;AAC5C,QAAI,MAAM,IAAI,IAAI,SAAS,iBAAiB;AAC5C,QAAI,MAAM,IAAI,IAAI,SAAS,gBAAgB;AAAA,EAC7C,OAAO;AACL,QAAI,MAAM,IAAI,IAAI,QAAQ,gBAAgB;AAC1C,QAAI,MAAM,IAAI,IAAI,SAAS,gBAAgB;AAAA,EAC7C;AAGA,OAAK,MAAM,KAAK,QAAQ;AAExB,SAAO,IAAI;AACb;AAEA,SAAS,SAAS,MAAM;AACtB,MAAI;AACF,UAAM,OAAO,KAAK,QAAQ,SAAS,IAAI,IACnCsL,UAAQ,IAAI,IAAIsB,WAAS,IAAI,IAC7B;AAEJ,WAAOZ,QAAM,SAAS,IAAI,KAAK,UAAU,EAAE,KAAK,CAAC,EAAE,WAAW;AAAA,EAChE,SAAS,KAAK;AACZ,UAAM,2BAA2B,OAAK,EAAE,EAAE;AAAA,EAC5C;AACF;AAEA,SAAS,SAAS,MAAM;AACtB,QAAM,MAAM,KAAK,UAAU,OAAK,EAAE;AAClC,SAAO,EAAE,KAAK,SAAS,KAAK,QAAQ,GAAG,MAAM,YAAY,GAAG;AAC9D;AAEA,MAAM,WAAW;AAAA,EACf,qBAAqB,GAAG,sBAAsB;AAAA,EAC9C,cAAc,GAAG,WAAW;AAAA,EAC5B,gBAAgB,GAAG,cAAc;AAAA,EACjC,gBAAgB,GAAG,cAAc;AAAA,EACjC,gBAAgB,GAAG,aAAa;AAAA,EAChC,kBAAkB,GAAG,gBAAgB;AAAA,EACrC,iBAAiB,GAAG,mBAAmB;AAAA,EACvC,yBAAyB,GAAG,sBAAsB;AAAA,EAClD,sBAAsB,GAAG,aAAa;AAAA,EACtC,oBAAoB,GAAG,sBAAsB;AAAA,EAC7C,eAAe,GAAG,cAAc;AAAA,EAChC,kBAAkB,GAAG,oBAAoB;AAAA,EAEzC,mBAAmB,MAAM,KAAK;AAC5B,sBAAkB,KAAK,IAAI,GAAG;AAAA,EAChC;AAAA,EACA,WAAW,MAAM,KAAK,QAAQ;AAC5B,QAAI,iBAAiB,MAAM,KAAK,MAAM,KAAK,CAAC,IAAI,MAAM,IAAI,KAAK,IAAI,GAAG;AAGpE,UAAI,MAAM,MAAM,gBAAgB,mBAAmB;AAAA,IACrD;AAAA,EACF;AAAA,EACA,eAAe,MAAM,KAAK;AACxB,UAAM5F,QAAO,aAAa,KAAK,MAAM;AACrC,UAAM,MAAM,aAAaA,KAAI,KAAK,UAAUA,KAAI;AAGhD,QAAI,KAAK;AACP,WAAK,IAAI,QAAQ,IAAI,cAAc,UAAU,aAAaA,KAAI,GAAG;AAC/D,wBAAgB,MAAM,GAAG;AAAA,MAC3B;AACA,WAAK,IAAI,QAAQ,IAAI,WAAW,UAAU,UAAUA,KAAI,GAAG;AACzD,qBAAa,MAAM,GAAG;AAAA,MACxB;AAEA,UAAI,MAAM;AACV,UAAI,IAAI,KAAK;AACX,2BAAmB,MAAMA,OAAM,GAAG;AAClC,aAAK,UAAU,QAAQ,SAAO,KAAK,KAAK,KAAK,UAAU,CAAC;AAAA,MAC1D,OAAO;AACL,cAAM2G,MAAK,IAAI,GAAG,cAAc,KAAK,KAAK3G,OAAM,KAAK,SAAS,CAAC;AAC/D,eAAO,OAAO,MAAM,EAAE,MAAMyG,KAAI,MAAME,IAAG,IAAI;AAAA,MAC/C;AACA,UAAI,MAAM;AACV,aAAO;AAAA,IACT,WAAW,YAAY3G,KAAI,GAAG;AAC5B,yBAAmB,MAAMA,OAAM,GAAG;AAAA,IACpC,OAAO;AACL,UAAI,MAAM,MAAM,gBAAgB,mBAAmB;AAAA,IACrD;AAAA,EACF;AAAA,EACA,iBAAiB,MAAM,KAAK,QAAQ;AAClC,UAAM,EAAE,QAAAsG,SAAQ,SAAQ,IAAK;AAI7B,QAAI,CAAC,GAAG,YAAYA,OAAM,EAAG;AAC7B,UAAM,EAAE,MAAAtG,MAAI,IAAKsG;AAGjB,QAAI,OAAO,IAAI,KAAK,GAAG,YAAY,QAAQ,KACpC,OAAO,OAAO,WAAW,SAAS,IAAI,GAAG;AAC9C,yBAAmB,MAAM,SAAS,IAAI;AACtC;AAAA,IACF;AAEA,UAAM,QAAQtG,UAAS,IAAI,QAAQ,IAC/BA,UAAS,IAAI,SAAS,IACtBA,UAAS,IAAI,SAAS,IACtB;AAEJ,QAAI,SAAS,GAAG;AAEd,aAAO,aAAa,MAAM,OAAO,KAAK,aAAa,MAAM;AAAA,IAC3D,WAAWA,UAAS,IAAI,QAAQ;AAE9B,aAAO,aAAa,MAAM,OAAO,KAAK,UAAU;AAAA,IAClD,WAAW,IAAI,UAAU,IAAIA,KAAI,GAAG;AAClC,0BAAoB,MAAM,IAAI,UAAU,IAAIA,KAAI,CAAC;AAAA,IACnD,WAAW,IAAI,UAAU,IAAIA,KAAI,GAAG;AAClC,uBAAiBsG,SAAQtG,OAAM,KAAK,IAAI;AAAA,IAC1C,WAAW,OAAO,OAAO,IAAI,QAAQA,KAAI,GAAG;AAC1C,0BAAoBsG,SAAQtG,KAAI;AAAA,IAClC;AAAA,EACF;AACF;AAEA,SAAS,aAAa,MAAM,OAAO,KAAK0I,QAAO,QAAQ;AACrD,QAAM,EAAE,UAAU,SAAQ,IAAK;AAC/B,MAAI1I;AAEJ,MAAI,CAAC,UAAU;AACb,IAAAA,QAAO,SAAS;AAAA,EAClB,WAAW,GAAG,SAAS,QAAQ,GAAG;AAChC,IAAAA,QAAO,SAAS;AAAA,EAClB,MAAO,KAAI;AAGT,SAAK,UAAU,KAAK,UAAU,IAAI;AAClC,IAAAA,QAAO,IAAI,MAAM,QAAQ;AAAA,EAC3B,SAAS,GAAG;AACV,QAAI,MAAM,MAAM,YAAY;AAAA,EAC9B;AAEA,EAAA0I,OAAM,MAAM1I,OAAM,OAAO,KAAK,MAAM;AACpC,SAAO;AACT;AAEA,MAAM,aAAa;AAAA,EACjB,GAAG;AAAA,EACH,oBAAoB,GAAG,uCAAuC;AAAA,EAC9D,WAAW,MAAM,KAAK,QAAQ;AAC5B,QAAI,iBAAiB,MAAM,KAAK,MAAM,GAAG;AACvC,UAAI,MAAM,MAAM,iBAAiB;AAAA,IACnC;AAAA,EACF;AAAA,EACA,eAAe,MAAM,KAAK;AACxB,UAAMA,QAAO,aAAa,KAAK,MAAM;AAGrC,QAAI,YAAYA,KAAI,GAAG;AACrB,yBAAmB,MAAMA,OAAM,GAAG;AAAA,IACpC,OAAO;AACL,UAAI,MAAM,MAAM,gBAAgB,mBAAmB;AAAA,IACrD;AAAA,EACF;AACF;AAEA,SAAS,cAAc,MAAM,KAAK;AAChC,MAAI,KAAK,UAAW,IAAG,qBAAqB,EAAE,MAAM,GAAG;AACvD,MAAI,KAAK,MAAO,IAAG,iBAAiB,EAAE,MAAM,GAAG;AAE/C,QAAM,EAAE,OAAM,IAAK;AACnB,QAAM,MAAM,OAAO;AACnB,QAAM,OAAO,WAAS,CAACA,OAAM7B,SAAQ,IAAI,UAAU,IAAI6B,OAAM,CAAC7B,MAAK,KAAK,CAAC;AACzE,QAAM,OAAO,CAAC6B,OAAM7B,SAAQ,IAAI,UAAU,IAAI6B,OAAM7B,IAAG;AAEvD,MAAI,CAAC,IAAK;AAAA,WAEC,IAAI,MAAM;AACnB,aAAS,KAAK,OAAO,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC;AAC1C,QAAI,MAAM,EAAG,UAAS,KAAK,OAAO,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC;AACvD,QAAI,MAAM,EAAG,UAAS,KAAK,OAAO,CAAC,GAAG,UAAU,IAAI;AAAA,EACtD,OAAO;AACL,aAAS,KAAK,OAAO,CAAC,GAAG,SAAS,KAAK,CAAC,CAAC;AACzC,QAAI,MAAM,EAAG,UAAS,KAAK,OAAO,CAAC,GAAG,UAAU,IAAI;AAAA,EACtD;AAEA,MAAI,OAAO,KAAK;AAClB;AAEA,SAAS,SAAS,KAAK,MAAM,SAAS,OAAO;AAC3C,MAAI,GAAG,YAAY,IAAI,GAAG;AACxB,QAAI,MAAM,IAAI,KAAK,IAAI;AACvB,QAAI,OAAO,IAAI,KAAK;AAAA,EACtB,WAAW,GAAG,eAAe,IAAI,GAAG;AAClC,SAAK,WAAW,QAAQ,OAAK;AAC3B,YAAMA,OAAM,GAAG,YAAY,EAAE,GAAG,IAAI,EAAE,IAAI,OACtC,GAAG,SAAS,EAAE,GAAG,IAAI,EAAE,IAAI,QAC3B,IAAI,MAAM,GAAG,cAAc;AAC/B,UAAI,CAAC,GAAG,YAAY,EAAE,KAAK,GAAG;AAC5B,YAAI,MAAM,EAAE,OAAO,iBAAiB;AAAA,MACtC;AACA,YAAM,EAAE,MAAM,MAAMA,IAAG;AAAA,IACzB,CAAC;AAAA,EACH;AACF;AAEA,SAAS,cAAc,KAAK,KAAK6B,OAAM,MAAM;AAC3C,QAAM,SAAS,CAAA;AACf,QAAM,SAAS,CAAA;AACf,QAAM,YAAY,IAAI,MAAM,CAAC,KAAK;AAClC,QAAM,YAAY,aAAa,IAAI,MAAM,CAAC,KAAK;AAE/C,OAAK,QAAQ,CAAC,KAAK,UAAU;AAC3B,QAAI,QAAQ,WAAW;AACrB,WAAK,KAAK,KAAK,UAAU;AACzB,aAAO,KAAK,IAAI,MAAM,GAAG,CAAC;AAAA,IAC5B,WAAW,QAAQ,WAAW;AAC5B,WAAK,KAAK,KAAK,UAAU;AACzB,aAAO,KAAK,IAAI,MAAM,GAAG,CAAC;AAAA,IAC5B,OAAO;AACL,UAAI,MAAM,KAAK,kBAAkB;AAAA,IACnC;AAAA,EACF,CAAC;AAED,SAAO,EAAE,MAAAA,OAAM,QAAQ,QAAQ,GAAI,IAAI,KAAK,UAAU,CAAA,EAAG;AAC3D;AAEA,SAAS,aAAa,MAAM;AAC1B,SAAO,GAAG,YAAY,IAAI,IAAI,KAAK,OAC/B,CAAC,GAAG,kBAAkB,IAAI,IAAI,OAC9B,OAAO,IAAI,IAAI,YAAY,KAAK,SAAS,IAAI,IAC7C,KAAK,SAAS;AACpB;AAEA,SAAS,OAAO,MAAM;AACpB,SAAO,GAAG,YAAY,KAAK,MAAM,KAAK,KAAK,OAAO,SAAS;AAC7D;AAEA,SAAS,YAAYA,OAAM;AACzB,SAAOA,UAAS,QAAQ,aACpBA,UAAS,QAAQ,UACjBA;AACN;AAEA,SAAS,iBAAiB,MAAM,KAAK,QAAQ;AAC3C,QAAM,EAAE,MAAAA,MAAI,IAAK;AAEjB,MAAI,GAAG,kBAAkB,MAAM,KAAK,OAAO,aAAa,KAAM;AAAA,WAEnD,GAAG,UAAU,MAAM,KAAK,OAAO,QAAQ,KAAM;AAAA,WAE7C,IAAI,UAAU,IAAIA,KAAI,GAAG;AAClC,wBAAoB,MAAM,IAAI,UAAU,IAAIA,KAAI,CAAC;AAAA,EACnD,WAAW,IAAI,UAAU,IAAIA,KAAI,GAAG;AAClC,qBAAiB,MAAMA,OAAM,KAAK,MAAM;AAAA,EAC1C,WAAW,OAAO,OAAO,IAAI,QAAQA,KAAI,GAAG;AAC1C,wBAAoB,MAAMA,KAAI;AAAA,EAChC,WAAW,OAAO,OAAO,WAAWA,KAAI,GAAG;AACzC,uBAAmB,MAAMA,KAAI;AAAA,EAC/B,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,SAAS,YAAY,MAAMA,OAAM,OAAO,KAAK,QAAQ;AAEnD,QAAMlE,SAAQ,UAAU,IAAI,IAAI,QAC5B,QAAQ,IAAI,IAAI,KAAK,QAAQ,CAAC,IAC9B;AACJ,QAAM,MAAMA,UAASA,OAAM,OAAOkE,KAAI;AACtC,MAAIlE,UAAS,CAAC,KAAK;AACjB,QAAI,MAAM,MAAM,YAAY;AAAA,EAC9B;AAGA,MAAI,IAAI,YAAY,CAAC,IAAI,KAAK;AAC5B,QAAI,MAAM,MAAM,cAAc;AAAA,EAChC;AAGA,UAAQ,MAAMkE,OAAM,OAAO,KAAK,MAAM;AACxC;AAEA,SAAS,iBAAiB,MAAM7B,MAAK,KAAK,QAAQ;AAChD,QAAM,CAAC6B,OAAM,KAAK,IAAI,IAAI,UAAU,IAAI7B,IAAG;AAC3C,cAAY,MAAM6B,OAAM,OAAO,KAAK,MAAM;AAC5C;AAEA,SAAS,WAAW,MAAMA,OAAM,OAAO,KAAK;AAC1C,MAAI,IAAI,UAAU,CAAC,OAAO,OAAO,IAAI,QAAQA,KAAI,GAAG;AAClD,QAAI,MAAM,MAAM,WAAW;AAAA,EAC7B;AACA,sBAAoB,MAAMA,KAAI;AAChC;AAEA,SAAS,oBAAoB,MAAMA,OAAM;AACvC,OAAK,OAAO;AACZ,OAAK,OAAOA;AACd;AAEA,SAAS,mBAAmB,MAAMA,OAAM;AACtC,OAAK,OAAO;AACZ,OAAK,OAAOA;AACZ,OAAK,MAAM,UAAUA,KAAI;AAC3B;AAEA,SAAS,mBAAmB,MAAMA,OAAM,KAAK;AAC3C,MAAIA,UAAS,YAAY;AACvB,UAAMpE,KAAI,IAAI;AACd,QAAI,CAACA,GAAG,KAAI,MAAM,MAAM,gBAAgB;AACxC;AAAA,MAAoB;AAAA,MAAMA;AAAA,MACxB,KAAK,UAAU,SACX,KAAK,UAAU,IAAI,CAAA+M,UAAQ;AACzB,cAAM,MAAM,IAAI,MAAMA,KAAI;AAC1B,cAAM3I,QAAO,SAAS,GAAG,IAAIpE,GAAE,WAAW,GAAG,IAAI;AACjD,YAAI,CAACA,GAAE,OAAOoE,KAAI,EAAG,KAAI,MAAM2I,OAAM,YAAY;AACjD,eAAO3I;AAAA,MACT,CAAC,IACDpE,GAAE,YAAW;AAAA,IACvB;AAAA,EACE,OAAO;AACL,SAAK,SAAS,EAAE,MAAMuL,YAAU,MAAAnH,MAAI;AAAA,EACtC;AACF;AAEA,SAAS,kBAAkB,MAAM,KAAK;AACpC,MAAI,GAAG,YAAY,IAAI,GAAG;AACxB,QAAI,MAAM,IAAI,KAAK,IAAI;AAAA,EACzB,WAAW,GAAG,cAAc,IAAI,GAAG;AACjC,SAAK,SAAS,QAAQ,SAAO,kBAAkB,KAAK,GAAG,CAAC;AAAA,EAC1D,WAAW,GAAG,eAAe,IAAI,GAAG;AAClC,SAAK,WAAW,QAAQ,UAAQ,kBAAkB,KAAK,OAAO,GAAG,CAAC;AAAA,EACpE,OAAO;AACL,QAAI,MAAM,KAAK,IAAI,iBAAiB;AAAA,EACtC;AACF;ACzYA,MAAM,WAAW,EAAE,CAACkH,QAAM,GAAG,GAAG,CAACT,GAAE,GAAG,EAAC;AAEhC,SAASb,OAAM,OAAO6B,OAAM,IAAI;AACrC,QAAM,WAAWA,KAAI,YAAY;AACjC,QAAM,WAAWA,KAAI,YAAY;AACjC,QAAM,SAAS,UAAUA,IAAG;AAC5B,QAAM,SAAS,CAAA;AACf,QAAM,SAAS,CAAA;AACf,QAAM,QAAQ,CAAA;AACd,QAAM,QAAQ,CAAA;AACd,MAAI,UAAU;AACd,MAAI,OAAO;AAEX,QAAM,cAAcA,KAAI,OAAO,SAAS,OACpCA,KAAI,SAAS,IAAI,SAAS,QAC1B,SAAS;AAGb,QAAM,MAAM;AAAA,IACV,GAAGd,KAAI;AACL,YAAMxI,OAAM,MAAMwI,GAAE;AACpB,aAAO,OAAOxI,IAAG,MAAMwI,IAAG,KAAK,EAAE,MAAM,OAAOxI,IAAG,IAAIwI;AAAA,IACvD;AAAA,IACA,MAAM,MAAM;AACV,YAAM,OAAO,SAAS,IAAI;AAC1B,aAAO,OAAO,IAAI,MAAM,OAAO,IAAI,IAAI,EAAE;AAAA,IAC3C;AAAA,IACA,MAAM,MAAM;AACV,aAAO,GAAG,SAAS,IAAI,IACnB,KAAK,QACL,SAAS,MAAM,SAAS,IAAI,GAAG,MAAM;AAAA,IAC3C;AAAA,IACA,MAAM3G,OAAM,MAAM;AAChB,YAAM,KAAKA,KAAI;AACf,YAAM,IAAI,KAAK,WAAWyH,KAAI,MAC1B,MAAM,IAAI,IACV,YAAY,SAAS,IAAI,GAAG,MAAM;AACtC,YAAM,KAAK,CAAC;AAGZ,UAAI,SAAS,KAAK,IAAI,KAAK,MAAM,QAAQ,SAAS,CAAC,GAAG;AACpD,UAAE,QAAQ,KAAK;AAAA,MACjB;AAAA,IACF;AAAA,IACA,MAAM,MAAM,KAAK,OAAO,IAAI;AAG1B,YAAM,IAAI,KAAK,QAAQ;AACvB,YAAM,IAAI,KAAK,MAAM;AACrB,YAAM,UAAU,OAAO,IAAI,IAAI,EAAE,MAAM,GAAG,CAAC;AAC3C,YAAM,GAAG,GAAG,MAAM,OAAO,IAAI,IAAI,EAAE;AAAA,IACrC;AAAA,EACJ;AAGE,SAAO,OAAO,KAAKA,MAAK,EAAE,OAAM,CAAE;AAGlC,aAAW,CAACzH,OAAMpG,MAAK,KAAK,QAAQ,KAAK,GAAG;AAC1C,QAAI;AAAA,MACFoG,QAAO;AAAA,MACPpG,OAAM,SACF,YAAY,KAAKA,QAAO,MAAM,IAC9B,gBAAgB,KAAKA,MAAK;AAAA,IACpC;AAAA,EACE;AAGA,MAAI6N,KAAI,KAAK;AACX,WAAO,EAAE,OAAO,MAAK;AAAA,EACvB;AAGA,QAAM,IAAI,CAAA;AACV,aAAWtJ,QAAO,QAAQ;AACxB,MAAE,OAAOA,IAAG,CAAC,IAAI,SAAS,KAAKA,MAAK,MAAM;AAAA,EAC5C;AAGA,QAAM,MAAM,OAAO,OAAO,MAAM;AAChC,MAAI,QAAQ,CAAAwI,QAAMA,IAAG,SAASA,IAAG,OAAO,IAAI,QAAM,EAAE,EAAE,CAAC,CAAC;AAExD,SAAO,EAAE,OAAO,OAAO,IAAG;AAC5B;AAEA,SAAS,MAAMA,KAAI;AACjB,MAAIxI,OAAM,GAAGwI,IAAG,IAAI,IAAIA,IAAG,OAAO,OAAOA,IAAG,MAAM,EAAE,KAAK,GAAG,CAAC;AAC7D,MAAIA,IAAG,OAAO;AACZ,UAAM,QAAQA,IAAG,MAAM,IAAI,OAAK,OAAO,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE;AACrE,IAAAxI,QAAO,IAAI,KAAK,IAAI,CAAC,CAACwI,IAAG,KAAK;AAAA,EAChC;AACA,SAAOxI;AACT;AAEA,SAAS,UAAUsJ,MAAK;AACtB,UAAQA,KAAI,QAAQ,eAAeA,KAAI,KAAK,IACxCA,KAAI,OAAO;AAAA,IACT,GAAG,eAAeA,KAAI,KAAK,CAAC,CAAC;AAAA,IAC7B,GAAG,eAAeA,KAAI,KAAK,CAAC,CAAC;AAAA,EACrC,IACM,CAAA,MAAO,CAAA;AACb;AAEA,SAAS,eAAe3L,QAAO;AAC7B,SAAOA,UAAS,WAAWA,OAAM,MAAM,IAAIA,OAAM,OAAM,IAAK,CAAA;AAC9D;AC7GO,SAASnB,OAAK,MAAM,YAAY;AACrC,SAAO,QAAQ,KAAK,OAChB,IAAI,QAAQ,EAAE,GAAG,MAAM,GAAG,WAAU,CAAE,IACtC,IAAI,QAAQ,YAAY,IAAI;AAClC;AAEA,MAAM,QAAQ;AAAA,EACZ,YAAY,YAAY,MAAM;AAC5B,SAAK,OAAO;AACZ,WAAO,OAAO,MAAM,UAAU;AAAA,EAChC;AAAA,EACA,WAAW;AACT,WAAO,OAAO,KAAK,IAAI;AAAA,EACzB;AAAA,EACA,WAAW;AACT,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM,KAAK,SAAQ;AAAA,MACnB,GAAI,WAAW,KAAK,IAAI,IAAI,EAAE,MAAM,KAAI,IAAK,CAAA;AAAA,IACnD;AAAA,EACE;AACF;AChBO,SAASoB,QAAM,MAAMiE,OAAMlE,SAAQ,GAAG;AAC3C,QAAM,QAAQA,SAAQ,EAAE,OAAO,MAAM,OAAAA,OAAK,IAAK,EAAE,OAAO,KAAI;AAC5D,SAAOnB;AAAAA,IACL;AAAA,IACAqF,QAAO,EAAE,MAAMA,OAAM,GAAG,MAAK,IAAK;AAAA,EACtC;AACA;ACjBO,SAAS4I,SAAO,KAAKC,QAAO;AACjC,aAAW,CAAC1K,MAAKvE,MAAK,KAAK,QAAQiP,MAAK,GAAG;AACzC,QAAI,IAAI1K,MAAKvE,MAAK;AAAA,EACpB;AACA,SAAO;AACT;ACGO,SAAS,QAAQkC,QAAO,KAAK,MAAM,oBAAI,IAAG,GAAI;AACnD,QAAM,SAAS,GAAG,IAAIA,OAAM,WAAW,GAAG,IAAI;AAE9C,MAAI,SAAS,GAAG,GAAG;AACjB,QAAI,IAAI,KAAK,GAAG;AAAA,EAClB,WAAWoJ,UAAQ,GAAG,GAAG;AACvB,QAAI,QAAQ,OAAK,QAAQpJ,QAAO,GAAG,GAAG,CAAC;AAAA,EACzC,WAAW,WAAW,GAAG,GAAG;AAC1B,YAAQA,QAAO,IAAIA,MAAK,GAAG,GAAG;AAAA,EAChC,WAAW,SAAS,GAAG,GAAG;AACxB8M,aAAO,KAAK,GAAG;AAAA,EACjB,OAAO;AACL,UAAM,6BAA6BpC,WAAS,GAAG,CAAC,EAAE;AAAA,EACpD;AAEA,SAAO;AACT;AAEA,SAAS,SAAS5M,QAAOkP,WAAU;AACjC,EAAAlP,OAAM,WAAWkP;AACjB,SAAOlP;AACT;AAEA,SAAS,SAASA,QAAO;AACvB,SAAOsL,UAAQtL,MAAK,IAAIA,OAAM,IAAI,QAAQ,IACtCA,UAASA,OAAM,WAAWA,OAAM,SAAQ,IACxCA;AACN;AAYO,SAAS,MAAM;AACpB,SAAO;AAAA,IACL,CAAAkC,WAASA,OAAM,YAAW;AAAA,IAC1B,OAAO,EAAE,KAAK,GAAE;AAAA,EACpB;AACA;AASO,SAAS,OAAO,WAAW;AAChC,cAAY,UAAU,KAAI;AAC1B,SAAO;AAAA,IACL,CAAAA,WAAS;AACP,YAAM,OAAO,QAAQA,QAAO,SAAS;AACrC,aAAOA,OAAM,YAAY,CAAAkE,UAAQ,CAAC,KAAK,IAAIA,KAAI,CAAC;AAAA,IAClD;AAAA,IACA,OAAO,EAAE,KAAK,SAAS,SAAS,EAAC;AAAA,EACrC;AACA;AC7DO,SAAS,WAAWA,OAAMlE,QAAO,QAAQ,UAAU,EAAE,QAAQ,SAAS;AAC3E,QAAM,QAAQ,oBAAI,IAAG;AAErB,QAAM,UAAU,WAAS;AACvB,YAAQ,SAAS,KAAK,IAAIA,OAAM,WAAW,KAAK,IAAI;AACpD,aAAS,KAAK,IAAI,MAAM,IAAI,OAAOC,QAAM,KAAK,CAAC,IAC3C,WAAW,KAAK,IAAI,QAAQD,QAAO,KAAK,EAAE,QAAQ,OAAO,IACzD,SAAS,KAAK,IAAI8M,SAAO,OAAO,KAAK,IACrC,MAAM,WAAW5I,KAAI,WAAW,QAAM,EAAE,EAAE;AAAA,EAChD;AAEA,UAAQ,MAAM,EAAE,QAAQ,OAAO;AAE/B,MAAI,QAAQ,UAAU;AACpB,YAAQ,SAAS,KAAK;AAAA,EACxB;AAEA,SAAO4F,OAAM,OAAO,EAAE,OAAA9J,QAAO,GAAG,QAAO,CAAE;AAC3C;ACzBO,SAAS,QAAQA,WAAU0C,SAAQ;AACxC,SAAO,SAAS1C,QAAO,WAAW,WAAWA,QAAO0C,QAAO,KAAI,CAAE,CAAC;AACpE;AAEO,SAAS,SAAS1C,QAAO,OAAO;AACrC,SAAOA,OAAM,OAAO;AAAA,IAClB,QAAQ,aAAaA,QAAO,KAAK;AAAA,EACrC,CAAG;AACH;AAEA,SAAS,aAAaA,QAAO,EAAE,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI,MAAM,CAAA,KAAM;AACjE,QAAM,IAAI,MAAM;AAChB,MAAI,MAAM,EAAG,QAAO;AAIpB,MAAI,MAAM,KAAK,CAACA,OAAM,WAAU,KAAM,MAAM,CAAC,EAAE,OAAO;AACpD,UAAM,MAAMA,OAAM,OAAO,MAAM,CAAC,EAAE,KAAK;AACvC,QAAI,IAAI,OAAQ,QAAO,IAAI,OAAO,KAAK;AAAA,EACzC;AAEA,MAAIoD,OAAM,aAAapD,QAAO,KAAK,KAAK;AACxC,QAAM,SAAS,YAAYoD,IAAG;AAC9B,QAAM,QAAQpD,OAAM,UAAS;AAC7B,QAAM4C,QAAO,IAAI,YAAY,KAAK;AAClC,QAAM,QAAQ,CAAA;AACd,QAAM,OAAO,CAAA;AAGb,QAAM5B,QAAOhB,OAAM,KAAI;AACvB,QAAM,OAAOA,OAAM,KAAI;AACvB,MAAI,MAAM;AACR,aAAS,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACvD,YAAMqC,OAAM,OAAO,GAAGrB,KAAI,IAAI;AAC9B,MAAA4B,MAAK,CAAC,IAAK,MAAMP,IAAG,MAAM,KAAK,KAAK,CAAC,IAAI;AAAA,IAC3C;AAAA,EACF,OAAO;AACL,aAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAC9B,YAAMA,OAAM,OAAO,GAAGrB,KAAI,IAAI;AAC9B,MAAA4B,MAAK,CAAC,IAAK,MAAMP,IAAG,MAAM,KAAK,KAAK,CAAC,IAAI;AAAA,IAC3C;AAAA,EACF;AAEA,MAAI,CAAC,IAAI,QAAQ;AAEf,IAAAe,OAAMA,KAAI,IAAI,OAAK,SAAO,EAAE,KAAKpC,KAAI,CAAC;AAAA,EACxC;AAEA,SAAO,EAAE,MAAA4B,OAAM,KAAAQ,MAAK,OAAO,MAAM,MAAM,KAAK,OAAM;AACpD;AC/CO,SAAS,UAAUpD,QAAO;AAC/B,SAAOA,SACH,IAAI,UAAU,EAAE,GAAGA,OAAM,KAAI,EAAE,GAAIA,OAAM,YAAW,CAAE,IACtD,IAAI,UAAS;AACnB;AAGO,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMrB,YAAYgB,OAAM,OAAO;AACvB,SAAK,OAAOA,SAAQ,CAAA;AACpB,SAAK,QAAQ,SAAS,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAIkD,OAAMxB,SAAQ;AAChB,QAAI,CAAC,KAAK,IAAIwB,KAAI,EAAG,MAAK,MAAM,KAAKA,QAAO,EAAE;AAC9C,WAAO,KAAK,KAAKA,KAAI,IAAIxB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAIwB,OAAM;AACR,WAAO,OAAO,OAAO,KAAK,MAAMA,KAAI;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,QAAQ;AACd,SAAK,SAAS;AACd,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,OAAO;AACT,UAAM,EAAE,MAAAlD,OAAM,OAAO,SAAS,KAAI,IAAK;AACvC,WAAO,MAAM,OAAO,EAAE,MAAAA,OAAM,OAAO,QAAQ,QAAQ,MAAM,OAAO,MAAM;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAO,OAAO;AACZ,WAAO,MAAM,OAAO,IAAI;AAAA,EAC1B;AACF;AC5EO,SAAS,OAAOhB,QAAO0C,SAAQ;AACpC,SAAO,QAAQ1C,QAAO8J,OAAMpH,SAAQ,EAAE,OAAA1C,QAAO,UAAU,MAAM,QAAQ,MAAK,CAAE,CAAC;AAC/E;AAEO,SAAS,QAAQA,QAAO,EAAE,OAAO,OAAO,MAAM,CAAA,KAAM;AAEzD,QAAM,OAAO,UAAS;AACtB,QAAM,SAASA,OAAM,OAAM;AAG3B,MAAI,OAAQ,aAAY,MAAM,MAAM;AAGpCgL,WAAO,OAAO,OAAO,QAAQ,UAAUhL,QAAO,GAAG,GAAG,IAAI;AAGxD,SAAO,KAAK,IAAIA,MAAK;AACvB;AAEA,SAASgL,SAAO,OAAO,OAAO,QAAQrN,UAAS,CAAA,GAAI,MAAM;AACvD,MAAI,CAAC,MAAM,OAAQ;AACnB,QAAM,OAAO,SAAS,OAAO,OAAO;AACpC,QAAMkN,MAAK,CAAC,IAAI,QAAQlN,QAAO,EAAE,EAAE,GAAG;AACtC,QAAM,IAAI,MAAM;AAEhB,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAMyF,OAAM,MAAM,CAAC;AACnB,QAAIA,KAAI,SAAS,MAAM;AAErB,WAAK,IAAI,MAAM,CAAC,GAAGzF,QAAOyF,KAAI,KAAK,CAAC;AAAA,IACtC,WAAW,OAAO,GAAG;AAEnB,YAAM,MAAM,KAAK,IAAI,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC;AAC1C,eAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,YAAI,CAAC,IAAIA,KAAI,GAAG,MAAMyH,GAAE;AAAA,MAC1B;AAAA,IACF,OAAO;AAEL,WAAK,IAAI,MAAM,CAAC,GAAG,CAAEzH,KAAI,GAAG,MAAMyH,GAAE,EAAG;AAAA,IACzC;AAAA,EACF;AACF;ACxCO,SAAS,OAAO7K,WAAU2H,UAAS;AACxC,SAAO,QAAQ3H,QAAO,QAAQA,QAAO2H,SAAQ,KAAI,CAAE,CAAC;AACtD;AAEO,SAAS,QAAQ3H,QAAO2H,UAAS;AACtC,QAAM,OAAO,UAAS;AAEtB,EAAAA,SAAQ,QAAQ,CAAC7J,QAAO,SAAS;AAC/B,UAAM,OAAO,SAASA,MAAK,IAAIA,SAAQ;AACvC,QAAI,MAAM;AACR,YAAM,MAAMkC,OAAM,OAAO,IAAI,KAAK,MAAM,wBAAwB,IAAI,EAAE;AACtE,WAAK,IAAI,MAAM,GAAG;AAAA,IACpB;AAAA,EACF,CAAC;AAED,SAAO,KAAK,OAAOA,MAAK;AAC1B;ACTO,SAAS,QAAQ,QAAQiN,SAAQ;AACtC,MAAI,CAAC,UAAU,CAACA,QAAQ,QAAO;AAG/B,QAAM,EAAE,MAAArK,OAAM,MAAM,KAAI,IAAK;AAC7B,QAAM,MAAM,IAAI,YAAY,IAAI;AAChC,EAAAqK,QAAO,KAAK,SAAO,IAAIrK,MAAK,GAAG,CAAC,IAAI,CAAC;AAGrC,QAAM,MAAM,IAAI,OAAO,CAACsK,MAAK,QAAQA,OAAM,KAAK,CAAC;AACjD,MAAI,QAAQ,KAAM,QAAO;AAGzB,QAAM,QAAQ,MAAM,GAAG;AACvB,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,QAAI,IAAI,CAAC,EAAG,OAAM,IAAI,CAAC,IAAI,OAAO,IAAI,KAAK,CAAC;AAAA,EAC9C;AAGA,QAAM,QAAQ,IAAI,YAAYtK,MAAK,MAAM;AACzC,EAAAqK,QAAO,KAAK,SAAO,MAAM,GAAG,IAAI,IAAIrK,MAAK,GAAG,CAAC,CAAC;AAE9C,SAAO,EAAE,GAAG,QAAQ,MAAM,OAAO,MAAM,OAAO,MAAM,MAAK;AAC3D;AAWO,SAAS,QAAQ,QAAQlF,OAAMuP,SAAQ,OAAO;AACnD,QAAM,EAAE,MAAArK,OAAM,MAAM,KAAI,IAAK;AAC7B,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,MAAM;AAEV,MAAIqK,SAAQ;AAEV,UAAM,IAAI,WAAW,IAAI;AACzB,IAAAvP,MAAK,SAAO,IAAIkF,MAAK,GAAG,CAAC,IAAI,CAAC;AAG9B,UAAM,MAAM,IAAI,OAAO,CAACsK,MAAK,QAAQA,OAAM,KAAK,CAAC;AACjD,QAAI,QAAQ,MAAM;AAEhB,cAAQ,MAAM,GAAG;AACjB,cAAQ;AACR,eAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,YAAI,IAAI,CAAC,EAAG,OAAM,IAAI,CAAC,IAAI,OAAO,IAAI,KAAK,CAAC;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAGA,MAAI,IAAI;AACR,QAAM,QAAQ,IAAI,YAAY,KAAK;AACnC,QAAM,KAAK,UAAU,OACjB,SAAO,MAAM,EAAE,CAAC,IAAI,IAAItK,MAAK,GAAG,CAAC,IACjC,SAAO,MAAM,EAAE,CAAC,IAAIA,MAAK,GAAG;AAChC,EAAAlF,MAAK,EAAE;AAEP,SAAO,EAAE,GAAG,QAAQ,MAAM,OAAO,MAAM,OAAO,MAAM,MAAK;AAC3D;AAEO,SAAS,KAAKsC,QAAO,KAAK,KAAK,MAAM;AAC1C,QAAM,MAAM,SAAS,SAAS,SAAS,OAAO,UAC1C,SAAS,YAAY,cACrB,SAAS,WAAW,aACpB,MAAM,sDAAsD;AAEhE,QAAM,EAAE,MAAK,IAAKA,OAAM,OAAM;AAC9B,QAAM,MAAM,WAAWA,OAAM,YAAW,GAAI,GAAG;AAI/C,MAAIF,KAAI,OAAOE,QAAO,CAAA,CAAE,EAAE,MAAM,GAAG,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,GAAG,GAAG,IAAG,EAAE,CAAE;AACpE,EAAAF,KAAI,OAAOA,IAAG,EAAE,CAAC,GAAG,GAAG,UAAU,GAAG,GAAG;AAGvC,WAAS,IAAI,MAAM,QAAQ,EAAE,KAAK,KAAI;AACpC,IAAAA,KAAI;AAAA,MACA,QAAQA,IAAG,MAAM,MAAM,GAAG,CAAC,CAAC;AAAA;AAAA,MAE5B,EAAE,CAAC,GAAG,GAAG,IAAI,MAAM,CAAC,GAAG,GAAG,EAAC;AAAA,IACnC;AAAA,EACE;AAGA,SAAOA,GAAE,IAAI,GAAG;AAClB;ACpGO,SAASqN,YAAU,QAAQ;AAEhC,SAAO7D,eAAa,MAAM,IAAI,OAAO,cAAc;AACrD;ACGO,IAAA,UAAA,MAAMtB,OAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBjB,YAAYL,UAAS,OAAOsF,SAAQ,OAAO,OAAO,QAAQ;AACxD,UAAMjM,QAAO,OAAO,OAAO,EAAE,GAAG2G,SAAO,CAAE;AACzC,YAAQ,OAAO,MAAK,KAAM,OAAO,KAAK3G,KAAI;AAC1C,UAAM,QAAQ,MAAM,SAASA,MAAK,MAAM,CAAC,CAAC,EAAE,SAAS;AAKrD,SAAK,SAAS,OAAO,OAAO,KAAK;AAKjC,SAAK,QAAQA;AAKb,SAAK,SAAS;AAKd,SAAK,SAASiM,SAAQ,MAAK,KAAM;AAKjC,SAAK,QAAQA,WAAU;AAKvB,SAAK,SAAS,SAAS;AAKvB,SAAK,SAAS,SAAS;AAKvB,SAAK,UAAU;AAKf,SAAK,SAAS;AAKd,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,OAAO;AAAA,IACL,MAAAjM,QAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAAiM,UAAS;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,EACZ,IAAM,IAAI;AACN,UAAM,IAAIA,YAAW,SAAYA,UAAS,KAAK,KAAI;AAEnD,WAAO,IAAI,KAAK;AAAA,MACdjM,SAAQ,KAAK;AAAA,MACb,UAAU,CAACA,QAAO,KAAK,SAAS;AAAA,MAChC;AAAA,MACA,WAAW,SAAY,SAAS,QAAQ,KAAK,QAAQiM,WAAU,CAAC;AAAA,MAChE,UAAU,SAAY,QAAQ,KAAK;AAAA,MACnC,KAAK;AAAA,IACX;AAAA,EACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,OAAOvK,SAAQ;AACb,QAAI,UAAU,QAAQ;AACpB,UAAIA,SAAQ;AACV,aAAK,UAAU,EAAE,GAAG,KAAK,SAAS,GAAGA,QAAM;AAAA,MAC7C;AACA,aAAO;AAAA,IACT,OAAO;AACL,aAAO,KAAK;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,OAAO,WAAW,IAAI;AACzB,QAAI,CAAC,KAAK,OAAQ,QAAO;AACzB,UAAM,KAAK,KAAK,QAAO;AACvB,UAAM,KAAK,KAAK,QAAO;AACvB,UAAM,SAAS,OAAK,MAAM,IAAI,MAAM;AACpC,WAAO,UAAU,EAAE,OAAO,OAAO,EAAE,CAAC,MAAM,EAAE,OAAO,OAAO,EAAE,CAAC,MACxD,KAAK,WAAU,IAAK,KAAK,KAAK,UAAS,CAAE,cAAc,OACvD,KAAK,UAAS,IAAK,KAAK,KAAK,OAAO,IAAI,YAAY,OACpD,KAAK,UAAS,IAAK,cAAc;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa;AACX,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY;AACV,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY;AACV,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO;AACL,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO;AACL,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS;AACP,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa;AACX,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AACR,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,YAAYuK,SAAQ;AAClB,WAAOA,UAAS,KAAK,OAAO,OAAOA,OAAM,IAAI,KAAK,OAAO,MAAK;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,OAAO;AAChB,WAAO,KAAK,OAAO,KAAK;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY/I,OAAM;AAChB,WAAO,KAAK,OAAO,QAAQA,KAAI;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAOA,OAAM;AACX,WAAO,KAAK,MAAMA,KAAI;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SAAS,OAAO;AACd,WAAO,KAAK,MAAM,KAAK,OAAO,KAAK,CAAC;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAMA,OAAM,cAAc,OAAO;AAC/B,UAAM,SAAS,KAAK,OAAOA,KAAI;AAC/B,UAAM3C,SAAQ,IAAI,YAAY,KAAK,QAAO,CAAE;AAC5C,QAAI,MAAM;AACV,SAAK,KAAK,SAAOA,OAAM,EAAE,GAAG,IAAI,OAAO,GAAG,GAAG,GAAG,IAAI;AACpD,WAAOA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI2C,OAAM,MAAM,GAAG;AACjB,UAAM,SAAS,KAAK,OAAOA,KAAI;AAC/B,WAAO,KAAK,gBAAgB,KAAK,UAAS,IACtC,OAAO,GAAG,KAAK,QAAO,EAAG,GAAG,CAAC,IAC7B,OAAO,GAAG,GAAG;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAOA,OAAM;AACX,UAAM,SAAS,KAAK,OAAOA,KAAI;AAC/B,UAAM,UAAU,KAAK,gBAAgB,KAAK,cAAc,KAAK,QAAO,IAAK;AACzE,QAAI,SAAS;AACX,aAAO,SAAO,OAAO,GAAG,QAAQ,GAAG,CAAC;AAAA,IACtC,WAAW,QAAQ;AACjB,aAAO,SAAO,OAAO,GAAG,GAAG;AAAA,IAC7B,OAAO;AACL,YAAM,wBAAwBA,KAAI,EAAE;AAAA,IACtC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,MAAM,GAAG;AACd,WAAOkJ,gBAAc,IAAI,EAAE,GAAG;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,UAAU,IAAI;AACpB,UAAM,EAAE,SAAS,OAAO,QAAA1O,QAAM,IAAK;AAGnC,UAAM,QAAQ,QAAQ,MAAM,QAAQ,WAAW,KAAK;AACpD,UAAM,YAAY,iBAAiB,MAAM,KAAK;AAC9C,UAAM,MAAM,CAAA;AACZ,SAAK;AAAA,MACH,CAAC,KAAKsC,UAAS,IAAI,KAAK,UAAU,KAAKA,KAAI,CAAC;AAAA,MAC5C;AAAA,MAAM;AAAA,MAAOtC;AAAA,IACnB;AAGI,QAAI,WAAW,KAAK,aAAa;AAC/B,YAAM,MAAM,CAAA;AACZ,WAAK,KAAK,SAAO,IAAI,KAAK,GAAG,GAAG,MAAM,OAAOA,OAAM;AACnD,aAAO,KAAK,MAAM,KAAK,KAAK,OAAO;AAAA,IACrC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,EAAE,OAAO,QAAQ,IAAI;AACnB,UAAM,YAAY0O,gBAAc,IAAI;AACpC,UAAM,IAAI,KAAK,QAAO;AACtB,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,YAAM,UAAU,CAAC;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,OAAOlJ,OAAM;AACZ,UAAMd,OAAM,KAAK,OAAOc,KAAI;AAC5B,UAAM,IAAI,KAAK,QAAO;AACtB,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,YAAMd,KAAI,CAAC;AAAA,IACb;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,UAAU,IAAI;AAClB,UAAMuI,OAAM,SAAS,OAAO,IACxB,EAAE,OAAO,CAAC,QAAO,IAEjB,EAAE,GAAG,SAAS,OAAO,GAAE;AAE3B,UAAM,MAAM,KAAK,QAAQ,EAAE,GAAGA,MAAK,SAAS,OAAO;AACnD,UAAM,MAAM,GAAG,KAAK,OAAO,WAAW,CAAC,aAAa,IAAI,MAAM;AAE9D,YAAQ,IAAI,GAAG;AACf,YAAQ,MAAM,GAAG;AACjB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,QAAQ,QAAQ,MAAM;AACpB,QAAI,KAAK,OAAQ,QAAO,KAAK;AAE7B,UAAM,IAAI,KAAK,QAAO;AACtB,UAAM,QAAQ,IAAI,YAAY,CAAC;AAC/B,UAAM,UAAU,KAAK,UAAS;AAC9B,UAAM,OAAO,KAAK,KAAI;AACtB,QAAI,MAAM;AAIV,QAAI,MAAM;AACR,eAAS,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACvD,cAAM,EAAE,GAAG,IAAI;AAAA,MACjB;AAAA,IACF,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,cAAM,EAAE,GAAG,IAAI;AAAA,MACjB;AAAA,IACF;AAGA,QAAI,SAAS,SAAS;AACpB,YAAM,EAAE,QAAQ,MAAK,IAAK;AAC1B,YAAM,KAAK,CAAC,GAAG,MAAM,OAAO,GAAG,GAAG,KAAK,CAAC;AAAA,IAC1C;AAGA,QAAI,SAAS,CAAC,SAAS;AACrB,WAAK,SAAS;AAAA,IAChB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,WAAW,QAAQ,MAAM;AAEvB,QAAI,KAAK,aAAa;AACpB,aAAO,KAAK;AAAA,IACd;AAGA,QAAI,CAAC,KAAK,aAAa;AACrB,aAAO,CAAE,KAAK,QAAQ,KAAK,CAAC;AAAA,IAC9B;AAGA,UAAM,EAAE,MAAA/I,OAAM,KAAI,IAAK,KAAK;AAC5B,UAAM,OAAO,OAAO,MAAM,MAAM,CAAA,CAAE;AAKlC,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK,KAAI;AACtB,UAAM,IAAI,KAAK,QAAO;AACtB,QAAI,QAAQ,KAAK,aAAa;AAC5B,eAAS,IAAI,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG;AAC7B,YAAI,KAAK,CAAC;AACV,aAAKA,MAAK,CAAC,CAAC,EAAE,KAAK,CAAC;AAAA,MACtB;AAAA,IACF,WAAW,MAAM;AACf,eAAS,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACvD,aAAKA,MAAK,CAAC,CAAC,EAAE,KAAK,CAAC;AAAA,MACtB;AAAA,IACF,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,aAAKA,MAAK,CAAC,CAAC,EAAE,KAAK,CAAC;AAAA,MACtB;AAAA,IACF;AAGA,QAAI,SAAS,CAAC,QAAQ,KAAK,UAAS,GAAI;AACtC,YAAMe,WAAU,KAAK;AACrB,YAAM3C,QAAO,KAAK;AAClB,eAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,aAAK,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM2C,SAAQ,GAAG,GAAG3C,KAAI,CAAC;AAAA,MAC5C;AAAA,IACF;AAGA,QAAI,SAAS,CAAC,KAAK,aAAa;AAC9B,WAAK,cAAc;AAAA,IACrB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,SAAS;AACb,UAAM,QAAQ,UAAU,QAAQ,SAAS,KAAK,QAAO;AACrD,UAAM,QAAQ,KAAK;AACnB,QAAIA,OAAM;AAEV,QAAI,CAAC,WAAW,CAAC,KAAK,UAAS,GAAI;AACjC,UAAI,CAAC,KAAK,cAAc;AACtB,eAAO;AAAA,MACT,WAAW,UAAU,KAAK,UAAS,GAAI;AACrC,QAAAA,QAAO,KAAK;MACd;AAAA,IACF;AAEA,QAAI,CAACA,OAAM;AACT,YAAMtD,QAAO,UAAU,OAAK,QAAQ,QAAQ,CAAC,IAAI,OAAK,KAAK,KAAK,GAAG,IAAI;AACvE,YAAM,QAAQ,MAAM;AACpB,MAAAsD,QAAO,CAAA;AAEP,eAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAC9B,cAAMkD,QAAO,MAAM,CAAC;AACpB,cAAM,OAAO,KAAK,OAAOA,KAAI;AAC7B,cAAM,OAAOlD,MAAKkD,KAAI,IAAI,KAAKiJ,YAAU,IAAI,GAAG,KAAK;AACrD,YAAI,IAAI;AAER,oBAAY,IAAI,IACZzP,MAAK,SAAO,KAAK,EAAE,CAAC,IAAI,KAAK,GAAG,CAAC,IACjCA,MAAK,SAAO,KAAK,EAAE,CAAC,IAAI,KAAK,GAAG,GAAG,CAAC;AAAA,MAC1C;AAEA,UAAI,KAAK,aAAa;AACpB,iBAAS,QAAQ,KAAK,OAAM,GAAIA,OAAM,CAAC,CAAC,SAAS,KAAK;AAAA,MACxD;AAAA,IACF;AAEA,WAAO,KAAK,OAAO,EAAE,MAAAsD,OAAM,OAAO,QAAQ,QAAQ,MAAM,OAAO,MAAM;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BA,KAAK,IAAI,OAAO,QAAQ,UAAUtC,UAAS,GAAG;AAC5C,UAAMuO,UAAS,KAAK;AACpB,UAAM,QAAQ,KAAK;AACnB,UAAMjM,QAAO,KAAK;AAElB,QAAI,IAAItC,WAAU;AAClB,QAAI,IAAI,MAAO;AAEf,UAAM,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK;AACnC,UAAM,OAAO,MAAM,IAAI,KAAK;AAE5B,QAAI,SAAS,KAAK,UAAS,KAAMuO,WAAU,KAAK,QAAQ;AACtD,YAAM,QAAQ,KAAK,QAAO;AAC1B,YAAMjM,QAAO,KAAK;AAClB,aAAO,IAAI,GAAG,EAAE,GAAG;AACjB,WAAG,MAAM,CAAC,GAAGA,OAAM,IAAI;AAAA,MACzB;AAAA,IACF,WAAWiM,SAAQ;AACjB,UAAI,IAAI,IAAI,IAAI;AAChB,WAAK,IAAIA,QAAO,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,IAAI,IAAIA,QAAO,KAAK,IAAI,CAAC,GAAG;AAC7D,WAAG,GAAGjM,OAAM,IAAI;AAAA,MAClB;AAAA,IACF,OAAO;AACL,aAAO,IAAI,GAAG,EAAE,GAAG;AACjB,WAAG,GAAGA,OAAM,IAAI;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAASoM,gBAAcpN,QAAO;AAC5B,MAAI,IAAIA,OAAM;AAEd,MAAI,CAAC,GAAG;AACN,UAAM,YAAY,iBAAiBA,MAAK;AACxC,UAAMgB,QAAOhB,OAAM,KAAI;AACvB,QAAIA,OAAM,UAAS,KAAMA,OAAM,WAAU,GAAI;AAC3C,YAAM,UAAUA,OAAM,QAAO;AAC7B,UAAI,SAAO,UAAU,QAAQ,GAAG,GAAGgB,KAAI;AAAA,IACzC,OAAO;AACL,UAAI,SAAO,UAAU,KAAKA,KAAI;AAAA,IAChC;AACA,IAAAhB,OAAM,WAAW;AAAA,EACnB;AAEA,SAAO;AACT;AC1oBO,SAAS,OAAOA,WAAU,QAAQ;AACvC,WAAS,OAAO,KAAI;AACpB,QAAM,QAAQA,OAAM,QAAO;AAC3B,QAAM,OAAOA,OAAM,MAAK;AACxB,QAAM,OAAO,UAAU,IAAI,EAAE,QAAQ,KAAK,QAAQ;AAClD,SAAO,QAAQ,WAAS;AACtB,YAAQ,iBAAiBgI,UAAQ,QAAQ,IAAIA,QAAM,KAAK;AACxD,QAAI,MAAM,QAAO,MAAO,MAAO,OAAM,gCAAgC;AACrE,YAAQ,MAAM,MAAK;AACnB,UAAM,YAAY,CAAA9D,UAAQ,KAAK,IAAIA,OAAM,MAAM,OAAOA,KAAI,CAAC,CAAC;AAAA,EAC9D,CAAC;AACD,SAAO,KAAK,IAAIlE,MAAK;AACvB;ACbO,SAAS,OAAOA,WAAU,QAAQ;AACvC,WAAS,OAAO,KAAI;AACpB,QAAM,QAAQA,OAAM,QAAO;AAC3B,QAAM,QAAQ,QAAQ,OAAO,OAAO,CAAC,GAAGF,OAAM,IAAIA,GAAE,QAAO,GAAI,CAAC;AAChE,MAAI,UAAU,MAAO,QAAOE;AAE5B,QAAM,SAAS,CAACA,QAAO,GAAG,MAAM;AAChC,QAAM,OAAO,UAAS;AAEtB,EAAAA,OAAM,YAAW,EAAG,QAAQ,CAAAkE,UAAQ;AAClC,UAAM,MAAM,MAAM,KAAK;AACvB,QAAI,MAAM;AACV,WAAO,QAAQ,CAAAlE,WAAS;AACtB,YAAM,MAAMA,OAAM,OAAOkE,KAAI,KAAK,EAAE,IAAI,MAAM,KAAI;AAClD,MAAAlE,OAAM,KAAK,UAAQ,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,CAAC;AAAA,IAC9C,CAAC;AACD,SAAK,IAAIkE,OAAM,GAAG;AAAA,EACpB,CAAC;AAED,SAAO,KAAK,IAAIlE,MAAK;AACvB;ACnBO,SAAS,SAASA,QAAO2H,UAAS;AAAA,EACvC,SAAS;AAAA,EACT,QAAQ;AACV,IAAI,IAAI;AACN,QAAM,MAAM,UAAU;AACtB,QAAM,MAAM,SAAS;AAErB,MAAI,EAAE,OAAO,MAAM;AACjB,UAAM,6CAA6C;AAAA,EACrD;AACA,MAAI,OAAO,KAAK;AACd,UAAM,2DAA2D;AAAA,EACnE;AAEA,EAAAA,WAAU,QAAQ3H,QAAO2H,QAAO;AAChC,QAAM,UAAU,CAAC,GAAG,QAAQ3H,QAAO,MAAM,SAAS,KAAK,EAAE,MAAM;AAC/D,QAAM,SAAS,MAAM,QAAQ,CAAC,IAAI,QAAQ,IAAG;AAC7C,QAAMqN,UAAS,oBAAI,IAAG;AAGtB,EAAArN,OAAM,YAAW,EAAG,QAAQ,CAAAkE,UAAQ;AAElC,UAAM4I,UAAS,CAACnF,SAAQ,IAAIzD,KAAI;AAGhC,QAAIA,UAAS,QAAQ;AACnB,UAAI,OAAO4I,QAAQ,CAAAO,QAAO,IAAInJ,OAAMA,KAAI;AACxC,iBAAW,CAAC7B,MAAKvE,MAAK,KAAK6J,UAAS;AAClC,QAAA0F,QAAO,IAAIhL,MAAKvE,MAAK;AAAA,MACvB;AACA,UAAI,IAAK;AAAA,IACX;AAEA,QAAIgP,QAAQ,CAAAO,QAAO,IAAInJ,OAAMA,KAAI;AAAA,EACnC,CAAC;AAED,SAAO,QAAQlE,QAAOqN,OAAM;AAC9B;ACzCO,SAAS,SAAS1J,UAAS;AAChC,SAAO;AAAA,IACL,KAAK,GAAG,GAAG,IAAI,IAAI;AACjB,UAAI,MAAM,KAAM,MAAK;AACrB,UAAI,MAAM,KAAM,MAAK,EAAE;AACvB,aAAO,KAAK,IAAI;AACd,cAAM,MAAM,KAAK,OAAO;AACxB,YAAIA,SAAQ,EAAE,GAAG,GAAG,CAAC,IAAI,EAAG,MAAK,MAAM;AAAA,YAClC,MAAK;AAAA,MACZ;AACA,aAAO;AAAA,IACT;AAAA,IACA,MAAM,GAAG,GAAG,IAAI,IAAI;AAClB,UAAI,MAAM,KAAM,MAAK;AACrB,UAAI,MAAM,KAAM,MAAK,EAAE;AACvB,aAAO,KAAK,IAAI;AACd,cAAM,MAAM,KAAK,OAAO;AACxB,YAAIA,SAAQ,EAAE,GAAG,GAAG,CAAC,IAAI,EAAG,MAAK;AAAA,YAC5B,MAAK,MAAM;AAAA,MAClB;AACA,aAAO;AAAA,IACT;AAAA,EACJ;AACA;AClBA,MAAM2J,WAAS,SAAS,SAAS;AAE1B,SAAS,YAAYtM,OAAM,OAAO,QAAQ,KAAK,OAAO;AAC3D,MAAI,MAAM,MAAM,OAAOrD,SAAQ0E;AAC/B,QAAM,SAAS,WAAS,KAAK,QAAQ,CAAC,MAAM,KAAK,KAAK;AACtD,QAAM,SAAS,IAAI;AACnB,QAAM,SAAS,MAAM;AAErB,QAAM,WAAW,IAAI,SACjB0I;AAAAA,IACE,CAAC,KAAK,KAAK,GAAG;AAAA,IACd,MAAMxB,SAAO,KAAK,CAAC,GAAG,MAAM,MAAM,CAAC,YAAY,CAAC,aAAa,CAAC,QAAQ,IAAI;AAAA,IAC1E;AAAA,EACR,IACM,MAAM;AAAA,EAAC;AAEX,QAAM,IAAI;AAAA,IACR,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,MAAM;AAAA,IACN,MAAM;AAAA,IAEN,KAAK,WAAW,OAAO,SAAS,OAAO;AACrC,QAAE,QAAQ,EAAE,KAAK,EAAE,KAAK;AACxB,QAAE,OAAO,MAAM;AACf,aAAO;AACP,aAAO;AACP,MAAA5L,UAAS;AACT,MAAA0E,OAAM;AAGN,cAAQ,QAAQ,MAAM,IAAI,UAAQ,KAAK,KAAI,CAAE,IAAI;AAGjD,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,YAAI,CAAC,EAAE,KAAI;AAAA,MACb;AAEA,aAAO;AAAA,IACT;AAAA,IAEA,MAAM,OAAOe,MAAK;AAChB,aAAOA,KAAI,KAAK,KAAK,GAAGpC,KAAI;AAAA,IAC9B;AAAA,IAEA,KAAK,KAAK;AACR,YAAM,CAAC,IAAI,EAAE,IAAI;AACjB,YAAM,IAAI,EAAE;AACZ,YAAM,KAAK,EAAE;AACb,YAAM,KAAK,EAAE;AAEb,QAAE,KAAK,MAAM,OAAO,KAAK,IAAI,GAAG,MAAM,KAAK,IAAI,EAAE,CAAC,IAAI;AACtD,QAAE,KAAK,MAAM,OAAO,KAAK,IAAI,GAAG,MAAM,KAAK,IAAI,EAAE,IAAI,CAAC,IAAI;AAC1D,QAAE,QAAQ;AAEV,UAAI,QAAQ;AACV,YAAI,EAAE,KAAK,KAAK,OAAO,EAAE,EAAE,GAAG;AAC5B,YAAE,KAAKsM,SAAO,KAAK,MAAM,KAAK,EAAE,EAAE,CAAC;AAAA,QACrC;AACA,YAAI,EAAE,KAAK,KAAK,OAAO,EAAE,EAAE,GAAG;AAC5B,YAAE,KAAKA,SAAO,MAAM,MAAM,KAAK,EAAE,KAAK,CAAC,CAAC;AAAA,QAC1C;AAAA,MACF;AAGA,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,cAAM,OAAO,MAAM,CAAC;AACpB,cAAM,OAAO,MAAM,CAAC;AACpB,iBAAS,IAAI,IAAI,IAAI,EAAE,IAAI,EAAE,GAAG;AAC9B,eAAK,IAAI,MAAM,KAAK,CAAC,GAAGtM,KAAI;AAAA,QAC9B;AACA,iBAAS,IAAI,IAAI,IAAI,EAAE,IAAI,EAAE,GAAG;AAC9B,eAAK,IAAI,MAAM,KAAK,CAAC,GAAGA,KAAI;AAAA,QAC9B;AACA,aAAK,MAAM,MAAMrD,SAAQ0E,IAAG;AAAA,MAC9B;AAGA,eAAS,GAAG1E,SAAQ0E,IAAG;AAEvB,aAAO1E;AAAA,IACT;AAAA,EACJ;AAEE,SAAO;AACT;ACrFA,MAAM,aAAa,CAAAkN,SAChBA,IAAG,SAAS,CAAC,MAAM,IAAI,GAAG,IAAI,OAAK,OAAO,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI;AAE7E,MAAM,aAAa,CAAAA,QAAM,CAAC,CAACA,IAAG;AAE9B,SAAS,SAAS,MAAM;AACtB,QAAM,EAAE,IAAI,MAAA3G,OAAM,SAAS,CAAA,GAAI,SAAS,CAAA,EAAE,IAAK;AAC/C,SAAO;AAAA,IACL,GAAG,UAAUA,KAAI,EAAE,OAAO,GAAG,MAAM;AAAA,IACnC,KAAK,OAAO,SAAS,OAAO,CAAC,IAAI;AAAA,IACjC;AAAA,EACJ;AACA;AAEO,SAAS,OAAOlE,QAAO,MAAM,OAAOrC,UAAS,CAAA,GAAI,KAAK;AAE3D,QAAMqD,QAAOhB,OAAM,KAAI;AACvB,QAAM,SAAS,aAAa,KAAKgB,KAAI;AACrC,QAAM,SAAS,OAAO;AAEtB,QAAM,QAAQ+J;AAAAA,IACZ,CAAC,KAAK,KAAK,IAAI;AAAA,IACf,MAAMxB,SAAO,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,aAAa,IAAI;AAAA,IAC9D;AAAA,IAAM;AAAA,EACV;AAGE,EAAAvJ,OAAM,WAAU,EAAG,QAAQ,CAAC,MAAMqC,SAAQ;AACxC,UAAM,OAAO,KAAK;AAClB,UAAM,QAAQ,YAAYrC,QAAO,IAAI;AAGrC,aAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,aAAO,CAAC,EAAE,KAAK,MAAM,OAAOrC,SAAQ0E,IAAG;AAAA,IACzC;AAGA,UAAMwI,MAAK,QAAMlN,QAAO,EAAE,EAAE0E,IAAG;AAC/B,aAAS,QAAQ,GAAG,QAAQ,MAAM,EAAE,OAAO;AAEzC,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,eAAO,CAAC,EAAE,KAAK,KAAK;AAAA,MACtB;AACA,YAAM,KAAK,KAAK,GAAGrB,OAAM6J,GAAE;AAAA,IAC7B;AAAA,EACF,CAAC;AACH;AAEA,SAAS,aAAa,KAAK7J,OAAM;AAC/B,QAAM,MAAM,CAAA;AAGZ,MAAI,QAAQ,CAAA6J,QAAM;AAChB,UAAM,QAAQ,WAAWA,GAAE;AAC3B,UAAM,QAAQ,WAAWA,GAAE;AAC3B,UAAMxI,OAAM,GAAG,KAAK,IAAI,KAAK;AAC7B,UAAM,EAAE,QAAQ,WAAW,IAAIA,IAAG,MAAM,IAAIA,IAAG,IAAI;AAAA,MACjD;AAAA,MACA;AAAA,MACA,QAAQ,CAAA;AAAA,MACR,QAAQ,CAAA;AAAA,IACd;AACI,iBAAawI,IAAG,IAAI,IAChB,OAAO,KAAKA,GAAE,IACd,OAAO,KAAK,SAASA,GAAE,CAAC;AAAA,EAC9B,CAAC;AAED,SAAO,OAAO,OAAO,GAAG,EAAE,IAAI,OAAK;AAAA,IACjC7J;AAAA,IAAM,EAAE;AAAA,IAAO,EAAE;AAAA,IAAO,EAAE;AAAA,IAC1B,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC,KAAK,OAAO,KAAK,CAAC;AAAA,EAClD,CAAG;AACH;AAEA,SAAS,YAAYhB,QAAO,MAAM;AAChC,MAAIA,OAAM,aAAa;AAErB,UAAM2D,WAAU3D,OAAM,WAAU;AAChC,UAAMgB,QAAOhB,OAAM,KAAI;AACvB,UAAM,QAAQ,KAAK;AACnB,UAAM,QAAQ,IAAI,YAAY,KAAK;AACnC,aAAS,IAAI,GAAG,QAAQ,GAAG,IAAI,OAAO,EAAE,GAAG;AACzC,YAAM,CAAC,IAAI2D,SAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,GAAG3C,KAAI,IAAI,EAAE,QAAQ;AAAA,IAC7D;AACA,WAAO;AAAA,EACT,OAAO;AAEL,WAAO;AAAA,EACT;AACF;ACtFA,SAAS,WAAW6J,KAAI;AACtB,SAAO,UAAUA,IAAG,IAAI,KACtBA,IAAG,UACD,OAAO,SAASA,IAAG,MAAM,CAAC,CAAC,KAC3B,OAAO,SAASA,IAAG,MAAM,CAAC,CAAC;AAEjC;AAEO,SAAS,OAAO7K,QAAO0C,SAAQ,UAAU,CAAA,GAAI;AAClD,QAAM,KAAK,QAAQ1C,QAAO8J,OAAMpH,SAAQ,EAAE,OAAA1C,QAAO,GAAG,OAAO;AAE3D,SAAO,QAAQ,QAAS,QAAQ,UAAU,QAAQ,QAAQ,SAAS,OAC/D,KACA;AAAA,IACE;AAAA,IACA,OAAO,KAAK0C,OAAM,EAAE,OAAO,CAAAwB,UAAQ,CAAClE,OAAM,OAAOkE,KAAI,CAAC;AAAA,IACtD;AAAA,EACR;AACA;AAEO,SAAS,QAAQlE,QAAO,EAAE,OAAO,OAAO,MAAM,CAAA,EAAE,GAAI,UAAU,IAAI;AAEvE,QAAM,QAAQA,OAAM,UAAS;AAC7B,QAAM,OAAO,UAAU,QAAQ,OAAO,OAAOA,MAAK;AAClD,QAAMgB,QAAO,MAAM,IAAI,CAAAkD,UAAQ,KAAK,IAAIA,OAAM,MAAM,KAAK,CAAC,CAAC;AAG3D,QAAM,CAAE,QAAQ,UAAW,WAAW,GAAG;AAEzC,QAAM,OAAOlE,OAAM,UAAS,IAAKA,OAAM,OAAM,EAAG,OAAO;AACvD,QAAMrC,UAAS;AAAA,IACbqC;AAAA,IAAO;AAAA,IACP,OAAO,IAAI,QAAQ,MAAM,MAAM,IAAI,CAAC;AAAA,EACxC;AAGE,SAAO,SACH,OAAOA,QAAOgB,OAAM,OAAOrD,SAAQ,MAAM,IACzCqN,SAAOhL,QAAOgB,OAAM,OAAOrD,OAAM;AAErC,SAAO,KAAK,OAAOqC,MAAK;AAC1B;AAEA,SAAS,WAAW,KAAK;AACvB,QAAM,SAAS,CAAA;AACf,QAAM,SAAS,CAAA;AACf,QAAM,IAAI,IAAI;AAEd,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAM6K,MAAK,IAAI,CAAC;AAChB,IAAAA,IAAG,KAAK;AACR,KAAC,WAAWA,GAAE,IAAI,SAAS,QAAQ,KAAKA,GAAE;AAAA,EAC5C;AAEA,SAAO,CAAC,QAAQ,MAAM;AACxB;AAEA,SAASG,SAAOhL,QAAO,MAAM,OAAOrC,SAAQ;AAC1C,QAAM,OAAOqC,OAAM,KAAI;AACvB,QAAMgB,QAAOhB,OAAM,KAAI;AACvB,QAAM,EAAE,MAAA4C,MAAI,IAAK5C,OAAM,OAAM,KAAM,CAAA;AACnC,QAAM6K,MAAKjI,QACP,CAAC,IAAI,QAAQjF,QAAO,EAAE,EAAEiF,MAAK,GAAG,CAAC,IACjC,QAAMjF,QAAO,EAAE,EAAE,CAAC;AAEtB,QAAM,IAAI,KAAK;AACf,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAMyF,OAAM,MAAM,CAAC;AACnB,UAAM,MAAM,KAAK,CAAC;AAIlB,QAAI,MAAM;AACR,eAAS,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACvD,YAAI,CAAC,IAAIA,KAAI,GAAGpC,OAAM6J,GAAE;AAAA,MAC1B;AAAA,IACF,OAAO;AACL,YAAM,IAAI7K,OAAM,UAAS;AACzB,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,YAAI,CAAC,IAAIoD,KAAI,GAAGpC,OAAM6J,GAAE;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AACF;ACvFO,SAAS,OAAO7K,QAAO,UAAU;AACtC,QAAM,OAAO8J,OAAM,EAAE,GAAG,SAAQ,GAAI,EAAE,OAAA9J,QAAO;AAC7C,MAAI,YAAY,KAAK,MAAM,CAAC;AAC5B,MAAI,KAAK,IAAI,QAAQ;AACnB,UAAMgB,QAAO,QAAQhB,QAAO,MAAM,EAAE,MAAM,KAAI,CAAE,EAAE,OAAO,GAAG;AAC5D,gBAAY,SAAOgB,MAAK,GAAG,GAAG;AAAA,EAChC;AACA,SAAO,QAAQhB,QAAO,SAAS;AACjC;AAEO,SAAS,QAAQA,QAAO,WAAW;AACxC,QAAM,IAAIA,OAAM,UAAS;AACzB,QAAM,OAAOA,OAAM,KAAI;AACvB,QAAMgB,QAAOhB,OAAM,KAAI;AACvB,QAAMiN,UAAS,IAAI,OAAO,CAAC;AAI3B,MAAI,MAAM;AACR,aAAS,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACvD,UAAI,UAAU,GAAGjM,KAAI,EAAG,CAAAiM,QAAO,IAAI,CAAC;AAAA,IACtC;AAAA,EACF,OAAO;AACL,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAI,UAAU,GAAGjM,KAAI,EAAG,CAAAiM,QAAO,IAAI,CAAC;AAAA,IACtC;AAAA,EACF;AAEA,SAAOjN,OAAM,OAAO,EAAE,QAAAiN,SAAQ;AAChC;AC9BO,SAAS,OAAOjN,WAAU4C,OAAM;AACrC,EAAAA,QAAOA,MAAK,KAAI;AAChB,QAAM,KAAK,QAAQ5C,QAAO4C,MAAK,SAASA,QAAO5C,OAAM,aAAa;AAClE,SAAO,OAAO,IAAI,oBAAoB,EAAE,QAAO,EAAG,MAAK;AACzD;ACPO,SAAS,UAAUA,QAAO,MAAM;AACrC,QAAM,MAAM,oBAAI,IAAG;AACnB,EAAAA,OAAM,KAAK,CAAC,KAAKgB,UAAS;AACxB,UAAMqB,OAAM,KAAK,KAAKrB,KAAI;AAC1B,QAAIqB,QAAO,QAAQA,SAAQA,MAAK;AAC9B,UAAI,IAAIA,MAAK,GAAG;AAAA,IAClB;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAEO,SAAS,YAAY,KAAKrB,OAAM,MAAM;AAC3C,QAAM,MAAM,oBAAI,IAAG;AACnB,QAAM,IAAI,IAAI;AACd,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAM,MAAM,IAAI,CAAC;AACjB,UAAMqB,OAAM,KAAK,KAAKrB,KAAI;AAC1B,QAAIqB,QAAO,QAAQA,SAAQA,MAAK;AAC9B,UAAI,IAAIA,IAAG,IACP,IAAI,IAAIA,IAAG,EAAE,KAAK,CAAC,IACnB,IAAI,IAAIA,MAAK,CAAC,CAAC,CAAC;AAAA,IACtB;AAAA,EACF;AACA,SAAO;AACT;ACxBO,SAASkL,YAAU,GAAG,GAAG;AAC9B,QAAM,MAAM,IAAI,IAAI,CAAC;AACrB,SAAO,EAAE,OAAO,OAAK,IAAI,IAAI,CAAC,CAAC;AACjC;ACOO,SAAS,SAASrJ,OAAMlE,QAAO,QAAQ;AAC5C,QAAM,QAAQ,oBAAI,IAAG;AAErB,UAAQ,MAAM,EAAE,QAAQ,CAAC,OAAO,MAAM;AACpC,YAAQ,SAAS,KAAK,IAAIA,OAAM,WAAW,KAAK,IAAI;AACpD,aAAS,KAAK,IAAI,MAAM,IAAI,GAAGC,QAAM,KAAK,CAAC,IACvC,WAAW,KAAK,KAAK,SAAS,KAAK,KAAK,MAAM,OAAO,MAAM,IAAI,GAAG,KAAK,IACvE,MAAM,WAAWiE,KAAI,eAAe,QAAM,EAAE,EAAE;AAAA,EACpD,CAAC;AAED,QAAM,KAAK4F,OAAM,OAAO,EAAE,OAAA9J,QAAO,WAAW,OAAO,QAAQ,OAAO;AAClE,SAAO,YAAY,GAAG,OAAO,IAAI;AACnC;AChBO,SAAS,UAAU,QAAQ,QAAQ,IAAI;AAC5C,MAAI,CAAC,IAAI;AAEP,UAAM,QAAQuN,YAAU,OAAO,YAAW,GAAI,OAAO,aAAa;AAClE,QAAI,CAAC,MAAM,OAAQ,OAAM,4CAA4C;AACrE,SAAK,CAAC,OAAO,KAAK;AAAA,EACpB,WAAW,SAAS,EAAE,GAAG;AACvB,SAAK,CAAC,IAAI,EAAE;AAAA,EACd,WAAWnE,UAAQ,EAAE,KAAK,GAAG,WAAW,GAAG;AACzC,SAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,EACpB;AAEA,SAAO;AACT;AAEO,SAAS,aAAa,QAAQ,QAAQ,KAAK,KAAK;AACrD,MAAI,IAAI,WAAW,IAAI,QAAQ;AAC7B,UAAM,gCAAgC;AAAA,EACxC;AACA,SAAO;AAAA,IACL,SAAS,QAAQ,QAAQ,GAAG;AAAA,IAC5B,SAAS,QAAQ,QAAQ,GAAG;AAAA,EAChC;AACA;ACtBO,SAAS,SAAS,QAAQ,QAAQ,IAAI;AAC3C,SAAO,YAAY,QAAQ,QAAQ,IAAI,EAAE,MAAM,OAAO;AACxD;AAEO,SAAS,SAAS,QAAQ,QAAQ,IAAI;AAC3C,SAAO,YAAY,QAAQ,QAAQ,IAAI,EAAE,MAAM,MAAM;AACvD;AAEO,SAAS,YAAY,QAAQ,QAAQ,IAAI,SAAS;AACvD,OAAK,UAAU,QAAQ,QAAQ,EAAE;AAEjC,QAAM,YAAYA,UAAQ,EAAE,IACxB,aAAa,QAAQ,QAAQ,GAAG,GAAG,IAAI,OAAO,CAAC,IAC/CU,OAAM,EAAE,MAAM,EAAE,MAAM,CAAC,QAAQ,MAAM,EAAC,CAAE,EAAE,MAAM,CAAC;AAErD,SAAO,aAAa,QAAQ,QAAQ,WAAW,OAAO;AACxD;AAEO,SAAS,aAAa,QAAQ,QAAQ,WAAW,UAAU,CAAA,GAAI;AAEpE,QAAMmD,UAAS,IAAI,OAAO,OAAO,UAAS,CAAE;AAC5C,QAAMxD,QAAOL,UAAQ,SAAS,IAAI,eAAe;AACjD,EAAAK,MAAKwD,SAAQ,QAAQ,QAAQ,SAAS;AAGtC,MAAI,QAAQ,MAAM;AAChB,IAAAA,QAAO,IAAG,EAAG,IAAI,OAAO,KAAI,CAAE;AAAA,EAChC;AAEA,SAAO,OAAO,OAAO,EAAE,QAAAA,SAAQ;AACjC;AAEA,SAAS,aAAaA,SAAQ,QAAQ,QAAQ,CAAC,MAAM,IAAI,GAAG;AAE1D,QAAM,MAAM,UAAU,QAAQ,IAAI;AAGlC,SAAO,KAAK,CAAC,MAAMjM,UAAS;AAC1B,UAAM,OAAO,IAAI,IAAI,KAAK,MAAMA,KAAI,CAAC;AACrC,QAAI,QAAQ,EAAG,CAAAiM,QAAO,IAAI,IAAI;AAAA,EAChC,CAAC;AACH;AAEA,SAAS,aAAaA,SAAQ,QAAQ,QAAQ,WAAW;AACvD,QAAM,KAAK,OAAO,QAAO;AACzB,QAAM,KAAK,OAAO,QAAO;AACzB,QAAM,QAAQ,OAAO,KAAI;AACzB,QAAM,QAAQ,OAAO,KAAI;AAEzB,MAAI,OAAO,WAAU,KAAM,OAAO,WAAU,GAAI;AAE9C,UAAM,OAAO,OAAO,QAAQ,KAAK;AACjC,UAAM,OAAO,OAAO,QAAQ,KAAK;AACjC,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,YAAM,OAAO,KAAK,CAAC;AACnB,eAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,YAAI,UAAU,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK,GAAG;AAC1C,UAAAA,QAAO,IAAI,IAAI;AACf;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AAEL,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,eAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,YAAI,UAAU,GAAG,OAAO,GAAG,KAAK,GAAG;AACjC,UAAAA,QAAO,IAAI,CAAC;AACZ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AC7EO,SAAS,OAAOjN,WAAU,QAAQ;AACvC,WAAS,OAAO,KAAI;AACpB,MAAI,OAAO,WAAW,EAAG,QAAOA;AAChC,QAAM,QAAQA,OAAM,YAAW;AAC/B,SAAO,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,SAAS,GAAG,EAAE,OAAO,KAAK,CAAC,GAAGA,MAAK,CAAC;AAC5E;ACHO,SAAS,OAAOA,QAAO0C,SAAQ,SAAS;AAC7C,SAAO;AAAA,IACL1C;AAAA,IACA,WAAW,UAAUA,QAAO0C,OAAM;AAAA,IAClC,WAAW,QAAQ,OACf,EAAE,GAAG,SAAS,MAAM,WAAW,UAAU1C,QAAO,QAAQ,IAAI,EAAE,MAAK,IACnE;AAAA,EACR;AACA;AAEO,SAAS,QAAQA,QAAO,EAAE,QAAQ,IAAI,QAAQ,CAAA,GAAI,MAAM,CAAA,KAAM,UAAU,CAAA,GAAI;AACjF,MAAI,CAAC,MAAM,OAAQ,QAAOA;AAE1B,QAAM,QAAQ,QAAQ,QAAQ,IAAI,CAAC,QAAQ,QAAQ;AACnD,QAAM,QAAQ,QAAQ,QAClB,QAAQ,UAAU,OAAO,UAAU,QAAQ,QAAQ,KACnD;AACJ,QAAM,OAAO,IAAI,IAAI,QAAQ,IAAI;AACjC,QAAMoD,OAAM,aAAapD,QAAO,KAAK,KAAK;AAG1C,QAAM,OAAO,UAAS;AACtB,QAAM,OAAO,IAAI,IAAI,KAAK;AAC1B,QAAM,SAAS,CAAA;AACf,QAAM,SAAS,CAAA;AACf,QAAM+K,UAAS,CAAA;AAGf,EAAA/K,OAAM,YAAW,EAAG,QAAQ,CAAAkE,UAAQ;AAClC,QAAI,CAAC,KAAK,IAAIA,KAAI,GAAG;AACnB,YAAM,MAAM,KAAK,IAAIA,OAAM,CAAA,CAAE;AAC7B,UAAI,CAAC,KAAK,IAAIA,KAAI,GAAG;AACnB,eAAO,KAAKlE,OAAM,OAAOkE,KAAI,CAAC;AAC9B,eAAO,KAAK,GAAG;AAAA,MACjB;AAAA,IACF;AAAA,EACF,CAAC;AAGD,QAAM,QAAQ,CAAAA,UAAQ;AACpB,QAAI,CAAC,KAAK,IAAIA,KAAI,GAAG;AACnB,UAAI,CAAC,KAAK,IAAIA,KAAI,EAAG,MAAK,IAAIA,OAAM,EAAE;AACtC,MAAA6G,QAAO,KAAK,KAAK,KAAK7G,KAAI,CAAC;AAAA,IAC7B;AAAA,EACF,CAAC;AAGD,QAAM,OAAO,QAAQ,KAAK,IAAI,OAAO,CAAA,CAAE,IAAI;AAE3C,MAAI,QAAQ;AACZ,QAAM,IAAI,OAAO;AACjB,QAAM,IAAI6G,QAAO;AAEjB,QAAM,OAAO,CAAC,KAAK,WAAW;AAC5B,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,aAAO,CAAC,EAAE,SAAS,QAAQ;AAC3B,aAAO,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE,GAAG,GAAG,GAAG,OAAO,QAAQ,MAAM;AAAA,IACzD;AAAA,EACF;AAEA,QAAM,UAAU,OACZ,CAAC,KAAK,WAAW;AACf,aAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,WAAK,MAAM,CAAC,IAAI;AAAA,IAClB;AAAA,EACF,IACA,MAAM;AAAA,EAAC;AAEX,MAAI,MAAM,GAAG;AAEX,UAAM,KAAK3H,KAAI,CAAC;AAChB,UAAM,MAAM2H,QAAO,CAAC;AAEpB,IAAA/K,OAAM,KAAK,CAAC,KAAKgB,UAAS;AAExB,YAAMO,SAAQ,QAAQ,GAAG,KAAKP,KAAI,CAAC;AACnC,YAAM,SAAS,KAAK,IAAIO,OAAM,QAAQ,KAAK;AAG3C,WAAK,KAAK,MAAM;AAGhB,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,YAAI,QAAQ,CAAC,IAAIA,OAAM,CAAC;AAAA,MAC1B;AAGA,cAAQ,OAAO,MAAM;AAErB,eAAS;AAAA,IACX,CAAC;AAAA,EACH,OAAO;AACL,IAAAvB,OAAM,KAAK,CAAC,KAAKgB,UAAS;AACxB,UAAI,SAAS;AAGb,YAAM,SAASoC,KAAI,IAAI,QAAM;AAC3B,cAAMtF,SAAQ,QAAQ,GAAG,KAAKkD,KAAI,CAAC;AACnC,iBAAS,KAAK,IAAI,KAAK,IAAI,QAAQlD,OAAM,MAAM,GAAG,KAAK;AACvD,eAAOA;AAAA,MACT,CAAC;AAGD,WAAK,KAAK,MAAM;AAGhB,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,cAAM,MAAMiN,QAAO,CAAC;AACpB,cAAM,MAAM,OAAO,CAAC;AACpB,iBAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,cAAI,QAAQ,CAAC,IAAI,IAAI,CAAC;AAAA,QACxB;AAAA,MACF;AAGA,cAAQ,OAAO,MAAM;AAErB,eAAS;AAAA,IACX,CAAC;AAAA,EACH;AAEA,SAAO,KAAK,IAAI/K,MAAK;AACvB;AC3HO,SAAS,KAAKA,QAAO0C,SAAQ,SAAS;AAC3C,SAAO,MAAM1C,QAAO,WAAW,QAAQA,QAAO0C,OAAM,GAAG,OAAO;AAChE;AAEO,SAAS,MAAM1C,QAAO,EAAE,QAAQ,IAAI,QAAQ,CAAA,GAAI,MAAM,CAAA,KAAM,UAAU,CAAA,GAAI;AAC/E,MAAI,MAAM,WAAW,EAAG,QAAOA;AAE/B,QAAM,CAAC,IAAI,OAAO,IAAI,OAAO,IAAI,QAAQ,MAAM,CAAA;AAC/C,QAAM,OAAO,aAAaA,QAAO,KAAK,KAAK;AAE3C,SAAO;AAAA,IACLA;AAAA,IACA;AAAA,MACE,OAAO,CAAC,GAAG,CAAC;AAAA,MACZ,OAAO,CAAC,MAAM,OAAO,CAAC,KAAKgB,UAAS,KAAK,IAAI,QAAM,GAAG,KAAKA,KAAI,CAAC,CAAC;AAAA,IACvE;AAAA,IACI,EAAE,GAAG,SAAS,MAAM,MAAK;AAAA,EAC7B;AACA;ACtBO,SAAS,QAAQhB,QAAO;AAC7B,SAAOA,OAAM,UAAS,IAClBA,OAAM,OAAO,EAAE,QAAQ,KAAI,CAAE,IAC7BA;AACN;ACSO,SAAS,OAAOA,QAAO0C,SAAQ,UAAU,CAAA,GAAI;AAClD,EAAAA,UAASoH,OAAMpH,SAAQ,EAAE,OAAA1C,OAAK,CAAE;AAEhC,EAAA0C,QAAO,MAAM;AAAA,IAAQ,CAAAwB,UACnBlE,OAAM,OAAOkE,KAAI,IAAI,IAAI,MAAM,yBAAyBwG,WAASxG,KAAI,CAAC,EAAE;AAAA,EAC5E;AAEE,MAAI,QAAQ,QAAQ;AAClB,UAAMyH,OAAM,EAAA,UAAE6B,YAAU,QAAQ,OAAO,UAAU,KAAI;AACrD,UAAM,SAAS,WAAW,UAAUxN,QAAO,QAAQ,QAAQ2L,IAAG;AAC9D,UAAMhO,UAAS,QAAQ,QAAQqC,MAAK,GAAG,MAAM;AAC7C,WAAO;AAAA,MACLA;AAAA,MAAO0C;AAAA,MAAQ,OAAO;AAAA,MACtB,OAAO,MAAM,IAAI,CAAAwB,UAAQvG,QAAO,IAAIuG,OAAM,CAAC,CAAC;AAAA,IAClD;AAAA,EACE,OAAO;AACL,WAAO,QAAQlE,QAAO0C,OAAM;AAAA,EAC9B;AACF;AAGA,SAAS8K,WAAS,KAAK;AACrB,MAAI;AAAA,IAAQ,CAAC1P,QAAOuE,SAClBvE,OAAM,QAAQ,IAAI,IAAIuE,MAAK,mBAAmBvE,SAAQ,EAAE,CAAC,IAAI;AAAA,EACjE;AACA;AAEO,SAAS,QAAQkC,QAAO0C,SAAQE,OAAM,QAAQ;AACnD,QAAM,QAAQA,SAAQA,MAAK;AAC3B,EAAA5C,SAAQ,QAAQ,OAAOA,QAAO4C,OAAM,MAAM,IAAI5C;AAC9C,QAAM,EAAE,OAAO,OAAO,IAAG,IAAK0C;AAC9B,QAAM,OAAO,aAAa1C,QAAO,KAAK,KAAK;AAC3C,QAAM,OAAO,QAAQ,OAAO,UAAUA,MAAK;AAC3C,QAAM,OAAOA,OAAM,UAAS;AAE5B,QAAM,QAAQ,CAACkE,OAAM,MAAM;AACzB,UAAM,MAAMlE,OAAM,OAAOkE,KAAI;AAC7B,UAAM,MAAM,QAAQ,MAAM,KAAK,IAAIA,OAAM,MAAM,IAAI,CAAC;AACpD,UAAMd,OAAM,KAAK,CAAC;AAElB,IAAApD,OAAM,KAAK,SAAO;AAChB,YAAM,IAAI,IAAI,GAAG,GAAG;AACpB,UAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAIoD,KAAI,GAAG,IAAI;AAAA,IACtC,CAAC;AAAA,EACH,CAAC;AAED,SAAO,QAAQpD,SAAQA,OAAM,OAAO,IAAI;AAC1C;AAEA,SAAS,OAAOA,QAAO4C,OAAMF,SAAQ;AACnC,QAAM,SAAS1C,OAAM,OAAM;AAC3B,QAAMgB,QAAOhB,OAAM,KAAI;AAGvB,QAAM,YAAY,SAAS,OAAO,QAAQ,CAAA,GAAI,OAAO4C,KAAI;AACzD,QAAM,UAAU,SAAS,OAAO,MAAM,CAAA,GACnC,OAAOA,MAAK,IAAI,CAAAP,SAAOrC,OAAM,OAAOqC,IAAG,CAAC,CAAC;AAG5C,QAAM,OAAO,oBAAI,IAAG;AACpB,QAAM,WAAW,YAAY,MAAM;AACnC,EAAArC,OAAM,KAAK,CAAC,KAAKgB,UAAS,KAAK,IAAI,SAAS,KAAKA,KAAI,CAAC,CAAC;AAGvD,QAAM,QAAQhB,OAAM,YAAW;AAC/B,QAAM,OAAO,UAAS;AACtB,QAAM,MAAM,MAAM,IAAI,CAAAkE,UAAQ,KAAK,IAAIA,OAAM,CAAA,CAAE,CAAC;AAChD,QAAM,QAAQ,CAACA,OAAM,MAAM;AACzB,UAAM,MAAMlD,MAAKkD,KAAI;AACrB,UAAM,MAAM,IAAI,CAAC;AACjB,IAAAlE,OAAM,KAAK,SAAO,IAAI,KAAK,IAAI,GAAG,GAAG,CAAC,CAAC;AAAA,EACzC,CAAC;AAGD,QAAM,UAAU,YAAY,OAAO,IAAI,CAAC,GAAG,MAAM,OAAK,EAAE,CAAC,CAAC,CAAC;AAC3D,QAAM,MAAM+K;AAAAA,IACV;AAAA,IACA,MAAM,IAAI,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI;AAAA,IAC5D;AAAA,IAAK,MAAM,IAAI,CAAA7G,UAAQ,SAAS,QAAQA,KAAI,CAAC;AAAA,EACjD;AAEE,MAAI,QAAQ;AACV,QAAI,MAAM,OAAO,KAAK;AACtB,UAAM,OAAOxB,QAAO,OAAO,CAAC,GAAG,MAAM,IAAI,EAAE,QAAQ,OAAO,IAAI;AAC9D,UAAME,QAAO,IAAI,YAAY,QAAQ,MAAM,KAAK,KAAK;AACrD,IAAAA,MAAK,IAAI,OAAO,IAAI;AACpB,cAAU,QAAQF,SAAQ,CAAC,KAAK,QAAQ;AACtC,UAAI,CAAC,KAAK,IAAI,QAAQ,GAAG,CAAC,GAAG;AAC3B,YAAI,GAAG;AACP,QAAAE,MAAK,KAAK,IAAI,IAAI,CAAC;AAAA,MACrB;AAAA,IACF,CAAC;AACD,SAAK,QAAQ,EAAE,GAAG,QAAQ,MAAAA,MAAI,CAAE;AAAA,EAClC,OAAO;AACL,cAAU,QAAQF,SAAQ,SAAO;AAC/B,UAAI,CAAC,KAAK,IAAI,QAAQ,GAAG,CAAC,EAAG,KAAI,GAAG;AAAA,IACtC,CAAC;AAAA,EACH;AAEA,SAAO,KAAK,IAAI1C,MAAK;AACvB;AAEA,SAAS,UAAU,QAAQ0C,SAAQ,UAAU;AAC3C,QAAMhE,UAAS,SAAS,OAAO,IAAI,SAAS;AAC5C,QAAM+O,OAAM,SAAS,IAAI;AACzB,QAAM,MAAMA,OAAM/K,QAAO;AACzB,QAAM,OAAO,IAAI,WAAW,GAAG;AAC/B,QAAM,OAAO,IAAI,WAAW,GAAG;AAC/B,QAAM,MAAM,CAAA;AAEZ,MAAI,QAAQ;AACV,UAAM,EAAE,KAAAU,MAAK,MAAM,KAAI,IAAK;AAC5B,SAAK,CAAC,IAAI;AACV,QAAI,KAAK,CAACsK,MAAK,QAAQ;AACrB,YAAM,MAAM,KAAK,GAAG;AACpB,eAAS,IAAI,GAAG,IAAIhP,SAAQ,EAAE,GAAG;AAC/B,QAAAgP,KAAI,CAAC,IAAItK,KAAI,CAAC,EAAE,GAAG;AAAA,MACrB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,EAAAV,QAAO,QAAQ,CAAC,GAAG,MAAM;AACvB,UAAM,IAAI,IAAIhE;AACd,SAAK,IAAI+O,IAAG,IAAI,EAAE;AAClB,QAAI,KAAK,CAACC,MAAK,QAAQA,KAAI,CAAC,IAAI,EAAE,GAAG,CAAC;AAAA,EACxC,CAAC;AAED,QAAM,MAAM,MAAMhP,UAASgE,QAAO,MAAM;AAGxC,WAAS,IAAI,GAAG,IAAI,KAAK,EAAE,GAAG;AAC5B,QAAI,CAAC,EAAE,KAAK,CAAC;AAAA,EACf;AACA,WAAS,KAAK,IAAI;AAGlB,WAAS,IAAI,MAAM,GAAG,KAAK,KAAI;AAC7B,UAAM,MAAM,EAAE,KAAK,CAAC;AACpB,QAAI,MAAM,KAAK,CAAC,GAAG;AACjB,UAAI,CAAC,EAAE,KAAK,GAAG;AACf,eAAS,KAAK,IAAI;AAClB,UAAI,MAAM;AAAA,IACZ,OAAO;AACL,WAAK,CAAC,IAAI;AACV,UAAI,CAAC,EAAE,KAAK,CAAC;AACb,QAAE;AAAA,IACJ;AAAA,EACF;AACF;AC9JO,SAAS,UAAU1C,WAAU,QAAQ;AAC1C,WAAS,OAAO,KAAI;AACpB,QAAM,QAAQA,OAAM,YAAW;AAC/B,SAAO,OAAO,SACV,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,SAAS,GAAG,EAAE,OAAO,KAAK,CAAC,GAAGA,MAAK,CAAC,IACnEA,OAAM,MAAM,EAAE;AACpB;ACIA,MAAM,QAAQ,EAAE,WAAW,OAAO,QAAQ,MAAK;AAC/C,MAAM,QAAQ,EAAE,GAAG,OAAO,OAAO,EAAC;AAClC,MAAM,OAAO;AAEN,SAAS,MAAMA,QAAO,OAAO0C,SAAQ,SAAS;AACnD,SAAO;AAAA,IACL1C;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN0C;AAAA,IACA,EAAE,GAAG,SAAS,MAAM,MAAM,OAAO,KAAI;AAAA,EACzC;AACA;AAEO,SAAS,KAAK,QAAQ,QAAQ,IAAIA,SAAQ,UAAU,IAAI;AAC7D,OAAK,UAAU,QAAQ,QAAQ,EAAE;AACjC,QAAM,WAAW,EAAE,MAAM,CAAC,QAAQ,MAAM,EAAC;AACzC,MAAI;AAEJ,MAAI0G,UAAQ,EAAE,GAAG;AACf,UAAM,CAAC,KAAK,GAAG,IAAI,GAAG,IAAI,OAAO;AACjC,gBAAY,aAAa,QAAQ,QAAQ,KAAK,GAAG;AAEjD,QAAI,CAAC1G,SAAQ;AAEX,MAAAA,UAAS,YAAY,QAAQ,KAAK,KAAK,OAAO;AAAA,IAChD;AAAA,EACF,OAAO;AACL,gBAAYoH,OAAM,EAAE,GAAE,GAAI,QAAQ,EAAE,MAAM,CAAC;AAE3C,QAAI,CAACpH,SAAQ;AAEX,MAAAA,UAAS,CAAC,OAAO,KAAK;AAAA,IACxB;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IAAQ;AAAA,IAAQ;AAAA,IAChBiL,cAAY,QAAQ,QAAQjL,SAAQ,UAAU,WAAW,QAAQ,MAAM;AAAA,IACvE;AAAA,EACJ;AACA;AAEA,SAAS,YAAY,QAAQ,KAAK,KAAK,SAAS;AAC9C,QAAM,QAAQ,CAAA;AACd,MAAI,QAAQ,CAAC,GAAG,MAAM,SAAS,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,MAAM,KAAK,CAAC,IAAI,CAAC;AACrE,QAAM,KAAK,IAAI,KAAK;AAEpB,MAAI,QAAQ,QAAQ,QAAQ,OAAO;AAEjC,UAAM,SAAS,IAAI,IAAI,KAAK;AAC5B,WAAO;AAAA,MACL,OAAO,YAAW,EAAG,IAAI,OAAK;AAC5B,cAAM,IAAI,IAAIgI,WAAS,CAAC,CAAC;AACzB,eAAO,OAAO,IAAI,CAAC,IACf,EAAE,CAAC,CAAC,GAAG,cAAc,CAAC,eAAe,CAAC,OAAO,CAAC,GAAE,IAChD;AAAA,MACN,CAAC;AAAA,MACD;AAAA,IACN;AAAA,EACE;AAEA,SAAO,QAAQ,QAAQ,CAAC,IAAI,IAAG,CAAE,IAAI,CAAC,IAAG,GAAI,EAAE;AACjD;AAEA,SAASiD,cAAY,QAAQ,QAAQjL,SAAQ,UAAU,SAAS,IAAI;AAClE,MAAI0G,UAAQ1G,OAAM,GAAG;AACnB,QAAI,IAAI,IAAI,IAAI,IAAIA,QAAO;AAC3B,SAAK,KAAK,KAAK,EAAE,OAAO,CAAA,GAAI,OAAO,GAAE;AAErC,QAAI,KAAK;AACP,WAAK,WAAW,QAAQ,QAAQA,QAAO,CAAC,GAAG,QAAQ;AAAA,IACrD;AACA,QAAI,KAAK;AACP,WAAK,WAAW,QAAQ,QAAQA,QAAO,CAAC,GAAG,KAAK;AAAA,IAClD;AACA,QAAI,KAAK;AACP,WAAKoH,OAAMpH,QAAO,CAAC,GAAG,QAAQ;AAAA,IAChC;AAGA,UAAMkL,UAAS,oBAAI,IAAG;AACtB,UAAM,SAAS,IAAI,IAAI,GAAG,KAAK;AAC/B,OAAG,MAAM,QAAQ,CAAA1J,UAAQ;AACvB,UAAI,OAAO,IAAIA,KAAI,GAAG;AACpB,QAAA0J,QAAO,IAAI1J,KAAI;AAAA,MACjB;AAAA,IACF,CAAC;AACD,QAAI0J,QAAO,MAAM;AACf,aAAO,CAAC,MAAM,MAAM,MAAM,GAAG,OAAOA,SAAQ,OAAO,CAAC,KAAK,IAAI;AAC7D,aAAO,CAAC,MAAM,MAAM,MAAM,GAAG,OAAOA,SAAQ,OAAO,CAAC,KAAK,IAAI;AAAA,IAC/D;AAEA,WAAO;AAAA,MACL,OAAO,GAAG,MAAM,OAAO,GAAG,OAAO,GAAG,KAAK;AAAA,MACzC,OAAO,GAAG,MAAM,OAAO,GAAG,OAAO,GAAG,KAAK;AAAA,IAC/C;AAAA,EACE,OAAO;AACL,WAAO9D,OAAMpH,SAAQ,QAAQ;AAAA,EAC/B;AACF;AAEA,SAAS,MAAM,OAAOkL,SAAQ,QAAQ;AACpC,QAAM,QAAQ,CAAC1J,OAAM,MAAM0J,QAAO,IAAI1J,KAAI,IACrC,MAAM,CAAC,IAAIA,QAAO,SACnB,CAAC;AACP;AAEA,SAAS,QAAQyD,UAAS,SAAS;AACjC,QAAM,OAAO,CAAC,KAAK,KAAK,KAAK,GAAG;AAChC,SAAOoD;AAAAA,IACL;AAAA,IACA,MAAMxB,SAAO5B,UAAS,CAAC,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,KAAK,IAAI;AAAA,IACjEA;AAAA,IAAS;AAAA,EACb;AACA;AAEO,SAAS,MAAM,QAAQ,QAAQ,WAAW,EAAE,OAAO,MAAK,GAAI,UAAU,IAAI;AAE/E,QAAM,QAAQ,OAAO,KAAI;AACzB,QAAM,OAAO,OAAO,QAAQ,KAAK;AACjC,QAAM,KAAK,KAAK;AAChB,QAAM,OAAO,IAAI,WAAW,EAAE;AAG9B,QAAM,QAAQ,OAAO,KAAI;AACzB,QAAM,OAAO,OAAO,QAAQ,KAAK;AACjC,QAAM,KAAK,KAAK;AAChB,QAAM,OAAO,IAAI,WAAW,EAAE;AAG9B,QAAM,QAAQ,MAAM;AACpB,QAAM,OAAO,UAAS;AACtB,QAAMA,WAAU,MAAM,KAAK;AAC3B,QAAM,UAAU,MAAM,KAAK;AAC3B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,IAAAA,SAAQ,CAAC,IAAI,KAAK,IAAI,MAAM,CAAC,GAAG,EAAE;AAClC,YAAQ,CAAC,IAAI,MAAM,CAAC;AAAA,EACtB;AACA,QAAM,OAAO,QAAQA,UAAS,OAAO;AAGrC,QAAM8B,QAAOL,UAAQ,SAAS,IAAI,WAAW;AAC7C,EAAAK,MAAK,MAAM,WAAW,OAAO,OAAO,MAAM,MAAM,MAAM,MAAM,IAAI,EAAE;AAElE,MAAI,QAAQ,MAAM;AAChB,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,UAAI,CAAC,KAAK,CAAC,GAAG;AACZ,aAAK,KAAK,CAAC,GAAG,OAAO,MAAM,KAAK;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAEA,MAAI,QAAQ,OAAO;AACjB,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,UAAI,CAAC,KAAK,CAAC,GAAG;AACZ,aAAK,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAEA,SAAO,KAAK,IAAI,MAAM;AACxB;AAEA,SAAS,SAAS,MAAM,WAAW,OAAO,OAAO,MAAM,MAAM,MAAM,MAAM,IAAI,IAAI;AAE/E,WAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,UAAM,OAAO,KAAK,CAAC;AACnB,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,YAAM,OAAO,KAAK,CAAC;AACnB,UAAI,UAAU,MAAM,OAAO,MAAM,KAAK,GAAG;AACvC,aAAK,MAAM,OAAO,MAAM,KAAK;AAC7B,aAAK,CAAC,IAAI;AACV,aAAK,CAAC,IAAI;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,SAAS,MAAM,CAAC,MAAM,IAAI,GAAG,OAAO,OAAO,MAAM,MAAM,MAAM,MAAM,IAAI,IAAI;AAElF,MAAI,UAAU,SAAS,SAAS;AAChC,MAAI,UAAU,SAAS,SAAS;AAChC,MAAI,WAAW;AACf,MAAI,MAAM,IAAI;AACZ,eAAW;AAAO,cAAU;AAAM,cAAU;AAAM,cAAU;AAC5D,eAAW;AAAO,cAAU;AAAM,cAAU;AAAM,cAAU;AAAA,EAC9D,OAAO;AACL,eAAW;AAAO,cAAU;AAAM,cAAU;AAAM,cAAU;AAC5D,eAAW;AAAO,cAAU;AAAM,cAAU;AAAM,cAAU;AAC5D,eAAW,CAAC,GAAG,GAAG,GAAG,MAAM,KAAK,GAAG,GAAG,GAAG,CAAC;AAAA,EAC5C;AAGA,QAAM,MAAM,YAAY,SAAS,UAAU,OAAO;AAGlD,QAAM,IAAI,QAAQ;AAClB,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAM,UAAU,QAAQ,CAAC;AACzB,UAAMtJ,QAAO,IAAI,IAAI,QAAQ,SAAS,QAAQ,CAAC;AAC/C,QAAIA,OAAM;AACR,YAAM,IAAIA,MAAK;AACf,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,cAAM,IAAIA,MAAK,CAAC;AAChB,iBAAS,SAAS,UAAU,QAAQ,CAAC,GAAG,QAAQ;AAChD,gBAAQ,CAAC,IAAI;AAAA,MACf;AACA,cAAQ,CAAC,IAAI;AAAA,IACf;AAAA,EACF;AACF;ACrNO,SAAS,OAAO,QAAQ,QAAQ,OAAOuC,SAAQ;AACpD,OAAK,UAAU,QAAQ,QAAQ,EAAE;AACjC,EAAAA,UAASA,QAAO,WAAW,IACvB,CAAC,IAAI,OAAO,aAAa,CAAC,IAC1BA,QAAO,KAAI;AACf,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,CAAE,SAAS,UAAU,QAAQ,GAAG,CAAC,CAAC,GAAG,SAAS,UAAU,QAAQ,GAAG,CAAC,CAAC,CAAC;AAAA,IACtE,WAAW,UAAU,QAAQA,OAAM;AAAA,EACvC;AACA;AAEO,SAAS,QAAQ,QAAQ,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE,OAAO,OAAO,MAAM,CAAA,EAAE,GAAI;AAEhF,QAAM,OAAO,UAAU,MAAM;AAC7B,QAAM,QAAQ,OAAO,UAAS;AAC9B,QAAM,QAAQ,CAAAwB,UAAQ,KAAK,IAAIA,OAAM,MAAM,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC;AAG7D,QAAM,MAAM,UAAU,QAAQ,IAAI;AAGlC,QAAM,MAAM6G;AAAAA,IACV,CAAC,MAAM,MAAM,MAAM;AAAA,IACnB,MAAMxB,SAAO,OAAO,CAAC,GAAG,MAAM,KAAK,CAAC,aAAa,CAAC,cAAc,IAAI;AAAA,IACpE,MAAM,IAAI,CAAArF,UAAQ,KAAK,KAAKA,KAAI,CAAC;AAAA,IACjC,aAAa,QAAQ,KAAK,KAAK;AAAA,EACnC;AAGE,QAAM,QAAQ,OAAO,KAAI;AACzB,SAAO,KAAK,CAAC,MAAMlD,UAAS;AAC1B,UAAM,OAAO,IAAI,IAAI,KAAK,MAAMA,KAAI,CAAC;AACrC,QAAI,QAAQ,EAAG,KAAI,MAAM,MAAM,KAAK;AAAA,EACtC,CAAC;AAED,SAAO,KAAK,OAAO,MAAM;AAC3B;AC5CA,MAAM,WAAW,CAAC,GAAG,GAAG,IAAI,OAAO,SAAS,CAAC,YAAY,CAAC,kCAAkC,EAAE,0CAA0C,EAAE,8FAA8F,EAAE,2BAA2B,EAAE;AACvQ,MAAM,WAAW,CAAC,GAAG,GAAG,IAAI,IAAI,MAAM,QAAQ,CAAC,UAAU,CAAC,6CAA6C,EAAE,kBAAkB,EAAE,WAAW,CAAC;AAElI,SAAS,QAAQhB,QAAO,QAAQ;AAErC,QAAM,QAAQ,CAAA;AACd,QAAM,QAAQ,CAAA;AACd,QAAM,KAAK,CAAA;AACX,MAAI4C,QAAO,MAAM,MAAM,KAAK,MAAM;AAClC,MAAI5C,OAAM,aAAa;AACrB,IAAA4C,QAAO5C,OAAM,OAAM,EAAG;AACtB,UAAM;AACN,UAAM;AAAA,EACR;AACA,QAAM,EAAE,IAAG,IAAK8J,OAAM,QAAQ;AAAA,IAC5B,OAAA9J;AAAA,IACA,OAAO,CAACkE,OAAM,SAAS;AACrB,YAAM,KAAKA,KAAI;AACf,UAAI,KAAK,QAAQ;AAEf,cAAM,IAAI,OAAK,MAAM,GAAG,MAAM,KAAK,CAAC;AACpC,cAAM,KAAK,CAAC,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC;AAC3B,WAAG,KAAK,KAAK,MAAM;AAAA,MACrB,OAAO;AAEL,cAAM,KAAK;AAAA,UACT,QAAQ,MAAM,EAAE,OAAO,KAAK,IAAI,KAAK;AAAA,UACrC,QAAQ,MAAM,EAAE,OAAO,KAAK,IAAI,IAAG,CAAE;AAAA,QAC/C,CAAS;AAAA,MACH;AAAA,IACF;AAAA,IACA,QAAQ;AAAA,EACZ,CAAG;AAGD,QAAMvG,UAAS,UAAUqC,QAAO,GAAG;AACnC,QAAM6K,MAAK,CAAC,IAAI,QAAQlN,QAAO,EAAE,EAAE,GAAG;AAGtC,QAAM,IAAI,MAAM;AAChB,MAAI,OAAO,wBACNkN,OAAM7K,OAAM,UAAS,IAAK,sCAAsC,MACjE;AACJ,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAMC,SAAQ,OAAO,IAAI,MAAM,CAAC,CAAC;AACjC,UAAM,IAAIA,OAAM,OAAO,KAAK;AAC5B,UAAM,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC;AACtB,QAAIA,OAAM,SAAS;AACjB,cAAQ,SAAS,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,IAAI,IAAI,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG;AACnE,SAAG,KAAKA,OAAM,OAAO;AAAA,IACvB,OAAO;AACL,cAAQ,SAAS,GAAG,GAAG,CAAC,GAAG,CAAC;AAAA,IAC9B;AAAA,EACF;AACA,UAAQ;AAGR,SAAO,SAAS,MAAM,QAAQ,MAAM,QAAQ,IAAI,EAAE4K,KAAIjI,OAAM,IAAI5C,OAAM,KAAI,CAAE;AAC9E;ACvDO,SAAS,QAAQA,WAAU0C,SAAQ;AACxC,SAAO,SAAS1C,QAAO,YAAYA,QAAO0C,QAAO,KAAI,CAAE,CAAC;AAC1D;AAEA,SAAS,YAAY1C,QAAO,QAAQ;AAClC,MAAI,QAAQ;AACZ,QAAM,QAAQ,oBAAI,IAAG;AACrB,QAAM,MAAM,SAAO,MAAM,IAAI,EAAE,QAAQ,IAAI,GAAG;AAE9C,SAAO,QAAQ,WAAS;AACtB,UAAM,OAAO,MAAM,QAAQ,OAAO,MAAM,OAAO;AAE/C,QAAI,SAAS,IAAI,KAAK,CAAC,WAAW,IAAI,GAAG;AACvC,iBAAWqC,QAAO,KAAM,KAAI,KAAKA,IAAG,CAAC;AAAA,IACvC,OAAO;AACL;AAAA,QACE,SAAS,IAAI,IAAIpC,QAAM,OAAOD,OAAM,WAAW,IAAI,CAAC,IAChD,SAAS,IAAI,IAAIC,QAAM,KAAK,IAC5B,WAAW,IAAI,IAAI,QACnB,MAAM,0BAA0B,QAAM,EAAE,EAAE;AAAA,MACtD;AAAA,IACI;AAAA,EACF,CAAC;AAED,SAAO,QAAQD,QAAO,KAAK;AAC7B;AAEO,SAAS,SAASA,QAAO,YAAY;AAC1C,SAAOA,OAAM,OAAO,EAAE,OAAO,WAAU,CAAE;AAC3C;AC9BO,SAAS,MAAMA,QAAO,IAAI0C,SAAQ,SAAS;AAChD,SAAO;AAAA,IACL1C;AAAA,IACA,WAAW,QAAQA,QAAO,EAAE;AAAA,IAC5B,WAAW,QAAQA,QAAO0C,SAAQ,EAAE,UAAU,QAAQ,OAAO,UAAU,MAAM;AAAA,IAC7E;AAAA,EACJ;AACA;AAGA,SAAS,SAAS,KAAK;AACrB,MAAI;AAAA,IAAQ,CAAC5E,QAAOuE,SAClBvE,OAAM,QAAQ,IAAI,IAAIuE,MAAK,IAAIvE,SAAQ,EAAE,CAAC,IAAI;AAAA,EAClD;AACA;AAEA,MAAM,MAAM,CAACA,QAAO,iBAAiBA,UAAS,OAAOA,SAAQ;AAEtD,SAAS,OAAOkC,QAAO,IAAI0C,SAAQ,UAAU,CAAA,GAAI;AACtD,QAAM,EAAE,MAAAE,OAAM,UAAS,IAAK,UAAU5C,QAAO,IAAI,OAAO;AACxD,QAAM,OAAO,IAAI,QAAQ,gBAAgB,GAAG;AAC5C,QAAM,SAAS0C,QAAO,MAAM,SAAS,IACjC,CAAC,GAAGwB,UAASA,QAAO,OAAOtB,MAAK,CAAC,IACjC,OAAKA,MAAK,CAAC;AAKf,QAAM,UAAUA,MAAK;AAAA,IACnB,OAAK,UAAU5C,QAAO0C,QAAO,IAAI,IAAI,CAAAmI,QAAM;AACzC,UAAIA,IAAG,SAAS,SAAS;AACvB,cAAM,KAAK,OAAK,MAAM,UAAU,CAAC,IAAI,IAAI;AACzC,WAAG,WAAW,MAAM,IAAI;AACxB,eAAO,EAAE,GAAGA,KAAI,MAAM,OAAO,QAAQ,CAAC,EAAE,EAAC;AAAA,MAC3C;AACA,YAAM,SAASA,IAAG,OAAO,IAAI,OAAK;AAChC,cAAM,KAAK,CAAC,GAAG,MAAM,MAAM,UAAU,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI;AACpD,WAAG,WAAW,MAAM,IAAI,MAAM;AAC9B,eAAO;AAAA,MACT,CAAC;AACD,aAAO,EAAE,GAAGA,KAAI,OAAM;AAAA,IACxB,CAAC,CAAC;AAAA,EACN;AAEE,SAAO,OAAOnI,SAAQ,QAAQ1C,OAAM,OAAM,GAAI,OAAO,EAAE,IAAIA,MAAK;AAClE;AAEA,SAAS,UAAUA,QAAO,IAAI,SAAS;AACrC,QAAM,QAAQ,QAAQ,QAAQ,IAAI,CAAC,QAAQ,QAAQ;AACnD,QAAM,OAAO,IAAI,QAAQ,MAAM,IAAI;AACnC,QAAM,OAAO,IAAI,QAAQ,cAAc,GAAG;AAG1C,QAAMoD,OAAM,aAAapD,QAAO,GAAG,KAAK,GAAG,KAAK;AAChD,QAAMqC,OAAMe,KAAI,WAAW,IACvBA,KAAI,CAAC,IACL,CAAC,KAAKpC,UAASoC,KAAI,IAAI,QAAM,GAAG,KAAKpC,KAAI,CAAC,EAAE,KAAK,IAAI;AAGzD,QAAM,OAAO,MAAMhB,OAAM,UAAS,CAAE;AACpC,EAAAA,OAAM,KAAK,CAAC,KAAKgB,UAAS,KAAK,GAAG,IAAIqB,KAAI,KAAKrB,KAAI,CAAC;AAGpD,QAAM,OAAO;AAAA,IACX,QAAQhB,MAAK;AAAA,IACb,CAAE;AAAA,MACA,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,QAAQ,EAAE,SAAO,KAAK,GAAG,EAAC;AAAA,MAAI,QAAQ,CAAA;AAAA,IAC5C,CAAK;AAAA,EACL,EAAI,CAAC,EAAE,CAAC;AAGN,QAAM4C,QAAO,OAAO,KAAK,KAAI,IAAK;AAGlC,SAAO;AAAA,IACL,MAAM,OAAO,SAAS,KAAK,IAAIA,MAAK,MAAM,GAAG,KAAK,IAAIA;AAAA,IACtD,WAAW;AAAA,EACf;AACA;AAEA,SAAS,OAAO,EAAE,OAAO,MAAK,GAAI,QAAQ,QAAQ,SAAS;AACzD,QAAM,OAAO,SAAS,OAAO,OAAO;AACpC,QAAM,OAAO,UAAS;AACtB,QAAM,IAAI,QAAQ;AAClB,QAAM,IAAI,MAAM;AAEhB,MAAIjF;AACJ,QAAMkN,MAAK,CAAC,IAAI,QAAQlN,QAAO,EAAE,EAAE,GAAG;AAGtC,MAAI,OAAQ,aAAY,MAAM,MAAM;AAGpC,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,UAAMyF,OAAM,MAAM,CAAC;AACnB,QAAIA,KAAI,SAAS,MAAM;AAErB,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,aAAK,IAAI,OAAO,GAAG,MAAM,CAAC,CAAC,GAAG,QAAQ,CAAC,EAAEA,KAAI,KAAK,CAAC;AAAA,MACrD;AAAA,IACF,WAAW,OAAO,GAAG;AAEnB,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,QAAAzF,UAAS,QAAQ,CAAC;AAClB,cAAM,MAAM,KAAK,IAAI,OAAO,GAAG,MAAM,CAAC,CAAC,GAAG,MAAM,IAAI,CAAC;AACrD,iBAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,cAAI,CAAC,IAAIyF,KAAI,GAAG,MAAMyH,GAAE;AAAA,QAC1B;AAAA,MACF;AAAA,IACF,OAAO;AAEL,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,QAAAlN,UAAS,QAAQ,CAAC;AAClB,aAAK,IAAI,OAAO,GAAG,MAAM,CAAC,CAAC,GAAG,CAAEyF,KAAI,GAAG,MAAMyH,GAAE,CAAC,CAAE;AAAA,MACpD;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AC7HO,SAAS,OAAO7K,QAAO,SAAS;AACrC,QAAM,OAAO,UAAS;AACtB,QAAM,SAASA,OAAM,OAAM;AAG3B,QAAM,EAAE,KAAAoD,MAAK,QAAQ,CAAA,GAAI,MAAM,OAAO,MAAM,UAAU,CAAA;AACtD,QAAM,SAAS,IAAI,YAAY,OAAO,CAAC;AACvC,QAAM,QAAQ,CAAAc,UAAQ,KAAK,IAAIA,OAAM,IAAI,CAAC;AAG1C,QAAM,QAAQ,SACV,aAAalE,QAAO,SAAS,MAAM,IACnC,CAAE,WAAWA,QAAO,OAAO,CAAC;AAGhC,UAAQ,QAAO,EAAG,IAAI,CAAAkE,UAAQ,KAAK,IAAIA,OAAM,CAAA,CAAE,CAAC;AAGhD,QAAM,IAAI,OAAO,SAAS;AAC1B,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,WAAO,OAAO,IAAI,CAAC,IAAI,QAAQ,MAAM,MAAM,CAAC,GAAG,KAAK,MAAM,OAAO,CAAC,CAAC;AAAA,EACrE;AAGA,MAAI,QAAQ;AACV,UAAMlD,QAAOhB,OAAM,KAAI;AACvB,UAAM,QAAQ,CAACkE,OAAM,UAAU;AAC7B,YAAM,SAAS,KAAK,KAAKA,KAAI,IAAI,MAAM,GAAG;AAC1C,YAAM,SAASd,KAAI,KAAK;AACxB,eAAS,IAAI,GAAG,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AACpC,eAAO,KAAK,OAAO,KAAK,CAAC,GAAGpC,KAAI,GAAG,GAAG,KAAK,OAAO,IAAI,CAAC,CAAC;AAAA,MAC1D;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,KAAK,IAAIhB,MAAK;AACvB;ACrCO,SAAS,OAAOA,WAAU2H,UAAS;AACxC,QAAM,MAAM,oBAAI,IAAG;AACnB,EAAA3H,OAAM,YAAY,QAAM,IAAI,IAAI,GAAG,CAAC,GAAG,EAAE;AACzC,SAAO,QAAQA,QAAO,QAAQA,QAAO2H,SAAQ,KAAI,GAAI,GAAG,CAAC;AAC3D;ACHO,SAASkG,SAAOpP,SAAQqP,UAAS,OAAO,QAAQ;AACrD,UACEA,WACK,SAAS,WAAW,WACpB,SAAS,WAAW,UACzBrP,QAAO,QAAQA,SAAQ,OAAO,MAAM;AACxC;AAIA,SAAS,SAAS,MAAMA,SAAQ,OAAO;AACrC,QAAM,IAAI,MAAM;AAChB,WAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,IAAAA,QAAO,CAAC,IAAI,MAAO,IAAI2L,SAAM,IAAM,CAAC;AAAA,EACtC;AACA,SAAO3L;AACT;AAIA,SAAS,SAAS,MAAMA,SAAQ,OAAO,QAAQ;AAC7C,QAAM,IAAI,MAAM;AAChB,QAAM,IAAI,IAAI,aAAa,CAAC;AAE5B,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,MAAE,CAAC,IAAK,OAAO,OAAO,MAAM,CAAC,CAAC;AAAA,EAChC;AAEA,QAAM6O,UAAS,SAAS,SAAS,EAAE;AACnC,WAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,IAAA7O,QAAO,CAAC,IAAI,MAAM6O,QAAO,GAAG,MAAMlD,SAAM,CAAE,CAAC;AAAA,EAC7C;AACA,SAAO3L;AACT;AAKA,SAAS,SAAS,MAAMA,SAAQ,OAAO;AACrC,QAAM,IAAI,MAAM;AAChB,MAAI,QAAQ,EAAG,QAAO;AAEtB,WAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,IAAAA,QAAO,CAAC,IAAI,MAAM,CAAC;AAAA,EACrB;AAEA,WAAS,IAAI,MAAM,IAAI,GAAG,EAAE,GAAG;AAC7B,UAAM,IAAI,IAAI2L,SAAM;AACpB,QAAI,IAAI,MAAM;AACZ,MAAA3L,QAAO,IAAI,CAAC,IAAI,MAAM,CAAC;AAAA,IACzB;AAAA,EACF;AAEA,SAAOA;AACT;AAKA,SAAS,SAAS,MAAMA,SAAQ,OAAO,QAAQ;AAC7C,QAAM,IAAI,MAAM;AAChB,MAAI,QAAQ,EAAG,QAAO;AAEtB,QAAM,IAAI,IAAI,aAAa,CAAC;AAC5B,QAAM,IAAI,IAAI,YAAY,CAAC;AAC3B,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,MAAE,CAAC,IAAI;AACP,MAAE,CAAC,IAAI,CAAC,KAAK,IAAI2L,SAAM,CAAE,IAAI,OAAO,MAAM,CAAC,CAAC;AAAA,EAC9C;AAEA,IAAE,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AAC5B,WAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,IAAA3L,QAAO,CAAC,IAAI,MAAM,EAAE,CAAC,CAAC;AAAA,EACxB;AACA,SAAOA;AACT;AC9EO,SAAS,QAAQ8C,QAAO,KAAK,GAAG,KAAKA,OAAM,QAAQ;AACxD,MAAI,IAAI,MAAM,KAAK,CAAC;AAEpB,SAAO,GAAG;AACR,UAAM,IAAI6I,aAAW,MAAM;AAC3B,UAAM,IAAI7I,OAAM,IAAI,EAAE;AACtB,IAAAA,OAAM,IAAI,EAAE,IAAIA,OAAM,IAAI,EAAE;AAC5B,IAAAA,OAAM,IAAI,EAAE,IAAI;AAAA,EAClB;AAEA,SAAOA;AACT;ACLO,SAAS,OAAOvB,QAAO,MAAM,UAAU,CAAA,GAAI;AAChD,SAAO;AAAA,IACLA;AAAA,IACA,UAAUA,QAAO,IAAI;AAAA,IACrB,YAAYA,QAAO,QAAQ,MAAM;AAAA,IACjC;AAAA,EACJ;AACA;AAEA,MAAM,MAAM,SAAO,SAAO,IAAI,GAAG,GAAG,KAAK;AAEzC,SAAS,UAAUA,QAAO,MAAM;AAC9B,SAAO,SAAS,IAAI,IAChB,MAAM,OACN,IAAI,QAAQA,QAAO8J,OAAM,EAAE,KAAI,GAAI,EAAE,OAAA9J,QAAO,QAAQ,MAAK,CAAE,CAAC,EAAE,OAAO,MAAM,CAAC;AAClF;AAEA,SAAS,YAAYA,QAAO,GAAG;AAC7B,MAAI,KAAK,KAAM,QAAO;AACtB,MAAI,SAAS,CAAC,IAAIA,OAAM,WAAW,CAAC,IAAI;AACxC,SAAO;AAAA,IACL,SAAS,CAAC,IACNA,OAAM,OAAO,CAAC,IACd,QAAQA,QAAO8J,OAAM,EAAE,EAAC,GAAI,EAAE,OAAA9J,QAAO,GAAG,EAAE,MAAM,MAAM,EAAE,OAAO,GAAG;AAAA,EAC1E;AACA;AAEO,SAAS,QAAQA,QAAO,MAAM,QAAQ,UAAU,CAAA,GAAI;AACzD,QAAM,EAAE,SAAA8N,mBAASC,UAAO,IAAK;AAC7B,QAAM,QAAQ/N,OAAM,WAAW,KAAK;AAEpC,MAAI,QAAQ;AACZ,SAAO,MAAM,IAAI,CAAC,KAAK,UAAU;AAC/B,QAAI,IAAI,KAAK,KAAK;AAClB,aAAU,IAAK8N,WAAU,IAAI,KAAK,IAAI,IAAI,QAAQ,CAAC;AACnD,WAAO;AAAA,EACT,CAAC;AAED,QAAM,UAAU,IAAI,YAAY,KAAK;AACrC,MAAI,OAAO;AAEX,QAAM,QAAQ,CAAC,KAAK,UAAU;AAC5B,UAAM,KAAK,KAAK,KAAK;AACrB,UAAMpJ,OAAM,QAAQ,SAAS,MAAM,QAAQ,EAAE;AAE7C,QAAI,CAACoJ,YAAW,OAAO,IAAI,QAAQ;AAGjC,MAAApJ,KAAI,IAAI,GAAG;AAAA,IACb,OAAO;AACLsJ,eAActJ,MAAKoJ,UAAS,KAAK,MAAM;AAAA,IACzC;AAAA,EACF,CAAC;AAED,MAAIC,cAAY,UAAU,MAAM,SAAS,KAAK,CAACD,WAAU;AAGvDG,YAAe,OAAO;AAAA,EACxB;AAEA,SAAOjO,OAAM,MAAM,OAAO;AAC5B;ACvDO,SAASiD,QAAM,QAAQ,GAAG,MAAM,UAAU;AAC/C,SAAO,GAAGiL,OAAK,KAAK,CAAC,sCAAsCA,OAAK,GAAG,CAAC;AACtE;AAEA,SAASA,OAAK,OAAO;AACnB,SAAO,QAAQ,IAAI,aAAa,KAAK,KAAK;AAC5C;ACjBO,SAAS,MAAMlO,QAAO,QAAQ,GAAG,MAAM,UAAU;AACtD,MAAIA,OAAM,aAAa;AACrB,WAAO,OAAOA,QAAOmO,QAAO,OAAO,GAAG,CAAC,EAAE,MAAK;AAAA,EAChD;AAGA,QAAM,UAAU,CAAA;AAChB,QAAM,QAAQnO,OAAM,QAAO;AAC3B,UAAQ,KAAK,IAAI,GAAG,SAAS,QAAQ,IAAI,QAAQ,EAAE;AACnD,QAAM,KAAK,IAAI,OAAO,KAAK,IAAI,GAAG,OAAO,MAAM,IAAI,QAAQ,EAAE,CAAC;AAC9D,EAAAA,OAAM,KAAK,SAAO,QAAQ,KAAK,GAAG,GAAG,MAAM,MAAM,OAAO,KAAK;AAC7D,SAAOA,OAAM,MAAM,OAAO;AAC5B;ACTO,SAAS,OAAOA,QAAO0C,SAAQ,SAAS;AAC7C,SAAO,QAAQ1C,QAAO,WAAW,UAAUA,QAAO0C,OAAM,GAAG,OAAO;AACpE;AAEO,SAAS,QAAQ1C,QAAO,EAAE,OAAO,OAAO,MAAM,CAAA,EAAE,GAAI,UAAU,IAAI;AACvE,MAAI,MAAM,WAAW,EAAG,QAAOA;AAG/B,QAAM,KAAM,MAAM,WAAW,KAAK,QAAQ,MAAO,CAAA;AACjD,QAAM,OAAO,QAAQ,QAAQ,OAAO,OAAO,CAAC,CAAC,QAAQ;AACrD,QAAM,QAAQ,QAAQ,SAAS,OAC3B,GAAG,UAAU,WACb,KAAK,IAAI,GAAG,CAAC,QAAQ,SAAS,CAAC;AAEnC,QAAMoD,OAAM,aAAapD,QAAO,KAAK,KAAK;AAC1C,QAAM,OAAO,UAAS;AACtB,QAAM,MAAM,MAAM,OAAO,CAACoO,MAAKlK,OAAM,MAAMkK,KAAI,IAAIlK,OAAM,CAAC,GAAG,oBAAI,IAAG,CAAE;AAEtE,QAAM,MAAM,CAAC,OAAOA,UAAS;AAC3B,UAAMyD,WAAU,WAAW3H,QAAOoD,KAAI,KAAK,GAAG,KAAK;AACnD,UAAM,IAAIuE,SAAQ;AAClB,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,WAAK,IAAI,GAAG,CAAC,KAAK,GAAGzD,KAAI,IAAI,IAAI,CAAC,IAAIyD,SAAQ,CAAC,CAAC;AAAA,IAClD;AAAA,EACF;AAEA,EAAA3H,OAAM,YAAW,EAAG,QAAQ,CAAAkE,UAAQ;AAClC,QAAI,IAAI,IAAIA,KAAI,GAAG;AACjB,UAAI,CAAC,KAAM,MAAK,IAAIA,OAAMlE,OAAM,OAAOkE,KAAI,CAAC;AAC5C,UAAI,IAAI,IAAIA,KAAI,GAAGA,KAAI;AACvB,UAAI,OAAOA,KAAI;AAAA,IACjB,OAAO;AACL,WAAK,IAAIA,OAAMlE,OAAM,OAAOkE,KAAI,CAAC;AAAA,IACnC;AAAA,EACF,CAAC;AAED,MAAI,QAAQ,GAAG;AAEf,SAAO,KAAK,OAAOlE,MAAK;AAC1B;AAEA,SAAS,WAAWA,QAAOoD,MAAK,OAAO;AACrC,QAAM,QAAQpD,OAAM,UAAS;AAC7B,QAAM2H,WAAU,CAAA;AAEhB,EAAA3H,OAAM,KAAK,CAAC,KAAKgB,UAAS;AACxB,UAAM0B,UAAS,QAAQU,KAAI,KAAKpC,KAAI,CAAC;AACrC,UAAM,IAAI,KAAK,IAAI0B,QAAO,QAAQ,KAAK;AACvC,WAAOiF,SAAQ,SAAS,GAAG;AACzB,MAAAA,SAAQ,KAAK,MAAM,KAAK,EAAE,KAAK,IAAI,CAAC;AAAA,IACtC;AACA,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,MAAAA,SAAQ,CAAC,EAAE,GAAG,IAAIjF,QAAO,CAAC;AAAA,IAC5B;AAAA,EACF,CAAC;AAED,SAAOiF;AACT;AC5DO,SAASnE,QAAMxD,WAAU,QAAQ;AACtC,SAAO,OAAO,OAAOA,QAAO,OAAO,KAAI,CAAE,CAAC;AAC5C;ACLO,SAAS,QAAQA,QAAO;AAC7B,SAAOA,OAAM,UAAS,IAClBA,OAAM,OAAO,EAAE,OAAO,KAAI,CAAE,IAC5BA;AACN;ACHO,MAAM,QAAQ,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AAGlD,MAAM,MAAM,WAAW,GAAG,KAAK,KAAK,KAAK,KAAK,GAAG,GAAG,GAAG,CAAC;AAKxD,MAAM;AAAA;AAAA,EAAgC;AAAA;AAAA,IAE3C,IAAI;AAAA;AAAA,IAMJ,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUJ,IAAI;AAAA,EACN;AAAA;AAKO,MAAM;AAAA;AAAA,EAAmC;AAAA,IAC9C,QAAQ;AAAA,EAEV;AAAA;AAKO,MAAM;AAAA;AAAA,EAAsC;AAAA,IACjD,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASR,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMjB,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQb,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQR,cAAc;AAAA,EAChB;AAAA;AAMO,MAAM;AAAA;AAAA,EAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQxC,YAAY;AAAA;AAAA,IAEZ,MAAM;AAAA;AAAA,IAEN,MAAM;AAAA;AAAA,IAEN,KAAK;AAAA;AAAA,IAEL,OAAO;AAAA;AAAA,IAEP,QAAQ;AAAA;AAAA,IAER,MAAM;AAAA;AAAA,IAEN,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMN,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQT,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBN,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmBN,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBX,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,IAKV,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOR,OAAO;AAAA;AAAA;AAAA;AAAA,IAIP,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,IAKjB,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA2Bf,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeL,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,IAKV,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA,IAKb,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,IAKX,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOX,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUf,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUZ,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMV,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,IAKV,eAAe;AAAA,EACjB;AAAA;AAKO,MAAM;AAAA;AAAA,EAAkC;AAAA;AAAA,IAE7C,MAAM;AAAA;AAAA,IAEN,QAAQ;AAAA;AAAA,IAER,QAAQ;AAAA,EACV;AAAA;AAKO,MAAM;AAAA;AAAA,EAAiC;AAAA;AAAA,IAE5C,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,IAKL,aAAa;AAAA,EACf;AAAA;AAKO,MAAM;AAAA;AAAA,EAAiC;AAAA;AAAA,IAE5C,QAAQ;AAAA;AAAA,IAER,aAAa;AAAA;AAAA,IAEb,aAAa;AAAA;AAAA,IAEb,YAAY;AAAA,EACd;AAAA;AAKO,MAAM;AAAA;AAAA,EAAqC;AAAA;AAAA;AAAA;AAAA;AAAA,IAKhD,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMZ,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUV,gBAAgB;AAAA,EAClB;AAAA;AAKO,MAAM;AAAA;AAAA,EAAkC;AAAA;AAAA,IAE7C,QAAQ;AAAA;AAAA,IAER,OAAO;AAAA,EACT;AAAA;ACpXO,MAAM,aAAa;AACnB,MAAM,cAAc;AACpB,MAAM,cAAc;AACpB,MAAM,cAAc;AACpB,MAAM,YAAY;AAClB,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,eAAe;AACrB,MAAM,eAAe;AAOrB,SAAS,kBAAkBgB,OAAM;AACtC,SAAOA,iBAAgB,eACrB,OAAO,sBAAsB,eAC7BA,iBAAgB;AAEpB;AASO,SAAS,aAAa,UAAU,QAAQ;AAC7C,QAAM,IAAI,KAAK,KAAK,QAAQ,IAAI;AAChC,UACE,SACI,CAAC,WAAW,YAAY,YAAY,UAAU,IAC9C,CAAC,YAAY,aAAa,aAAa,WAAW,GACtD,CAAC;AACL;AAGA,MAAM,aAAa,OAAO,eAAe,SAAS;AAQ3C,SAAS,aAAalD,QAAO;AAClC,SAAOA,kBAAiB;AAC1B;AAQO,SAAS,QAAQA,QAAO;AAC7B,SAAO,MAAM,QAAQA,MAAK,KAAK,aAAaA,MAAK;AACnD;AASO,SAAS,iBAAiBA,QAAO;AACtC,SAAOA,WAAU,cAAcA,WAAU;AAC3C;AASO,SAAS,OAAO,SAAS,OAAO;AACrC,MAAI,IAAI;AACR,MAAI,IAAI,QAAQ;AAChB,MAAI,KAAK,YAAY;AAGnB,OAAG;AACD,YAAM,MAAO,IAAI,MAAO;AACxB,UAAI,QAAQ,GAAG,KAAK,MAAO,KAAI,MAAM;AAAA,UAChC,KAAI;AAAA,IACX,SAAS,IAAI;AAAA,EACf,OAAO;AAGL,OAAG;AACD,YAAM,MAAM,KAAK,OAAO,IAAI,KAAK,CAAC;AAClC,UAAI,QAAQ,GAAG,KAAK,MAAO,KAAI,MAAM;AAAA,UAChC,KAAI;AAAA,IACX,SAAS,IAAI;AAAA,EACf;AACA,SAAO;AACT;AAQA,SAAS,QAAQa,SAAQ,MAAM,GAAG;AAChC,UAAUA,UAAS,MAAO,IAAK,MAAM;AACvC;AASO,SAAS,MAAM4C,QAAO5C,UAAS4C,OAAM,QAAQ;AAClD,QAAM,gBAAgB,QAAQ5C,SAAQ4C,OAAM,iBAAiB;AAC7D,SAAOA,OAAM,SAAS;AAAA;AAAA,IAAkCA,OAAM,SAAS,GAAG,aAAa;AAAA,MACnFA,OAAM,SAAS,gBAAgB,OAAOA,QAAO,aAAa,IAC1DA;AACN;AAUO,SAAS,OAAOA,QAAO,WAAW7C,UAAS,GAAG;AAEnD,QAAM,WAAW,IAAI6C,OAAM,YAAY,SAAS;AAChD,WAAS,IAAIA,QAAO7C,OAAM;AAC1B,SAAO;AACT;AAWO,SAAS,KAAK6C,QAAO,OAAO,OAAO;AACxC,SAAOA,OAAM,UAAU,OAAO;AAC5B,IAAAA,SAAQ,OAAOA,QAAOA,OAAM,UAAU,GAAG,QAAQA,OAAM,SAAS,CAAC;AAAA,EACnE;AACA,SAAOA;AACT;AC1JO,SAAS,OAAOzD,QAAO;AAC5B,SAAOA,kBAAiB;AAC1B;AAOO,SAAS,WAAWA,QAAO;AAChC,SAAO,OAAOA,OAAM,OAAO,QAAQ,MAAM;AAC3C;AAYO,SAAS,MAAMA,QAAO,MAAM,SAAS;AAC1C,MAAI,KAAKA,MAAK,EAAG,QAAOA;AACxB,QAAM,IAAI,MAAM,QAAQA,MAAK,CAAC;AAChC;AAYO,SAAS,WAAWA,QAAO,KAAK,SAAS;AAC9C,QAAM,MAAM,QAAQ,GAAG,IAAI,MAAM,OAAO,OAAO,GAAG;AAClD,SAAO;AAAA,IACLA;AAAA,IACA,CAACA,WAAU,IAAI,SAASA,MAAK;AAAA,IAC7B,YAAY,MAAM,GAAGA,MAAK,mBAAmB,GAAG;AAAA,EACpD;AACA;AAQO,SAAS,OAAO0M,SAAQ1M,QAAO;AACpC,aAAW,CAACuE,MAAK,GAAG,KAAK,OAAO,QAAQmI,OAAM,GAAG;AAC/C,QAAI,QAAQ1M,OAAO,QAAOuE;AAAA,EAC5B;AACA,SAAO;AACT;ACpDO,MAAM,kBAAkB,CAAC,WAC9B,2BAA2B,OAAO,MAAM,MAAM,CAAC,SAAS,MAAM;AAczD,MAAM,QAAQ,CAAC6B,OAAM,MAAM,WAAW,MAAM,WAAW,UAAU;AAAA,EACtE,MAAAA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAOA,SAAS,QAAQpG,QAAO;AACtB,SAAO,OAAO,OAAOA,QAAO,MAAM,KAAK,WAAWA,OAAM,IAAI;AAC9D;AAOA,SAAS,WAAWA,QAAO;AACzB,SAAO,OAAOA,QAAO,WAAW;AAClC;AAUA,SAAS,QAAQA,QAAO,cAAc,IAAI,kBAAkB,MAAM;AAChE,SAAO,QAAQA,MAAK,IAChBA,SACA;AAAA,IACE;AAAA,IACA,MAAMA,QAAO,YAAY,MAAM,qBAAqB;AAAA,IACpD;AAAA,EACR;AACA;AASA,MAAM,YAAY,CAAC,YAAY,EAAE;AAuB1B,MAAMwE,eAAa,CAAC,MAAM,WAAW,UAAU,OAAO,KAAK,QAAQ;AAAA,EACxE,QAAQ,KAAK;AAAA,EACb;AAAA,EACA,YAAY;AAAA,EACZ,SAAS,aAAa,MAAK;AAAA,EAC3B;AACF;AAOO,MAAM,WAAW,MAAM,UAAU,KAAK,IAAI;AAU1C,MAAM,MAAM,CAAC,WAAW,IAAI,SAAS,UAAU;AAAA,EACpD,QAAQ,KAAK;AAAA,EACb,UAAU,WAAW,UAAU,CAAC,GAAG,IAAI,IAAI,EAAE,CAAC;AAAA,EAC9C;AAAA,EACA,QAAQ,aAAa,UAAU,MAAM;AACvC;AAKO,MAAM,OAAO,MAAM,IAAI,CAAC;AAKxB,MAAM,QAAQ,MAAM,IAAI,EAAE;AAK1B,MAAM,QAAQ,MAAM,IAAI,EAAE;AAK1B,MAAM,QAAQ,MAAM,IAAI,EAAE;AAK1B,MAAM,QAAQ,MAAM,IAAI,GAAG,KAAK;AAKhC,MAAM,SAAS,MAAM,IAAI,IAAI,KAAK;AAKlC,MAAM,SAAS,MAAM,IAAI,IAAI,KAAK;AAKlC,MAAM,SAAS,MAAM,IAAI,IAAI,KAAK;AASlC,MAAM,QAAQ,CAAC,YAAY,OAAO;AAAA,EACvC,QAAQ,KAAK;AAAA,EACb,WAAW,WAAW,WAAW,SAAS;AAAA,EAC1C,QAAQ,CAAC,aAAa,cAAc,YAAY,EAAE,SAAS;AAC7D;AAUO,MAAM,UAAU,MAAM,MAAM,UAAU,MAAM;AAK5C,MAAM,UAAU,MAAM,MAAM,UAAU,MAAM;AAO5C,MAAM,SAAS,OAAO;AAAA,EAC3B,QAAQ,KAAK;AAAA,EACb,SAAS;AACX;AAQO,MAAM,OAAO,OAAO;AAAA,EACzB,QAAQ,KAAK;AAAA,EACb,SAAS;AACX;AAOO,MAAM,OAAO,MAAM,UAAU,KAAK,IAAI;AAgBtC,MAAM,UAAU,CAAC,WAAW,OAAO,WAAW,SAAS;AAAA,EAC5D,QAAQ,KAAK;AAAA,EACb;AAAA,EACA;AAAA,EACA,UAAU,WAAW,UAAU,CAAC,IAAI,IAAI,KAAK,GAAG,CAAC;AAAA,EACjD,QAAQ,aAAa,KAAK,aAAa;AACzC;AA+CO,MAAM,OAAO,CAAC,UAAU;AAAA,EAC7B,QAAQ,KAAK;AAAA,EACb,MAAM,WAAW,MAAM,QAAQ;AAAA,EAC/B,QAAQ,SAAS,SAAS,MAAM,aAAa;AAC/C;AAKO,MAAM,UAAU,MAAM,KAAK,SAAS,GAAG;AAwBvC,MAAM,OAAO,CAAC,OAAO,SAAS,gBAAgB;AACnD,SAAO,WAAW,MAAM,QAAQ;AAChC,QAAM,WAAW,SAAS,SAAS,UAAU,SAAS,SAAS,cAAc,KAAK;AAClF,SAAO;AAAA,IACL,QAAQ,KAAK;AAAA,IACb;AAAA,IACA;AAAA,IACA,QAAQ,aAAa,KAAK,aAAa;AAAA,EAC3C;AACA;AAuCO,MAAM,YAAY,CAAC,OAAO,SAAS,aAAa,WAAW,UAAU;AAAA,EAC1E,QAAQ,KAAK;AAAA,EACb,MAAM,WAAW,MAAM,QAAQ;AAAA,EAC/B;AAAA,EACA,QAAQ;AACV;AA0BO,MAAM,WAAW,CAAC,OAAO,aAAa,oBAAoB;AAAA,EAC/D,QAAQ,KAAK;AAAA,EACb,MAAM,WAAW,MAAM,YAAY;AAAA,EACnC,QAAQ,SAAS,aAAa,iBAAiB,SAAY;AAC7D;AAUO,MAAM,OAAO,CAAC,WAAW;AAAA,EAC9B,QAAQ,KAAK;AAAA,EACb,UAAU,CAAE,QAAQ,KAAK,CAAC;AAAA,EAC1B,SAAS;AACX;AAYO,MAAM,SAAS,CAAC,cAAc;AAAA,EACnC,QAAQ,KAAK;AAAA,EACb,UAAU,MAAM,QAAQ,QAAQ,KAAK,QAAQ,SAAS,CAAC,CAAC;AAAA;AAAA,IAC5B;AAAA,MACxB,OAAO,QAAQ,QAAQ,EAAE,IAAI,CAAC,CAAC4B,OAAM,IAAI,MAAM,MAAMA,OAAM,IAAI,CAAC;AACtE;AA6BO,MAAM,QAAQ,CAAC,MAAM,UAAU,SAAS,mBAAmB;AAChE,cAAY,SAAS,IAAI,CAAC,GAAG,MAAM,CAAC;AACpC,SAAO;AAAA,IACL,QAAQ,KAAK;AAAA,IACb,MAAM,WAAW,MAAM,SAAS;AAAA,IAChC;AAAA,IACA,SAAS,QAAQ,OAAO,CAAC,GAAG,IAAI,OAAQ,EAAE,EAAE,IAAI,GAAI,IAAI,CAAA,CAAE;AAAA,IAC1D,UAAU,SAAS,IAAI,CAAC,GAAG,MAAM,QAAQ,GAAG,IAAI,CAAC,EAAE,CAAC;AAAA,IACpD;AAAA,IACA,SAAS;AAAA,EACb;AACA;AAQO,MAAM,kBAAkB,CAAC,YAAY;AAAA,EAC1C,QAAQ,KAAK;AAAA,EACb;AACF;AAWO,MAAM,gBAAgB,CAAC,OAAO,YAAY;AAAA,EAC/C,QAAQ,KAAK;AAAA,EACb;AAAA,EACA,UAAU,CAAE,QAAQ,KAAK,CAAC;AAC5B;AAQO,MAAM,UAAU,CAAC,YAAY,WAAW;AAAA,EAC7C,QAAQ,KAAK;AAAA,EACb;AAAA,EACA,UAAU,CAAC,KAAK;AAAA,EAChB,SAAS;AACX;AA+BO,MAAM,WAAW,CAAC,OAAO,SAAS,iBAAiB;AAAA,EACxD,QAAQ,KAAK;AAAA,EACb,MAAM,WAAW,MAAM,QAAQ;AAAA,EAC/B,QAAQ;AACV;AAQO,MAAM,cAAc,OAAO;AAAA,EAChC,QAAQ,KAAK;AAAA,EACb,SAAS;AACX;AASO,MAAM,YAAY,OAAO;AAAA,EAC9B,QAAQ,KAAK;AAAA,EACb,SAAS;AACX;AAWO,MAAM,YAAY,CAAC,WAAW;AAAA,EACnC,QAAQ,KAAK;AAAA,EACb,UAAU,CAAE,QAAQ,KAAK,CAAC;AAAA,EAC1B,SAAS;AACX;AAaO,MAAM,gBAAgB,CAAC,WAAW,iBAAiB;AAAA,EACxD,QAAQ,KAAK;AAAA,EACb,UAAU;AAAA,IACR;AAAA,MACE,QAAQ,WAAW,UAAU;AAAA,MAC7B,CAACjE,WAAUA,OAAM,KAAK,WAAW,KAAK;AAAA,MACtC,MAAM;AAAA,IACZ;AAAA,IACI,QAAQ,aAAa,QAAQ;AAAA,EACjC;AACA;AAyCO,MAAM,WAAW,CAAC,WAAW;AAAA,EAClC,QAAQ,KAAK;AAAA,EACb,UAAU,CAAE,QAAQ,OAAO,OAAO,CAAC;AAAA,EACnC,SAAS;AACX;AAcO,MAAM,gBAAgB,CAAC,WAAW;AAAA,EACvC,QAAQ,KAAK;AAAA,EACb,UAAU,CAAE,QAAQ,OAAO,OAAO,CAAC;AAAA,EACnC,SAAS;AACX;AC9pBA,MAAM,MAAM,IAAI,aAAa,CAAC;AAC9B,MAAM,MAAM,IAAI;AAChB,MAAM,MAAM,IAAI,WAAW,GAAG;AAC9B,MAAM,MAAM,IAAI,YAAY,GAAG;AAC/B,MAAM,MAAM,IAAI,WAAW,GAAG;AAC9B,MAAM,KAAK,IAAI,WAAW,GAAG;AAQtB,SAASoO,WAASvQ,QAAO;AAC9B,SAAOA;AACT;AAOO,SAAS,SAASA,QAAO;AAC9B,SAAO,OAAOA,MAAK;AACrB;AAMO,SAAS,SAAS,MAAM;AAC7B,SAAO,iBAAiB,IAAI,IAAI,WAAWuQ;AAC7C;AAOO,SAAS,UAAUvQ,QAAO;AAC/B,SAAQA,SAAQ,QAAS;AAC3B;AAOO,SAAS,YAAY,MAAM;AAChC,SAAO,SAAS,SAAS,SAAS,CAAAA,WAAS,SAASA,SAAQ,GAAG,IAC3D,SAAS,SAAS,cAAc,WAChC,SAAS,SAAS,cAAc,CAAAA,WAAS,SAASA,SAAQ,GAAG,IAC7D,CAAAA,WAAS,SAASA,SAAQ,GAAG;AACnC;AASO,SAAS,oBAAoB,CAAC,GAAG,GAAG,CAAC,GAAG;AAC7C,MAAI,CAAC,IAAI;AACT,MAAI,CAAC,IAAI;AACT,MAAI,CAAC,IAAI,SAAS,CAAC;AACnB,SAAO;AACT;AAQO,SAAS,SAASA,QAAO;AAC9B,MAAIA,SAAQ,OAAO,oBAAoBA,SAAQ,OAAO,kBAAkB;AACtE,UAAM,MAAM,iDAAiDA,MAAK,EAAE;AAAA,EACtE;AACA,SAAO,OAAOA,MAAK;AACrB;AASO,SAAS,OAAO,KAAK,KAAK;AAC/B,SAAO,OAAO,MAAM,GAAG,IAAI,OAAO,MAAM,GAAG,IAAI,OAAO,GAAG;AAC3D;AAQO,SAAS,YAAY,OAAO;AACjC,SAAO,CAACA,WAAU,OAAOA,WAAU,WAC/B,OAAOA,MAAK,IACZ,KAAK,MAAMA,SAAQ,KAAK;AAC9B;AAYO,SAAS,UAAUA,QAAO4G,MAAKhG,SAAQ,QAAQ,OAAO;AAC3D,QAAM,IAAI,OAAOZ,WAAU,WACvBA,SACA,SAAS,KAAK,MAAMA,SAAQ,KAAK,CAAC;AAEtC,EAAA4G,KAAIhG,OAAM,IAAI;AACd,MAAI,SAAS,GAAG;AACd,IAAAgG,KAAIhG,UAAS,CAAC,IAAK,KAAK;AACxB,QAAI,SAAS,GAAG;AACd,MAAAgG,KAAIhG,UAAS,CAAC,IAAK,KAAK;AACxB,MAAAgG,KAAIhG,UAAS,CAAC,IAAK,KAAK;AAAA,IAC1B;AAAA,EACF;AACF;AAGA,MAAM,WAAW,OAAK,OAAO,QAAQ,IAAI,CAAC;AASnC,SAAS,cAAcgG,MAAKhG,SAAQ;AACzC,SAAO,OAAO,OAAO,IAAIgG,KAAIhG,OAAM,CAAC;AACtC;AASO,SAAS,eAAegG,MAAKhG,SAAQ;AAC1C,QAAM,IAAIA,WAAU;AACpB,MAAI;AACJ,MAAI,OAAO,OAAO,IAAIgG,KAAI,IAAI,CAAC,CAAC,IAAI,GAAG;AACrC,QAAI,SAAS,CAACA,KAAI,CAAC,CAAC,IAAK,SAAS,CAACA,KAAI,IAAI,CAAC,CAAC,KAAK;AAClD,QAAI,EAAE,IAAI;AAAA,EACZ,OAAO;AACL,QAAIA,KAAI,CAAC,IAAKA,KAAI,IAAI,CAAC,KAAK;AAAA,EAC9B;AACA,SAAO;AACT;AASO,SAAS,eAAeA,MAAKhG,SAAQ;AAC1C,QAAM,IAAIA,WAAU;AACpB,MAAI;AACJ,MAAI,OAAO,OAAO,IAAIgG,KAAI,IAAI,CAAC,CAAC,IAAI,GAAG;AACrC,QAAI,SAAS,CAACA,KAAI,CAAC,CAAC,IACf,SAAS,CAACA,KAAI,IAAI,CAAC,CAAC,KAAK,MACzB,SAAS,CAACA,KAAI,IAAI,CAAC,CAAC,KAAK,OACzB,SAAS,CAACA,KAAI,IAAI,CAAC,CAAC,KAAK;AAC9B,QAAI,EAAE,IAAI;AAAA,EACZ,OAAO;AACL,QAAIA,KAAI,CAAC,IACJA,KAAI,IAAI,CAAC,KAAK,MACdA,KAAI,IAAI,CAAC,KAAK,OACdA,KAAI,IAAI,CAAC,KAAK;AAAA,EACrB;AACA,SAAO;AACT;AA2BO,SAAS,UAAU5G,QAAO;AAC/B,MAAIA,WAAUA,OAAO,QAAO;AAC5B,MAAI,CAAC,IAAIA;AAMT,QAAMwD,SAAQ,IAAI,CAAC,IAAI,eAAe,KAAK;AAC3C,MAAI,OAAQ,IAAI,CAAC,IAAI,YAAa,OAAO;AAEzC,MAAI,QAAQ,YAAY;AAgBtB,QAAI,IAAI,CAAC,IAAI,GAAG;AACd,aAAO;AAAA,IACT,OAAO;AACL,cAAQ,OAAO,eAAe;AAC9B,cAAQ,IAAI,CAAC,IAAI,YAAe;AAAA,IAClC;AAAA,EACF,WAAW,QAAQ,YAAY;AAO7B,WAAO,WAAY,IAAI,CAAC,IAAI;AAC5B,WAAO,WAAY,SAAU,QAAQ,MAAM,QAAS;AACpD,WAAO;AAAA,EACT,OAAO;AAOL,WAAQ,OAAO,cAAe;AAC9B,YAAS,IAAI,CAAC,IAAI,WAAc,OAAU;AAAA,EAC5C;AACA,SAAOA,QAAO,OAAO,OAAO;AAC9B;AC/QA,MAAM,cAAc,IAAI,YAAY,OAAO;AAC3C,MAAM,cAAc,IAAI,YAAW;AAO5B,SAAS,WAAWoD,MAAK;AAC9B,SAAO,YAAY,OAAOA,IAAG;AAC/B;AAOO,SAAS,WAAW,KAAK;AAC9B,SAAO,YAAY,OAAO,GAAG;AAC/B;AAOO,SAAS,UAAU5G,QAAO;AAC/B,QAAM,MAAM,OAAOA,WAAU,YAAY,CAACA,SAASA,UAAS,OACxD,OAAOA,MAAK,IAAI,CAACA,SAEjB,QAAQA,MAAK,IAAI,IAAIA,OAAM,IAAI,SAAS,CAAC,MACzC,UAAUA,MAAK;AACnB,SAAO,GAAG,GAAG;AACf;AAEA,SAAS,UAAUA,QAAO;AACxB,MAAI,IAAI;AACR,MAAI,IAAI;AACR,aAAW,KAAKA,QAAO;AACrB,QAAI,EAAE,IAAI,EAAG,MAAK;AAClB,SAAK,IAAI,CAAC,KAAK,UAAUA,OAAM,CAAC,CAAC,CAAC;AAAA,EACpC;AACA,SAAO,IAAI,CAAC;AACd;AC1CO,MAAM,aAAa;AAGnB,MAAM,eAAe;AAQrB,SAAS,UAAUqF,SAAQ,OAAO;AACvC,UAAQA,QAAO,SAAS,CAAC,IAAI,KAAM,QAAQ,OAAQ;AACrD;AAOO,SAAS,WAAWuB,MAAK,OAAO;AACrC,QAAM,MAAM,QAAQ,UAAUA,MAAK,KAAK;AACxC,QAAM,SAAS,MAAM,UAAUA,MAAK,GAAG;AACvC,QAAM,OAAO,UAAUA,MAAK,MAAM;AASlC,SAAO,CAAC4J,QAAO,MAAM,WAAW,SAAS;AACvC,QAAIA,SAAQ,MAAM;AAChB,YAAM,MAAM,UAAU5J,MAAK,SAAS4J,MAAK;AACzC,UAAI,IAAK,QAAO,KAAK5J,MAAK,MAAM,GAAG;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AACF;AAQO,SAAS,WAAWA,MAAKhG,SAAQ;AACtC,SAAOA;AACT;AAQO,SAAS,YAAYgG,MAAKhG,SAAQ;AACvC,SAAO,CAAC,CAAC,SAASgG,MAAKhG,OAAM;AAC/B;AAQO,SAAS,SAASgG,MAAKhG,SAAQ;AACpC,SAAO,UAAUgG,MAAKhG,OAAM,KAAK,MAAM;AACzC;AAQO,SAAS,UAAUgG,MAAKhG,SAAQ;AACrC,SAAOgG,KAAIhG,OAAM;AACnB;AAQO,SAAS,UAAUgG,MAAKhG,SAAQ;AACrC,SAAO,WAAWgG,MAAKhG,OAAM,KAAK,MAAM;AAC1C;AAQO,SAAS,WAAWgG,MAAKhG,SAAQ;AACtC,SAAOgG,KAAIhG,OAAM,IAAIgG,KAAIhG,UAAS,CAAC,KAAK;AAC1C;AAQO,SAAS,UAAUgG,MAAKhG,SAAQ;AACrC,SAAOgG,KAAIhG,OAAM,IACbgG,KAAIhG,UAAS,CAAC,KAAK,IACnBgG,KAAIhG,UAAS,CAAC,KAAK,KACnBgG,KAAIhG,UAAS,CAAC,KAAK;AACzB;AAQO,SAAS,WAAWgG,MAAKhG,SAAQ;AACtC,SAAO,UAAUgG,MAAKhG,OAAM,MAAM;AACpC;AASO,SAAS,UAAUgG,MAAKhG,SAAQ;AACrC,SAAO,SAAS,OAAO;AAAA,IACrB;AAAA,IACA,OAAO,WAAWgG,MAAKhG,OAAM,CAAC,KAC3B,OAAO,WAAWgG,MAAKhG,UAAS,UAAU,CAAC,KAAK;AAAA,EACvD,CAAG;AACH;AASO,SAAS,WAAWgG,MAAK,OAAO;AACrC,MAAIhG,UAAS,QAAQ,UAAUgG,MAAK,KAAK;AACzC,QAAM/F,UAAS,UAAU+F,MAAKhG,OAAM;AACpC,EAAAA,WAAU;AACV,SAAO,WAAWgG,KAAI,SAAShG,SAAQA,UAASC,OAAM,CAAC;AACzD;AAWO,SAAS,WAAW+F,MAAKhG,SAAQ,QAAQ,SAAS;AACvD,MAAI,CAACA,QAAQ,QAAO,CAAA;AAGpB,QAAM,OAAOA,UAAS,UAAUgG,MAAKhG,OAAM;AAG3C,SAAO,MAAM;AAAA,IACX,EAAE,QAAQ,UAAUgG,MAAK,IAAI,EAAC;AAAA,IAC9B,CAAC,GAAG,MAAM,QAAQA,MAAK,OAAO,aAAa,IAAI,MAAM;AAAA,EACzD;AACA;AC1KO,MAAM,WAAW,uBAAO,UAAU;AAUlC,SAAS,aAAa,OAAO,SAAS;AAAA,EAC3C,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,IAKd,YAAY,OAAO;AACjB,WAAK,QAAQ,IAAI;AAAA,IACnB;AAAA;AAAA;AAAA;AAAA,IAKA,SAAS;AACP,aAAO,aAAa,OAAO,SAAS,KAAK,QAAQ,CAAC;AAAA,IACpD;AAAA,EACJ;AAGE,QAAM,QAAQ,UAAU;AAExB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AAErC,QAAI,OAAO,OAAO,OAAO,MAAM,CAAC,CAAC,EAAG;AAGpC,UAAM,QAAQ,QAAQ,CAAC;AACvB,WAAO,eAAe,OAAO,MAAM,CAAC,GAAG;AAAA,MACrC,MAAM;AAAE,eAAO,MAAM,GAAG,KAAK,QAAQ,CAAC;AAAA,MAAG;AAAA,MACzC,YAAY;AAAA,IAClB,CAAK;AAAA,EACH;AAEA,SAAO,WAAS,IAAI,UAAU,KAAK;AACrC;AAUO,SAAS,cAAc,OAAO,SAAS;AAC5C,SAAO,WAAS,aAAa,OAAO,SAAS,KAAK;AACpD;AASO,SAAS,aAAa,OAAO,SAAS,OAAO;AAClD,QAAM,MAAM,CAAA;AACZ,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,QAAI,MAAM,CAAC,CAAC,IAAI,QAAQ,CAAC,EAAE,GAAG,KAAK;AAAA,EACrC;AACA,SAAO;AACT;AC9DO,SAAS,cAAc,OAAO;AACnC,SAAO,iBAAiB;AAC1B;AAOO,MAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,OAAO,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcnB,YAAY;AAAA,IACV,QAAA/F;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAA+D;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GAAK;AACD,SAAK,SAAS/D;AACd,SAAK,YAAY;AACjB,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,SAAS+D;AACd,SAAK,UAAU;AACf,SAAK,QAAQ;AACb,SAAK,WAAW;AAKhB,QAAI,CAAC,aAAa,CAAC,KAAK,UAAU;AAEhC,WAAK,KAAK,WAAS,KAAK,MAAM,KAAK;AAAA,IACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,OAAO,WAAW,IAAI;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,GAAG,OAAO;AACR,WAAO,KAAK,QAAQ,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,OAAO;AACb,WAAO,UAAU,KAAK,UAAU,KAAK;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,OAAO;AACX;AAAA;AAAA,MAAyB,KAAK,OAAO,KAAK;AAAA;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,OAAO,KAAK;AAChB,UAAM,IAAI,MAAM;AAChB,UAAMA,UAAS,MAAM,CAAC;AACtB,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,MAAAA,QAAO,CAAC,IAAI,KAAK,GAAG,QAAQ,CAAC;AAAA,IAC/B;AACA,WAAOA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,EAAE,OAAO,QAAQ,IAAI;AACnB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,EAAE,GAAG;AACpC,YAAM,KAAK,GAAG,CAAC;AAAA,IACjB;AAAA,EACF;AACF;AAOO,MAAM,oBAAoB,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUrC,YAAY,SAAS;AACnB,UAAM,OAAO;AAGb,UAAM,EAAE,QAAA/D,SAAQ,QAAA+D,QAAM,IAAK;AAC3B,SAAK,SAASA,QAAO,SAAS,GAAG/D,OAAM;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,OAAO,KAAK;AAEhB,WAAO,KAAK,YACR,MAAM,MAAM,OAAO,GAAG,IACtB,KAAK,OAAO,SAAS,OAAO,GAAG;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,OAAO,QAAQ,IAAI;AAClB,WAAO,KAAK,YACR,MAAM,OAAO,QAAQ,EAAC;AAAA;AAAA,MACO,KAAK,OAAO,OAAO,QAAQ,EAAC;AAAA;AAAA,EAC/D;AACF;AAMO,MAAM,oBAAoB,MAAM;AAAA,EACrC,OAAO,YAAY;AACrB;AAOO,MAAM,mBAAmB,MAAM;AAAA,EACpC,OAAO,YAAY;AACrB;AAMO,MAAM,kBAAkB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKxC,MAAM,OAAO;AACX,WAAO;AAAA,EACT;AACF;AAMO,MAAM,mBAAmB,YAAY;AAAA;AAAA;AAAA;AAAA,EAI1C,MAAM,OAAO;AACX,WAAO;AAAA;AAAA,MAAgC,KAAK,OAAO,KAAK;AAAA,IAAC;AAAA,EAC3D;AACF;AAMO,MAAM,qBAAqB,YAAY;AAAA;AAAA;AAAA;AAAA,EAI5C,MAAM,OAAO;AACX,UAAM;AAAA;AAAA,MAA2B,KAAK,OAAO,KAAK;AAAA;AAClD,UAAM,QAAQ,IAAI,UAAW;AAC7B,UAAM,QAAQ,IAAI,QAAU;AAC5B,UAAM2C,QAAQ,UAAS,IAAI,UAAW;AACtC,YAAQ,MAAI;AAAA,MACV,KAAK;AAAM,eAAOA,SAAQ,OAAO,OAAO,MAAM,IAAI;AAAA,MAClD,KAAK;AAAM,eAAOA,SAAQ,OAAO,iBAAiB,OAAO;AAAA,IAC/D;AACI,WAAOA,QAAQ,MAAM,OAAO,OAAQ,IAAI;AAAA,EAC1C;AACF;AAMO,MAAM,kBAAkB,WAAW;AAAA;AAAA;AAAA;AAAA,EAIxC,MAAM,OAAO;AACX,WAAO;AAAA;AAAA,MAAqC,KAAK;AAAA,MAAS;AAAA,IAAK;AAAA,EACjE;AACF;AAQO,MAAM,6BAA6B,YAAY;AAAA,EACpD,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,UAAM,EAAE,MAAK;AAAA;AAAA,MAAiC,KAAK;AAAA;AACnD,SAAK,QAAQ,MAAM;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO;AACX;AAAA;AAAA,MAA6B,KAAK,OAAO,KAAK,IAAK,KAAK;AAAA;AAAA,EAC1D;AACF;AAQO,MAAM,qBAAqB,MAAM;AAAA,EACtC,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,UAAM,EAAE,UAAU;;MAAsC,KAAK;AAAA;AAC7D,SAAK,UAAU,aAAa,KAAK,gBAC7B,aAAa,MAAM,iBACnB;AACJ,SAAK,QAAQ,OAAO,OAAO,KAAK;AAAA,EAClC;AACF;AAQO,MAAM,2BAA2B,aAAa;AAAA,EACnD,OAAO,YAAY;AAAA;AAAA;AAAA;AAAA,EAInB,MAAM,OAAO;AACX,WAAO;AAAA,MACL,KAAK;AAAA;AAAA,QAAuC,KAAK;AAAA,QAAS;AAAA,MAAK;AAAA,MAC/D,KAAK;AAAA,IACX;AAAA,EACE;AACF;AAQO,MAAM,2BAA2B,aAAa;AAAA,EACnD,OAAO,YAAY;AAAA;AAAA;AAAA;AAAA,EAInB,MAAM,OAAO;AACX,WAAO,KAAK;AAAA;AAAA,MAAuC,KAAK;AAAA,MAAS;AAAA,IAAK;AAAA,EACxE;AACF;AAQO,MAAM,kBAAkB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKxC,YAAY,OAAO;AACjB,UAAM,KAAK;AACX,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO;AACX,WAAO,IAAI,KAAK,KAAK,OAAO,MAAM,KAAK,CAAC;AAAA,EAC1C;AACF;AAKO,MAAM,qBAAqB,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAK5C,MAAM,OAAO;AAEX,WAAO;AAAA,IAAkC,KAAK,OAAO,KAAK;AAAA,EAC5D;AACF;AAKO,MAAM,0BAA0B;AAKhC,MAAM,6BAA6B,WAAW;AAAA;AAAA;AAAA;AAAA,EAInD,MAAM,OAAO;AACX,WAAO,MAAM,MAAM,KAAK,IAAI;AAAA,EAC9B;AACF;AAKO,MAAM,4BAA4B;AAKlC,MAAM,kCAAkC,WAAW;AAAA;AAAA;AAAA;AAAA,EAIxD,MAAM,OAAO;AAEX,WAAO;AAAA;AAAA,MAA8B,KAAK,OAAO,KAAK;AAAA,MAAI;AAAA,IAAK;AAAA,EACjE;AACF;AAKO,MAAM,iCAAiC,WAAW;AAAA;AAAA;AAAA;AAAA,EAIvD,MAAM,OAAO;AAEX,WAAO;AAAA;AAAA,MAA8B,KAAK,OAAO,KAAK;AAAA,MAAI;AAAA,IAAQ;AAAA,EACpE;AACF;AAMO,MAAM,6BAA6B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKnD,MAAM,OAAO;AACX,UAAMoB;AAAA;AAAA,MAAoC,KAAK;AAAA;AAC/C,WAAOA,QAAO,SAAS,SAAS,GAAI,QAAQ,KAAM,CAAC;AAAA,EACrD;AACF;AAMO,MAAM,kCAAkC,WAAW;AAAA;AAAA;AAAA;AAAA,EAIxD,MAAM,OAAO;AACX,UAAMA;AAAA;AAAA,MAAoC,KAAK;AAAA;AAC/C,UAAM,OAAO,SAAS;AACtB,WAAO,aAAa;AAAA,MAClB,UAAUA,SAAQ,IAAI;AAAA,MACtB,UAAUA,SAAQ,OAAO,CAAC;AAAA,MAC1B,UAAUA,SAAQ,OAAO,CAAC;AAAA,IAChC;AAAA,EACE;AACF;AAEA,MAAM,WAAW,CAAC,EAAC,QAAAA,SAAQ,QAAO,GAAG,UAAUA,QAAO,SAAS,QAAQ,KAAK,GAAG,QAAQ,QAAQ,CAAC,CAAC;AACjG,MAAM,WAAW,CAAC,EAAC,QAAAA,SAAQ,QAAO,GAAG,UAAUA,QAAO,SAAS,SAAS,QAAQ,KAAK,CAAC,GAAG,SAAS,QAAQ,QAAQ,CAAC,CAAC,CAAC;AAO9G,MAAM,oBAAoB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK1C,MAAM,OAAO;AACX,WAAO,SAAS,MAAM,KAAK;AAAA,EAC7B;AACF;AAQO,MAAM,yBAAyB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK/C,MAAM,OAAO;AACX,WAAO,SAAS,MAAM,KAAK;AAAA,EAC7B;AACF;AAMO,MAAM,kBAAkB,WAAW;AAAA;AAAA;AAAA;AAAA,EAIxC,MAAM,OAAO;AACX,WAAO,WAAW,SAAS,MAAM,KAAK,CAAC;AAAA,EACzC;AACF;AAOO,MAAM,uBAAuB,WAAW;AAAA;AAAA;AAAA;AAAA,EAI7C,MAAM,OAAO;AACX,WAAO,WAAW,SAAS,MAAM,KAAK,CAAC;AAAA,EACzC;AACF;AAQO,MAAM,kBAAkB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKxC,MAAM,OAAO;AACX,UAAM;AAAA;AAAA,MAAqC,KAAK;AAAA;AAChD,WAAO,KAAK,SAAS,CAAC,EAAE,MAAM,QAAQ,KAAK,GAAG,QAAQ,QAAQ,CAAC,CAAC;AAAA,EAClE;AACF;AASO,MAAM,uBAAuB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK7C,MAAM,OAAO;AACX,UAAM;AAAA;AAAA,MAAwC,KAAK;AAAA;AACnD,WAAO,KAAK,SAAS,CAAC,EAAE,MAAM,SAAS,QAAQ,KAAK,CAAC,GAAG,SAAS,QAAQ,QAAQ,CAAC,CAAC,CAAC;AAAA,EACtF;AACF;AAQO,MAAM,sBAAsB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK5C,MAAM,OAAO;AACX,UAAM;AAAA;AAAA,MAA2B,KAAK,QAAQ,KAAK;AAAA;AACnD,UAAM,IAAI;AAAA,IAA2B,KAAK,MAAM,KAAK;AACrD,WAAO,KAAK,SAAS,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,EACpC;AACF;AASO,MAAM,2BAA2B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjD,MAAM,OAAO;AACX,UAAM;AAAA;AAAA,MAA2B,KAAK,QAAQ,KAAK;AAAA;AACnD,UAAM,IAAI;AAAA,IAA2B,KAAK,MAAM,KAAK;AACrD,WAAO,KAAK,SAAS,CAAC,EAAE,MAAM,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA,EACxD;AACF;AAOA,MAAM,mBAAmB,WAAW;AAAA,EAClC,YAAY,SAAS;AACnB,UAAM,OAAO;AAGb,SAAK,SAAS,KAAK,KAAK;AAAA,EAC1B;AACF;AAOO,MAAM,yBAAyB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK/C,MAAM,OAAO;AACX,UAAM,EAAE,QAAQ,QAAAA,QAAM,IAAK;AAC3B;AAAA;AAAA,MAAkCA,QAC/B,SAAS,QAAQ,SAAS,QAAQ,KAAK,MAAM;AAAA;AAAA,EAClD;AACF;AAOO,MAAM,uBAAuB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK7C,MAAM,OAAO;AACX,UAAM,EAAE,UAAU,OAAM,IAAK;AAC7B,WAAO,SAAS,CAAC,EAAE,MAAM,QAAQ,SAAS,QAAQ,KAAK,MAAM;AAAA,EAC/D;AACF;AAKA,SAAS,MAAM,EAAE,UAAU,QAAO,GAAI,OAAO;AAC3C,QAAM,CAAEE,OAAM,IAAI,IAAK,SAAS,CAAC,EAAE;AACnC,QAAM,QAAQ,QAAQ,KAAK;AAC3B,QAAM,MAAM,QAAQ,QAAQ,CAAC;AAC7B,QAAMR,WAAU,CAAA;AAChB,WAAS,IAAI,OAAO,IAAI,KAAK,EAAE,GAAG;AAChC,IAAAA,SAAQ,KAAK,CAACQ,MAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC;AAAA,EACvC;AACA,SAAOR;AACT;AAQO,MAAM,sBAAsB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5C,MAAM,OAAO;AACX;AAAA;AAAA,MAAgC,MAAM,MAAM,KAAK;AAAA;AAAA,EACnD;AACF;AAQO,MAAM,iBAAiB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMvC,MAAM,OAAO;AACX,WAAO,IAAI;AAAA;AAAA,MAA6B,MAAM,MAAM,KAAK;AAAA,IAAC;AAAA,EAC5D;AACF;AAQO,MAAM,yBAAyB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa/C,YAAY,EAAE,SAAS,GAAG,WAAW;AACnC,UAAM,OAAO;AAEb,SAAK,UAAU;AAGf,SAAK,UAAU,KAAK,KAAK;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO1D,UAAS,OAAO;AAC3B,UAAM,EAAE,SAAS,UAAU,QAAO,IAAK;AACvC,WAAO,SAAS,QAAQ,QAAQ,KAAK,CAAC,CAAC,EAAE,GAAGA,OAAM;AAAA,EACpD;AACF;AAQO,MAAM,wBAAwB,iBAAiB;AAAA;AAAA;AAAA;AAAA,EAIpD,MAAM,OAAO;AACX,WAAO,MAAM;AAAA,MAAM;AAAA;AAAA,MAA8B,KAAK,QAAQ,KAAK;AAAA,IAAC;AAAA,EACtE;AACF;AAOO,MAAM,oBAAoB,WAAW;AAAA,EAC1C,YAAY,SAAS,UAAU,eAAe;AAC5C,UAAM,OAAO;AAGb,SAAK,QAAQ,KAAK,KAAK,SAAS,IAAI,WAAS,MAAM,IAAI;AACvD,SAAK,UAAU,QAAQ,KAAK,OAAO,KAAK,QAAQ;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO;AACX,WAAO,KAAK,QAAQ,KAAK;AAAA,EAC3B;AACF;AAQO,MAAM,yBAAyB,YAAY;AAAA,EAChD,YAAY,SAAS;AACnB,UAAM,SAAS,YAAY;AAAA,EAC7B;AACF;AAOO,MAAM,2BAA2B,WAAW;AAAA;AAAA;AAAA;AAAA,EAIjD,MAAM,OAAO;AACX,UAAM,CAAE,EAAE,QAAQ,KAAI,GAAI,IAAI,IAAK,KAAK;AACxC,WAAO,KAAK;AAAA,MACV;AAAA;AAAA,QAAmC;AAAA,QAAO;AAAA,MAAK;AAAA,IACrD;AAAA,EACE;AACF;AAOO,MAAMqG,yBAAwB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ9C,cAAczC,aAAY;AACxB,SAAK,aAAaA;AAClB,SAAK,QAAQA,YAAW,MAAK;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO;AACX,WAAO,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,OAAO;AACT;AAAA;AAAA,MAA8B,KAAK,OAAO,KAAK;AAAA;AAAA,EACjD;AACF;AAMA,MAAM,kBAAkB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWjC,YAAY,EAAE,MAAAtB,OAAM,GAAG,WAAW;AAChC,UAAM,OAAO;AACb,SAAK,OAAOA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAK,OAAO;AACV,UAAM,EAAE,QAAA0B,SAAQ,MAAA1B,MAAI,IAAK;AACzB,UAAMtC,UAAS,SAAS;AACxB,QAAI,QAAQA,UAAS;AACrB,QAAIgG;AAAA;AAAA,MAAiChC;AAAA;AACrC,UAAM/D,UAAS,UAAU+F,MAAKhG,OAAM;AACpC,QAAIC,UAAS,IAAI;AAEf,cAAQ,UAAU+F,MAAKhG,UAAS,EAAE;AAClC,MAAAgG,OAAM1D,MAAK,UAAU0D,MAAKhG,UAAS,CAAC,CAAC;AAAA,IACvC;AACA,WAAOgG,KAAI,SAAS,OAAO,QAAQ/F,OAAM;AAAA,EAC3C;AACF;AAOO,MAAM,wBAAwB,UAAU;AAAA;AAAA;AAAA;AAAA,EAI7C,MAAM,OAAO;AACX,WAAO,KAAK,KAAK,KAAK;AAAA,EACxB;AACF;AAMO,MAAM,sBAAsB,UAAU;AAAA;AAAA;AAAA;AAAA,EAI3C,MAAM,OAAO;AACX,WAAO,WAAW,KAAK,KAAK,KAAK,CAAC;AAAA,EACpC;AACF;AC92BO,SAAS,cAAc,MAAM;AAClC,MAAIqC,QAAO,CAAA;AACX,SAAO;AAAA,IACL,IAAI,OAAO;AAAE,MAAAA,MAAK,KAAK,KAAK;AAAG,aAAO;AAAA,IAAM;AAAA,IAC5C,OAAO,MAAMA,QAAO,CAAA;AAAA,IACpB,MAAM,MAAM,IAAI,OAAOA,OAAM,IAAI;AAAA,EACrC;AACA;AAUO,MAAM,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOlB,YAAYA,OAAM,OAAOA,MAAK,CAAC,GAAG,MAAM;AAMtC,SAAK,OAAO;AAMZ,SAAK,SAASA,MAAK,OAAO,CAAC,GAAG,MAAM,IAAI,EAAE,QAAQ,CAAC;AAMnD,SAAK,YAAYA,MAAK,OAAO,CAAC,GAAG,MAAM,IAAI,EAAE,WAAW,CAAC;AAMzD,SAAK,OAAOA;AAEZ,UAAM,IAAIA,MAAK;AACf,UAAM,UAAU,IAAI,WAAW,IAAI,CAAC;AACpC,QAAI,MAAM,GAAG;AACX,YAAM,CAAE,KAAK,IAAKA;AAClB,cAAQ,CAAC,IAAI,MAAM;AAEnB,WAAK,KAAK,WAAS,MAAM,GAAG,KAAK;AAAA,IACnC,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACjC,gBAAQ,IAAI,CAAC,IAAK,KAAKA,MAAK,CAAC,EAAE;AAAA,MACjC;AAAA,IACF;AAQA,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,OAAO,WAAW,IAAI;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,OAAO,QAAQ,IAAI;AAClB,UAAMA,QAAO,KAAK;AAClB,WAAOA,MAAK,WAAW,IACnBA,MAAK,CAAC,EAAE,OAAO,QAAQ,EAAC,IACxB,gBAAgBA,KAAI;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,GAAG,OAAO;AAGR,UAAM,EAAE,MAAAA,OAAM,QAAO,IAAK;AAC1B,UAAM,IAAI,OAAO,SAAS,KAAK,IAAI;AACnC,WAAOA,MAAK,CAAC,GAAG,GAAG,QAAQ,QAAQ,CAAC,CAAC;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,OAAO;AACT,WAAO,KAAK,GAAG,KAAK;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,UAAM,EAAE,QAAArC,SAAQ,WAAW,MAAAqC,MAAI,IAAK;AACpC,UAAM,OAAO,CAAC,aAAa,cAAcA,MAAK,CAAC,CAAC;AAChD,UAAM,IAAIA,MAAK;AAEf,QAAI,QAAQ,MAAM,GAAG;AAGnB,aAAOA,MAAK,CAAC,EAAE;AAAA,IACjB;AAGA,UAAM,YAAY,CAAC,KAAK,YAAY,IAAI,QAEnCA,MAAK,CAAC,EAAE,YAAY,aAAaA,MAAK,CAAC,EAAE,OAAO;AAErD,UAAMO,SAAQ,IAAI,UAAU5C,OAAM;AAClC,WAAO,OAAO,UAAU4C,QAAOP,KAAI,IAAI,aAAaO,QAAOP,KAAI;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ;AACN,WAAO,KAAK,WAAW,KAAK,SAAS,KAAK;EAC5C;AACF;AAEA,UAAU,gBAAgBA,OAAM;AAC9B,WAAS,IAAI,GAAG,IAAIA,MAAK,QAAQ,EAAE,GAAG;AACpC,UAAM,OAAOA,MAAK,CAAC,EAAE,OAAO,QAAQ,EAAC;AACrC,aAAS,OAAO,KAAK,QAAQ,CAAC,KAAK,MAAM,OAAO,KAAK,QAAQ;AAC3D,YAAM,KAAK;AAAA,IACb;AAAA,EACF;AACF;AAEA,SAAS,UAAUO,QAAOP,OAAM;AAC9B,WAAS,IAAI,GAAGtC,UAAS,GAAG,IAAIsC,MAAK,QAAQ,EAAE,GAAG;AAChD,UAAM,EAAE,QAAA0B,QAAM,IAAK1B,MAAK,CAAC;AACzB,IAAAO,OAAM,IAAImB,SAAQhE,OAAM;AACxB,IAAAA,WAAUgE,QAAO;AAAA,EACnB;AACA,SAAOnB;AACT;AAEA,SAAS,aAAaA,QAAOP,OAAM;AACjC,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAIA,MAAK,QAAQ,EAAE,GAAG;AACpC,UAAM,QAAQA,MAAK,CAAC;AACpB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,MAAAO,OAAM,EAAE,KAAK,IAAI,MAAM,GAAG,CAAC;AAAA,IAC7B;AAAA,EACF;AACA,SAAOA;AACT;AC9KO,MAAMyG,OAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQjB,YAAY,QAAQ,UAAU,WAAW,OAAO;AAC9C,UAAM,QAAQ,OAAO,OAAO,IAAI,OAAK,EAAE,IAAI;AAM3C,SAAK,SAAS;AAKd,SAAK,QAAQ;AAKb,SAAK,WAAW;AAKhB,SAAK,UAAU,WAAW,eAAe;AAGzC,UAAM,MAAM,CAAA;AASZ,SAAK,aAAa,OAAK,IAAI,CAAC,MACtB,IAAI,CAAC,IAAI,KAAK,QAAQ,OAAO,SAAS,IAAI,OAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,OAAO,WAAW,IAAI;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,UAAU;AACZ,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,UAAU;AACZ,WAAO,KAAK,SAAS,CAAC,GAAG,UAAU;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,OAAO;AAChB,WAAO,KAAK,SAAS,KAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SAAS9D,OAAM;AACb,UAAM,IAAI,KAAK,MAAM,UAAU,OAAK,MAAMA,KAAI;AAC9C,WAAO,IAAI,KAAK,KAAK,SAAS,CAAC,IAAI;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,SAAS,SAAS,KAAK,IAAI;AACzB,UAAM,EAAE,UAAU,SAAS,OAAM,IAAK;AACtC,UAAM,EAAE,OAAM,IAAK;AACnB,WAAO,IAAI8D;AAAA,MACT;AAAA,QACE,GAAG;AAAA,QACH,QAAQ,QAAQ,IAAI,CAAC,GAAG,MAAM,YAAY,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAAA,MACnE;AAAA,MACM,QAAQ,IAAI,OAAK,SAAS,CAAC,CAAC;AAAA,MAC5B,YAAY;AAAA,IAClB;AAAA,EACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,OAAO,OAAO,IAAI;AAChB,UAAMuG;AAAA;AAAA,MAAyB,KAAK;AAAA;AACpC,UAAM,UAAU,MAAM,IAAI,CAAArK,UAAQqK,KAAI,QAAQrK,KAAI,CAAC;AACnD,WAAO,KAAK,SAAS,SAAS,EAAE;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY;AACV,UAAM,EAAE,UAAU,MAAK,IAAK;AAG5B,UAAM,OAAO,CAAA;AACb,UAAM,QAAQ,CAACA,OAAM,MAAM,KAAKA,KAAI,IAAI,SAAS,CAAC,GAAG,QAAO,KAAM,CAAA,CAAE;AACpE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AACR,UAAM,EAAE,UAAU,YAAY,QAAO,IAAK;AAC1C,UAAMlD,QAAO,SAAS,CAAC,GAAG,QAAQ,CAAA;AAClC,UAAMgK,UAAS,MAAM,OAAO;AAC5B,aAAS,IAAI,GAAG,MAAM,IAAI,IAAIhK,MAAK,QAAQ,EAAE,GAAG;AAC9C,YAAM,IAAI,WAAW,CAAC;AACtB,eAAS,IAAI,GAAG,IAAIA,MAAK,CAAC,EAAE,QAAQ,EAAE,GAAG;AACvC,QAAAgK,QAAO,EAAE,GAAG,IAAI,EAAE,CAAC;AAAA,MACrB;AAAA,IACF;AACA,WAAOA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,EAAE,OAAO,QAAQ,IAAI;AACnB,UAAM,EAAE,UAAU,WAAU,IAAK;AACjC,UAAMhK,QAAO,SAAS,CAAC,GAAG,QAAQ,CAAA;AAClC,aAAS,IAAI,GAAG,IAAIA,MAAK,QAAQ,EAAE,GAAG;AACpC,YAAM,IAAI,WAAW,CAAC;AACtB,eAAS,IAAI,GAAG,IAAIA,MAAK,CAAC,EAAE,QAAQ,EAAE,GAAG;AACvC,cAAM,EAAE,CAAC;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,GAAG,OAAO;AACR,UAAM,EAAE,UAAU,YAAY,QAAO,IAAK;AAC1C,QAAI,QAAQ,KAAK,SAAS,QAAS,QAAO;AAC1C,UAAM,CAAC,EAAE,QAAO,CAAE,IAAI;AACtB,UAAM,IAAI,OAAO,SAAS,KAAK,IAAI;AACnC,WAAO,WAAW,CAAC,EAAE,QAAQ,QAAQ,CAAC,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,OAAO;AACT,WAAO,KAAK,GAAG,KAAK;AAAA,EACtB;AACF;AAEA,SAAS,YAAYf,QAAOiE,OAAM;AAChC,SAAQA,SAAQ,QAAQA,UAASjE,OAAM,OACnC,EAAE,GAAGA,QAAO,MAAAiE,MAAI,IAChBjE;AACN;AC1MO,SAAS,UAAU,MAAM,UAAU,IAAI;AAC5C,QAAM,EAAE,QAAQ,UAAU,MAAM,WAAW,KAAI;AAAA;AAAA,IAAwB;AAAA;AACvE,QAAM,EAAE,WAAW,SAAS,eAAe,QAAQ,SAAQ,IAAK;AAEhE,UAAQ,QAAM;AAAA,IACZ,KAAK,KAAK;AAAM,aAAO;AAAA,IACvB,KAAK,KAAK;AAAM,aAAO;AAAA,IACvB,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,aAAa,WAAW,KAAK,cAAc;AAAA,IACpD,KAAK,KAAK;AACR,aAAO,YAAY,cAAc;AAAA,IACnC,KAAK,KAAK;AACR,aAAO;AAAA,QACL,SAAS,SAAS,MAAM,eAAe;AAAA,QACvC,WAAW;AAAA,MACnB;AAAA,IACI,KAAK,KAAK;AACR,aAAO;AAAA,QACL,SAAS,SAAS,SAAS,uBACvB,SAAS,SAAS,cAAc,4BAChC,SAAS,SAAS,cAAc,4BAChC;AAAA,QACJ,WAAW;AAAA,MACnB;AAAA,IACI,KAAK,KAAK;AACR,aAAO,aAAa,KACf,gBAAgB,cAAc,uBAC9B,gBAAgB,qBAAqB;AAAA,IAC5C,KAAK,KAAK;AACR,aAAO,SAAS,aAAa,WAAW,uBACpC,SAAS,aAAa,aAAa,cACnC;AAAA,IACN,KAAK,KAAK;AAAiB,aAAO;AAAA,IAClC,KAAK,KAAK;AAAM,aAAO;AAAA,IACvB,KAAK,KAAK;AAAW,aAAO;AAAA,IAC5B,KAAK,KAAK;AAAQ,aAAO;AAAA,IACzB,KAAK,KAAK;AAAa,aAAO;AAAA,IAC9B,KAAK,KAAK;AAAY,aAAO;AAAA,IAC7B,KAAK,KAAK;AAAU,aAAO;AAAA,IAC3B,KAAK,KAAK;AAAM,aAAO;AAAA,IACvB,KAAK,KAAK;AAAW,aAAO;AAAA,IAC5B,KAAK,KAAK;AAAK,aAAO,SAAS,WAAW;AAAA,IAC1C,KAAK,KAAK;AAAU,aAAO;AAAA,IAC3B,KAAK,KAAK;AAAe,aAAO;AAAA,IAChC,KAAK,KAAK;AAAe,aAAO;AAAA,IAChC,KAAK,KAAK;AAAQ,aAAO,WAAW,mBAAmB;AAAA,IACvD,KAAK,KAAK;AAAe,aAAO;AAAA,IAChC,KAAK,KAAK;AAAY,aAAO8E;AAAA,IAC7B,KAAK,KAAK;AAAO,aAAO,OAAO,kBAAkB;AAAA,EACrD;AACE,QAAM,IAAI,MAAM,gBAAgB,MAAM,CAAC;AACzC;AAEA,SAAS,KAAK,WAAW,cAAc;AACrC,SAAO,eACH,MAAM,kBAAkB,aAAa;AAAA,IACnC,YAAY,SAAS;AACnB,YAAM,IAAI,UAAU,OAAO,CAAC;AAAA,IAC9B;AAAA,EACR,IACM;AACN;ACnEO,SAAS,YAAYL,MAAK,OAAO;AAItC,SAAO;AAAA,IACL,QAAQ,UAAUA,MAAK,KAAK;AAAA,IAC5B,gBAAgB,UAAUA,MAAK,QAAQ,CAAC;AAAA,IACxC,YAAY,UAAUA,MAAK,QAAQ,EAAE;AAAA,EACzC;AACA;AAQO,SAAS,aAAaA,MAAK,OAAO;AACvC,SAAO,WAAWA,MAAK,OAAO,IAAI,WAAW;AAC/C;ACdO,SAAS,kBAAkBA,MAAK,OAAOJ,UAAS;AAMrD,QAAMlB,OAAM,WAAWsB,MAAK,KAAK;AACjC,MAAItB,KAAI,IAAI,YAAY,CAAC,GAAG;AAC1B,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AAIA,QAAM1E,UAAS4F,WAAU,QAAQ,KAAK,IAAI;AAE1C,SAAO;AAAA,IACL,QAAQlB,KAAI,GAAG,WAAW,CAAC;AAAA,IAC3B,OAAO,WAAWsB,MAAKtB,KAAI,GAAG,UAAU,GAAG,IAAI,CAACsB,MAAK,SAAS;AAAA,MAC5D,QAAQ,UAAUA,MAAK,GAAG;AAAA,MAC1B,WAAW,UAAUA,MAAK,MAAM,CAAC;AAAA,IACvC,EAAM;AAAA,IACF,SAAS,WAAWA,MAAKtB,KAAI,GAAG,UAAU,GAAG,KAAK1E,SAAQ,CAACgG,MAAK,SAAS;AAAA,MACvE,QAAQ,UAAUA,MAAK,MAAMhG,OAAM;AAAA,MACnC,QAAQ,UAAUgG,MAAK,MAAMhG,UAAS,CAAC;AAAA,IAC7C,EAAM;AAAA,IACF,UAAU,WAAWgG,MAAKtB,KAAI,IAAI,UAAU,GAAG,GAAG,SAAS;AAAA,EAC/D;AACA;AC3BO,SAAS,sBAAsBsB,MAAK,OAAOJ,UAAS;AAIzD,QAAMlB,OAAM,WAAWsB,MAAK,KAAK;AACjC,SAAO;AAAA,IACL,IAAItB,KAAI,GAAG,WAAW,CAAC;AAAA,IACvB,MAAMA,KAAI,GAAG,CAACsB,MAAK,QAAQ,kBAAkBA,MAAK,KAAKJ,QAAO,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAM/D,SAASlB,KAAI,GAAG,aAAa,KAAK;AAAA,EACtC;AACA;ACZO,SAAS,eAAesB,MAAK,OAAO,QAAQ,UAAU;AAC3D,aAAW,QAAQ,MAAM,eAAe;AACxC,QAAMtB,OAAM,WAAWsB,MAAK,KAAK;AAEjC,UAAQ,QAAM;AAAA;AAAA,IAEZ,KAAK,KAAK;AAAQ,aAAO,OAAM;AAAA,IAC/B,KAAK,KAAK;AAAM,aAAO,KAAI;AAAA,IAC3B,KAAK,KAAK;AAAa,aAAO,YAAW;AAAA,IACzC,KAAK,KAAK;AAAW,aAAO,UAAS;AAAA,IACrC,KAAK,KAAK;AAAM,aAAO,KAAK,SAAS,CAAC,CAAC;AAAA,IACvC,KAAK,KAAK;AAAU,aAAO,SAAS,SAAS,CAAC,CAAC;AAAA,IAC/C,KAAK,KAAK;AAAW,aAAO,UAAU,SAAS,CAAC,CAAC;AAAA,IACjD,KAAK,KAAK;AAAe,aAAO,cAAc,SAAS,CAAC,CAAC;AAAA,IACzD,KAAK,KAAK;AAAQ,aAAO,OAAO,QAAQ;AAAA,IACxC,KAAK,KAAK;AAAe,aAAO,cAAc,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA;AAAA,IAGtE,KAAK,KAAK;AAAK,aAAO;AAAA;AAAA,QAEpBtB,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA,QACnBA,KAAI,GAAG,aAAa,KAAK;AAAA;AAAA,MAC/B;AAAA,IACI,KAAK,KAAK;AAAO,aAAO;AAAA;AAAA,QAEtBA,KAAI,GAAG,WAAW,UAAU,IAAI;AAAA;AAAA,MACtC;AAAA,IACI,KAAK,KAAK;AAAS,aAAO;AAAA,QACxBA,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA,QACnBA,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA;AAAA,QAEnBA,KAAI,GAAG,WAAW,GAAG;AAAA;AAAA,MAC3B;AAAA,IACI,KAAK,KAAK;AAAM,aAAO;AAAA;AAAA,QAErBA,KAAI,GAAG,WAAW,SAAS,WAAW;AAAA;AAAA,MAC5C;AAAA,IACI,KAAK,KAAK;AAAM,aAAO;AAAA;AAAA,QAErBA,KAAI,GAAG,WAAW,SAAS,WAAW;AAAA;AAAA,MAC5C;AAAA,IACI,KAAK,KAAK;AAAW,aAAO;AAAA;AAAA,QAE1BA,KAAI,GAAG,WAAW,SAAS,MAAM;AAAA;AAAA,QACjCA,KAAI,GAAG,UAAU;AAAA;AAAA,MACvB;AAAA,IACI,KAAK,KAAK;AAAU,aAAO;AAAA;AAAA,QAEzBA,KAAI,GAAG,WAAW,aAAa,UAAU;AAAA;AAAA,MAC/C;AAAA,IACI,KAAK,KAAK;AAAU,aAAO;AAAA;AAAA,QAEzBA,KAAI,GAAG,WAAW,SAAS,WAAW;AAAA;AAAA,MAC5C;AAAA,IAEI,KAAK,KAAK;AAAiB,aAAO;AAAA,QAChCA,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA,MACzB;AAAA,IACI,KAAK,KAAK;AAAe,aAAO;AAAA,QAC9B,SAAS,CAAC;AAAA,QACVA,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA,MACzB;AAAA,IACI,KAAK,KAAK;AAAK,aAAO;AAAA,QACpBA,KAAI,GAAG,aAAa,KAAK;AAAA;AAAA,QACzB,SAAS,CAAC;AAAA,MAChB;AAAA,IAEI,KAAK,KAAK;AAAO,aAAO;AAAA;AAAA,QAEtBA,KAAI,GAAG,WAAW,UAAU,MAAM;AAAA;AAAA,QAClC;AAAA,QACA,WAAWsB,MAAKtB,KAAI,GAAG,UAAU,GAAG,GAAG,SAAS;AAAA;AAAA,MACtD;AAAA,EACA;AAOE,SAAO,EAAE,OAAM;AACjB;ACtFO,SAAS,eAAesB,MAAK,OAAO;AACzC,QAAMtC,WAAU,WAAWsC,MAAK,OAAO,GAAG,CAACA,MAAK,QAAQ;AACtD,UAAMtB,OAAM,WAAWsB,MAAK,GAAG;AAC/B;AAAA;AAAA,MAAwC;AAAA,QACtCtB,KAAI,GAAG,UAAU;AAAA;AAAA,QACjBA,KAAI,GAAG,UAAU;AAAA;AAAA,MACvB;AAAA;AAAA,EACE,CAAC;AACD,SAAOhB,SAAQ,SAAS,IAAI,IAAIA,QAAO,IAAI;AAC7C;ACJO,SAAS,aAAasC,MAAK,OAAOJ,UAAS;AAKhD,QAAMlB,OAAM,WAAWsB,MAAK,KAAK;AACjC,SAAO;AAAA,IACL,SAAAJ;AAAA,IACA;AAAA;AAAA,MAAwClB,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA,IAC3D,QAAQA,KAAI,GAAG,oBAAoB,CAAA,CAAE;AAAA,IACrC,UAAUA,KAAI,GAAG,cAAc;AAAA,EACnC;AACA;AAKA,SAAS,mBAAmBsB,MAAK,cAAc;AAC7C,SAAO,WAAWA,MAAK,cAAc,GAAG,WAAW;AACrD;AAKA,SAAS,YAAYA,MAAK,OAAO;AAQ/B,QAAMtB,OAAM,WAAWsB,MAAK,KAAK;AACjC,QAAM,SAAStB,KAAI,GAAG,WAAW,KAAK,IAAI;AAC1C,QAAM,aAAaA,KAAI,IAAI,YAAY,CAAC;AACxC,QAAM,OAAOA,KAAI,IAAI,gBAAgB;AACrC,QAAM,WAAWA,KAAI,IAAI,CAACsB,MAAK,QAAQ,oBAAoBA,MAAK,GAAG,CAAC;AAEpE,MAAI,OAAO,eAAeA,MAAK,YAAY,QAAQ,QAAQ;AAC3D,MAAI,MAAM;AACR,SAAK,aAAa;AAClB,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,MAAMtB,KAAI,GAAG,UAAU;AAAA,IACvB;AAAA,IACA,UAAUA,KAAI,GAAG,aAAa,KAAK;AAAA,IACnC,UAAUA,KAAI,IAAI,cAAc;AAAA,EACpC;AACA;AAKA,SAAS,oBAAoBsB,MAAK,aAAa;AAC7C,QAAM,WAAW,WAAWA,MAAK,aAAa,GAAG,WAAW;AAC5D,SAAO,SAAS,SAAS,WAAW;AACtC;AAOA,SAAS,iBAAiBA,MAAK,OAAO;AACpC,MAAI,CAAC,MAAO,QAAO;AAKnB,QAAMtB,OAAM,WAAWsB,MAAK,KAAK;AACjC,SAAOpC;AAAAA,IACL;AAAA;AAAA,IACAc,KAAI,GAAG,WAAW,OAAO;AAAA;AAAA,IACzBA,KAAI,GAAG,aAAa,KAAK;AAAA;AAAA,IACzBA,KAAI,GAAG,WAAW,CAAC;AAAA;AAAA,EACvB;AACA;AAQA,SAAS,UAAUsB,MAAK,OAAO;AAC7B;AAAA;AAAA,IACE,eAAeA,MAAK,OAAO,KAAK,GAAG;AAAA;AAEvC;AChGA,MAAM,yBAAyB,CAAC,UAAU,WACxC,oBAAoB,QAAQ,kCAAkC,MAAM;AAEtE,MAAM,2BAA2B,CAAC,UAAU,WAC1C,oBAAoB,QAAQ,0CAA0C,MAAM;AAE9E,MAAM,qBAAqB,CAAC,SAC1B,6BAA6B,IAAI,KAAK,OAAO,eAAe,IAAI,CAAC;AAU5D,SAAS,cAAcA,MAAK,OAAO;AAExC,MAAI,iBAAiB,UAAUA,MAAK,KAAK,KAAK;AAC9C,WAAS;AAKT,MAAI,mBAAmB,IAAI;AACzB,qBAAiB,UAAUA,MAAK,KAAK,KAAK;AAC1C,aAAS;AAAA,EACX;AACA,MAAI,mBAAmB,EAAG,QAAO;AAEjC,QAAM,OAAOA,KAAI,SAAS,OAAO,SAAS,cAAc;AACxD,MAAI,KAAK,aAAa,gBAAgB;AACpC,UAAM,IAAI,MAAM,uBAAuB,gBAAgB,KAAK,UAAU,CAAC;AAAA,EACzE;AAOA,QAAMtB,OAAM,WAAW,MAAM,CAAC;AAC9B,QAAMkB;AAAA;AAAA,IACHlB,KAAI,GAAG,WAAW,QAAQ,EAAE;AAAA;AAC/B,QAAM;AAAA;AAAA,IACHA,KAAI,GAAG,WAAW,cAAc,IAAI;AAAA;AACvC,QAAM1E,UAAS0E,KAAI,GAAG,YAAY,CAAC;AACnC,QAAM,aAAaA,KAAI,IAAI,WAAW,CAAC;AACvC,MAAI;AAEJ,MAAI1E,SAAQ;AAEV,UAAM8P,WAAU,SAAS,cAAc,SAAS,eAC5C,SAAS,cAAc,kBAAkB,wBACzC,SAAS,cAAc,cAAc,oBACrC;AACJ,QAAI,CAACA,SAAS,OAAM,IAAI,MAAM,mBAAmB,IAAI,CAAC;AACtD,cAAUA,SAAQ,MAAM9P,SAAQ4F,QAAO;AAGvC,QAAI,aAAa,GAAG;AAClB,YAAM,OAAOI,KAAI,SAAS,OAAO,SAAS,UAAU;AACpD,UAAI,KAAK,aAAa,YAAY;AAChC,cAAM,IAAI,MAAM,yBAAyB,YAAY,KAAK,UAAU,CAAC;AAAA,MACvE;AAEA,cAAQ,OAAO;AAAA,IACjB,WAAW,SAAS,cAAc,QAAQ;AAGxC,cAAQ,OAAO,IAAI,WAAW,CAAC;AAAA,IACjC;AAAA,EACF;AAEA,SAAO,EAAE,SAAAJ,UAAS,MAAM,OAAO,QAAO;AACxC;AC1DO,SAAS,UAAUtD,OAAM;AAC9B,QAAMxC,UAAS,kBAAkBwC,KAAI,IAAI,IAAI,WAAWA,KAAI,IAAIA;AAChE,SAAOxC,mBAAkB,cAAc,kBAAkBA,OAAM,IAC3D,cAAcA,OAAM,IACpB,gBAAgBA,OAAM;AAC5B;AAMA,SAAS,kBAAkBkG,MAAK;AAC9B,MAAI,CAACA,QAAOA,KAAI,SAAS,EAAG,QAAO;AACnC,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,QAAI,MAAM,CAAC,MAAMA,KAAI,CAAC,EAAG,QAAO;AAAA,EAClC;AACA,SAAO;AACT;AAWO,SAAS,gBAAgB1D,OAAM;AACpC,QAAM,SAAS,CAACA,KAAI,EAAE,KAAI;AAE1B,MAAI;AACJ,QAAM,UAAU,CAAA;AAChB,QAAM,eAAe,CAAA;AAGrB,aAAW0D,QAAO,QAAQ;AACxB,QAAI,EAAEA,gBAAe,aAAa;AAChC,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AACA,QAAIhG,UAAS;AAGb,WAAO,MAAM;AACX,YAAM,IAAI,cAAcgG,MAAKhG,OAAM;AACnC,UAAI,MAAM,KAAM;AAChB,MAAAA,UAAS,EAAE;AACX,UAAI,CAAC,EAAE,QAAS;AAChB,cAAQ,EAAE,MAAI;AAAA,QACZ,KAAK,cAAc;AAEjB,cAAI,CAAC,OAAQ,UAAS,EAAE;AACxB;AAAA,QACF,KAAK,cAAc;AACjB,kBAAQ,KAAK,EAAE,OAAO;AACtB;AAAA,QACF,KAAK,cAAc;AACjB,uBAAa,KAAK,EAAE,OAAO;AAC3B;AAAA,MACV;AAAA,IACI;AAAA,EACF;AAEA;AAAA;AAAA,IACE,EAAE,QAAQ,cAAc,SAAS,UAAU,KAAI;AAAA;AAEnD;AASO,SAAS,cAAcsC,OAAM;AAElC,QAAMtC,UAASsC,MAAK,cAAc,MAAM,SAAS;AACjD,QAAMrC,UAAS,UAAUqC,OAAMtC,OAAM;AAQrC,QAAM0E,OAAM,WAAWpC,OAAMtC,UAASC,OAAM;AAC5C,QAAM2F;AAAA;AAAA,IACHlB,KAAI,GAAG,WAAW,QAAQ,EAAE;AAAA;AAC/B,QAAM,QAAQA,KAAI,GAAG,cAAc,CAAA,CAAE;AACrC,QAAM,OAAOA,KAAI,IAAI,cAAc,CAAA,CAAE;AAErC;AAAA;AAAA,IAAiC;AAAA,MAC/B,QAAQA,KAAI,GAAG,CAACsB,MAAK,UAAU,aAAaA,MAAK,OAAOJ,QAAO,CAAC;AAAA,MAChE,cAAc,MAAM,IAAI,CAAC,EAAE,QAAA5F,cAAa,cAAcsC,OAAMtC,OAAM,EAAE,OAAO;AAAA,MAC3E,SAAS,KAAK,IAAI,CAAC,EAAE,QAAAA,cAAa,cAAcsC,OAAMtC,OAAM,EAAE,OAAO;AAAA,MACrE,UAAU0E,KAAI,IAAI,cAAc;AAAA,IACpC;AAAA;AACA;AClGO,SAAS,aAAapC,OAAM,SAAS;AAC1C,SAAO,YAAY,UAAUA,KAAI,GAAG,OAAO;AAC7C;AAWO,SAAS,YAAYA,OAAM,UAAU,IAAI;AAC9C,QAAM,EAAE,SAAS,EAAE,QAAQ,CAAA,EAAE,GAAI,cAAc,QAAO,IAAKA;AAC3D,QAAM,EAAE,SAAAsD,UAAS,OAAM,IAAK;AAC5B,QAAM,gBAAgB,oBAAI;AAC1B,QAAM,UAAU,iBAAiB,SAASA,UAAS,aAAa;AAGhE,QAAM,kBAAkB,oBAAI;AAC5B,oBAAkB,QAAQ,CAAArE,WAAS;AACjC,UAAM,OAAOA,OAAM;AACnB,QAAI,KAAK,WAAW,KAAK,YAAY;AACnC,sBAAgB,IAAI,KAAK,IAAI,KAAK,UAAU;AAAA,IAC9C;AAAA,EACF,CAAC;AAGD,QAAM,QAAQ,oBAAI;AAClB,aAAW,QAAQ,cAAc;AAC/B,UAAM,EAAE,IAAI,MAAAe,OAAM,SAAS,KAAI,IAAK;AACpC,UAAM,OAAO,gBAAgB,IAAI,EAAE;AACnC,UAAM,QAAQuK,QAAM,MAAM,QAAQ,EAAE,GAAGvK,OAAM,KAAI,CAAE,CAAC;AACpD,QAAI,CAAC,MAAM,IAAI,EAAE,GAAG;AAClB,UAAI,SAAS;AACX,cAAM,IAAI,MAAM,iDAAiD;AAAA,MACnE;AACA,YAAM,IAAI,IAAI,cAAc,IAAI,EAAE,IAAI,KAAK,CAAC;AAAA,IAC9C,OAAO;AACL,YAAMyN,QAAO,MAAM,IAAI,EAAE;AACzB,UAAI,CAAC,QAAS,CAAAA,MAAK,MAAK;AACxB,MAAAA,MAAK,IAAI,KAAK;AAAA,IAChB;AAAA,EACF;AACA,QAAM,QAAQ,CAAC3Q,QAAOuE,SAAQ,cAAc,IAAIA,MAAKvE,OAAM,KAAI,CAAE,CAAC;AAGlE,QAAM,OAAO,OAAO,IAAI,OAAK,cAAc,EAAE,IAAI,CAAC;AAClD,aAAW,SAAS,SAAS;AAC3B,UAAM,MAAM,QAAQ,KAAK;AACzB,WAAO,QAAQ,CAAC,GAAG,MAAM,KAAK,CAAC,EAAE,IAAIyN,QAAM,EAAE,MAAM,GAAG,CAAC,CAAC;AAAA,EAC1D;AAEA,SAAO,IAAIvD,OAAM,QAAQ,KAAK,IAAI,OAAK,EAAE,KAAI,CAAE,GAAG,QAAQ,QAAQ;AACpE;AAOA,SAAS,kBAAkB,QAAQ,SAAS;AAC1C,SAAO,OAAO,QAAQ,SAAS,WAAW/H,QAAO;AAC/C,YAAQA,MAAK;AAEb,IAAAA,OAAM,KAAK,YAAY,UAAU,QAAQ,UAAU;AAEnD,IAAAA,OAAM,KAAK,UAAU,QAAQ,UAAU;AAAA,EACzC,CAAC;AACH;AAKA,SAAS,iBAAiB,SAASqE,UAAS,eAAe;AACzD,QAAM,OAAO;AAAA,IACX,SAAAA;AAAA,IACA;AAAA,IACA,YAAY,QAAM,cAAc,IAAI,EAAE;AAAA,EAC1C;AAME,SAAO,WAAS;AACd,UAAM,EAAE,QAAA3F,SAAQ,OAAO,SAAS,UAAU,KAAI,IAAK;AACnD,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,gBAAgB;AACpB,WAAO;AAAA,MACL,GAAG;AAAA,MACH,QAAAA;AAAA,MACA,MAAM,MAAM,MAAM,EAAE,SAAS;AAAA,MAC7B,QAAQ,CAAC,cAAc;AACrB,cAAM,EAAE,QAAAA,SAAQ,QAAAD,QAAM,IAAK,QAAQ,EAAE,WAAW;AAChD,eAAO,YACH,IAAI,UAAU,KAAK,QAAQ,KAAK,aAAaA,SAAQC,UAAS,UAAU,iBAAiB,IACzF,KAAK,SAASD,SAAQA,UAASC,OAAM;AAAA,MAC3C;AAAA,MACA,UAAU,MAAM,SAAS,EAAE,aAAa;AAAA,MACxC,MAAM,UAAU;AAAE,eAAO,SAAS,IAAI,OAAK4M,QAAM,EAAE,MAAM,IAAI,CAAC;AAAA,MAAG;AAAA,IACvE;AAAA,EACE;AACF;AAKA,SAASA,QAAM,MAAM,KAAK;AACxB,QAAM,EAAE,OAAM,IAAK;AACnB,QAAM,EAAE,SAAS,MAAM,QAAA9M,SAAQ,UAAU,SAAA6F,SAAO,IAAK;AACrD,QAAM,YAAY,UAAU,MAAM,OAAO;AAGzC,QAAM,OAAO,EAAE,GAAG,KAAI,GAAI,KAAI;AAE9B,MAAI,WAAW,KAAK,MAAM;AAExB,WAAO,IAAI,UAAU,EAAE,GAAG,MAAM,WAAW,KAAK,QAAQ;AAAA,EAC1D;AAEA,UAAQ,QAAM;AAAA;AAAA,IAEZ,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAU7F,QAAM;AAAA,QAChB,QAAQA,QAAO,KAAK,MAAM;AAAA,MAClC,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAUA,QAAM;AAAA,QAChB,SAASA,QAAO,KAAK,OAAO;AAAA,QAC5B,QAAQA,QAAM;AAAA,MACtB,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAUA,QAAM;AAAA,QAChB,QAAQA,QAAM;AAAA;AAAA,QACd,MAAM,MAAM,KAAK,EAAE,QAAQ,WAAU,GAAI,MAAMA,SAAQ;AAAA;AAAA,MAC/D,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAUA,QAAM;AAAA,QAChB,SAASA,QAAO,KAAK,OAAO;AAAA,QAC5B,UAAU,IAAI,MAAM,KAAK,QAAQ;AAAA,MACzC,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAUA,QAAM;AAAA,QAChB,SAASA,QAAO,KAAK,OAAO;AAAA,QAC5B,OAAOA,QAAO,KAAK,OAAO;AAAA,QAC1B,UAAU,IAAI,MAAM,KAAK,QAAQ;AAAA,MACzC,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAUA,QAAM;AAAA,QAChB,UAAU,IAAI,MAAM,KAAK,QAAQ;AAAA,MACzC,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK;AACR,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAU,IAAI,MAAM,KAAK,QAAQ;AAAA,MACzC,CAAO;AAAA;AAAA,IAGH,KAAK,KAAK,YAAY;AACpB,YAAM,EAAE,IAAI,QAAO,IAAK;AACxB,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,UAAUA,QAAM;AAAA,QAChB,QAAQA,QAAO,QAAQ,MAAM;AAAA,MACrC,CAAO,EAAE,cAAc,IAAI,WAAW,EAAE,CAAC;AAAA,IACrC;AAAA;AAAA,IAGA,KAAK,KAAK,OAAO;AACf,UAAI6F,WAAU,QAAQ,IAAI;AACxB,QAAA7F;MACF;AACA,aAAO,IAAI,UAAU;AAAA,QACnB,GAAG;AAAA,QACH,SAASA,QAAO,SAAS;AAAA,QACzB,SAAS,KAAK,SAAS,UAAU,SAAS,OAAOA,QAAO,KAAK,OAAO;AAAA,QACpE,UAAU,IAAI,MAAM,KAAK,QAAQ;AAAA,MACzC,CAAO;AAAA,IACH;AAAA;AAAA,IAGA;AACE,YAAM,IAAI,MAAM,gBAAgB,MAAM,CAAC;AAAA,EAC7C;AACA;ACxPO,SAAS,WAAWiG,MAAK,OAAO5G,QAAO;AAC5C,EAAA4G,KAAI,KAAK,IAAI5G;AACb,EAAA4G,KAAI,QAAQ,CAAC,IAAI5G,UAAS;AAC1B,EAAA4G,KAAI,QAAQ,CAAC,IAAI5G,UAAS;AAC1B,EAAA4G,KAAI,QAAQ,CAAC,IAAI5G,UAAS;AAC5B;AAEA,MAAM,YAAY;AAGX,MAAMyG,SAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKnB,YAAY,MAAM;AAKhB,SAAK,OAAO;AAKZ,SAAK,WAAW;AAKhB,SAAK,MAAM,IAAI,WAAW,SAAS;AAKnC,SAAK,QAAQ;AAMb,SAAK,UAAU,CAAA;AAIf,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS;AACP,WAAO,KAAK,IAAI,SAAS,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAUzG,QAAO;AACf,SAAK,IAAI,KAAK,SAAS,CAAC,IAAIA;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAWA,QAAO;AAChB,SAAK,IAAI,KAAK,SAAS,CAAC,IAAIA;AAC5B,SAAK,IAAI,KAAK,QAAQ,CAAC,IAAIA,UAAS;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAWA,QAAO;AAChB,eAAW,KAAK,KAAK,KAAK,SAAS,GAAGA,MAAK;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAWA,QAAO;AAChB,UAAM,IAAI,OAAOA,MAAK;AACtB,SAAK,WAAW,OAAO,OAAO,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,CAAC,CAAC;AAC1D,SAAK,WAAW,OAAO,OAAO,OAAO,IAAI,CAAC,CAAC,CAAC;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQA,QAAO;AACb,SAAK,MAAM,GAAG,CAAC;AACf,SAAK,UAAUA,MAAK;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAASA,QAAO;AACd,SAAK,MAAM,GAAG,CAAC;AACf,SAAK,WAAWA,MAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAASA,QAAO;AACd,SAAK,MAAM,GAAG,CAAC;AACf,SAAK,WAAWA,MAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAASA,QAAO;AACd,SAAK,MAAM,GAAG,CAAC;AACf,SAAK,WAAWA,MAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAUY,SAAQ;AAChB,SAAK,MAAM,YAAY,CAAC;AACxB,SAAK,WAAW,KAAK,OAAM,IAAKA,UAAS,UAAU;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,WAAW,WAAW;AAC9B,UAAM,IAAI,cAAc,MAAM,SAAS;AACvC,gBAAY,CAAC;AACb,WAAO,EAAE,OAAM;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,UAAU,OAAO,UAAU,WAAW,WAAW;AAC/C,UAAM,IAAI,OAAO;AACjB,QAAI,CAAC,EAAG,QAAO;AACf,SAAK,MAAM,YAAY,WAAW,CAAC;AACnC,SAAK,MAAM,WAAW,WAAW,CAAC;AAClC,aAAS,IAAI,GAAG,EAAE,KAAK,KAAI;AACzB,gBAAU,MAAM,MAAM,CAAC,CAAC;AAAA,IAC1B;AACA,SAAK,WAAW,CAAC;AACjB,WAAO,KAAK,OAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,SAAS;AACvB,WAAO,KAAK,UAAU,SAAS,GAAG,GAAG,CAAC,GAAG,QAAQ,EAAE,UAAU,GAAG,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,GAAG;AACX,QAAI,KAAK,KAAM,QAAO;AACtB,UAAMwB,QAAO,WAAW,CAAC;AACzB,UAAM,IAAIA,MAAK;AACf,SAAK,QAAQ,CAAC;AACd,SAAK,MAAM,YAAY,CAAC;AACxB,SAAK,IAAI,IAAIA,OAAM,KAAK,SAAS,CAAC;AAClC,SAAK,WAAW,CAAC;AACjB,WAAO,KAAK,OAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,YAAY;AACjB,SAAK,MAAM,KAAK,UAAU,UAAU;AACpC,SAAK,UAAU,UAAU;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ;AACN,UAAM,EAAE,KAAAwE,MAAK,KAAI,IAAK;AACtB,UAAM,QAAQA,KAAI,SAAS,KAAK,OAAOA,KAAI,MAAM;AACjD,SAAK,MAAM,KAAK;AAChB,SAAK,eAAe,MAAM;AAC1B,SAAK,WAAW;AAChB,SAAK,UAAU,CAAA;AACf,SAAK,MAAM,IAAI,WAAW,SAAS;AACnC,SAAK,QAAQ;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAUjG,SAAQ;AAChB,UAAM,OAAOA,QAAO;AACpB,QAAI,CAAC,KAAM,QAAO;AAClB,SAAK,KAAK,MAAMA,OAAM;AACtB,SAAK,eAAe;AACpB,UAAMgP,QAAQ,OAAO,IAAK,MAAM;AAChC,SAAK,WAAWA,IAAG;AACnB,WAAO,OAAOA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,WAAW;AACpB,QAAI,YAAY,GAAG;AACjB,WAAK,KAAK,MAAM,IAAI,WAAW,SAAS,CAAC;AACzC,WAAK,eAAe;AAAA,IACtB;AAAA,EACF;AACF;AAWO,SAAS,KAAKlN,UAAS,MAAM,iBAAiB;AACnD,MAAI,EAAE,KAAAmE,MAAK,OAAO,SAAQ,IAAKnE;AAG/B,MAAI,OAAO,UAAU;AACnB,IAAAA,SAAQ,WAAW;AAAA,EACrB;AAGA,QAAM,UAAUmE,KAAI;AACpB,QAAM,OAAO,UAAU,QAAQ;AAC/B,QAAM,YAAa,CAAC,OAAO,IAAM,OAAO;AAGxC,EAAAA,OAAM,KAAKA,MAAK,OAAO,YAAY,OAAO,GAAG,IAAI;AACjD,WAASA,KAAI,SAAS;AAGtB,WAAS,IAAI,GAAG,IAAI,WAAW,EAAE,GAAG;AAClC,IAAAA,KAAI,EAAE,KAAK,IAAI;AAAA,EACjB;AAGA,EAAAnE,SAAQ,MAAMmE;AACd,EAAAnE,SAAQ,QAAQ;AAClB;AAQA,SAAS,cAAcA,UAAS,WAAW;AAEzC,QAAM,SAAS,MAAM,SAAS,EAAE,KAAK,CAAC;AACtC,QAAM,cAAcA,SAAQ,OAAM;AAElC,WAAS,KAAK,OAAO;AACnB,WAAO,KAAK,IAAIA,SAAQ,OAAM;AAAA,EAChC;AAEA,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOL,QAAQ,OAAOzC,QAAO,cAAc;AAClC,UAAIA,UAAS,cAAc;AACzB,QAAAyC,SAAQ,QAAQzC,MAAK;AACrB,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,SAAS,OAAOA,QAAO,cAAc;AACnC,UAAIA,UAAS,cAAc;AACzB,QAAAyC,SAAQ,SAASzC,MAAK;AACtB,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,SAAS,OAAOA,QAAO,cAAc;AACnC,UAAIA,UAAS,cAAc;AACzB,QAAAyC,SAAQ,SAASzC,MAAK;AACtB,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,SAAS,OAAOA,QAAO,cAAc;AACnC,UAAIA,UAAS,cAAc;AACzB,QAAAyC,SAAQ,SAASzC,MAAK;AACtB,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,UAAU,OAAOA,QAAO,cAAc;AACpC,UAAIA,UAAS,cAAc;AACzB,QAAAyC,SAAQ,UAAUzC,MAAK;AACvB,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,SAAS;AAEP,MAAAyC,SAAQ,SAAS,CAAC;AAClB,YAAM,eAAeA,SAAQ,OAAM;AAGnC,UAAI,IAAI;AACR,aAAO,EAAE,KAAK,KAAK,OAAO,CAAC,MAAM,GAAG;AAAA,MAAC;AACrC,YAAM,OAAO,IAAI;AAGjB,aAAO,KAAK,GAAG,EAAE,GAAG;AAElB,QAAAA,SAAQ,SAAS,OAAO,CAAC,IAAK,eAAe,OAAO,CAAC,IAAK,CAAC;AAAA,MAC7D;AAEA,YAAM,iBAAiB;AACvB,MAAAA,SAAQ,SAAS,eAAe,WAAW;AAC3C,YAAM,OAAO,OAAO,kBAAkB;AACtC,MAAAA,SAAQ,SAAS,GAAG;AAGpB,UAAI,gBAAgB;AACpB,YAAM,EAAE,KAAAmE,MAAK,SAAS,OAAO,IAAG,IAAKnE;AACvC;AACE,aAAK,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACnC,gBAAM,MAAMmE,KAAI,SAAS,QAAQ,CAAC;AAClC,cAAI,OAAO,UAAUA,MAAK,GAAG,GAAG;AAC9B,qBAAS,IAAI,cAAc,IAAI,KAAK,KAAK,cAAc;AACrD,kBAAI,UAAUA,MAAK,MAAM,CAAC,KAAK,UAAUA,MAAK,MAAM,CAAC,GAAG;AACtD,yBAAS;AAAA,cACX;AAAA,YACF;AACA,4BAAgB,QAAQ,CAAC;AACzB;AAAA,UACF;AAAA,QACF;AAEA,UAAI,eAAe;AAGjB,QAAAnE,SAAQ,QAAQmE,KAAI,SAAS;AAC7B,mBAAWA,MAAKnE,SAAQ,OAAO,gBAAgB,YAAY;AAAA,MAC7D,OAAO;AAGL,cAAM,MAAMA,SAAQ,OAAM;AAC1B,gBAAQ,KAAK,GAAG;AAChB,mBAAWmE,MAAKA,KAAI,SAAS,cAAc,MAAM,YAAY;AAAA,MAC/D;AAEA,aAAO;AAAA,IACT;AAAA,EACJ;AACA;AC7aO,SAAS,kBAAkBnE,UAAS,OAAO;AAChD,QAAM,EAAE,OAAO,SAAS,SAAQ,IAAK;AACrC,QAAM,aAAaA,SAAQ;AAAA,IAAU;AAAA,IAAO;AAAA,IAAI;AAAA,IAC9C,CAACA,UAAS,SAAS;AACjB,MAAAA,SAAQ,WAAW,KAAK,SAAS;AACjC,MAAAA,SAAQ,WAAW,KAAK,MAAM;AAC9B,aAAOA,SAAQ,OAAM;AAAA,IACvB;AAAA,EACJ;AACE,QAAM,eAAeA,SAAQ;AAAA,IAAU;AAAA,IAAS;AAAA,IAAI;AAAA,IAClD,CAACA,UAAS,WAAW;AACnB,MAAAA,SAAQ,WAAW,OAAO,MAAM;AAChC,MAAAA,SAAQ,WAAW,OAAO,MAAM;AAChC,aAAOA,SAAQ,OAAM;AAAA,IACvB;AAAA,EACJ;AACE,QAAM,iBAAiBA,SAAQ;AAAA,IAAU;AAAA,IAAU;AAAA,IAAG;AAAA,IACpD,CAACA,UAASwI,WAAUxI,SAAQ,SAASwI,MAAK;AAAA,EAC9C;AACE,SAAOxI,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,MAAM,CAAC,EAAE,QAAQ,CAAC;AAChC,MAAE,UAAU,GAAG,YAAY,CAAC;AAC5B,MAAE,UAAU,GAAG,cAAc,CAAC;AAE9B,MAAE,UAAU,GAAG,gBAAgB,CAAC;AAAA,EAClC,CAAC;AACH;ACzBO,SAAS,sBAAsBA,UAAS,iBAAiB;AAC9D,QAAM,aAAa,kBAAkBA,UAAS,gBAAgB,IAAI;AAClE,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,gBAAgB,IAAI,CAAC;AACnC,MAAE,UAAU,GAAG,YAAY,CAAC;AAC5B,MAAE,QAAQ,GAAG,CAAC,gBAAgB,SAAS,CAAC;AAAA,EAC1C,CAAC;AACH;ACTO,SAAS,eAAeA,UAAS,UAAU;AAChD,SAAO,UAAU,OAAO,IACnBA,SAAQ,gBAAgB,MAAM,KAAK,UAAU,CAAC,CAAC,GAAG,CAAC,MAAM;AACxD,UAAM8B,OAAM9B,SAAQ,UAAU,GAAG,CAAC,EAAE;AACpC,UAAM,MAAMA,SAAQ,UAAU,GAAG,CAAC,EAAE;AACpC,WAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,QAAE,UAAU,GAAG8B,MAAK,CAAC;AACrB,QAAE,UAAU,GAAG,KAAK,CAAC;AAAA,IACvB,CAAC;AAAA,EACH,CAAC,CAAC,IACF;AACN;ACNO,SAAS,eAAe9B,UAAS,MAAM;AAC5C,QAAM,SAAS,WAAW,KAAK,QAAQ,MAAM,eAAe;AAE5D,UAAQ,QAAM;AAAA,IACZ,KAAK,KAAK;AACR,aAAO,iBAAiBA,UAAS,IAAI;AAAA,IACvC,KAAK,KAAK;AACR,aAAO,UAAUA,UAAS,IAAI;AAAA,IAChC,KAAK,KAAK;AACR,aAAO,YAAYA,UAAS,IAAI;AAAA,IAClC,KAAK,KAAK;AACR,aAAO,cAAcA,UAAS,IAAI;AAAA,IACpC,KAAK,KAAK;AACR,aAAO,WAAWA,UAAS,IAAI;AAAA,IACjC,KAAK,KAAK;AACR,aAAO,WAAWA,UAAS,IAAI;AAAA,IACjC,KAAK,KAAK;AACR,aAAO,gBAAgBA,UAAS,IAAI;AAAA,IACtC,KAAK,KAAK;AACR,aAAO,eAAeA,UAAS,IAAI;AAAA,IACrC,KAAK,KAAK;AACR,aAAO,eAAeA,UAAS,IAAI;AAAA,IACrC,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,gBAAgBA,UAAS,IAAI;AAAA,IACtC,KAAK,KAAK;AACR,aAAO,UAAUA,UAAS,IAAI;AAAA,IAChC,KAAK,KAAK;AACR,aAAO,YAAYA,UAAS,IAAI;AAAA,EACtC;AAeE,SAAOA,SAAQ,UAAU,CAAC;AAC5B;AAEA,SAAS,WAAWA,UAAS,MAAM;AACjC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,MAAM,SAAS,WAAW;AAAA,EAC/C,CAAC;AACH;AAEA,SAAS,cAAcA,UAAS,MAAM;AACpC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,WAAW,CAAC;AAC/B,MAAE,SAAS,GAAG,KAAK,OAAO,CAAC;AAC3B,MAAE,SAAS,GAAG,KAAK,UAAU,GAAG;AAAA,EAClC,CAAC;AACH;AAEA,SAAS,eAAeA,UAAS,MAAM;AACrC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,MAAM,SAAS,WAAW;AAAA,EAC/C,CAAC;AACH;AAEA,SAAS,gBAAgBA,UAAS,MAAM;AACtC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,QAAQ,CAAC;AAAA,EAC9B,CAAC;AACH;AAEA,SAAS,YAAYA,UAAS,MAAM;AAClC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,WAAW,UAAU,IAAI;AAAA,EAC9C,CAAC;AACH;AAEA,SAAS,UAAUA,UAAS,MAAM;AAChC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,UAAU,CAAC;AAC9B,MAAE,QAAQ,GAAG,CAAC,KAAK,QAAQ,CAAC;AAAA,EAC9B,CAAC;AACH;AAEA,SAAS,eAAeA,UAAS,MAAM;AACrC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,MAAM,aAAa,UAAU;AAAA,EAClD,CAAC;AACH;AAEA,SAAS,UAAUA,UAAS,MAAM;AAChC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,QAAQ,GAAG,CAAC,KAAK,YAAY,CAAC;AAAA,EAClC,CAAC;AACH;AAEA,SAAS,WAAWA,UAAS,MAAM;AACjC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,MAAM,SAAS,WAAW;AAC7C,MAAE,SAAS,GAAG,KAAK,UAAU,EAAE;AAAA,EACjC,CAAC;AACH;AAEA,SAAS,gBAAgBA,UAAS,MAAM;AACtC,QAAM,iBAAiBA,SAAQ,UAAU,KAAK,QAAQ;AACtD,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,MAAM,SAAS,MAAM;AACxC,MAAE,UAAU,GAAG,gBAAgB,CAAC;AAAA,EAClC,CAAC;AACH;AAEA,SAAS,YAAYA,UAAS,MAAM;AAClC,QAAM,gBAAgBA,SAAQ;AAAA,IAC5B,KAAK;AAAA,IAAS;AAAA,IAAG;AAAA,IACjB,CAACA,UAASzC,WAAUyC,SAAQ,SAASzC,MAAK;AAAA,EAC9C;AACE,SAAOyC,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,MAAM,UAAU,MAAM;AACzC,MAAE,UAAU,GAAG,eAAe,CAAC;AAAA,EACjC,CAAC;AACH;AAEA,SAAS,iBAAiBA,UAAS,MAAM;AAIvC,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,KAAK,IAAI,CAAC;AACxB,MAAE,UAAU,GAAG,eAAeA,UAAS,KAAK,OAAO,GAAG,CAAC;AACvD,MAAE,QAAQ,GAAG,CAAC,KAAK,SAAS,CAAC;AAAA,EAE/B,CAAC;AACH;AC5IA,MAAM,iBAAiB,IAAI,YAAY,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM;AAOtE,SAAS,aAAaA,UAAS,QAAQ;AAC5C,QAAM,EAAE,QAAQ,SAAQ,IAAK;AAC7B,QAAM,eAAe,OAAO,IAAI,OAAK,YAAYA,UAAS,CAAC,CAAC;AAC5D,QAAM,qBAAqBA,SAAQ,gBAAgB,YAAY;AAC/D,QAAM,iBAAiB,eAAeA,UAAS,QAAQ;AACvD,SAAOA,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,SAAS,GAAG,CAAE,CAAC,gBAAiB,CAAC;AACnC,MAAE,UAAU,GAAG,oBAAoB,CAAC;AACpC,MAAE,UAAU,GAAG,gBAAgB,CAAC;AAAA,EAElC,CAAC;AACH;AAOA,SAAS,YAAYA,UAASN,QAAO;AACnC,QAAM,EAAE,MAAAiE,OAAM,UAAU,MAAM,SAAQ,IAAKjE;AAC3C,MAAI,EAAE,OAAM,IAAK;AAGjB,MAAI,aAAa;AACjB,MAAI,mBAAmB;AACvB,MAAI,WAAW,KAAK,YAAY;AAC9B,iBAAa,eAAeM,UAAS,IAAI;AAAA,EAC3C,OAAO;AACL,UAAM;AAAA;AAAA,MAAsC,KAAM;AAAA;AAClD,aAAS,KAAK;AACd,uBAAmB,eAAeA,UAAS,IAAI;AAC/C,iBAAa,eAAeA,UAAS,IAAI;AAAA,EAC3C;AAIA,QAAM,gBAAgB,KAAK,YAAY,CAAA,GAAI,IAAI,OAAK,YAAYA,UAAS,CAAC,CAAC;AAC3E,QAAM,uBAAuBA,SAAQ,gBAAgB,YAAY;AACjE,QAAM,iBAAiB,eAAeA,UAAS,QAAQ;AACvD,QAAM,aAAaA,SAAQ,UAAU2D,KAAI;AACzC,SAAO3D,SAAQ,UAAU,GAAG,OAAK;AAC/B,MAAE,UAAU,GAAG,YAAY,CAAC;AAC5B,MAAE,QAAQ,GAAG,CAAC,UAAU,CAAM;AAC9B,MAAE,QAAQ,GAAG,QAAQ,KAAK,IAAI;AAC9B,MAAE,UAAU,GAAG,YAAY,CAAC;AAC5B,MAAE,UAAU,GAAG,kBAAkB,CAAC;AAClC,MAAE,UAAU,GAAG,sBAAsB,CAAC;AACtC,MAAE,UAAU,GAAG,gBAAgB,CAAC;AAAA,EAClC,CAAC;AACH;AChDO,SAAS,YAAYA,UAAS,QAAQ,YAAY,cAAc,UAAU;AAE/E,QAAM,iBAAiB,eAAeA,UAAS,QAAQ;AACvD,QAAM,aAAaA,SAAQ,UAAU,cAAc,IAAI,GAAG,WAAW;AACrE,QAAM,cAAcA,SAAQ,UAAU,YAAY,IAAI,GAAG,WAAW;AACpE,QAAM,eAAe,aAAaA,UAAS,MAAM;AACjD,EAAAA,SAAQ;AAAA,IACNA,SAAQ,UAAU,GAAG,OAAK;AACxB,QAAE,SAAS,GAAG,QAAQ,IAAI,QAAQ,EAAE;AACpC,QAAE,UAAU,GAAG,cAAc,CAAC;AAC9B,QAAE,UAAU,GAAG,aAAa,CAAC;AAC7B,QAAE,UAAU,GAAG,YAAY,CAAC;AAC5B,QAAE,UAAU,GAAG,gBAAgB,CAAC;AAAA,IAClC,CAAC;AAAA,EACL;AACE,QAAM,OAAOA,SAAQ,OAAM;AAG3B,EAAAA,SAAQ,SAAS,CAAC;AAClB,EAAAA,SAAQ,SAAS,EAAE;AAGnB,EAAAA,SAAQ,MAAK;AAGb,EAAAA,SAAQ,KAAK,MAAM,IAAI,WAAW,WAAW,GAAG,IAAI,EAAE,MAAM,CAAC;AAC7D,EAAAA,SAAQ,KAAK,MAAM,KAAK;AAC1B;AAQA,SAAS,YAAYA,UAAS,EAAE,QAAA7B,SAAQ,gBAAgB,WAAU,GAAI;AACpE,EAAA6B,SAAQ,WAAW,UAAU;AAC7B,EAAAA,SAAQ,WAAW,CAAC;AACpB,EAAAA,SAAQ,WAAW,cAAc;AACjC,EAAAA,SAAQ,WAAW7B,OAAM;AACzB,SAAO6B,SAAQ,OAAM;AACvB;AC3CO,SAAS,aAAaA,UAAS,YAAY,cAAc,YAAY,QAAQ;AAClF,EAAAA,SAAQ;AAAA,IACNA,SAAQ,UAAU,GAAG,OAAK;AACxB,QAAE,SAAS,GAAG,QAAQ,IAAI,QAAQ,EAAE;AACpC,QAAE,QAAQ,GAAG,YAAY,cAAc,IAAI;AAC3C,QAAE,UAAU,GAAG,cAAc,CAAC;AAC9B,QAAE,SAAS,GAAG,YAAY,CAAC;AAAA,IAE7B,CAAC;AAAA,EACL;AAEE,QAAM,aAAa;AACnB,QAAM,cAAcA,SAAQ,OAAM;AAClC,QAAM,cAAe,cAAc,aAAa,IAAK;AAGrD,UAAQ,KAAK;AAAA,IACX,QAAQA,SAAQ;AAAA,IAChB,gBAAgB;AAAA,IAChB;AAAA,EACJ,CAAG;AAGD,EAAAA,SAAQ,SAAS,cAAc,UAAU;AAGzC,EAAAA,SAAQ,SAAS,EAAE;AAGnB,EAAAA,SAAQ,MAAK;AAGb,EAAAA,SAAQ,WAAW,cAAc,cAAc,UAAU;AAC3D;AC/CO,MAAM,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAKhB,MAAM,OAAO;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,WAAW;AACb,SAAK,MAAM,IAAI,WAAW,SAAS,CAAC;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACP,WAAO;AAAA,EACT;AACF;AAEO,MAAM,mBAAmB,KAAK;AAAA;AAAA;AAAA;AAAA,EAInC,cAAc;AACZ,UAAK;AACL,SAAK,UAAU,CAAA;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO;AACX,SAAK,QAAQ,KAAK,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACP,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,YAAY,CAAC;AAC1D,UAAMmE,OAAM,IAAI,WAAW,IAAI;AAC/B,aAAS,IAAI,GAAG,MAAM,GAAG,IAAI,KAAK,QAAQ,EAAE,GAAG;AAC7C,MAAAA,KAAI,IAAI,KAAK,CAAC,GAAG,GAAG;AACpB,aAAO,KAAK,CAAC,EAAE;AAAA,IACjB;AACA,WAAOA;AAAA,EACT;AACF;AC1CA,MAAM,SAAS;AACf,MAAM,OAAO;AAUN,SAAS,UAAU1D,OAAM,EAAE,MAAM,SAAS,OAAM,IAAK,IAAI;AAC9D,MAAI,WAAW,UAAU,WAAW,MAAM;AACxC,UAAM,IAAI,MAAM,kCAAkC,MAAM,EAAE;AAAA,EAC5D;AACA,QAAM,EAAE,QAAQ,eAAe,CAAA,GAAI,UAAU,CAAA,GAAI,SAAQ,IAAKA;AAC9D,QAAMT,WAAU,IAAIgE,SAAQ,QAAQ,IAAI,WAAU,CAAE;AACpD,QAAM,OAAO,WAAW;AACxB,QAAM,aAAa,CAAA;AACnB,QAAM,eAAe,CAAA;AAErB,MAAI,MAAM;AACR,IAAAhE,SAAQ,UAAU,KAAK;AAAA,EACzB;AAGA,MAAI,QAAQ;AACV;AAAA,MACEA;AAAA,MACA,cAAc;AAAA,MACd,aAAaA,UAAS,MAAM;AAAA,MAC5B;AAAA,IACN;AAAA,EACE;AAGA,aAAW,QAAQ,cAAc;AAC/B,UAAM,EAAE,MAAAS,MAAI,IAAK;AACjB;AAAA,MACET;AAAA,MACA,cAAc;AAAA,MACd,sBAAsBA,UAAS,IAAI;AAAA,MACnCS,MAAK;AAAA,MACL;AAAA,IACN;AACI,iBAAaT,UAASS,MAAK,OAAO;AAAA,EACpC;AAGA,aAAW,SAAS,SAAS;AAC3B;AAAA,MACET;AAAA,MACA,cAAc;AAAA,MACd,kBAAkBA,UAAS,KAAK;AAAA,MAChC,MAAM;AAAA,MACN;AAAA,IACN;AACI,iBAAaA,UAAS,MAAM,OAAO;AAAA,EACrC;AAGA,EAAAA,SAAQ,UAAU,GAAG;AAErB,MAAI,MAAM;AACR,gBAAYA,UAAS,QAAQ,YAAY,cAAc,QAAQ;AAAA,EACjE;AAEA,SAAOA,SAAQ;AACjB;AAQA,SAAS,aAAaA,UAAS,SAAS;AACtC,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,IAAAA,SAAQ,UAAU,QAAQ,CAAC,CAAC;AAAA,EAC9B;AACF;ACxEO,SAAS,WAAWP,QAAO,SAAS;AAEzC,MAAI,OAAO,YAAY,UAAU;AAC/B,cAAU,EAAE,QAAQ,QAAO;AAAA,EAC7B;AAEA,QAAM2H,WAAU3H,OAAM;AACtB,oBAAkB2H,QAAO;AAEzB,QAAM,EAAE,cAAc,UAAU,0BAA0BA,QAAO;AACjE,QAAM,UAAU,sBAAsBA,QAAO;AAC7C,QAAM,SAAS,eAAe3H,OAAM,QAAQ,KAAK;AACjD,QAAMgB,QAAO,EAAE,QAAQ,cAAc,QAAO;AAC5C,SAAO,UAAUA,OAAM,OAAO,EAAE,OAAM;AACxC;AAEA,SAAS,kBAAkB2G,UAAS;AAClC,QAAM,IAAIA,SAAQ,CAAC,GAAG,KAAK,IAAI,OAAK,EAAE,MAAM;AAC5C,EAAAA,SAAQ,QAAQ,CAAC,EAAE,MAAA3G,YAAW;AAC5B,QAAIA,MAAK,WAAW,EAAE,UAAUA,MAAK,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,CAAC,CAAC,GAAG;AACtE,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAAA,EACF,CAAC;AACH;AAKA,SAAS,kBAAkB;AACzB,MAAI,aAAa;AACjB,QAAM,QAAQ,CAAA;AACd,QAAM,UAAU,CAAA;AAChB,QAAM,UAAU,CAAA;AAChB,QAAM,WAAW,CAAA;AACjB,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA,IAKL,KAAKrC,SAAQ,WAAW;AACtB,YAAM,KAAK,EAAE,QAAAA,SAAQ,UAAS,CAAE;AAAA,IAClC;AAAA;AAAA;AAAA;AAAA,IAIA,OAAO,GAAG;AACR,YAAM,OAAO,EAAE;AACf,YAAMA,UAAW,OAAO,IAAK;AAC7B,cAAQ,KAAK,EAAE,QAAQ,YAAY,QAAAA,QAAM,CAAE;AAC3C,oBAAcA;AACd,cAAQ,KAAK,IAAI,WAAW,EAAE,QAAQ,EAAE,YAAY,IAAI,CAAC;AAAA,IAC3D;AAAA;AAAA;AAAA;AAAA,IAIA,SAASA,SAAQ;AACf,eAAS,KAAKA,OAAM;AAAA,IACtB;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,SAAS,MAAM,OAAO;AAEpB,WAAK,SAAS,QAAQ,CAACsB,QAAO,UAAU;AACtC,cAAMA,OAAM,MAAM,MAAM,SAAS,KAAK,GAAG,IAAI;AAAA,MAC/C,CAAC;AAAA,IACH;AAAA;AAAA;AAAA;AAAA,IAIA,OAAO;AACL,aAAO,EAAE,YAAY,OAAO,SAAS,UAAU,QAAO;AAAA,IACxD;AAAA,EACJ;AACA;AAYA,SAAS,0BAA0B0H,UAAS;AAC1C,QAAM,eAAe,CAAA;AACrB,QAAM,UAAU,oBAAI;AACpB,QAAM,QAAQ,oBAAI;AAClB,MAAI,KAAK;AAGT,QAAM,UAAU,sBAAoB;AAClC,QAAI,CAAC,QAAQ,IAAI,gBAAgB,GAAG;AAClC,cAAQ,IAAI,kBAAkB,EAAE,EAAE;AAClC,eAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK,QAAQ,EAAE,GAAG;AACrD,qBAAa,KAAK;AAAA,UAChB;AAAA,UACA,SAAS,IAAI;AAAA,UACb,MAAM,oBAAoB,CAAC,gBAAgB,GAAG,CAAC;AAAA,QACzD,CAAS;AAAA,MACH;AACA,YAAM,IAAI,iBAAiB,MAAM,EAAE;AAAA,IACrC,OAAO;AACL,YAAM,IAAI,iBAAiB,MAAM,QAAQ,IAAI,gBAAgB,CAAC;AAAA,IAChE;AAAA,EACF;AAKA,EAAAA,SAAQ,QAAQ,SAAO,kBAAkB,IAAI,KAAK,CAAC,GAAG,OAAO,CAAC;AAE9D,SAAO,EAAE,cAAc,MAAK;AAC9B;AAOA,SAAS,kBAAkB,OAAO,SAAS;AACzC,MAAI,OAAO,KAAK,WAAW,KAAK,YAAY;AAE1C,UAAMrF,cAAa,MAAM;AACzB,YAAQA,WAAU;AAClB,sBAAkBA,YAAW,KAAK,CAAC,GAAG,OAAO;AAAA,EAC/C;AACA,SAAO,UAAU,QAAQ,WAAS,kBAAkB,OAAO,OAAO,CAAC;AACrE;AAWA,SAAS,eAAe,QAAQ,OAAO;AAErC,MAAI,CAAC,MAAM,KAAM,QAAO;AAExB,QAAMiJ,SAAQ,UAAQ;AACpB,QAAI,KAAK,WAAW,KAAK,YAAY;AACnC,WAAK,KAAK,MAAM,IAAI,KAAK,UAAU;AACnC,oBAAc,IAAI;AAAA,IACpB;AACA,QAAI,KAAK,UAAU;AACjB,OAAC,KAAK,WAAW,KAAK,SAAS,MAAK,GAAI,QAAQ,WAAW;AAAA,IAC7D;AAAA,EACF;AAGA,QAAM,cAAc,CAACtL,QAAO,OAAOsB,WAAU;AAC3C,UAAM,OAAO,EAAE,GAAGtB,OAAM,KAAI;AAC5B,IAAAsB,OAAM,KAAK,IAAI,EAAE,GAAGtB,QAAO,KAAI;AAC/B,IAAAsL,OAAM,IAAI;AAAA,EACZ;AAGA,QAAM,gBAAgB,CAAC,eAAe;AACpC,UAAM,OAAO,EAAE,GAAG,WAAW,WAAU;AACvC,eAAW,aAAa;AACxB,IAAAA,OAAM,IAAI;AAAA,EACZ;AAEA,WAAS,EAAE,GAAG,QAAQ,QAAQ,OAAO,OAAO,QAAO;AACnD,SAAO,OAAO,QAAQ,WAAW;AACjC,SAAO;AACT;AAOA,SAAS,sBAAsB5D,UAAS;AACtC,UAAQA,SAAQ,CAAC,GAAG,QAAQ,CAAA,GACzB,IAAI,CAAC,GAAG,UAAU,oBAAoBA,UAAS,KAAK,CAAC;AAC1D;AAQA,SAAS,oBAAoBA,UAAS,aAAa,GAAG;AACpD,QAAM,MAAM,gBAAe;AAC3B,EAAAA,SAAQ,QAAQ,YAAU;AACxB,UAAM,OAAO,MAAM,OAAO,KAAK,UAAU,GAAG,GAAG;AAAA,EACjD,CAAC;AACD,SAAO,IAAI,KAAI;AACjB;AAQA,SAAS,MAAM,MAAM,OAAO,KAAK;AAC/B,QAAM,EAAE,OAAM,IAAK;AAGnB,MAAI,KAAK,MAAM,QAAQ,MAAM,SAAS;AAGtC,MAAI,WAAW,KAAK,KAAM;AAE1B,UAAQ,QAAM;AAAA;AAAA;AAAA,IAGZ,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,UAAI,OAAO,MAAM,QAAQ;AACzB,UAAI,OAAO,MAAM,MAAM;AACvB;AAAA;AAAA,IAGF,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,UAAI,OAAO,MAAM,QAAQ;AACzB,UAAI,OAAO,MAAM,OAAO;AACxB,UAAI,OAAO,MAAM,MAAM;AACvB;AAAA;AAAA,IAGF,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,UAAI,OAAO,MAAM,QAAQ;AACzB,UAAI,OAAO,MAAM,MAAM;AAEvB,UAAI,SAAS,MAAM,KAAK,MAAM;AAE9B,YAAM,KAAK,QAAQ,OAAK,IAAI,OAAO,CAAC,CAAC;AACrC;AAAA;AAAA,IAGF,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,UAAI,OAAO,MAAM,QAAQ;AACzB,UAAI,OAAO,MAAM,OAAO;AACxB,UAAI,SAAS,MAAM,KAAK;AACxB;AAAA;AAAA,IAGF,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,UAAI,OAAO,MAAM,QAAQ;AACzB,UAAI,OAAO,MAAM,OAAO;AACxB,UAAI,OAAO,MAAM,KAAK;AACtB,UAAI,SAAS,MAAM,KAAK;AACxB;AAAA;AAAA,IAGF,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,UAAI,OAAO,MAAM,QAAQ;AACzB,UAAI,SAAS,MAAM,KAAK;AACxB;AAAA;AAAA,IAGF,KAAK,KAAK;AACR,UAAI,SAAS,MAAM,KAAK;AACxB;AAAA;AAAA,IAGF,KAAK,KAAK,OAAO;AAEf,UAAI,OAAO,MAAM,OAAO;AACxB,UAAI,KAAK,SAAS,UAAU,OAAO;AACjC,YAAI,OAAO,MAAM,OAAO;AAAA,MAC1B;AACA,UAAI,SAAS,MAAM,KAAK;AACxB;AAAA,IACF;AAAA;AAAA,IAGA;AACE,YAAM,IAAI,MAAM,gBAAgB,MAAM,CAAC;AAAA,EAC7C;AACA;ACnTO,SAAS,OAAOwF,YAAW;AAChC,SAAO,IAAI1M,QAAO0M,UAAS;AAC7B;AAKO,MAAM1M,QAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKlB,YAAY0M,aAAY,YAAY;AAClC,SAAK,MAAM,IAAIA,WAAU,GAAG;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,MAAM;AACV,WAAO,MAAM,KAAK,KAAK,IAAI;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,OAAO;AACV,QAAI,SAAS,KAAK,IAAI,QAAQ;AAC5B,WAAK,MAAM,KAAK,KAAK,KAAK,KAAK;AAAA,IACjC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAO;AACT,WAAO,KAAK,IAAI,KAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAIrP,QAAO,OAAO;AAChB,SAAK,KAAK,KAAK;AACf,SAAK,IAAI,KAAK,IAAIA;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAO,OAAO;AAClB,SAAK,KAAK,QAAQ,MAAM,MAAM;AACJ,IAAC,KAAK,IAAK,IAAI,OAAO,KAAK;AAAA,EACvD;AACF;AAMO,SAAS,SAAS;AACvB,SAAO,IAAI,OAAM;AACnB;AAKO,MAAM,eAAe2C,QAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjC,IAAI,OAAO;AACT,UAAM,IAAI,SAAS;AACnB,SAAK,KAAK,CAAC;AACe,IAAC,KAAK,IAAK,CAAC,KAAM,KAAM,QAAQ;AAAA,EAC5D;AACF;ACrFO,MAAM,aAAa;AAAA,EACxB,YAAY,MAAM,KAAK;AACrB,SAAK,OAAO;AACZ,SAAK,MAAM;AACX,SAAK,aAAa,IAAI,UAAU,IAAI;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO;AACL,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI3C,QAAO,OAAO;AAChB,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO;AACL,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ;AACN,UAAM,IAAI,IAAI,KAAK,WAAW,KAAK,KAAI,CAAE;AACzC,SAAK,KAAI;AACT,WAAO;AAAA,EACT;AACF;AC7CO,MAAM,wBAAwB,aAAa;AAAA,EAChD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AAAA,EACjB;AAAA,EAEA,OAAO;AACL,SAAK,YAAY;AACjB,SAAK,WAAW,OAAM;AACtB,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAIA,QAAO,OAAO;AAChB,SAAK,QAAQ;AACb,UAAM4F,WAAU5F,UAAS;AACzB,QAAI4F,UAAS;AACX,WAAK,SAAS,IAAI,KAAK;AAAA,IACzB,OAAO;AACL,WAAK;AAAA,IACP;AACA,WAAOA;AAAA,EACT;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,OAAO,WAAW,MAAM,SAAQ,IAAK;AAC7C,WAAO;AAAA,MACL,QAAQ,QAAQ;AAAA,MAChB;AAAA,MACA;AAAA,MACA,UAAU,YACN,SAAS,OAAO,SAAS,KAAK,CAAC,IAC/B,IAAI,WAAW,CAAC;AAAA,IAC1B;AAAA,EACE;AACF;AChCO,SAAS,oBAAoB;AAClC,QAAM,QAAQ,oBAAI;AAClB,QAAM,QAAQ,oBAAI;AAClB,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQL,IAAI,MAAM,KAAK;AAIb,YAAM,KAAK,KAAK;AAChB,UAAI,MAAM,KAAK,MAAM,IAAI,EAAE,GAAG;AAC5B,eAAO,MAAM,IAAI,EAAE;AAAA,MACrB,OAAO;AACL,cAAM,OAAO,iBAAiB,MAAM,GAAG;AACvC,YAAI,MAAM,EAAG,OAAM,IAAI,IAAI,IAAI;AAC/B,cAAM,IAAI,IAAI;AACd,eAAO;AAAA,MACT;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,OAAO,SAAS;AACd,YAAM,QAAQ,UAAQ,KAAK,OAAO,OAAO,CAAC;AAAA,IAC5C;AAAA,EACJ;AACA;AASO,SAAS,iBAAiB,MAAM,KAAK;AAC1C,QAAMd,QAAO,uBAAO,OAAO,IAAI;AAC/B,QAAMF,UAAS,IAAI,QAAQ,KAAK,UAAU;AAC1C,QAAM,UAAU,CAAA;AAEhB,EAAAA,QAAO,KAAI;AACX,MAAI,QAAQ;AAEZ,SAAO;AAAA,IACL;AAAA,IACA,QAAAA;AAAA,IAEA,IAAI,OAAO;AACT,cAAQ,KAAK,KAAK;AAClB,aAAO;AAAA,IACT;AAAA,IAEA,IAAI5E,QAAO;AACT,YAAM,IAAI,UAAUA,MAAK;AACzB,UAAI,IAAI8E,MAAK,CAAC;AACd,UAAI,MAAM,QAAW;AACnB,QAAAA,MAAK,CAAC,IAAI,IAAI,EAAE;AAChB,QAAAF,QAAO,IAAI5E,QAAO,CAAC;AAAA,MACrB;AACA,aAAO;AAAA,IACT;AAAA,IAEA,OAAO,SAAS;AACd,YAAM,YAAY,KAAK;AACvB,YAAM,QAAQ,KAAK,UAAU,WAAW,OAAO,GAAG4E,QAAO,MAAM;AAC/D,YAAMJ,cAAa,IAAI,OAAO,CAAC,KAAK,CAAC;AACrC,cAAQ,QAAQ,CAAAoM,WAASA,OAAM,cAAcpM,WAAU,CAAC;AAAA,IAC1D;AAAA,EACJ;AACA;AAKO,MAAM,0BAA0B,gBAAgB;AAAA,EACrD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,OAAO,IAAI,WAAW,IAAI;AAAA,EACjC;AAAA,EAEA,OAAO;AACL,SAAK,SAAS,OAAO,KAAK,KAAK,QAAQ,MAAM;AAC7C,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAIxE,QAAO,OAAO;AAChB,QAAI,MAAM,IAAIA,QAAO,KAAK,GAAG;AAC3B,WAAK,OAAO,IAAI,KAAK,KAAK,IAAIA,MAAK,GAAG,KAAK;AAAA,IAC7C;AAAA,EACF;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQ,KAAK,OAAO,MAAM,KAAK,QAAQ,CAAC;AAAA,IAC9C;AAAA,EACE;AAAA,EAEA,QAAQ;AAGN,WAAO,KAAK,KAAK,IAAI,MAAM,MAAK,CAAE;AAAA,EACpC;AACF;AChHO,SAAS6Q,YAAUpD,QAAO;AAC/B,QAAM,UAAU,SAAQ;AACxB,EAAAA,OAAM,CAAAzN,WAAS,QAAQ,IAAIA,MAAK,CAAC;AACjC,SAAO,QAAQ,KAAI;AACrB;AAEA,SAAS,WAAW;AAClB,MAAIa,UAAS;AACb,MAAI,YAAY;AAChB,MAAI,YAAY;AAChB,MAAI,cAAc;AAClB,MAAI,WAAW;AACf,MAAI,cAAc;AAClB,MAAI,YAAY;AAChB,MAAI,WAAW;AACf,MAAI,cAAc;AAClB,MAAI,aAAa;AACjB,MAAI,cAAc;AAClB,MAAIqK,OAAM;AACV,MAAIf,OAAM;AACV,MAAI,YAAY;AAChB,MAAI,YAAY;AAChB,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,iBAAiB,CAAA;AAErB,SAAO;AAAA,IACL,IAAInK,QAAO;AACT,MAAAa;AACA,UAAIb,UAAS,MAAM;AACjB;AACA;AAAA,MACF;AACA,cAAQ,OAAOA,QAAK;AAAA,QAClB,KAAK;AACH;AACA;AAAA,QACF,KAAK;AACH;AACA,cAAIA,SAAQkL,KAAK,CAAAA,OAAMlL;AACvB,cAAIA,SAAQmK,KAAK,CAAAA,OAAMnK;AACvB,cAAI,OAAO,UAAUA,MAAK,EAAG;AAC7B;AAAA,QACF,KAAK;AACH;AACA,cAAI,cAAc,QAAW;AAC3B,wBAAY,YAAYA;AAAA,UAC1B,OAAO;AACL,gBAAIA,SAAQ,UAAW,aAAYA;AACnC,gBAAIA,SAAQ,UAAW,aAAYA;AAAA,UACrC;AACA;AAAA,QACF,KAAK;AACH;AACA;AAAA,QACF,KAAK;AACH,cAAIA,kBAAiB,MAAM;AACzB;AAEA,gBAAK,CAACA,SAAQ,UAAW,EAAG;AAAA,UAC9B,WAAW,QAAQA,MAAK,GAAG;AACzB;AACA,kBAAM,MAAMA,OAAM;AAClB,gBAAI,MAAM,UAAW,aAAY;AACjC,gBAAI,MAAM,UAAW,aAAY;AACjC,6BAAiB,SAAQ;AACzB,YAAAA,OAAM,QAAQ,aAAa,GAAG;AAAA,UAChC,OAAO;AACL;AACA,uBAAWuE,QAAOvE,QAAO;AACvB,oBAAM,gBAAgB,eAAeuE,IAAG,MAClC,eAAeA,IAAG,IAAI;AAC5B,4BAAc,IAAIvE,OAAMuE,IAAG,CAAC;AAAA,YAC9B;AAAA,UACF;AAAA,MACV;AAAA,IACI;AAAA,IACA,OAAO;AACL,YAAM,QAAQ1D,UAAS;AACvB,aAAO,UAAU,IAAI,SAAQ,IACzB,aAAa,QAAQ,QAAQqK,MAAKf,IAAG,IACrC,gBAAgB,QAAQ,QAAO,IAC/B,gBAAgB,QAAQ,WAAW,WAAW,SAAS,IACvD,cAAc,QAAQ,KAAI,IAC1B,aAAa,QAAQ,QAAO,IAC5B,cAAc,QAAQ,UAAS,IAC/B,gBAAgB,QAAQ3F,aAAW,KAAI,CAAE,IACzC,eAAe,QAAQ,UAAU,aAAa,KAAI,GAAI,WAAW,SAAS,IAC1E,gBAAgB,QAAQ;AAAA,QACtB,OAAO,QAAQ,cAAc,EAAE,IAAI,OAAK,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,KAAI,CAAE,CAAC;AAAA,MAC5E,IACU,UAAS;AAAA,IACf;AAAA,EACJ;AACA;AASA,SAAS,UAAU,MAAM,WAAW,WAAW;AAC7C,SAAO,cAAc,YACjB,cAAc,MAAM,SAAS,IAC7B,KAAK,IAAI;AACf;AAOA,SAAS,QAAQ0G,MAAKf,MAAK;AACzB,QAAM,IAAI,KAAK,IAAI,KAAK,IAAIe,IAAG,IAAI,GAAGf,IAAG;AACzC,SAAO,IAAK,KAAK,IAAK,KAAI,IACtB,IAAK,KAAK,KAAM,MAAK,IACrB,IAAK,KAAK,KAAM,MAAK,IACrB,QAAO;AACb;AAOA,SAAS,WAAWe,MAAKf,MAAK;AAC5B,QAAM,IAAI,CAACe,OAAMf,OAAM,CAACe,OAAM,KAAKf;AACnC,MAAI,KAAK,KAAK,IAAI;AAChB,UAAM,IAAI,MAAM,2BAA2B,CAAC,EAAE;AAAA,EAChD;AACA,SAAO,MAAK;AACd;AAKA,SAAS,YAAY;AACnB,QAAM,IAAI,MAAM,mDAAmD;AACrE;AClJO,MAAM,sBAAsB,gBAAgB;AAAA,EACjD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,WAAW,SAAS,KAAK,OAAO;AAAA,EACvC;AAAA,EAEA,OAAO;AACL,SAAK,UAAU,OAAO,KAAK,KAAK,OAAO;AACvC,SAAK,SAAS,OAAM;AACpB,SAAK,MAAM;AACX,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAInK,QAAO,OAAO;AAChB,UAAM,EAAE,SAAS,QAAA4E,SAAQ,UAAAkM,UAAQ,IAAK;AACtC,QAAI,MAAM,IAAI9Q,QAAO,KAAK,GAAG;AAC3B,MAAA4E,QAAO,MAAM5E,QAAO,KAAK,GAAG;AAC5B,WAAK,OAAOA,OAAM;AAAA,IACpB;AACA,YAAQ,IAAI8Q,UAAS,KAAK,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC3C;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,SAAS,KAAK,QAAQ,MAAM,KAAK,QAAQ,CAAC;AAAA,MAC1C,QAAQ,KAAK,OAAO,MAAM,KAAK,MAAM,CAAC;AAAA,IAC5C;AAAA,EACE;AACF;AC9BO,MAAM,oBAAoB,gBAAgB;AAAA,EAC/C,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AAAA,EACjB;AAAA,EAEA,OAAO;AACL,SAAK,SAAS,OAAM;AACpB,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAI9Q,QAAO,OAAO;AAChB,UAAM,IAAIA,QAAO,KAAK;AACtB,QAAIA,OAAO,MAAK,OAAO,IAAI,KAAK;AAAA,EAClC;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQ,KAAK,OAAO,OAAO,KAAK,SAAS,KAAK,CAAC;AAAA,IACrD;AAAA,EACE;AACF;ACpBO,MAAM,uBAAuB,gBAAgB;AAAA,EAClD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,QAAQ,MAAM,KAAK;AACxB,SAAK,SAAS,KAAK,YAAY;AAAA,EACjC;AAAA,EAEA,OAAO;AACL,SAAK,SAAS,OAAO,KAAK,KAAK,MAAM;AACrC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAIA,QAAO,OAAO;AAChB,UAAM,EAAE,OAAO,QAAQ,QAAA4E,QAAM,IAAK;AAClC,QAAI,MAAM,IAAI5E,QAAO,KAAK,GAAG;AAC3B,MAAA4E,QAAO,MAAM,QAAQ,KAAK,MAAM;AAEhC,gBAAU5E,QAAO4E,QAAO,KAAK,QAAQ,QAAQ,QAAQ,KAAK;AAAA,IAC5D;AAAA,EACF;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,OAAO,QAAQ,QAAAA,QAAM,IAAK;AAClC,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQA,QAAO,OAAO,QAAQ,KAAK,MAAM;AAAA,IAC/C;AAAA,EACE;AACF;AC7BO,MAAM,+BAA+B,gBAAgB;AAAA,EAC1D,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,SAAS,KAAK;AAAA,EACrB;AAAA,EAEA,OAAO;AACL,SAAK,SAAS,OAAM;AACpB,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAI5E,QAAO,OAAO;AAChB,QAAI,MAAM,IAAIA,QAAO,KAAK,GAAG;AAC3B,WAAK,OAAO,MAAMA,QAAO,QAAQ,KAAK,MAAM;AAAA,IAC9C;AAAA,EACF;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,QAAQ,QAAA4E,QAAM,IAAK;AAC3B,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQA,QAAO,MAAM,UAAU,KAAK,QAAQ,EAAE;AAAA,IACpD;AAAA,EACE;AACF;ACzBO,MAAM,6BAA6B,gBAAgB;AAAA,EACxD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,QAAQ,IAAI,QAAQ,KAAK,KAAK,SAAS,CAAC,EAAE,IAAI;AACnD,SAAK,SAAS,KAAK;AAAA,EACrB;AAAA,EAEA,OAAO;AACL,SAAK,MAAM,KAAI;AACf,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAI5E,QAAO,OAAO;AAChB,UAAM,EAAE,OAAO,OAAM,IAAK;AAC1B,UAAM,OAAO,QAAQ;AACrB,QAAI,MAAM,IAAIA,QAAO,KAAK,GAAG;AAC3B,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,cAAM,IAAIA,OAAM,CAAC,GAAG,OAAO,CAAC;AAAA,MAC9B;AAAA,IACF,OAAO;AACL,YAAM,QAAQ,OAAO;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,MAAK,IAAK;AAClB,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,UAAU,CAAE,MAAM,MAAK,CAAE;AAAA,IAC/B;AAAA,EACE;AACF;AC7BO,MAAM,+BAA+B,gBAAgB;AAAA,EAC1D,OAAO;AACL,SAAK,SAAS,OAAO,KAAK,KAAK,MAAM;AACrC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAIA,QAAO,OAAO;AAChB,QAAI,MAAM,IAAIA,QAAO,KAAK,GAAG;AAC3B,YAAM,IAAI,SAAS;AACnB,WAAK,OAAO,IAAIA,OAAM,CAAC,GAAG,CAAC;AAC3B,WAAK,OAAO,IAAIA,OAAM,CAAC,GAAG,IAAI,CAAC;AAAA,IACjC;AAAA,EACF;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQ,KAAK,OAAO,MAAO,KAAK,QAAQ,KAAM,CAAC;AAAA,IACrD;AAAA,EACE;AACF;AAKO,MAAM,oCAAoC,gBAAgB;AAAA,EAC/D,OAAO;AACL,SAAK,SAAS,OAAM;AACpB,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAIA,QAAO,OAAO;AAChB,QAAI,MAAM,IAAIA,QAAO,KAAK,GAAG;AAC3B,WAAK,OAAO,MAAM,oBAAoBA,MAAK,GAAG,SAAS,CAAC;AAAA,IAC1D;AAAA,EACF;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQ,KAAK,OAAO,MAAO,KAAK,QAAQ,KAAM,CAAC;AAAA,IACrD;AAAA,EACE;AACF;AC3CO,MAAM,4BAA4B,gBAAgB;AAAA,EACvD,YAAY,MAAM,KAAK,OAAO;AAC5B,UAAM,MAAM,GAAG;AACf,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,OAAO;AACL,SAAK,MAAM,KAAI;AACf,UAAM,aAAa,KAAK,KAAK;AAC7B,SAAK,UAAU,OAAO,UAAU;AAChC,SAAK,WAAW,SAAS,UAAU;AACnC,SAAK,MAAM;AACX,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,SAAS,KAAK,QAAQ,MAAM,KAAK,QAAQ,CAAC;AAAA,MAC1C,UAAU,CAAE,KAAK,MAAM,MAAK,CAAE;AAAA,IACpC;AAAA,EACE;AACF;AAKO,MAAM,oBAAoB,oBAAoB;AAAA,EACnD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,KAAK,IAAI,QAAQ,KAAK,SAAS,CAAC,EAAE,IAAI,CAAC;AAAA,EACrD;AAAA,EAEA,IAAIA,QAAO,OAAO;AAChB,UAAM,EAAE,OAAO,SAAS,UAAA8Q,UAAQ,IAAK;AACrC,QAAI,MAAM,IAAI9Q,QAAO,KAAK,GAAG;AAC3B,MAAAA,OAAM,QAAQ,OAAK,MAAM,IAAI,GAAG,KAAK,KAAK,CAAC;AAAA,IAC7C;AACA,YAAQ,IAAI8Q,UAAS,KAAK,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC3C;AACF;ACzCO,MAAM,8BAA8B,gBAAgB;AAAA,EACzD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,WAAW,KAAK,SAAS,IAAI,OAAK,IAAI,QAAQ,EAAE,IAAI,CAAC;AAAA,EAC5D;AAAA,EAEA,OAAO;AACL,SAAK,SAAS,QAAQ,OAAK,EAAE,KAAI,CAAE;AACnC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,SAAQ,IAAK;AACrB,aAAS,QAAQ,OAAK,EAAE,QAAQ,KAAK,KAAK;AAC1C,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,UAAU,SAAS,IAAI,OAAK,EAAE,MAAK,CAAE;AAAA,IAC3C;AAAA,EACE;AACF;AAKO,MAAM,sBAAsB,sBAAsB;AAAA,EACvD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,UAAU,KAAK,SAAS,IAAI,CAAC,OAAO,MAAM;AAC7C,YAAM1K,QAAO,KAAK,SAAS,CAAC,EAAE;AAC9B,aAAO,CAACpG,QAAO,UAAU,MAAM,IAAIA,SAAQoG,KAAI,GAAG,KAAK;AAAA,IACzD,CAAC;AAAA,EACH;AAAA,EAEA,IAAIpG,QAAO,OAAO;AAChB,UAAM,IAAIA,QAAO,KAAK;AACtB,UAAM,UAAU,KAAK;AACrB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,cAAQ,CAAC,EAAEA,QAAO,KAAK;AAAA,IACzB;AAAA,EACF;AACF;ACvCO,MAAM,mBAAmB,oBAAoB;AAAA,EAClD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,KAAK,IAAI,iBAAiB,KAAK,SAAS,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,EACnE;AAAA,EAEA,IAAIA,QAAO,OAAO;AAChB,UAAM,EAAE,OAAO,SAAS,UAAA8Q,UAAQ,IAAK;AACrC,QAAI,MAAM,IAAI9Q,QAAO,KAAK,GAAG;AAC3B,iBAAW,gBAAgBA,QAAO;AAChC,cAAM,IAAI,cAAc,KAAK,KAAK;AAAA,MACpC;AAAA,IACF;AACA,YAAQ,IAAI8Q,UAAS,KAAK,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC3C;AACF;AAKA,MAAM,yBAAyB,sBAAsB;AAAA,EACnD,IAAI9Q,QAAO,OAAO;AAChB,UAAM,IAAIA,QAAO,KAAK;AACtB,UAAM,CAACuE,MAAK,GAAG,IAAI,KAAK;AACxB,IAAAA,KAAI,IAAIvE,OAAM,CAAC,GAAG,KAAK;AACvB,QAAI,IAAIA,OAAM,CAAC,GAAG,KAAK;AAAA,EACzB;AACF;AC7BA,MAAM,WAAW,CAAA;AAKV,MAAM,6BAA6B,aAAa;AAAA,EACrD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,WAAW,KAAK,SAAS,IAAI,OAAK,IAAI,QAAQ,EAAE,IAAI,CAAC;AAAA,EAC5D;AAAA,EAEA,OAAO;AACL,SAAK,MAAM;AACX,SAAK,MAAM;AACX,SAAK,QAAQ;AACb,SAAK,SAAS,QAAQ,OAAK,EAAE,KAAI,CAAE;AACnC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,OAAO;AACL,UAAM,CAAC,MAAM,IAAI,IAAI,KAAK;AAC1B,SAAK,IAAI,KAAK,QAAQ,GAAG,KAAK,GAAG;AACjC,SAAK,IAAI,KAAK,OAAO,KAAK,KAAK;AAAA,EACjC;AAAA,EAEA,IAAIA,QAAO,OAAO;AAEhB,QAAIA,WAAU,KAAK,OAAO;AAExB,YAAMuE,OAAM,UAAUvE,MAAK;AAC3B,UAAIuE,SAAQ,KAAK,KAAK;AAEpB,YAAI,KAAK,IAAK,MAAK,KAAI;AACvB,aAAK,MAAMA;AACX,aAAK,QAAQvE;AAAA,MACf;AAAA,IACF;AACA,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,OAAO;AACL,SAAK,KAAI;AACT,UAAM,EAAE,UAAU,OAAO,KAAI,IAAK;AAClC,WAAO;AAAA,MACL,QAAQ,QAAQ;AAAA,MAChB,WAAW;AAAA,MACX;AAAA,MACA,UAAU,SAAS,IAAI,OAAK,EAAE,MAAK,CAAE;AAAA,IAC3C;AAAA,EACE;AACF;AC9CO,MAAM,6BAA6B,aAAa;AAAA,EACrD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,WAAW,KAAK,SAAS,IAAI,OAAK,IAAI,QAAQ,EAAE,IAAI,CAAC;AAC1D,SAAK,UAAU,KAAK;AACpB,SAAK,SAAS,KAAK;AAAA,EACrB;AAAA,EAEA,OAAO;AACL,SAAK,YAAY;AACjB,SAAK,UAAU,OAAO,SAAS;AAC/B,SAAK,SAAS,QAAQ,OAAK,EAAE,KAAI,CAAE;AACnC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,IAAIA,QAAO,OAAO;AAChB,UAAM,EAAE,UAAU,QAAA+Q,SAAQ,SAAS,QAAO,IAAK;AAC/C,SAAK,QAAQ;AACb,UAAM,SAASA,QAAO/Q,QAAO,KAAK;AAClC,UAAM,QAAQ,SAAS,QAAQ,MAAM,CAAC;AACtC,YAAQ,IAAI,QAAQ,KAAK;AACzB,QAAIA,UAAS,KAAM,GAAE,KAAK;AAE1B,SAAK,OAAOA,QAAO,OAAO,KAAK;AAAA,EACjC;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,UAAU,WAAW,MAAM,QAAO,IAAK;AAC/C,UAAMa,UAAS,KAAK,QAAQ;AAC5B,WAAO;AAAA,MACL,QAAAA;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,QAAQ,MAAMA,OAAM;AAAA,MAC7B,UAAU,SAAS,IAAI,OAAK,EAAE,MAAK,CAAE;AAAA,IAC3C;AAAA,EACE;AACF;AAKO,MAAM,2BAA2B,qBAAqB;AAAA,EAC3D,OAAOb,QAAO,OAAO,OAAO;AAG1B,UAAM,IAAIA,QAAO,KAAK;AACtB,SAAK,SAAS,QAAQ,OAAK;AAAE,UAAI,MAAM,MAAO,GAAE,IAAI,MAAM,KAAK;AAAA,IAAE,CAAC;AAAA,EACpE;AACF;AAKO,MAAM,0BAA0B,qBAAqB;AAAA,EAC1D,OAAO;AACL,SAAK,UAAU,OAAO,KAAK,KAAK,OAAO;AACvC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA,EAEA,OAAOA,QAAO,OAAO,OAAO;AAC1B,UAAMY,UAAS,MAAM,QAAQ;AAC7B,UAAM,IAAIZ,QAAOY,OAAM;AACvB,SAAK,QAAQ,IAAIA,SAAQ,KAAK;AAAA,EAChC;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,SAAS,KAAK,QAAQ,MAAM,KAAK,QAAQ,CAAC;AAAA,IAChD;AAAA,EACE;AACF;ACzEO,MAAM,oBAAoB,cAAc;AAAA,EAC7C,IAAIZ,QAAO,OAAO;AAChB,UAAM,IAAIA,UAAS,WAAWA,MAAK,GAAG,KAAK;AAAA,EAC7C;AACF;ACHO,MAAM,sBAAsB,gBAAgB;AAAA,EACjD,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AACf,SAAK,SAAS,OAAO,KAAK,MAAM;AAAA,EAClC;AAAA,EAEA,OAAO;AACL,SAAK,SAAS,OAAO,KAAK,KAAK,MAAM;AACrC,WAAO,MAAM,KAAI;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAIA,QAAO,OAAO;AAChB,QAAI,MAAM,IAAIA,QAAO,KAAK,GAAG;AAC3B,WAAK,OAAO,IAAIA,QAAO,KAAK;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,OAAO;AACL,WAAO;AAAA,MACL,GAAG,MAAM,KAAI;AAAA,MACb,QAAQ,KAAK,OAAO,MAAM,KAAK,QAAQ,CAAC;AAAA,IAC9C;AAAA,EACE;AACF;AAKO,MAAM,qBAAqB,cAAc;AAAA,EAC9C,IAAIA,QAAO,OAAO;AAChB,UAAM,IAAIA,UAAS,OAAOA,SAAQ,SAASA,MAAK,GAAG,KAAK;AAAA,EAC1D;AACF;AAMO,MAAM,yBAAyB,cAAc;AAAA,EAClD,YAAY,MAAM,KAAK,WAAW;AAChC,UAAM,MAAM,GAAG;AACf,SAAK,YAAY;AAAA,EACnB;AAAA,EACA,IAAIA,QAAO,OAAO;AAChB,UAAM,IAAIA,UAAS,OAAOA,SAAQ,KAAK,UAAUA,MAAK,GAAG,KAAK;AAAA,EAChE;AACF;AC5BO,SAAS,eACd,UAAU,CAAA,GACV,eAAe,kBAAiB,GAChC;AACA,SAAO;AAAA,IACL,WAAW,UAAQ,UAAU,MAAM,OAAO;AAAA,IAC1C,QAAQ,MAAM;AAAE,aAAO,QAAQ,MAAM,IAAI;AAAA,IAAG;AAAA,IAC5C,WAAW,MAAM;AAAE,aAAO,aAAa,IAAI,MAAM,IAAI;AAAA,IAAG;AAAA,IACxD,QAAQ,MAAM,aAAa,OAAO,OAAO;AAAA,EAC7C;AACA;AAQO,SAAS,QAAQ,MAAM,MAAM,kBAAkB;AACpD,QAAM,EAAE,OAAM,IAAK;AACnB,UAAQ,QAAM;AAAA,IACZ,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,iBAAiB,KAAK,MAAM,IAC/B,IAAI,aAAa,MAAM,GAAG,IAC1B,IAAI,cAAc,MAAM,GAAG;AAAA,IACjC,KAAK,KAAK;AACR,aAAO,KAAK,YACR,IAAI,cAAc,MAAM,GAAG,IAC3B,IAAI,iBAAiB,MAAM,KAAK,SAAS;AAAA,IAC/C,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,cAAc,MAAM,GAAG;AAAA,IACpC,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,YAAY,MAAM,GAAG;AAAA,IAClC,KAAK,KAAK;AACR,aAAO,IAAI,YAAY,MAAM,GAAG;AAAA,IAClC,KAAK,KAAK;AACR,aAAO,KAAK,aAAa,KACrB,IAAI,iBAAiB,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC,IACvD,IAAI,eAAe,MAAM,GAAG;AAAA,IAClC,KAAK,KAAK;AACR,aAAO,IAAI,iBAAiB,MAAM,KAAK,KAAK,OAAO,WAAW,SAAS;AAAA,IACzE,KAAK,KAAK;AACR,aAAO,IAAI,iBAAiB,MAAM,KAAK,YAAY,KAAK,IAAI,CAAC;AAAA,IAC/D,KAAK,KAAK;AACR,cAAQ,KAAK,MAAI;AAAA,QACf,KAAK,aAAa;AAChB,iBAAO,IAAI,uBAAuB,MAAM,GAAG;AAAA,QAC7C,KAAK,aAAa;AAChB,iBAAO,IAAI,4BAA4B,MAAM,GAAG;AAAA,MAC1D;AAEM,aAAO,IAAI,cAAc,MAAM,GAAG;AAAA,IACpC,KAAK,KAAK;AAAA,IACV,KAAK,KAAK;AACR,aAAO,IAAI,YAAY,MAAM,GAAG;AAAA,IAClC,KAAK,KAAK;AACR,aAAO,IAAI,cAAc,MAAM,GAAG;AAAA,IACpC,KAAK,KAAK;AACR,aAAO,KAAK,OACR,IAAI,kBAAkB,MAAM,GAAG,IAC/B,IAAI,mBAAmB,MAAM,GAAG;AAAA,IACtC,KAAK,KAAK;AACR,aAAO,IAAI,uBAAuB,MAAM,GAAG;AAAA,IAC7C,KAAK,KAAK;AACR,aAAO,IAAI,qBAAqB,MAAM,GAAG;AAAA,IAC3C,KAAK,KAAK;AACR,aAAO,IAAI,WAAW,MAAM,GAAG;AAAA,IACjC,KAAK,KAAK;AACR,aAAO,IAAI,qBAAqB,MAAM,GAAG;AAAA,IAE3C,KAAK,KAAK;AACR,aAAO,IAAI,kBAAkB,MAAM,GAAG;AAAA,EAC5C;AAKE,QAAM,IAAI,MAAM,gBAAgB,MAAM,CAAC;AACzC;ACxFO,SAAS,iBAAiB4E,SAAQ,MAAM,UAAU,CAAA,GAAI,OAAO;AAClE,QAAM6I,SAAQ,WAAW7I,OAAM,IAC3B,cAAY;AAAE,eAAW5E,UAAS4E,QAAQ,UAAS5E,MAAK;AAAA,EAAG,IAC3D4E;AAEJ,WAASiM,YAAUpD,MAAK;AACxB,QAAM,EAAE,eAAe,UAAU,GAAGI,KAAG,IAAK;AAC5C,MAAI3K;AAEJ,MAAI,KAAK,WAAW,KAAK,MAAM;AAC7B,QAAIrC,UAAS;AACb,IAAA4M,OAAM,MAAM,EAAE5M,OAAM;AACpB,IAAAqC,QAAO,YAAY,MAAMrC,SAAQ,YAAY;AAAA,EAC/C,OAAO;AACL,UAAM,MAAM,eAAegN,MAAK,KAAK;AACrC,UAAM,IAAI,QAAQ,MAAM,GAAG,EAAE,KAAI;AACjC,UAAM,OAAO,CAAAxC,OAAKnI,MAAK,KAAKmI,GAAE,OAAO;AACrC,IAAAnI,QAAO,CAAA;AAEP,QAAI,MAAM;AACV,IAAAuK,OAAM,CAAAzN,WAAS;AACb,QAAE,IAAIA,QAAO,KAAK;AAClB,UAAI,OAAO,cAAc;AACvB,aAAK,CAAC;AACN,cAAM;AAAA,MACR;AAAA,IACF,CAAC;AACD,QAAI,IAAK,MAAK,CAAC;AAGf,QAAI,OAAM;AAAA,EACZ;AAEA,SAAO,IAAI,OAAOkD,OAAM,IAAI;AAC9B;AASA,SAAS,YAAY,MAAMrC,SAAQ,OAAO;AACxC,QAAMqC,QAAO,CAAA;AACb,QAAM,QAAQ,CAAArC,YAAU,IAAI,UAAU,EAAE,QAAAA,SAAQ,WAAWA,SAAQ,MAAM;AACzE,QAAM,aAAa,KAAK,MAAMA,UAAS,KAAK;AAC5C,WAAS,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AACnC,IAAAqC,MAAK,KAAK,MAAM,KAAK,CAAC;AAAA,EACxB;AACA,QAAM,MAAMrC,UAAS;AACrB,MAAI,IAAK,CAAAqC,MAAK,KAAK,MAAM,GAAG,CAAC;AAC7B,SAAOA;AACT;ACvDO,SAAS,gBAAgBO,QAAO,MAAM,UAAU,CAAA,GAAI,OAAO;AAChE,SAAO,CAAC,QAAQ,aAAaA,MAAK,IAC9B,qBAAqBA,QAAO,OAAO,IACnC,iBAAiB,OAAKA,OAAM,QAAQ,CAAC,GAAG,MAAM,SAAS,KAAK;AAClE;AAUA,SAAS,qBAAqBmB,SAAQ,EAAE,cAAc,UAAS,GAAI;AACjE,QAAMyK;AAAA;AAAA,IACJzK,QAAO;AAAA;AAET,QAAM,OAAO,kBAAkByK,UAAS;AACxC,QAAMxO,UAAS+D,QAAO;AACtB,QAAM,QAAQ,KAAK,IAAI,gBAAgB,UAAU/D,OAAM;AACvD,QAAM,aAAa,KAAK,MAAMA,UAAS,KAAK;AAE5C,QAAM,UAAU,CAAA;AAChB,QAAMmQ,aAAY,iBAAiB3B,UAAS,KAAK,CAAC,YAAY,aAAa;AAC3E,QAAM,MAAM,CAAC,OAAO,QAAQ,QAAQ,KAAK,IAAI2B,WAAU;AAAA,IACrD,QAAQ,MAAM;AAAA,IACd,WAAW;AAAA,IACX;AAAA,IACA,UAAU,IAAI,WAAW,CAAC;AAAA,IAC1B,QAAQpM,QAAO,SAAS,OAAO,GAAG;AAAA,EACtC,CAAG,CAAC;AAEF,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,YAAY,EAAE,EAAG,KAAI,KAAK,OAAO,KAAK;AAC1D,MAAI,MAAM/D,QAAQ,KAAI,KAAKA,OAAM;AAEjC,SAAO,IAAI,OAAO,OAAO;AAC3B;AAOA,SAAS,kBAAkBwO,YAAW;AACpC,UAAQA,YAAS;AAAA,IACf,KAAK;AAAc,aAAO,QAAO;AAAA,IACjC,KAAK;AAAc,aAAO,QAAO;AAAA,IACjC,KAAK;AAAW,aAAO,KAAI;AAAA,IAC3B,KAAK;AAAY,aAAO,MAAK;AAAA,IAC7B,KAAK;AAAY,aAAO,MAAK;AAAA,IAC7B,KAAK;AAAY,aAAO,MAAK;AAAA,IAC7B,KAAK;AAAY,aAAO,MAAK;AAAA,IAC7B,KAAK;AAAa,aAAO,OAAM;AAAA,IAC/B,KAAK;AAAa,aAAO,OAAM;AAAA,IAC/B,KAAK;AAAa,aAAO,OAAM;AAAA,EACnC;AACA;AChEO,SAAS,iBAAiBnM,OAAM,UAAU;AAC/C,QAAM,SAAS,CAAA;AACf,QAAMoB,WAAU,MAAM,QAAQpB,KAAI,IAAIA,QAAO,OAAO,QAAQA,KAAI;AAChE,QAAMrC,UAASyD,SAAQ,CAAC,IAAI,CAAC,EAAE;AAE/B,QAAMuF,WAAUvF,SAAQ,IAAI,CAAC,CAAC8B,OAAM,GAAG,MAAM;AAC3C,QAAI,IAAI,WAAWvF,SAAQ;AACzB,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AACA,WAAO,KAAK,MAAMuF,OAAM,IAAI,IAAI,CAAC;AACjC,WAAO;AAAA,EACT,CAAC;AAED,QAAM,SAAS;AAAA,IACb,SAAS,QAAQ;AAAA,IACjB,YAAY,WAAW;AAAA,IACvB;AAAA,IACA,UAAU;AAAA,EACd;AAEE,SAAO,IAAI8D,OAAM,QAAQL,UAAS,QAAQ;AAC5C;AC7BO,SAAS,QAAQ3H,QAAO,OAAO;AAEpC,SAAO,WAAW,KAAK,IAAI,MAAMA,MAAK,IAClC,SAASA,OAAM,YAAW;AAChC;ACCO,SAAS,QAAQA,QAAO,UAAU,IAAI;AAC3C,QAAM,WAAE2H,WAAS,QAAQ,UAAU,QAAAjJ,UAAS,GAAG,OAAA8J,SAAQ,CAAA,GAAI,GAAGmD,KAAG,IAAK;AACtE,QAAM,QAAQ0B,QAAOrN,QAAO2H,SAAO;AACnC,QAAM3G,QAAOhB,OAAM,KAAI;AAGvB,QAAM,WAAWtB,YAAW,KACvBsB,OAAM,QAAO,KAAM,SACnB,CAACA,OAAM,WAAU,KACjB,CAACA,OAAM,UAAS;AAErB,SAAO,iBAAiB,MAAM,IAAI,CAAAkE,UAAQ;AACxC,UAAMxB,UAAS1B,MAAKkD,KAAI;AACxB,UAAM,OAAOsE,OAAMtE,KAAI;AACvB,UAAMkF,WAAU,YAAY1G,OAAM;AAClC,QAAI;AACJ,QAAI,aAAa0G,YAAW,WAAW1G,QAAO,OAAO,IAAI;AAEvD,YAAM,gBAAgB0G,WAAU1G,UAASA,QAAO,QAAO,GAAI,MAAMiJ,IAAG;AAAA,IACtE,OAAO;AAEL,YAAMvI,OAAMgG,WACR,SAAO1G,QAAO,GAAG,IACjB,SAAOA,QAAO,GAAG,GAAG;AACxB,YAAM;AAAA,QACJ,CAAA6I,WAASvL,OAAM,KAAK,SAAOuL,OAAMnI,KAAI,GAAG,CAAC,GAAG,MAAM,OAAO1E,OAAM;AAAA,QAC/D;AAAA,QACAiN;AAAA,MACR;AAAA,IACI;AACA,WAAO,CAACzH,OAAM,GAAG;AAAA,EACnB,CAAC,CAAC;AACJ;AClCO,SAAS,WAAWlD,OAAM,UAAU,IAAI;AAC7C,QAAM,EAAE,SAAS,UAAU,GAAG,eAAc,IAAK;AACjD,SAAO,WAAW,QAAQA,OAAM,cAAc,GAAG,EAAE,QAAQ;AAC7D;ACdO,SAAS,SAAS,GAAG;AAC1B,SAAO;AACT;ACAO,SAAS,KAAKhB,QAAO,OAAO,QAAQ,KAAKtB,SAAQ,KAAK;AAC3D,QAAM,EAAE,QAAQ,UAAU,MAAM,MAAM,SAAQ,IAAK;AACnD,QAAMsC,QAAOhB,OAAM,KAAI;AACvB,QAAM,IAAI,MAAM;AAChB,EAAAA,OAAM,KAAK,SAAO;AAChB,UAAM,GAAG;AACT,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,YAAMkE,QAAO,MAAM,CAAC;AACpB,WAAKlD,MAAKkD,KAAI,EAAE,GAAG,GAAG,GAAGA,OAAM,CAAC;AAAA,IAClC;AACA,QAAI,GAAG;AAAA,EACT,GAAG,MAAM,OAAOxF,OAAM;AACxB;ACiBO,SAAS,MAAMsB,QAAO,UAAU,IAAI;AACzC,QAAM,QAAQ,QAAQA,QAAO,QAAQ,OAAO;AAC5C,QAAM,SAAS,QAAQ,UAAU,CAAA;AACjC,QAAM,QAAQ,QAAQ,aAAa;AACnC,QAAM,SAAS,QAAQ,UAAU;AACjC,QAAM,WAAW,IAAI,OAAO,KAAK,KAAK;AAAA,IAAO;AAE7C,QAAM+O,eAAc,CAAAjR,WAASA,UAAS,OAAO,KACzCmL,SAAOnL,MAAK,IAAI,cAAcA,QAAO,IAAI,IACzC,SAAS,KAAKA,UAAS,EAAE,IAAI,MAAMA,OAAM,QAAQ,MAAM,IAAI,IAAI,MAC/DA;AAEJ,QAAM,OAAO,MAAM,IAAIiR,YAAW;AAClC,MAAI,OAAO,SAAU,KAAK,KAAK,KAAK,IAAI,OAAQ;AAEhD,OAAK/O,QAAO,OAAO,QAAQ,SAAS,UAAU,QAAQ,QAAQ;AAAA,IAC5D,KAAKlC,QAAOoG,OAAM,OAAO;AACvB,WAAK,KAAK,IAAI6K,aAAY,OAAO7K,KAAI,IAAI,OAAOA,KAAI,EAAEpG,MAAK,IAAIA,MAAK;AAAA,IACtE;AAAA,IACA,MAAM;AACJ,cAAQ,KAAK,KAAK,KAAK,IAAI;AAAA,IAC7B;AAAA,EACJ,CAAG;AAED,SAAO;AACT;ACxDO,SAAS,UAAU,KAAK,IAAIkN,UAAS,CAAA,GAAI;AAC9C,aAAW3I,QAAO,KAAK;AACrB,IAAA2I,QAAO3I,IAAG,IAAI,GAAG,IAAIA,IAAG,GAAGA,IAAG;AAAA,EAChC;AACA,SAAO2I;AACT;ACHA,SAAS,eAAe,GAAG;AACzB,SAAO,EAAE,kBAAkB,KACtB,EAAE,cAAa,MAAO,KACtB,EAAE,cAAa,MAAO,KACtB,EAAE,mBAAkB,MAAO;AAClC;AAEO,SAAS,YAAYtN,OAAM,UAAU,IAAI;AAC9C,MAAIqL,SAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,OAAO;AACX,MAAI,SAAS;AAEb,EAAArL,MAAK,CAAAI,WAAS;AACZ,MAAEiL;AACF,QAAIjL,UAAS,MAAM;AACjB,QAAE;AACF;AAAA,IACF;AAEA,UAAM,OAAO,OAAOA;AACpB,QAAI,SAAS,YAAYmL,SAAOnL,MAAK,GAAG;AACtC,QAAE;AACF,UAAI,eAAeA,MAAK,EAAG,GAAE;AAAA,IAC/B,WAAW,SAAS,UAAU;AAC5B,QAAE;AACF,UAAIA,WAAUA,WAAWA,SAAQ,OAAOA,QAAO;AAC7C,cAAM,IAAIA,SAAQ;AAClB,cAAM,IAAI,EAAE,QAAQ,GAAG;AACvB,YAAI,KAAK,GAAG;AACV,gBAAM,IAAI,EAAE,QAAQ,GAAG;AACvB,gBAAM,IAAI,IAAI,IAAI,IAAI,EAAE;AACxB,mBAAS,KAAK,IAAI,QAAQ,IAAI,IAAI,CAAC;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL,QAAS,QAAQ,OAAO,SAASiL,SAAQ,MAAM,MAAM;AAAA,IACrD,QAAQ;AAAA,MACN,KAAQ,UAAU;AAAA,MAClB,QAAQ,KAAK,IAAI,QAAQ,QAAQ,aAAa,CAAC;AAAA,IACrD;AAAA,EACA;AACA;AC/CO,SAAS,QAAQ/I,QAAO,OAAO,SAAS;AAC7C,QAAM,YAAY,QAAQ,UAAU,CAAA;AACpC,QAAM,WAAW,QAAQ,SAAS,CAAA;AAClC,QAAM,SAAS,CAAA;AACf,QAAMgP,SAAQ,CAAA;AAEd,QAAM,QAAQ,CAAA9K,UAAQ;AACpB,UAAM,OAAO,YAAY,OAAOlE,QAAOkE,KAAI,GAAG,OAAO;AACrD,IAAA8K,OAAM9K,KAAI,IAAI,SAASA,KAAI,KAAK,KAAK;AACrC,WAAOA,KAAI,IAAI,UAAUA,KAAI,KAAK,KAAK;AAAA,EACzC,CAAC;AAED,SAAO,EAAE,OAAA8K,QAAO,OAAM;AACxB;AAEA,SAAS,OAAOhP,QAAO,YAAY;AACjC,QAAM,SAASA,OAAM,OAAO,UAAU;AACtC,SAAO,QAAMA,OAAM,KAAK,SAAO,GAAG,OAAO,GAAG,GAAG,CAAC,CAAC;AACnD;ACTO,SAAS,YAAY,GAAG,UAAU,IAAI;AAC3C,MAAI,WAAW,OAAO,GAAG;AAEvB,WAAO,QAAQ,CAAC,IAAI;AAAA,EACtB;AAEA,QAAM,OAAO,OAAO;AAEpB,MAAI,SAAS,UAAU;AACrB,QAAIiJ,SAAO,CAAC,GAAG;AAEb,aAAO,QAAQ,MAAM,cAAc,CAAC,IAAI,WAAW,CAAC;AAAA,IACtD,OAAO;AACL,YAAM,IAAI,KAAK;AAAA,QACb;AAAA;AAAA,QAEA,CAAC,GAAGjL,OAAMsL,eAAatL,EAAC,IAAI,MAAM,KAAKA,EAAC,IAAIA;AAAA,MACpD;AAEM,YAAM,SAAS,QAAQ,UAAU;AACjC,aAAO,EAAE,SAAS,SACd,EAAE,MAAM,GAAG,EAAE,IAAI,OAAY,EAAE,CAAC,MAAM,MAAM,MAAM,OAClD;AAAA,IACN;AAAA,EACF,WAAW,SAAS,UAAU;AAE5B,UAAM,SAAS,QAAQ,UAAU;AACjC,QAAI;AACJ,WAAO,MAAM,OAAO,IAAI,KAAK,IAAI,CAAC,MAAM,QAAQ,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,KACpE,EAAE,cAAc,MAAM,IACtB,EAAE,QAAQ,MAAM;AAAA,EACtB,OAAO;AACL,WAAO,IAAI;AAAA,EACb;AACF;ACkBO,SAAS,OAAOgC,QAAO,UAAU,IAAI;AAC1C,QAAM,QAAQ,QAAQA,QAAO,QAAQ,OAAO;AAC5C,QAAM,EAAE,OAAAgP,QAAO,OAAM,IAAK,QAAQhP,QAAO,OAAO,OAAO;AACvD,QAAM,QAAQiP,SAAO,OAAO;AAC5B,QAAM,UAAU,QAAQ;AAExB,QAAM,aAAa,OAAK,MAAM,MAAM,WAAW,MAAM,MAAM,UAAU;AACrE,QAAMC,UAAS,OAAK,EAAE,QAAQ,MAAM,OAAO,EACxC,QAAQ,MAAM,MAAM,EACpB,QAAQ,MAAM,MAAM;AACvB,QAAM,aAAa,CAACpR,QAAO6N,SAAQuD,QAAO,YAAYpR,QAAO6N,IAAG,CAAC;AACjE,QAAM,YAAY,UACd,CAAC7N,QAAO6N,SAAQ7N,UAAS,OAAO,QAAQA,MAAK,IAAI,WAAWA,QAAO6N,IAAG,IACtE;AAEJ,MAAI,IAAI;AACR,MAAI,MAAM;AAEV,QAAM,MAAM,CAACwD,MAAKjL,OAAM,gBAAgB;AACtC,UAAM,IAAI,cAAc,WAAW8K,OAAM9K,KAAI,CAAC,IAAI;AAClD,UAAM,IAAI,MAAMiL,IAAG,IAAK,MAAMA,IAAG,EAAEjL,OAAM,KAAK,CAAC,KAAK,KAAM;AAC1D,UAAM,OAAO,IAAK,eAAe,CAAC,OAAO,IAAI,MAAM,MAAO,MAAM;AAChE,WAAO,IAAIiL,IAAG,GAAG,MAAM,WAAW,GAAG,MAAM,EAAE;AAAA,EAC/C;AAEA,MAAI,OAAO,IAAI,OAAO,IAClB,IAAI,OAAO,IACX,IAAI,MAAM,CAAC,IACX,MAAM,IAAI,CAAAjL,UAAQ,GAAG,IAAI,MAAMA,OAAM,CAAC,CAAC,GAAGA,KAAI,OAAO,EAAE,KAAK,EAAE,IAC9D,kBACA,IAAI,OAAO;AAEf,OAAKlE,QAAO,OAAO,QAAQ,OAAO,QAAQ,QAAQ;AAAA,IAChD,MAAM,KAAK;AACT,UAAI;AACJ,QAAE;AACF,cAAQ,IAAI,IAAI;AAAA,IAClB;AAAA,IACA,KAAKlC,QAAOoG,OAAM;AAChB,cAAQ,IAAI,MAAMA,OAAM,CAAC,IACrB,UAAUpG,QAAO,OAAOoG,KAAI,CAAC,IAC7B;AAAA,IACN;AAAA,IACA,MAAM;AACJ,cAAQ;AAAA,IACV;AAAA,EACJ,CAAG;AAED,SAAO,OAAO;AAChB;AAEA,SAAS+K,SAAO,SAAS;AACvB,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,CAAAnR,WAAS,WAAWA,MAAK,IAAIA,SAAQ,MAAMA;AAAA,EAC/C;AACA;ACjHO,MAAM,UAAU;AAChB,MAAM,SAAS;ACsBtB,MAAM,mBAAmB,CAAAA,WAASmL,SAAOnL,MAAK,IAC1C,cAAcA,QAAO,IAAI,IACzBA;AAQG,SAAS,OAAOkC,QAAO;AAAA,EAC5B;AAAA,EACA,SAAS;AAAA,EACT,SAAS,CAAA;AAAA,EACT;AAAA,EACA,QAAAtB;AACF,IAAI,IAAI;AACN,QAAM,QAAQ,QAAQsB,QAAO,IAAI;AACjC,QAAM,MAAM,MAAM,IAAI,CAAAkE,UAAQ,OAAOA,KAAI,KAAK,gBAAgB;AAC9D,QAAMxG,QAAO,QAAMsC,OAAM,KAAK,IAAI,MAAM,OAAOtB,OAAM;AAErD,SAAO,SAAS,UACZ,UAAUsB,QAAO,OAAO,KAAKtC,KAAI,IACjC,OAAOsC,QAAO,OAAO,KAAKtC,OAAM,SAAS,MAAM;AACrD;AAEA,SAAS,UAAUsC,QAAO,OAAO,QAAQtC,OAAM;AAC7C,MAAI,OAAO;AAEX,QAAM,QAAQ,CAACwG,OAAM,MAAM;AACzB,aAAS,IAAI,MAAM,MAAM,KAAK,UAAUA,KAAI,IAAI;AAEhD,UAAM,SAASlE,OAAM,OAAOkE,KAAI;AAChC,UAAM,YAAY,OAAO,CAAC;AAC1B,QAAI,IAAI;AACR,IAAAxG,MAAK,SAAO;AACV,YAAMI,SAAQ,OAAO,GAAG,GAAG;AAC3B,eAAS,EAAE,IAAI,MAAM,MAAM,KAAK,UAAU,UAAUA,MAAK,CAAC;AAAA,IAC5D,CAAC;AAED,YAAQ;AAAA,EACV,CAAC;AAED,SAAO,OAAO;AAChB;AAEA,SAAS,OAAOkC,QAAO,OAAO,QAAQtC,OAAM,KAAK,OAAO;AACtD,QAAM,IAAI,MAAM;AAChB,QAAMkF,QAAO,MAAM,IAAI,CAAAsB,UAAQ,IAAIA,KAAI,IAAI;AAC3C,QAAM,OAAO,MAAM,IAAI,CAAAA,UAAQlE,OAAM,OAAOkE,KAAI,CAAC;AAEjD,QAAM,SAAS,KAAK,OAAK,EAAE,WAAW,MAAM,EAAE,IAAI;AAClD,QAAM,MAAM,KAAK,OAAO;AACxB,MAAI,OAAO,KAAK,KAAK;AAErB,MAAI,IAAI;AACR,EAAAxG,MAAK,SAAO;AACV,UAAM,QAAQ,CAAA;AACd,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,YAAM,KAAKkF,MAAK,CAAC,IAAI,KAAK,UAAU,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAAA,IACjE;AACA,aAAS,EAAE,IAAI,MAAM,MAAM,OAAO,IAAI,MAAM,KAAK,GAAG,CAAC,GAAG;AAAA,EAC1D,CAAC;AAED,SAAO,QAAQ,KAAK,KAAK;AAC3B;AC7DO,SAAS,WAAW5C,QAAO,UAAU,IAAI;AAC9C,QAAM,QAAQ,QAAQA,QAAO,QAAQ,OAAO;AAC5C,QAAM,EAAE,OAAAgP,QAAO,OAAM,IAAK,QAAQhP,QAAO,OAAO,OAAO;AAEvD,QAAM,aAAa,OAAK,MAAM,MAAM,QAAQ,MAAM,MAAM,OAAO;AAC/D,QAAMkP,UAAS,OAAK,EAAE,QAAQ,OAAO,KAAK;AAE1C,MAAI,OAAO,MACP,MAAM,IAAIA,OAAM,EAAE,KAAK,GAAG,IAC1B,SACA,MAAM,IAAI,CAAAhL,UAAQ,WAAW8K,OAAM9K,KAAI,CAAC,CAAC,EAAE,KAAK,GAAG,IACnD;AAEJ,OAAKlE,QAAO,OAAO,QAAQ,OAAO,QAAQ,QAAQ;AAAA,IAChD,QAAQ;AACN,cAAQ;AAAA,IACV;AAAA,IACA,KAAKlC,QAAOoG,OAAM;AAChB,cAAQgL,QAAO,YAAYpR,QAAO,OAAOoG,KAAI,CAAC,CAAC,IAAI;AAAA,IACrD;AAAA,IACA,MAAM;AACJ,cAAQ;AAAA,IACV;AAAA,EACJ,CAAG;AAED,SAAO;AACT;ACfO,MAAM,oBAAoB8D,QAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWrC,UAAU,QAAQ;AAChB,WAAO,OAAO,MAAM,GAAG,MAAM;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,UAAU,IAAI;AAClB,UAAM,EAAE,KAAK,QAAO,IAAK;AACzB,WAAO,OAAO,MAAM,EAAE,CAAC,EAAE,GAAG,MAAK,EAAE,CAAE;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,OAAOtF,SAAQ,SAAS;AACtB,WAAO,OAAO,MAAMA,SAAQ,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,OAAO,UAAU;AACf,WAAO,OAAO,MAAM,QAAQ;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,OAAO,KAAK;AAChB,WAAO,MAAM,MAAM,OAAO,GAAG;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,WAAWE,OAAM;AACf,WAAO,QAAQ,MAAM,GAAGA,KAAI;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,WAAWA,OAAM;AACf,WAAO,QAAQ,MAAM,GAAGA,KAAI;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,SAAS+E,UAAS,SAAS;AACzB,WAAO,SAAS,MAAM,QAAQA,QAAO,GAAG,OAAO;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,UAAUA,UAAS;AACjB,WAAO,OAAO,MAAM,GAAGA,QAAO;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,OAAO,SAAS;AACd,WAAO,OAAO,MAAM,OAAO;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,OAAOjF,SAAQ;AACb,WAAO,OAAO,MAAMA,OAAM;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,OAAO,MAAM,SAAS;AACpB,WAAO,OAAO,MAAM,MAAM,OAAO;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,UAAUiF,UAAS;AACjB,WAAO,OAAO,MAAM,GAAGA,QAAO;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU;AACR,WAAO,QAAQ,IAAI;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU;AACR,WAAO,QAAQ,IAAI;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,UAAU/E,OAAM;AACd,WAAO,OAAO,MAAM,GAAGA,KAAI;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BA,OAAOF,SAAQ,SAAS;AACtB,WAAO,OAAO,MAAMA,SAAQ,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,KAAKA,SAAQ,SAAS;AACpB,WAAO,KAAK,MAAMA,SAAQ,OAAO;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,MAAME,OAAMF,SAAQ,SAAS;AAC3B,WAAO,MAAM,MAAME,OAAMF,SAAQ,OAAO;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,OAAOA,SAAQ,SAAS;AACtB,WAAO,OAAO,MAAMA,SAAQ,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,OAAOA,SAAQ,SAAS;AACtB,WAAO,OAAO,MAAMA,SAAQ,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,OAAO,OAAO,OAAOA,SAAQ;AAC3B,WAAO,OAAO,MAAM,OAAO,IAAI,GAAGA,OAAM;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0CA,KAAK,OAAO,IAAIA,SAAQ,SAAS;AAC/B,WAAO,KAAK,MAAM,OAAO,IAAIA,SAAQ,OAAO;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCA,UAAU,OAAO,IAAIA,SAAQ,SAAS;AACpC,UAAMiJ,OAAM,EAAE,GAAG,SAAS,MAAM,MAAM,OAAO,MAAK;AAClD,WAAO,KAAK,MAAM,OAAO,IAAIjJ,SAAQiJ,IAAG;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCA,WAAW,OAAO,IAAIjJ,SAAQ,SAAS;AACrC,UAAMiJ,OAAM,EAAE,GAAG,SAAS,MAAM,OAAO,OAAO,KAAI;AAClD,WAAO,KAAK,MAAM,OAAO,IAAIjJ,SAAQiJ,IAAG;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCA,UAAU,OAAO,IAAIjJ,SAAQ,SAAS;AACpC,UAAMiJ,OAAM,EAAE,GAAG,SAAS,MAAM,MAAM,OAAO,KAAI;AACjD,WAAO,KAAK,MAAM,OAAO,IAAIjJ,SAAQiJ,IAAG;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BA,MAAM,OAAOjJ,SAAQ,SAAS;AAC5B,WAAO,MAAM,MAAM,OAAOA,SAAQ,OAAO;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,SAAS,OAAO,IAAI;AAClB,WAAO,SAAS,MAAM,OAAO,EAAE;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,SAAS,OAAO,IAAI;AAClB,WAAO,SAAS,MAAM,OAAO,EAAE;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,UAAU,QAAQ;AAChB,WAAO,OAAO,MAAM,GAAG,MAAM;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,SAAS,QAAQ;AACf,WAAOc,QAAM,MAAM,GAAG,MAAM;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,aAAa,QAAQ;AACnB,WAAO,UAAU,MAAM,GAAG,MAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,UAAU,QAAQ;AAChB,WAAO,OAAO,MAAM,GAAG,MAAM;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,QAAQ,SAAS;AACf,WAAO,QAAQ,MAAM,OAAO;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,SAAS;AAClB,WAAO,WAAW,MAAM,OAAO;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,SAAS;AACb,WAAO,MAAM,MAAM,OAAO;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,SAAS;AACd,WAAO,OAAO,MAAM,OAAO;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,SAAS;AACd,WAAO,OAAO,MAAM,OAAO;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,SAAS;AAClB,WAAO,WAAW,MAAM,OAAO;AAAA,EACjC;AACF;ACj0BO,SAAS,UAAU,OAAO,SAAS;AACxC,QAAM,EAAE,SAAAmE,WAAU,IAAG,GAAI,GAAG,KAAI,IAAgB,CAAA;AAChD,QAAM,QAAQ,iBAAiB,eAAe,iBAAiB,aAC3D,aAAa,OAAO,EAAE,SAAS,MAAM,GAAG,KAAI,CAAE,IAC9C;AAEJ,QAAM,EAAE,WAAW,MAAM;AAGzB,QAAM,QAAQ,OAAO,IAAI,OAAK,EAAE,IAAI;AACpC,QAAM,MAAM,QAAQ;AAAA,IAClB,aAAa,UAAQ,OAAO,MAAM,OAAO,IAAI,IAAI,MAAM,MAAK;AAAA,IAC5D,aAAa,CAAAzD,UAAQ,MAAM,QAAQA,KAAI;AAAA,EAC3C,GAAKyD,QAAO;AAGV,QAAM,OAAO,UAAS;AACtB,MAAI,QAAQ,CAACzD,OAAM7B,SAAQ;AACzB,UAAM;AAAA;AAAA,MAAuD,MAAM,SAASA,IAAG;AAAA;AAC/E,SAAK,IAAI6B,OAAM,IAAI,KAAK,WAAW,KAAK,WAAW,GAAG,IAAI,GAAG;AAAA,EAC/D,CAAC;AAED,SAAO,IAAI,YAAY,KAAK,MAAM,KAAK,KAAK;AAC9C;AA0BA,SAAS,WAAW,QAAQ;AAC1B,QAAM,EAAE,MAAAlD,OAAM,QAAArC,SAAQ,UAAS,IAAK;AACpC,QAAM,QAAQqC,MAAKA,MAAK,SAAS,CAAC;AAElC,QAAM,QAAQ,MAAM,SAAS,MAAM,WAAW,QAAO;AACrD,QAAM,OAAO,MAAM;AACnB,QAAM4B,QAAO,SAAS5B,OAAMrC,SAAQ,WAAW,IAAI;AAEnD,QAAMyE,OAAM,aACP,OAAK,MAAM,OAAO,OAAO,MAAM,CAAC,MAChC,OAAK,MAAM,CAAC;AAEjB,SAAO;AAAA,IACL,QAAAzE;AAAA,IACA;AAAA,IACA,IAAI,SAAOyE,KAAIR,MAAK,GAAG,CAAC;AAAA,IACxB,KAAK,SAAOA,MAAK,GAAG;AAAA,IACpB,OAAO9E,QAAO;AACZ,UAAIA,WAAU,KAAM,QAAO,YAAY,OAAO;AAC9C,eAAS,IAAI,GAAG,IAAI,MAAM,EAAE,GAAG;AAC7B,YAAI,MAAM,CAAC,MAAMA,OAAO,QAAO;AAAA,MACjC;AACA,aAAO;AAAA,IACT;AAAA,IACA,OAAO,OAAO;AACZ,YAAM,IAAI,QAAQ,YAAY,IAAI;AAClC,aAAO;AAAA,QACL,MAAA8E;AAAA,QACA,KAAK,CAACQ,IAAG;AAAA,QACT;AAAA,QACA,MAAM,SAAS,GAAG,CAAC;AAAA,QACnB,MAAM;AAAA,MACd;AAAA,IACI;AAAA,IACA,CAAC,OAAO,QAAQ,GAAG,MAAM,OAAO,OAAO,QAAQ,EAAC;AAAA,IAChD,SAAS,MAAM,OAAO,QAAO;AAAA,EACjC;AACA;AASA,SAAS,SAASpC,OAAMrC,SAAQ,OAAO,MAAM;AAC3C,QAAM,IAAIqC,MAAK,SAAS,KAAK,QACzB,QAAQA,OAAMrC,OAAM,IACpBqC,MAAK,CAAC,EAAE;AACZ,SAAO,QAAQ,SAASA,OAAM,GAAG,IAAI,IAAI;AAC3C;AAKA,SAAS,QAAQA,OAAMrC,SAAQ;AAC7B,QAAM,OAAOqC,MAAK,CAAC,EAAE,OAAO;AAC5B,QAAMO,SAAQ,IAAI,KAAK5C,OAAM;AAC7B,QAAM,IAAIqC,MAAK;AACf,WAAS,IAAI,GAAG,MAAM,GAAG,KAAK,IAAI,GAAG,EAAE,GAAG;AACxC,UAAMA,MAAK,CAAC,EAAE;AACd,IAAAO,OAAM,IAAIP,MAAK,CAAC,EAAE,OAAO,SAAS,GAAG,GAAG,GAAG,GAAG;AAC9C,WAAO;AAAA,EACT;AACA,SAAOO;AACT;AAOA,SAAS,SAASP,OAAM4B,OAAMP,MAAK;AAEjC,QAAM,IAAIrB,MAAK;AACf,WAAS,IAAI,GAAG,MAAM,GAAG,MAAM,IAAI,GAAG,EAAE,GAAG;AACzC,UAAM,QAAQA,MAAK,CAAC;AACpB,UAAM,EAAE,QAAArC,QAAM,IAAK;AAEnB,UAAM,WAAW,MAAM,YAAY,MAAM;AACzC,UAAM,IAAIA,WAAU;AACpB,QAAI,YAAY,SAAS,QAAQ;AAC/B,eAAS,IAAI,GAAG,KAAK,GAAG,EAAE,GAAG;AAC3B,aAAK,OAAO,SAAS,CAAC,OAAO,KAAK;AAChC,gBAAM,OAAO,OAAO,KAAK;AACzB,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAiE,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAC9C,eAAK,OAAQ,KAAK,OAAQ,EAAG,CAAAO,MAAK,OAAO,CAAC,IAAIP;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AACA,WAAO1D;AAAA,EACT;AACA,SAAOiE;AACT;ACvJO,SAAS,OAAO9E,QAAO;AAC5B,SAAOe,OAAKf,QAAO;AAAA,IACjB,QAAQ;AAAA,IACR,WAAW;AAAE,YAAM,uCAAuC;AAAA,IAAG;AAAA,EACjE,CAAG;AACH;ACRO,SAAS,YAAY4E,SAAQ,OAAO;AACzC,QAAM0M,SAAQ,UAAQ;AACpB,UAAM,0BAA0B,QAAQ,OAAO1M,OAAM,EAAE;AACvD;AAAA;AAAA,MAAsD,CAAA;AAAA;AAAA,EACxD;AAEA,SAAOA,mBAAkB,MAAM,kBAAkBA,QAAO,QAAO,GAAI,KAAK,IACpEuG,SAAOvG,OAAM,IAAI0M,OAAM,MAAM,IAC7B,SAAS1M,OAAM,IAAI0M,OAAM,QAAQ,IACjC,SAAS1M,OAAM,IAAI0M,OAAK,IACxBhG,UAAQ1G,OAAM,IAAI,UAAUA,SAAQ,KAAK,IACzC,WAAWA,QAAO,OAAO,QAAQ,CAAC,IAAI,aAAaA,SAAQ,KAAK,IAChE,SAASA,OAAM,IAAI,kBAAkB,OAAO,QAAQA,OAAM,GAAG,KAAK,IAClE0M,OAAK;AACX;AAOA,SAAS,kBAAkBhN,UAAS,QAAQ,CAAC,OAAO,OAAO,GAAG;AAC5D,QAAMQ,QAAO,CAAA;AACb,QAAM,OAAO,CAAA;AAEb,aAAW,CAACP,MAAK,GAAG,KAAKD,UAAS;AAChC,IAAAQ,MAAK,KAAKP,IAAG;AACb,SAAK,KAAK,GAAG;AAAA,EACf;AAGA,QAAMsF,WAAU,CAAA;AAChB,MAAI,MAAM,CAAC,EAAG,CAAAA,SAAQ,MAAM,CAAC,CAAC,IAAI/E;AAClC,MAAI,MAAM,CAAC,EAAG,CAAA+E,SAAQ,MAAM,CAAC,CAAC,IAAI;AAClC,SAAOA;AACT;AAOA,SAAS,UAAUjF,SAAQ,OAAO;AAChC,QAAM,MAAMA,QAAO;AAEnB,QAAMiF,WAAU,CAAA;AAChB,QAAM,MAAM,CAAAzD,UAAQyD,SAAQzD,KAAI,IAAI,MAAM,GAAG;AAE7C,MAAI,KAAK;AACP,YAAQ,SAAS,OAAO,KAAKxB,QAAO,CAAC,CAAC;AACtC,UAAM,OAAO,MAAM,IAAI,GAAG;AAC1B,UAAM,IAAI,KAAK;AACf,aAAS,MAAM,GAAG,MAAM,KAAK,EAAE,KAAK;AAClC,YAAM,MAAMA,QAAO,GAAG;AACtB,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,aAAK,CAAC,EAAE,GAAG,IAAI,IAAI,MAAM,CAAC,CAAC;AAAA,MAC7B;AAAA,IACF;AAAA,EACF,WAAW,OAAO;AAChB,UAAM,QAAQ,GAAG;AAAA,EACnB;AAEA,SAAOiF;AACT;AAOA,SAAS,aAAajF,SAAQ,OAAO;AAEnC,QAAMiF,WAAU,CAAA;AAChB,QAAM,MAAM,CAAAzD,UAAQyD,SAAQzD,KAAI,IAAI,CAAA;AAEpC,MAAI;AACJ,MAAI;AACJ,aAAW,OAAOxB,SAAQ;AACxB,QAAI,CAAC,MAAM;AACT,cAAQ,SAAS,OAAO,KAAK,GAAG;AAChC,aAAO,MAAM,IAAI,GAAG;AACpB,UAAI,KAAK;AAAA,IACX;AACA,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,WAAK,CAAC,EAAE,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC;AAAA,IAC5B;AAAA,EACF;AAEA,MAAI,CAAC,QAAQ,OAAO;AAClB,UAAM,QAAQ,GAAG;AAAA,EACnB;AAEA,SAAOiF;AACT;ACvFO,SAAS,MAAMA,UAAS,OAAO;AACpC,MAAIA,oBAAmB,YAAa,QAAOA;AAE3C,QAAM3G,QAAO,CAAA;AACb,QAAM4B,QAAO,CAAA;AACb,aAAW,CAACP,MAAKvE,MAAK,KAAK,QAAQ6J,QAAO,GAAG;AAC3C,IAAA3G,MAAKqB,IAAG,IAAIvE;AACZ,IAAA8E,MAAK,KAAKP,IAAG;AAAA,EACf;AACA,SAAO,IAAI,YAAYrB,OAAe4B,KAAI;AAC5C;AAgBO,SAAS,KAAKF,SAAQ,OAAO;AAClC,SAAO,IAAI,YAAY,YAAYA,SAAQ,KAAK,GAAG,KAAK;AAC1D;;;;;;;;AC3CA,OAAA,UAAkB,SAAS,QAAS,GAAG;AACrC,QAAI,IAAI;AACR,QAAI,IAAI,cAAc,KAAK,MAAM;AACjC,QAAI,IAAI,aAAa,MAAM;AAC3B,QAAI,IAAI,aAAa,KAAK,KAAK;AAC/B,QAAI,IAAI,aAAa,KAAK;AAC1B,QAAI,IAAI,aAAa,KAAK,KAAK;AAC/B,WAAO,IAAI,cAAc,MAAM,KAAK;AAAA,EACtC;AAGA,OAAA,UAAkB,SAAS,QAAS,GAAG,GAAG;AACxC,QAAI,IAAI;AACR,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,WAAO;AAAA,EACT;AAGA,OAAA,UAAkB,SAAS,QAAS,GAAG,GAAG;AACxC,QAAI,IAAI;AACR,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,SAAK,EAAE,GAAG,KAAK;AACf,WAAO;AAAA,EACT;AAGA,OAAA,WAAmB,SAAS,SAAU,GAAG,GAAG,GAAG;AAC7C,MAAE,GAAG,IAAK,KAAK,IAAK;AACpB,MAAE,GAAG,IAAK,KAAK,IAAK;AACpB,MAAE,GAAG,IAAK,KAAK,KAAM;AACrB,MAAE,GAAG,IAAK,KAAK,KAAM;AAAA,EACvB;AAIA,OAAA,OAAe,SAAS,KAAM,GAAG,GAAG;AAClC,QAAI,KAAK,MAAM;AACf,QAAI,KAAK,IAAI;AACb,QAAI,KAAK,MAAM;AACf,QAAI,KAAK,IAAI;AAEb,WAAO,KAAK,MAAM,KAAK,KAAK,KAAK,MAAM,MAAM;AAAA,EAC/C;;;;;;;ACpDA,MAAI2M,QAAOC,YAAA;AAGX,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,SAAS;AAKb,WAAS,OAAQ,GAAG,GAAG;AACrB,QAAI,IAAI;AACR,QAAI,IAAI;AAER,WAAO,OAAO,KAAK,IAAI,KAAK,KAAK,IAAI;AAAA,EACvC;AAEA,WAAS,SAAU,GAAG,GAAG,GAAG;AAC1B,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,IAAI;AAER,WAAOD,MAAK,KAAK,OAAO,KAAK,IAAI,KAAK,KAAK,GAAG,CAAC,IAAI;AAAA,EACrD;AAEA,WAAS,WAAY,GAAG,GAAG;AACzB,QAAI,IAAI;AACR,QAAI,IAAI;AAER,WAAO,MAAM,IAAI,IAAI;AAAA,EACvB;AAKA,WAAS,SAAU,GAAG,KAAK,IAAI,GAAG,IAAI;AACpC,WAAO,SAASA,MAAK,KAAK,KAAK,EAAE,IAAI,GAAG,GAAG,EAAE;AAAA,EAC/C;AAEA,WAAS,KAAM,GAAG,KAAK,OAAO;AAC5B,WAAO,SAAU,IAAIA,MAAK,KAAK,IAAI,KAAK,GAAG,MAAM,GAAI,IAAI,MAAM;AAAA,EACjE;AAEA,WAAS,KAAM,GAAG,KAAK,OAAO;AAC5B,WAAO,SAAS,GAAGA,MAAK,QAAQ,KAAK,KAAK,GAAG,QAAQ,IAAI,MAAM;AAAA,EACjE;AAEA,WAAS,MAAO,GAAG,KAAK,OAAO;AAC7B,WAAO;AAAA,MACL,SAAS,EAAE,CAAC,GAAGA,MAAK,QAAQ,KAAK,QAAQ,CAAC,GAAG,QAAQ,IAAI,MAAM;AAAA,MAC/D,SAAS,EAAE,CAAC,GAAGA,MAAK,QAAQ,KAAK,QAAQ,CAAC,GAAG,QAAQ,IAAI,MAAM;AAAA,MAC/D,SAAS,EAAE,CAAC,GAAGA,MAAK,QAAQ,KAAK,QAAQ,CAAC,GAAG,QAAQ,IAAI,MAAM;AAAA,MAC/D,SAAS,EAAE,CAAC,GAAGA,MAAK,QAAQ,KAAK,QAAQ,EAAE,GAAG,QAAQ,IAAI,MAAM;AAAA;EAEpE;AAEA,WAASE,QAAO,MAAM,KAAK,OAAO,KAAK;AACrC,QAAI,GAAG;AACP,QAAI;AACJ,QAAI,OAAO,IAAI;AACb,UAAI;AAAA,QACF,OAAO,SAAS;AAAA,QAChB,OAAO;AAAA,QACP;AAAA,QACA,OAAO;AAAA;AAGT,aAAO,OAAO,IAAI;AAChB,YAAI,MAAM,GAAG,KAAK,KAAK;AAEvB,iBAAS;AACT,eAAO;AAAA,MACb;AAEI,UAAI,OAAO,EAAE,CAAC,GAAG,CAAC,IAAI,OAAO,EAAE,CAAC,GAAG,CAAC,IAAI,OAAO,EAAE,CAAC,GAAG,EAAE,IAAI,OAAO,EAAE,CAAC,GAAG,EAAE,IAAI;AAAA,IAClF,OAAS;AACL,UAAK,OAAO,SAAS,QAAS;AAAA,IAClC;AAEE,WAAO,OAAO,GAAG;AACf,UAAI,KAAK,GAAG,KAAK,KAAK;AAEtB,eAAS;AACT,aAAO;AAAA,IACX;AAEE,WAAO,MAAM,GAAG;AACd,UAAI,KAAK,GAAG,KAAK,KAAK;AAEtB;AACA;AAAA,IACJ;AAEE,QAAI,WAAWF,MAAK,KAAK,WAAWA,MAAK,KAAK,WAAW,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE;AAE1F,WAAO,MAAM;AAAA,EACf;AAEAG,QAAA,OAAeD;;;;;;;;AC3Ff,QAAI,SAASD,aAAA;AACb,QAAID,QAAOI,YAAA;AAMX,QAAI,WAAW;AACf,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,cAAc;AAClB,QAAI,WAAW,KAAK;AAGpB,QAAI,SAAS;AACb,QAAI,UAAU,KAAK,UAAU;AAC7B,QAAI,UAAU;AACd,QAAI,WAAW,KAAK,WAAW;AAG/B,QAAI,WAAW,WAAW,KAAK,EAAE;AACjC,QAAI,YAAY,cAAa;AAG7B,QAAI,WAAW;AAGf,QAAI,kBAAkB;AACtB,QAAI,gBAAgB;AACpB,QAAI,gBAAgB;AAEpB,QAAI,YAAY;AAChB,QAAI,gBAAgB;AAGpB,QAAI,iBAAiB;AACrB,QAAI,YAAY;AAChB,QAAI,UAAU;AACd,QAAI,SAAS;AACb,QAAI,QAAQ;AAAA,MACV,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA;AAOL,aAAS,gBAAiB;AACxB,UAAI;AACF,eAAO,IAAI,YAAY,QAAQ;AAAA,MACnC,SAAWxR,QAAO;AACd,YAAIyR,aAAY,IAAI,MAAM,QAAQ;AAElC,iBAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,UAAAA,WAAU,CAAC,IAAI;AAAA,QACrB;AAEI,eAAOA;AAAA,MACX;AAAA,IACA;AAGA,aAAS,eAAgB1P,QAAO;AAC9B,eAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,kBAAU,CAAC,IAAI;AAAA,MACnB;AAAA,IACA;AAGA,aAAS,WAAY,MAAM;AACzB,UAAI;AACF,eAAO,IAAI,WAAW,IAAI;AAAA,MAC9B,SAAW/B,QAAO;AACd,YAAIyG,OAAM,IAAI,MAAM,IAAI;AAExB,iBAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC7B,UAAAA,KAAI,CAAC,IAAI;AAAA,QACf;AAEI,eAAOA;AAAA,MACX;AAAA,IACA;AAEA,aAAS,WAAYnD,QAAO,OAAO,KAAK;AACtC,UAAI,OAAOA,OAAM,WAAW,QAAW;AACrC,YAAI,WAAW,UAAU,OAAO;AAC9B,iBAAOA,OAAM,MAAM,OAAO,GAAG;AAAA,QACnC,OAAW;AAEL,cAAI,MAAMA,OAAM;AAGhB,kBAAQ,QAAQ;AAChB,kBAAS,QAAQ,IAAK,KAAK,IAAI,MAAM,OAAO,CAAC,IAAI,KAAK,IAAI,OAAO,GAAG;AAGpE,gBAAO,QAAQ,SAAa,MAAM,MAAM;AACxC,gBAAO,MAAM,IAAK,KAAK,IAAI,MAAM,KAAK,CAAC,IAAI,KAAK,IAAI,KAAK,GAAG;AAG5D,cAAI,aAAa,IAAI,WAAW,MAAM,KAAK;AAC3C,mBAAS,IAAI,OAAO,IAAI,GAAG,IAAI,OAAM;AACnC,uBAAW,GAAG,IAAIA,OAAM,GAAG;AAAA,UACnC;AAEM,iBAAO;AAAA,QACb;AAAA,MACA,OAAS;AAEL,eAAOA,OAAM,MAAM,OAAO,GAAG;AAAA,MACjC;AAAA,IACA;AAMA,YAAA,gBAAwB,SAAS,cAAe,GAAG;AACjD,aAAQ,IAAK,IAAI,MAAO,KAAM;AAAA,IAChC;AAGA,YAAA,kBAA0B,SAAS,gBAAiB,KAAK;AACvD,UAAI,SAAS;AAGb,UAAI8N,MAAK,QAAQ,KAAK,MAAM,MAAM,UAAU;AAC1C,cAAM,IAAI,MAAM,sBAAsB;AAAA,MAC1C;AAEE,gBAAU;AAGV,UAAI,aAAa,IAAI,QAAQ;AAG7B,WAAK,aAAa,mBAAmB,WAAW;AAC9C,cAAM,IAAI,MAAM,sCAAsC,aAAa,cAAc;AAAA,MACrF;AAGE,UAAI,eAAe,aAAa,mBAAmB;AACnD,UAAI,kBAAkB,aAAa,mBAAmB;AAGtD,UAAI,QAAS,IAAI,QAAQ,KAAK,UAAW;AAEzC,UAAI,MAAM,KAAK,MAAM,QAAW;AAC9B,cAAM,IAAI,MAAM,wBAAwB,KAAK;AAAA,MACjD;AAEE,UAAI,eAAe,MAAM,KAAK;AAG9B,UAAI,gBAAgB;AAClB,eAAOA,MAAK,QAAQ,KAAK,MAAM;AAAA,MACnC;AAGE;AAGA,UAAI,UAAU;AACd,aAAO,MAAM;AACX,YAAI,YAAYA,MAAK,QAAQ,KAAK,MAAM;AACxC,kBAAU;AAEV,YAAI,YAAY,gBAAgB;AAC9B,uBAAa,CAAC;AACd,qBAAW;AAAA,QACjB,OAAW;AACL,qBAAW;AAAA,QACjB;AAEI,YAAI,cAAc,GAAG;AACnB,iBAAO;AAAA,QACb;AAEI,YAAI,aAAa;AACf,oBAAU;AAAA,QAChB;AAEI,kBAAU;AAAA,MACd;AAAA,IACA;AAGA,YAAA,aAAqB;AAGrB,YAAA,kBAA0B,SAAS,gBAAiB,KAAK,KAAK,QAAQ,SAAS,QAAQ;AACrF,UAAI,SAAS,SAAS,MAAM,GAAG;AAG/B,aAAO,SAAS;AAGhB,aAAO,SAAS,MAAM;AACpB,YAAI,QAAQ,IAAI,QAAQ;AAGxB,YAAI,eAAgB,SAAS;AAC7B,YAAI,eAAe,GAAG;AAEpB,cAAI,iBAAiB,IAAK;AACxB,mBAAO,MAAM;AACX,8BAAgB,IAAI,MAAM;AAC1B,kBAAI,IAAI,QAAQ,MAAM,KAAM;AAC1B;AAAA,cACZ;AAAA,YACA;AAAA,UACA;AAGM,eAAK,IAAI,SAAS,cAAc,SAAS,KAAI;AAC3C,gBAAI,QAAQ,IAAI,IAAI,QAAQ;AAAA,UACpC;AAAA,QACA;AAEI,YAAI,UAAU,MAAM;AAClB;AAAA,QACN;AAGI,kBAAW,QAAQ;AAGnB,kBAAU,IAAI,QAAQ,IAAK,IAAI,QAAQ,KAAK;AAG5C,YAAI,YAAY,IAAK;AACnB,iBAAO,MAAM;AACX,uBAAW,IAAI,MAAM;AACrB,gBAAI,IAAI,QAAQ,MAAM,KAAM;AAC1B;AAAA,YACV;AAAA,UACA;AAAA,QACA;AAEI,mBAAW;AAGX,aAAK,IAAI,SAAS,SAAS,IAAI,IAAI,SAAS,IAAI,KAAI;AAClD,cAAI,QAAQ,IAAI,IAAI,GAAG,IAAI;AAAA,QACjC;AAAA,MACA;AAEE,aAAO;AAAA,IACT;AAGA,YAAA,gBAAwB,SAAS,cAAe,KAAK,KAAK,QAAQ,SAASK,YAAW;AACpF,UAAI,QAAQ,SAAS,SAAS,SAAS;AACvC,UAAI,cAAc,QAAQ,MAAM;AAGhC,eAAS;AACT,aAAO,UAAU;AACjB,gBAAU;AAGV,UAAI,WAAW,WAAW;AACxB,YAAI,oBAAoB,KAAK,eAAe;AAG5C,eAAO,SAAS,WAAW,OAAO,aAAa;AAC7C,cAAI,MAAML,MAAK,QAAQ,KAAK,MAAM;AAClC,cAAI,OAAOA,MAAK,QAAQ,GAAG,MAAM;AAGjC,kBAAS,QAAQ,KAAM,UAAU,IAAI;AAGrC,mBAASK,WAAU,IAAI,IAAI;AAG3B,UAAAA,WAAU,IAAI,IAAI,SAAS;AAG3B,cAAI,SAAS,KAAO,SAAS,WAAY,KAAM,KAAKL,MAAK,QAAQ,KAAK,MAAM,MAAM,KAAK;AACrF,oBAAQ,sBAAsB;AAC9B,sBAAU;AACV;AAAA,UACR;AAEM,8BAAoB,KAAK,eAAe;AAGxC,yBAAe,SAAS;AACxB,oBAAU,SAAS;AAGnB,oBAAU;AACV,oBAAU;AAKV,oBAAU;AACV,iBAAO,SAAS,OAAO,eAAe,IAAI,MAAM,MAAM,IAAI,MAAM,GAAG;AACjE;AACA;AAAA,UACR;AACM,oBAAU,SAAS;AAGnB,cAAI,QAAQ,UAAU,SAAS,UAAU;AACzC,cAAI,gBAAgB,SAAS;AAC3B,gBAAI,QAAQ,KAAK,WAAW,UAAU;AACtC,iBAAK,IAAI,eAAe,SAAS,KAAK,KAAM,KAAK,KAAM;AACrD,kBAAI,QAAQ,IAAI;AAAA,YAC1B;AACQ,gBAAI,QAAQ,IAAI;AAAA,UACxB,OAAa;AACL,gBAAI,QAAQ,KAAK,gBAAgB,UAAU;AAAA,UACnD;AAGM,mBAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACrC,gBAAI,QAAQ,IAAI,IAAI,UAAU,CAAC;AAAA,UACvC;AAGM,cAAI,QAAQ,IAAI;AAChB,cAAI,QAAQ,IAAK,WAAW;AAG5B,cAAI,WAAW,QAAQ;AACrB,iBAAK,IAAI,UAAU,QAAQ,KAAK,KAAM,KAAK,KAAM;AAC/C,kBAAI,QAAQ,IAAI;AAAA,YAC1B;AACQ,gBAAI,QAAQ,IAAI;AAAA,UACxB;AAGM,oBAAU;AAAA,QAChB;AAAA,MACA;AAGE,UAAI,YAAY,GAAG;AACjB,eAAO;AAAA,MACX;AAIE,qBAAe,OAAO;AACtB,UAAI,gBAAgB,SAAS;AAC3B,YAAI,QAAQ,IAAK,WAAW;AAC5B,aAAK,IAAI,eAAe,SAAS,KAAK,KAAM,KAAK,KAAM;AACrD,cAAI,QAAQ,IAAI;AAAA,QACtB;AACI,YAAI,QAAQ,IAAI;AAAA,MACpB,OAAS;AACL,YAAI,QAAQ,IAAK,gBAAgB;AAAA,MACrC;AAGE,eAAS;AACT,aAAO,SAAS,MAAM;AACpB,YAAI,QAAQ,IAAI,IAAI,QAAQ;AAAA,MAChC;AAEE,aAAO;AAAA,IACT;AAGA,YAAA,kBAA0B,SAAS,gBAAiB,KAAK,KAAK;AAC5D,UAAI,aAAa,eAAe,gBAAgB;AAChD,UAAI,SAAS;AACb,UAAI,SAAS;AAGb,UAAIA,MAAK,QAAQ,KAAK,MAAM,MAAM,UAAU;AAC1C,cAAM,IAAI,MAAM,sBAAsB;AAAA,MAC1C;AAEE,gBAAU;AAGV,mBAAa,IAAI,QAAQ;AAGzB,WAAK,aAAa,mBAAmB,WAAW;AAC9C,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACrD;AAGE,qBAAe,aAAa,mBAAmB;AAC/C,uBAAiB,aAAa,qBAAqB;AACnD,wBAAkB,aAAa,mBAAmB;AAGlD,UAAI,QAAS,IAAI,QAAQ,KAAK,UAAW;AAEzC,UAAI,MAAM,KAAK,MAAM,QAAW;AAC9B,cAAM,IAAI,MAAM,oBAAoB;AAAA,MACxC;AAEE,UAAI,gBAAgB;AAElB,kBAAU;AAAA,MACd;AAEE;AAGA,aAAO,MAAM;AACX,YAAI;AAEJ,mBAAWA,MAAK,QAAQ,KAAK,MAAM;AACnC,kBAAU;AAEV,YAAI,aAAa,GAAG;AAClB;AAAA,QACN;AAEI,YAAI,aAAa;AAEf,oBAAU;AAAA,QAChB;AAGI,aAAK,WAAW,oBAAoB,GAAG;AAErC,sBAAY,CAAC;AAGb,mBAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,gBAAI,QAAQ,IAAI,IAAI,QAAQ;AAAA,UACpC;AAAA,QACA,OAAW;AAEL,mBAAS,QAAQ,gBAAgB,KAAK,KAAK,QAAQ,UAAU,MAAM;AACnE,oBAAU;AAAA,QAChB;AAAA,MACA;AAEE,UAAI,eAAe;AAEjB,kBAAU;AAAA,MACd;AAEE,aAAO;AAAA,IACT;AAGA,YAAA,gBAAwB,SAAS,cAAe,KAAK,KAAK;AACxD,UAAI,SAAS;AAGb,MAAAA,MAAK,SAAS,KAAK,QAAQ,QAAQ;AACnC,gBAAU;AAGV,UAAI,QAAQ,IAAI;AAChB,UAAI,QAAQ,IAAI,aAAa;AAG7B,UAAI,MAAM,IAAI,OAAO,KAAK,GAAG,KAAK,GAAG,SAAS,CAAC,KAAK;AACpD;AAGA,UAAI,eAAe,MAAM,SAAS;AAClC,UAAI,YAAY,IAAI;AACpB,UAAI,SAAS;AAGb,qBAAwB;AAGxB,aAAO,YAAY,GAAG;AACpB,YAAI,WAAW;AACf,YAAI,YAAY,YAAY,eAAe,eAAe;AAE1D,mBAAW,QAAQ,cAAc,KAAK,UAAU,QAAQ,WAAW,SAAS;AAE5E,YAAI,WAAW,aAAa,aAAa,GAAG;AAE1C,UAAAA,MAAK,SAAS,KAAK,QAAQ,aAAa,SAAS;AACjD,oBAAU;AAEV,mBAAS,IAAI,SAAS,WAAW,SAAS,KAAI;AAC5C,gBAAI,QAAQ,IAAI,IAAI,QAAQ;AAAA,UACpC;AAEM,uBAAa;AAAA,QACnB,OAAW;AAEL,UAAAA,MAAK,SAAS,KAAK,QAAQ,QAAQ;AACnC,oBAAU;AAEV,mBAAS,IAAI,GAAG,IAAI,YAAW;AAC7B,gBAAI,QAAQ,IAAI,SAAS,GAAG;AAAA,UACpC;AAEM,oBAAU;AACV,uBAAa;AAAA,QACnB;AAAA,MACA;AAGE,MAAAA,MAAK,SAAS,KAAK,QAAQ,CAAC;AAC5B,gBAAU;AAEV,aAAO;AAAA,IACT;AAKA,YAAA,aAAqB,SAAS,WAAY,KAAK,SAAS;AACtD,UAAI,KAAK;AAET,UAAI,YAAY,QAAW;AACzB,kBAAU,QAAQ,gBAAgB,GAAG;AAAA,MACzC;AAEE,YAAM,QAAQ,WAAW,OAAO;AAChC,aAAO,QAAQ,gBAAgB,KAAK,GAAG;AAEvC,UAAI,SAAS,SAAS;AACpB,cAAM,WAAW,KAAK,GAAG,IAAI;AAAA,MACjC;AAEE,aAAO;AAAA,IACT;AAKA,YAAA,WAAmB,SAAS,SAAU,KAAK,SAAS;AAClD,UAAI,KAAK;AAET,UAAI,YAAY,QAAW;AACzB,kBAAU,QAAQ,cAAc,IAAI,MAAM;AAAA,MAC9C;AAEE,YAAM,QAAQ,WAAW,OAAO;AAChC,aAAO,QAAQ,cAAc,KAAK,GAAG;AAErC,UAAI,SAAS,SAAS;AACpB,cAAM,WAAW,KAAK,GAAG,IAAI;AAAA,MACjC;AAEE,aAAO;AAAA,IACT;AAAA;;;;ACxhBO,MAAM,mBAAmB,CAAC,UAAoC;AAEnE,2BAAA;AAMA,QAAM,aAAazG,eAAa,KAAK;AAGrC,QAAM,oBAAoBE,aAAW,UAAU;AAG/C,MAAI9I,UAAQ,UAAU,iBAAiB;AAIvCA,YAAQ,YAAYA,OAAK;AAOzB,QAAM2H,WAAqC,CAAA;AAC3C,QAAM,cAAc3H,QAAM,YAAA;AAI1B,aAAW,WAAW,aAAa;AAGjC,UAAM,UAAUA,QAAM,MAAM,OAAO;AACnC,IAAA2H,SAAQ,OAAO,IAAI,MAAM,QAAQ,OAAO,IACpC,UACA,MAAM,KAAK,OAA4B;AAAA,EAC7C;AAIA,SAAOgI,MAAahI,QAAO;AAC7B;AAGA,IAAI,kBAAkB;AACtB,SAAS,2BAAiC;AACxC,MAAI,CAAC,iBAAiB;AACpB,UAAM,WAAkB;AAAA,MACtB,OAAO3G,OAA8B;AACnC,eAAO4O,WAAAA,SAAe5O,KAAI;AAAA,MAC5B;AAAA,MACA,OAAOA,OAA8B;AACnC,eAAO6O,WAAAA,WAAiB7O,KAAI;AAAA,MAC9B;AAAA,IAAA;AAEF,wBAAoB,IAAI,gBAAgB,WAAW,QAAQ;AAC3D,sBAAkB;AAAA,EACpB;AACF;AAKA,SAAS,YAAYhB,QAAiC;AACpD,QAAM,cAAcA,OAAM,YAAA;AAC1B,QAAM,WACJ,YAAY,SAAS,OAAO,KAAK,YAAY,SAAS,YAAY;AACpE,QAAM,iBAAiB,YAAY,SAAS,oBAAoB;AAGhE,MAAI,CAAC,YAAY,CAAC,gBAAgB;AAChC,WAAOA;AAAA,EACT;AAGA,QAAM,YAAY,CAChBlC,QACA,cACqC;AACrC,QAAIA,WAAU,QAAQA,WAAU,QAAW;AACzC,aAAO;AAAA,IACT;AAEA,QAAI,cAAc,WAAW;AAE3B,UAAI,OAAOA,WAAU,WAAW;AAC9B,eAAOA;AAAA,MACT;AAEA,YAAM,SAAS,OAAOA,MAAK,EAAE,YAAA;AAC7B,UAAI,WAAW,QAAQ;AACrB,eAAO;AAAA,MACT;AACA,UAAI,WAAW,SAAS;AACtB,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,WAAW,cAAc,UAAU;AAEjC,UAAI,OAAOA,WAAU,UAAU;AAC7B,eAAOA;AAAA,MACT;AAEA,YAAM,SAAS,OAAOA,MAAK,EAAE,KAAA;AAC7B,UAAI,WAAW,IAAI;AAEjB,eAAO;AAAA,MACT;AACA,YAAM,MAAM,OAAO,MAAM;AACzB,aAAO,MAAM,GAAG,IAAI,OAAO;AAAA,IAC7B,OAAO;AAEL,aAAOA;AAAA,IACT;AAAA,EACF;AAGA,QAAM,cAGF,CAAA;AAEJ,MAAI,UAAU;AACZ,gBAAY,QAAQ,OAAO,CAAC,MAA8C;AACxE,aAAO,UAAU,EAAE,OAAO,EAAE,UAAU;AAAA,IACxC,CAAC;AAAA,EACH;AAEA,MAAI,gBAAgB;AAClB,gBAAY,qBAAqB;AAAA,MAC/B,CAAC,MAAsC;AACrC,YAAI,OAAO,EAAE,uBAAuB,UAAU;AAC5C,iBAAO,EAAE,oBAAoB,YAAA,MAAkB;AAAA,QACjD;AAEA,eAAO,CAAC,CAAC,EAAE;AAAA,MACb;AAAA,IAAA;AAAA,EAEJ;AAGA,SAAOkC,OAAM,OAAO,WAAW;AACjC;ACxIA,eAAsB,oBACpB,aACsB;AAKtB,QAAM,WAAW,YAAY,YAAA;AAC7B,MAAI,CAAC,SAAS,SAAS,YAAY,GAAG;AACpC,UAAM,UAAU,YAAY,QAAA;AAC5B,UAAM,cAAc,IAAI,MAAc,OAAO;AAC7C,QAAI,SAAS,SAAS,MAAM,GAAG;AAC7B,YAAM,QAAQ,YAAY,MAAM,MAAM;AACtC,eAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,oBAAY,CAAC,IAAI,MAAM,CAAC,KAAK,OAAO,WAAA;AAAA,MACtC;AAAA,IACF,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,oBAAY,CAAC,IAAI,OAAO,WAAA;AAAA,MAC1B;AAAA,IACF;AACA,kBAAc,YAAY,OAAO,EAAE,YAAY,aAAa;AAAA,EAC9D;AAGA,MACE,CAAC,SAAS,SAAS,YAAY,KAC/B,CAAC,SAAS,SAAS,OAAO,KAC1B,YAAY,QAAA,MAAc,GAC1B;AACA,WAAO;AAAA,EACT;AAGA,QAAM,iBAAiB,YACpB,OAAO,CAAC,MAA8B,EAAE,eAAe,WAAW,EAClE,QAAA;AACH,MAAI,mBAAmB,GAAG;AAExB,WAAO;AAAA,EACT;AAGA,QAAM,gBAAgB,YAAY;AAAA,IAChC,CAAC,MAA8B,EAAE,eAAe;AAAA,EAAA;AAElD,QAAM,YAAY,YAAY;AAAA,IAC5B,CAAC,MAA8B,EAAE,eAAe;AAAA,EAAA;AAKlD,QAAM,aAAa,cAAc,QAAA;AACjC,QAAM,wBAAmD,CAAA;AAEzD,aAAW,OAAO,YAAY;AAC5B,QAAI;AAEF,YAAM8P,YAAW,IAAI;AACrB,YAAM,UAAUA,YAAWC,IAAM,MAAgBD,SAAQ,IAAI,CAAA;AAI7D,UAAI,CAAC,WAAW,QAAQ,WAAW,GAAG;AACpC,cAAM,cAAc,EAAE,GAAG,IAAA;AACzB,oBAAY,QAAQ;AACpB,oBAAY,aAAa;AACzB,8BAAsB,KAAK,WAAW;AACtC;AAAA,MACF;AAEA,iBAAWnS,WAAU,SAAS;AAC5B,cAAM,cAAc,EAAE,GAAG,IAAA;AAGzB,oBAAY,aAAaA,QAAO,QAAQ,OAAO,WAAA;AAI/C,oBAAY,QAAQA,QAAO,SAAS;AACpC,oBAAY,SAASA,QAAO,UAAU;AACtC,oBAAY,cAAcA,QAAO,eAAe;AAGhD,YACE,IAAI,qBACJ,OAAO,IAAI,sBAAsB,UACjC;AACA,sBAAY,oBAAoB,MAAM;AAAA,YACpC;AAAA,YACA,IAAI;AAAA,UAAA;AAAA,QAER;AAGA,cAAM,WAAWA,QAAO,YAAY,CAAA;AACpC,oBAAY,WAAW,oBAAoB,QAAQ;AAGnD,cAAM,YAAYA,QAAO,QAAQ,UAAUA,QAAO,KAAK;AACvD,oBAAY,aAAa;AAGzB,cAAMG,SAAQ,oBAAoBH,QAAO,KAAK;AAC9C,oBAAY,QAAQG;AAGpB,cAAM,aAAaH,QAAO,cAAc,CAAA;AACxC,cAAM,cAAc,WAAW,OAAO,CAACiO,SAAQA,KAAI,SAAS,SAAS;AACrE,cAAM,YAAY,WAAW,OAAO,CAACA,SAAQA,KAAI,SAAS,OAAO;AACjE,oBAAY,qBAAqB,oBAAoB,WAAW;AAChE,oBAAY,mBAAmB,oBAAoB,SAAS;AAQ5D,8BAAsB,KAAK,WAAW;AAAA,MACxC;AAAA,IACF,SAAS3N,QAAO;AACd,cAAQ,MAAM,oCAAoCA,MAAK;AACvD;AAAA,IACF;AAAA,EACF;AAGA,QAAM,gBAAgB,MAAM;AAAA,IAC1B;AAAA,IACA;AAAA,EAAA;AAIF,MAAI,sBAAsB,WAAW,GAAG;AACtC,WAAO;AAAA,EACT,OAAO;AAEL,UAAM,iBAAiB,UAAU,QAAA;AAEjC,UAAM,eAAe;AAAA,MACnB,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IAAA;AAIL,WAAO,KAAK,YAAY;AAAA,EAC1B;AACF;AAEA,eAAe,uBACb,KACA,qBAC4C;AAC5C,MAAI,CAAC,IAAI,SAAS,OAAO,IAAI,UAAU,UAAU;AAC/C,WAAO;AAAA,EACT;AAEA,MAAI;AACF,UAAM,mBAAmB,MAAM,eAAwB,mBAAmB;AAG1E,QACE,OAAO,qBAAqB,YAC5B,qBAAqB,QACrB,CAAC,MAAM,QAAQ,gBAAgB,GAC/B;AAEA,YAAM,iBAAiB;AACvB,YAAM,kBAAkB,eAAe,IAAI,KAAK;AAChD,aAAO,mBAAmB;AAAA,IAC5B;AAGA,WAAO;AAAA,EACT,SAASA,QAAO;AAEd,WAAO;AAAA,EACT;AACF;AAaA,eAAe,oBACb,cACA,eACoC;AACpC,MAAI,cAAc,WAAW,KAAK,aAAa,WAAW,GAAG;AAC3D,WAAO,CAAA;AAAA,EACT;AAGA,QAAM,WAAW,aAAa,CAAC;AAC/B,MACE,CAAC,YACD,CAAC,SAAS,qBACV,OAAO,SAAS,sBAAsB,UACtC;AACA,WAAO,CAAA;AAAA,EACT;AAEA,MAAI;AAEF,UAAM,eAAe,MAAM;AAAA,MACzB,SAAS;AAAA,IAAA;AAEX,QACE,OAAO,iBAAiB,YACxB,iBAAiB,QACjB,MAAM,QAAQ,YAAY,GAC1B;AACA,aAAO,CAAA;AAAA,IACT;AAEA,UAAM,mBAAmB;AAGzB,UAAM,eAAe,SAAS,oBAC1B,MAAM;AAAA,MACJ,OAAO,SAAS,sBAAsB,WAClC,SAAS,oBACT,KAAK,UAAU,SAAS,iBAAiB;AAAA,IAAA,IAE/C,CAAA;AACJ,UAAM,oBACJ,OAAO,iBAAiB,YAAY,CAAC,MAAM,QAAQ,YAAY,IAC1D,eACD,CAAA;AAGN,UAAM,gBAAgB,IAAI;AAAA,MACxB,aACG,IAAI,CAAC,QAAQ,IAAI,KAAK,EACtB,OAAO,CAAC,UAAU,UAAU,QAAQ,UAAU,MAAS;AAAA,IAAA;AAI5D,UAAM,iBAAiB,OAAO,KAAK,gBAAgB;AAGnD,UAAM,gBAAgB,eAAe;AAAA,MACnC,CAAC,UAAU,CAAC,cAAc,IAAI,KAAK;AAAA,IAAA;AAIrC,UAAM,gBAA2C,CAAA;AACjD,UAAM,iBAAiB,CAAC,OAAO,MAAM,QAAQ,QAAQ,GAAG,EAAE;AAE1D,eAAW,SAAS,eAAe;AACjC,YAAM,gBAAgB,iBAAiB,KAAK;AAG5C,UAAI,CAAC,eAAe,SAAS,aAAsB,GAAG;AACpD;AAAA,MACF;AAGA,YAAM,cAAc,EAAE,GAAG,cAAc,CAAC,EAAA;AAGxC,kBAAY,QAAQ;AACpB,kBAAY,QAAQ;AACpB,kBAAY,aACV,OAAO,kBAAkB,YAAY,YAAY;AACnD,kBAAY,SAAS;AACrB,kBAAY,cAAc;AAC1B,kBAAY,WAAW,oBAAoB,EAAE;AAC7C,kBAAY,qBAAqB,oBAAoB,EAAE;AACvD,kBAAY,mBAAmB,oBAAoB,EAAE;AACrD,kBAAY,OAAO;AACnB,kBAAY,aAAa,OAAO,WAAA;AAGhC,kBAAY,oBAAoB,kBAAkB,KAAK,KAAK;AAG5D,kBAAY,aAAa;AACzB,kBAAY,uBAAuB;AACnC,kBAAY,kBAAkB;AAG9B,kBAAY,oBAAoB;AAChC,kBAAY,mBAAmB;AAE/B,oBAAc,KAAK,WAAW;AAAA,IAChC;AAEA,WAAO;AAAA,EACT,SAASA,QAAO;AAEd,WAAO,CAAA;AAAA,EACT;AACF;AAEA,SAAS,UAAUH,QAA2B;AAC5C,MAAI,OAAOA,WAAU,WAAW;AAC9B,WAAO;AAAA,EACT,WAAW,OAAOA,WAAU,UAAU;AACpC,WAAO;AAAA,EACT,WAAW,OAAOA,WAAU,UAAU;AACpC,WAAO;AAAA,EACT,WAAW,MAAM,QAAQA,MAAK,GAAG;AAC/B,WAAO;AAAA,EACT,WAAWA,WAAU,QAAQ,OAAOA,WAAU,UAAU;AACtD,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEA,MAAM,sBAAsB,CAC1BA,WACqC;AACrC,MAAIA,WAAU,UAAaA,WAAU,MAAM;AACzC,WAAO;AAAA,EACT;AACA,MACE,OAAOA,WAAU,YACjB,OAAOA,WAAU,YACjB,OAAOA,WAAU,WACjB;AACA,WAAOA;AAAA,EACT;AAEA,SAAOiS,IAAM,UAAUjS,MAAK;AAC9B;AC5VO,MAAM,mBAAmB,CAC9B,WAC2B;AAC3B,QAAM,MAAM,OAAA;AAEZ,SAAO,sBAAsB;AAAA,IAC3B,UACE,WAAW,YACP,CAAC,SAAS,IACV;AAAA,MACE;AAAA,MACA,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP;AAAA,IAAA;AAAA,IAER,SACE,WAAW,YACP,YACA,YACE;AAAA,MACE;AAAA,QACE,MAAM,IAAI;AAAA,UACR,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO;AAAA,QAAA;AAAA,MACT;AAAA,IACF;AAAA,IAEV,WAAW;AAAA,EAAA,CACZ;AACH;ACtCO,MAAM,qBAAqB,MAAyB;AACzD,QAAM,kBAAkB,SAAS,CAAC,UAAU,MAAM,eAAe;AAGjE,QAAM,iBAAiB;AAAA,IACrB,gBAAA;AAAA,IACA;AAAA,EAAA;AAGF,QAAM,2BAA2BkS,aAAAA;AAAAA,IAC/B,MAAO,kBAAkBhP,OAAK,eAAe,IAAI;AAAA,IACjD,CAAC,eAAe;AAAA,EAAA;AAGlB,SAAO,4BAA4B;AACrC;AAEA,MAAM,uBAAuB,CAAC,MAAsB;AAClD,QAAMrD,UAAS,EAAE,QAAQ,WACrB,OAAO,KAAK,EAAE,QAAQ,QAAQ,EAAE,CAAC,IACjC;AACJ,MAAI,CAACA,SAAQ;AACX,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC5C;AACA,SAAOA;AACT;ACzBO,MAAM,2BAA2B,MAA8B;AACpE,QAAM,EAAE,kBAAkB,SAAA,IAAa,aAAA;AACvC,QAAM,UAAU,mBAAA;AAEhB,SAAO;AAAA,IACL,oBAAoB,YAAY,QAAQ,OACpC,EAAE,UAAU,kBAAkB,UAAU,SAAS,QAAQ,KAAA,IACzD;AAAA,EAAA;AAER;ACPO,MAAM,sBAAsB,OACjC,aAC4B;AAC5B,QAAM,YAAY,SAAS,IAAI,cAAc,CAAC;AAE9C,QAAM,4BAA4B;AAAA,IAChC;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAIF,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACAG;AAAA,IACA;AAAA,IACA;AAAA,EAAA,IACE,MAAM,QAAQ,IAAI;AAAA,IACpB,UAAU,SAAS,IAAI,oBAAoB,CAAC,CAAW;AAAA,IACvD,UAAU,SAAS,IAAI,aAAa,CAAC,CAAW;AAAA,IAChD,UAAU,SAAS,IAAI,sBAAsB,CAAC,CAAW;AAAA,IACzD,UAAU,SAAS,IAAI,YAAY,CAAC,CAAW;AAAA,IAC/C,UAAU,SAAS,IAAI,eAAe,CAAC,CAAW;AAAA,IAClD,UAAU,SAAS,IAAI,iBAAiB,CAAC,CAAW;AAAA,IACpD,UAAU,SAAS,IAAI,oBAAoB,CAAC,CAAW;AAAA,IACvD,UAAU,SAAS,IAAI,aAAa,CAAC,CAAW;AAAA,IAChD,UAAU,SAAS,IAAI,kBAAkB,CAAC,CAAW;AAAA,IACrD,UAAU,SAAS,IAAI,uBAAuB,CAAC,CAAW;AAAA,IAC1D;AAAA,MACE,SAAS,IAAI,qBAAqB,CAAC;AAAA,IAAA;AAAA,IAErC,aAAwB,SAAS,IAAI,qBAAqB,CAAC,CAAC;AAAA,IAC5D,iBAAiB,SAAS,IAAI,SAAS,CAAC,GAAG,SAAS;AAAA,IACpD,4BACI,UAAU,yBAAyB,IACnC,QAAQ,QAAQ,MAAS;AAAA,IAC7B,yBAAyB,QAAQ,yBAAyB,SACtD,eAAe,oBAAoB,IACnC,QAAQ,QAAQ,MAAS;AAAA,EAAA,CAC9B;AAED,QAAM,aAAa,SAAS,IAAI,cAAc,CAAC;AAC/C,QAAM,OAAO,SAAS,IAAI,QAAQ,CAAC;AACnC,QAAMiM,aAAY,kBAA0B,UAAU,WAAW;AACjE,QAAM,SAAS,SAAS,IAAI,UAAU,CAAC;AACvC,QAAM,QAAQ,kBAA0B,UAAU,OAAO;AACzD,QAAM,cAAc,SAAS,IAAI,eAAe,CAAC;AACjD,QAAM,YAAY,SAAS,IAAI,cAAc,CAAC;AAM9C,QAAM,YAAY,SAAS,IAAI,cAAc,CAAC;AAC9C,QAAM,qBAAqB,SAAS,IAAI,wBAAwB,CAAC;AAGjE,QAAM,mBACJ,kBAA2B,UAAU,oBAAoB,KAAK;AAChE,QAAM,SAAS,SAAS,IAAI,WAAW,CAAC;AACxC,QAAM,kBAAkB,SAAS,IAAI,qBAAqB,CAAC;AAC3D,QAAM,cAAc,SAAS,IAAI,gBAAgB,CAAC;AAClD,QAAM,aAAa,SAAS,IAAI,eAAe,CAAC;AAChD,QAAM,cAAc,SAAS,IAAI,gBAAgB,CAAC;AAClD,QAAM,eAAe,SAAS,IAAI,iBAAiB,CAAC;AACpD,QAAM,qBAAqB,SAAS,IAAI,wBAAwB,CAAC;AACjE,QAAM,sBAAsB,SAAS;AAAA,IACnC;AAAA,IACA;AAAA,EAAA;AAGF,QAAM,oBAAoB;AAAA,IACxB;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,iBAAiB,kBAA0B,UAAU,iBAAiB;AAC5E,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,oBAAoB;AAAA,IACxB;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,sBAAsB;AAAA,IAC1B;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,wBAAwB;AAAA,IAC5B;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,yBAAyB;AAAA,IAC7B;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,EAAA;AAGF,QAAM,WAAW;AAAA,IACf;AAAA,IACA;AAAA,IACA,WAAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,oBAAqB,sBAAsB,CAAA;AAAA,IAC3C;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAOjM,UAAS;AAAA,IAChB;AAAA,EAAA;AAMF,0CAAwC,QAAQ;AAEhD,SAAO,EAAE,GAAG,UAAU,UAAA;AACxB;AAEO,MAAM,2BAA2B,OACtC,YAEA,QAAQ;AAAA,EACN,QAAQ,IAAI,OAAO,QAAQ;AACzB,UAAM,IAAI;AAEV,UAAM,YAAY,EAAE;AAGpB,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,IAAA,IACE,MAAM,QAAQ,IAAI;AAAA,MACpB,aAAgD,EAAE,iBAAiB;AAAA,MACnE,aAAwB,EAAE,iBAAiB;AAAA,MAC3C,UAAqC,EAAE,mBAA6B;AAAA,MACpE,UAAU,EAAE,gBAA0B;AAAA,MACtC,UAAU,EAAE,kBAA4B;AAAA,MACxC,iBAAiB,EAAE,OAAO,SAAS;AAAA,IAAA,CACpC;AAED,UAAM,cAAc;AAAA,MAClB,YAAY,EAAE;AAAA,MACd,MAAM,EAAE;AAAA,MACR,OAAO,EAAE;AAAA,MACT,aAAa,EAAE;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAOA,UAAS;AAAA,MAChB;AAAA,MACA,mBAAmB,EAAE;AAAA,MACrB,kBAAkB,EAAE;AAAA,MACpB,sBAAsB,EAAE;AAAA,MACxB,iBAAiB,EAAE;AAAA,MACnB,oBAAoB,sBAAsB,CAAA;AAAA,MAC1C,oBAAoB,EAAE;AAAA,MACtB,WAAW,EAAE;AAAA,MACb,kBAAkB,EAAE;AAAA,MACpB,WAAW,EAAE,YAAa,EAAE,YAAuB;AAAA,IAAA;AAGrD,4CAAwC,WAAW;AAEnD,UAAM,YAAY,EAAE;AAOpB,WAAO,EAAE,GAAG,aAAa,UAAA;AAAA,EAC3B,CAAC;AACH;AAEF,SAAS,wCAQPkD,OAAe;AACf,MAAIA,MAAK,oBAAoB,QAAW;AACtC,IAAAA,MAAK,kBAAkBA,MAAK,mBAAmB,OAAO;AAAA,EACxD;AAEA,MAAIA,MAAK,sBAAsB,QAAW;AACxC,IAAAA,MAAK,oBAAoBA,MAAK,mBAAmB,WAAW;AAAA,EAC9D;AAEA,MAAIA,MAAK,qBAAqB,QAAW;AACvC,IAAAA,MAAK,mBAAmBA,MAAK,mBAAmB,IAAI;AAAA,EACtD;AAEA,MAAIA,MAAK,yBAAyB,QAAW;AAC3C,IAAAA,MAAK,uBAAuBA,MAAK,mBAAmB,OAAO;AAAA,EAC7D;AACF;AAEA,MAAM,YAAY,OAAU,SAC1B,SAAS,OAAO,eAAkB,IAAI,IAAI;AAE5C,MAAM,eAAe,OAAU,SAA8B;AAC3D,MAAI;AACF,WAAO,MAAM,eAAkB,IAAc;AAAA,EAC/C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAIA,MAAM,mBAAmB,CACvB,KACA,cAIA,cAAc,YAAY,cAAc,UACpC,UAA8B,GAAa,IAC3C,QAAQ,QAAQ,GAAuC;AAE7D,MAAM,iBAAiB,CAAC,QAAkD;AACxE,MAAI,CAAC,KAAK;AACR,WAAO,QAAQ,QAAQ,MAAS;AAAA,EAClC;AAEA,MAAI,OAAO,QAAQ,YAAY,OAAO,GAAG,GAAG;AAC1C,WAAO,UAAqB,GAAG,EAAE,KAAK,CAAC,WAAW,MAAmB;AAAA,EACvE,OAAO;AACL,WAAO,QAAQ,QAAQ,GAAgB;AAAA,EACzC;AACF;AAEA,SAAS,kBACPhB,QACA,YACA,WAAmB,GACJ;AACf,SAAOA,OAAM,cAAc,SAAS,UAAU,IACzCA,OAAM,IAAI,YAAY,QAAQ,IAC/B;AACN;ACzLO,SAAS,cACdrC,SACsE;AACtE,SAAOA,QAAO,cAAc;AAC9B;AAEO,SAAS,cACdA,SACsE;AACtE,SAAOA,QAAO,cAAc;AAC9B;AAEO,SAAS,eACdA,SACwE;AACxE,SAAOA,QAAO,cAAc;AAC9B;AAEO,SAAS,YACdA,SACkE;AAClE,SAAOA,QAAO,cAAc;AAC9B;AAEO,SAAS,aACdA,SACwE;AACxE,SAAOA,QAAO,cAAc;AAC9B;AAEO,SAAS,cACdA,SACsE;AACtE,SAAOA,QAAO,cAAc;AAC9B;AAGO,SAAS,kBACd,OAIA;AACA,SAAO,MAAM,cAAc;AAC7B;AAEO,SAAS,eACd,OAC6E;AAC7E,SAAO,MAAM,cAAc;AAC7B;AAEO,SAAS,gBACd,OAIA;AACA,SAAO,MAAM,cAAc;AAC7B;AAEO,SAAS,aACd,OACyE;AACzE,SAAO,MAAM,cAAc;AAC7B;AAEO,SAAS,cACd,OACwE;AACxE,SAAO,MAAM,cAAc;AAC7B;ACxMO,MAAM,cAAoC,CAAC;AAAA,EAChD;AAAA,EACA;AAAA,EACA;AACF,MAAiB;AACf,SACEE,kCAAAA;AAAAA,IAAC;AAAA,IAAA;AAAA,MACC,UAAU,SAAS,eAAe;AAAA,MAClC;AAAA,MACA;AAAA,IAAA;AAAA,EAAA;AAGN;;;;;;;;;ACdO,MAAM,mBAA8C,CAAC;AAAA,EAC1D,QAAAF;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAEJ,MAAI,OAAOA,YAAW,WAAW;AAC/B,WACEE,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,OAAOF;AAAA,QACP,aAAa,SAAS,mBAAmB,QAAQ,KAAK,CAAC;AAAA,MAAA;AAAA,IAAA;AAAA,EAG7D,WAAWA,YAAW,QAAQ,OAAOA,YAAW,UAAU;AACxD,UAAMyE,WAAU,OAAO,QAAQzE,OAAM;AAErC,WACEE,kCAAAA,IAAC,OAAA,EAAI,WAAW,KAAKoR,SAAO,eAAe,GACxC,UAAA7M,SAAQ,IAAI,CAAC,CAACC,MAAKvE,MAAK,4CACtB,OAAA,EACC,UAAAD,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,OAAAC;AAAA,QACA,aAAa,SAAS,mBAAmB,QAAQuE,IAAG,CAAC;AAAA,MAAA;AAAA,IAAA,EACvD,GAJQ,qBAAqBA,IAAG,EAKlC,CACD,EAAA,CACH;AAAA,EAEJ;AACF;AAEA,MAAM,SAAuD,CAAC;AAAA,EAC5D,OAAAvE;AAAA,EACA,aAAAmS;AACF,MAAM;AACJ,gDACG,OAAA,EACC,UAAA;AAAA,IAAApS,kCAAAA,IAAC,OAAA,EAAI,WAAW,KAAKC,SAAQmR,SAAO,OAAOA,SAAO,OAAOA,SAAO,MAAM,GACnE,UAAAnR,SACCD,kCAAAA,IAAC,KAAA,EAAE,WAAW,KAAK,iBAAiB,KAAK,EAAA,CAAG,IAE5CA,kCAAAA,IAAC,KAAA,EAAE,WAAW,KAAK,iBAAiB,CAAC,EAAA,CAAG,EAAA,CAE5C;AAAA,IACAA,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,WAAW;AAAA,UACToR,SAAO;AAAA,UACP;AAAA,UACA;AAAA,QAAA;AAAA,QAEF,OAAOgB;AAAA,QAEN,UAAAA;AAAA,MAAA;AAAA,IAAA;AAAA,EACH,GACF;AAEJ;AAEA,MAAM,qBAAqB,CAAC,QAAoB5N,SAA4B;AAC1E,MAAI,WAAW,QAAW;AACxB,WAAO;AAAA,EACT;AAEA,MAAIA,SAAQ,QAAW;AACrB,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,OAAO,WAAW,YAAY,CAAC,MAAM,QAAQ,MAAM,GAAG;AAClE,WAAQ,OAAqCA,IAAG,KAAK;AAAA,EACvD;AACA,SAAO;AACT;AAEA,MAAM,WAAW,CAAC,WAA+B;AAC/C,MAAI,WAAW,MAAM;AACnB,WAAO;AAAA,EACT,WAAW,OAAO,WAAW,UAAU;AACrC,WAAO;AAAA,EACT,WAAW,OAAO,WAAW,YAAY,OAAO,WAAW,WAAW;AACpE,WAAO,OAAO,SAAA;AAAA,EAChB,WAAW,MAAM,QAAQ,MAAM,GAAG;AAChC,WAAO,UAAU,OAAO,MAAM;AAAA,EAChC,WAAW,OAAO,WAAW,UAAU;AACrC,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACF;;;;;;;;;;;;;;;;;AClEO,MAAM,QAAwB,CAAC;AAAA,EACpC,SAAS1E;AAAA,EACT;AAAA,EACA;AAAA,EACA,eAAe;AAAA,EACf,cAAc;AAAA,EACd;AACF,MAAiB;AACf,MAAI,cAAcA,OAAM,GAAG;AACzB,WACEE,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,UAAUF,QAAO;AAAA,QACjB;AAAA,QACA;AAAA,MAAA;AAAA,IAAA;AAAA,EAGN,WAAW,cAAcA,OAAM,KAAKA,QAAO,UAAU,MAAM;AACzD,WAAO,oBAAoBA,QAAO,KAAK;AAAA,EACzC,WAAW,eAAeA,OAAM,GAAG;AACjC,WACEE,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,WAAW;AAAA,UACT,OAAO;AAAA,UACPF,QAAO,QAAQ,OAAO,OAAO,OAAO;AAAA,QAAA;AAAA,QAGrC,UAAA,OAAOA,QAAO,KAAK;AAAA,MAAA;AAAA,IAAA;AAAA,EAG1B,WAAW,YAAYA,OAAM,GAAG;AAC9B,WAAOE,kCAAAA,IAAC,UAAK,UAAA,OAAA,CAAI;AAAA,EACnB,WAAW,aAAaF,OAAM,GAAG;AAC/B,WACEE,kCAAAA;AAAAA,MAACsN;AAAA,MAAA;AAAA,QACC,OAAOxN,QAAO;AAAA,QACd,SAASA;AAAA,QACT;AAAA,QACA;AAAA,QACA,aAAa;AAAA,QACb;AAAA,MAAA;AAAA,IAAA;AAAA,EAGN,WAAW,cAAcA,OAAM,GAAG;AAChC,WACEE,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,OAAOF,QAAO;AAAA,QACd,SAASA;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IAAA;AAAA,EAGN,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,MAAMwN,aAOD,CAAC;AAAA,EACJ,OAAArN;AAAA,EACA,SAASH;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAEJ,QAAM,iBAAiBG,OAAM,MAAM,GAAG,WAAW;AAGjD,SACED,kCAAAA;AAAAA,IAAC;AAAA,IAAA;AAAA,MACC,WAAW;AAAA,QACT,OAAO;AAAA,QACP,UAAU,WAAW,OAAO,SAAS,OAAO;AAAA,MAAA;AAAA,MAG7C,UAAA,eAAe,IAAI,CAAC,MAAM,UAAU;AACnC,cAAM,eAAe;AAAA,UACnB;AAAA,UACA;AAAA,UACAF;AAAA,UACA;AAAA,UACA;AAAA,QAAA;AAEF,sDACGuS,uBAAA,EACC,UAAA;AAAA,UAAAtS,kCAAAA;AAAAA,YAAC;AAAA,YAAA;AAAA,cACC,WAAW;AAAA,gBACT,OAAO;AAAA,gBACP;AAAA,gBACA;AAAA,gBACA;AAAA,cAAA;AAAA,cAEH,UAAA;AAAA,gBAAA;AAAA,gBACG;AAAA,gBAAM;AAAA,cAAA;AAAA,YAAA;AAAA,UAAA;AAAA,gDAET,OAAA,EAAI,WAAW,KAAK,OAAO,UAAU,GAAI,UAAA,aAAA,CAAa;AAAA,QAAA,EAAA,GAX1C,mBAAmB,KAAK,EAYvC;AAAA,MAEJ,CAAC;AAAA,IAAA;AAAA,EAAA;AAGP;AAEA,MAAM,aAOD,CAAC;AAAA,EACJ,OAAAE;AAAA,EACA,SAASH;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAEJ,QAAM,aAAa,OAAO,KAAKG,MAAK,EAAE,KAAK,CAAC,GAAG,MAAM;AACnD,UAAM,OAAQA,OAAkC,CAAC;AACjD,UAAM,OAAQA,OAAkC,CAAC;AACjD,QAAI,OAAO,SAAS,aAAa,OAAO,SAAS,WAAW;AAC1D,aAAO,OAAO,IAAI,IAAI,OAAO,IAAI;AAAA,IACnC,WAAW,OAAO,SAAS,YAAY,OAAO,SAAS,UAAU;AAC/D,aAAO,OAAO;AAAA,IAChB,OAAO;AAEL,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAGD,QAAM,gBAAgB,WAAW,MAAM,GAAG,YAAY;AACtD,QAAM,WAAW,OAAO,KAAKA,MAAK,EAAE,SAAS;AAG7C,SACEF,kCAAAA;AAAAA,IAAC;AAAA,IAAA;AAAA,MACC,WAAW;AAAA,QACT,OAAO;AAAA,QACP,UAAU,WAAW,OAAO,SAAS,OAAO;AAAA,MAAA;AAAA,MAG7C,UAAA;AAAA,QAAA,cAAc,IAAI,CAACyE,MAAK,UAAU;AACjC,gBAAM,eAAe;AAAA,YACnB;AAAA,YACCvE,OAAkCuE,IAAG;AAAA,YACtC1E;AAAA,YACA;AAAA,YACA;AAAA,UAAA;AAEF,wDACGuS,uBAAA,EACC,UAAA;AAAA,YAAArS,kCAAAA;AAAAA,cAAC;AAAA,cAAA;AAAA,gBACC,WAAW;AAAA,kBACT,OAAO;AAAA,kBACP;AAAA,kBACA;AAAA,kBACA;AAAA,gBAAA;AAAA,gBAGD,UAAAwE;AAAA,cAAA;AAAA,YAAA;AAAA,kDAEF,OAAA,EAAI,WAAW,KAAK,OAAO,UAAU,GAAI,UAAA,aAAA,CAAa;AAAA,UAAA,EAAA,GAX1C,mBAAmBA,IAAG,EAYrC;AAAA,QAEJ,CAAC;AAAA,QACA,WAAW,KACVzE,kCAAAA,KAACsS,aAAAA,UAAA,EACC,UAAA;AAAA,UAAAtS,kCAAAA;AAAAA,YAAC;AAAA,YAAA;AAAA,cACC,WAAW;AAAA,gBACT,OAAO;AAAA,gBACP;AAAA,gBACA;AAAA,gBACA;AAAA,cAAA;AAAA,cAGD,UAAA;AAAA,gBAAA;AAAA,gBAAS;AAAA,cAAA;AAAA,YAAA;AAAA,UAAA;AAAA,gDAEX,OAAA,EAAI,WAAW,KAAK,OAAO,UAAU,EAAA,CAAG;AAAA,QAAA,EAAA,GAX5B,sBAYf;AAAA,MAAA;AAAA,IAAA;AAAA,EAAA;AAIR;AAGA,MAAM,cAAc,CAClB,OACA,KACA,SACA,YACA,gBACc;AACd,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAOC,kCAAAA,IAAC,2BAAA,EAA0B,UAAU,KAAK,WAAA,CAAwB;AAAA,EAC3E,WAAW,OAAO,QAAQ,UAAU;AAClC,WAAO,oBAAoB,GAAG;AAAA,EAChC,WAAW,OAAO,QAAQ,WAAW;AACnC,WACEA,kCAAAA,IAAC,OAAA,EAAI,WAAW,KAAK,OAAO,SAAS,MAAM,OAAO,OAAO,OAAO,KAAK,GAClE,UAAA,OAAO,GAAG,GACb;AAAA,EAEJ,WAAW,QAAQ,MAAM;AACvB,iDAAQ,OAAA,EAAI,WAAW,KAAK,OAAO,KAAK,GAAG,UAAA,QAAI;AAAA,EACjD,WAAW,MAAM,QAAQ,GAAG,GAAG;AAC7B,WAAO,WAAW,KAAK,EAAE;AAAA,EAC3B,WAAW,OAAO,QAAQ,UAAU;AAClC,WAAO,CAAC,cACN,YAAY,KAAK,EAAE,IAEnBA,kCAAAA;AAAAA,MAAC;AAAA,MAAA;AAAA,QACC,IAAI,gBAAgB,QAAQ,UAAU,IAAI,KAAK;AAAA,QAC/C,QAAQ;AAAA,MAAA;AAAA,IAAA;AAAA,EAGd,OAAO;AACL,WAAO;AAAA,EACT;AACF;ACxPO,MAAM,iBAA0C,CAAC;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAEJ,QAAM,EAAE,YAAY,oBAAA,IAAwB;AAAA,IAC1C,UAAU,CAAA;AAAA,IACV;AAAA,EAAA;AAGF,SACEA,kCAAAA;AAAAA,IAAC;AAAA,IAAA;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAAA;AAGN;ACnBO,MAAM,kBAAkB,CAC7B,SACA,cACG;AACH,QAAM,EAAE,UAAU,SAAA,IAAa,aAAA;AAC/B,QAAM,CAAC,mBAAmB,IAAI,gBAAA;AAK9B,QAAM,WAAWmS,aAAAA,QAAQ,MAAM;AAC7B,QAAI,CAAC,SAAS,YAAY;AACxB,aAAO,CAAC,gBAAwB,IAAI,WAAW;AAAA,IACjD;AAEA,WAAO,CAAC,gBAAwB;AAC9B,UAAI,CAAC,UAAU;AACb,eAAO,IAAI,WAAW;AAAA,MACxB;AAEA,YAAM,eAAe,IAAI,gBAAgB,mBAAmB;AAE5D,YAAM,YAAY,IAAI,gBAAgB,WAAW;AACjD,iBAAW,CAAC3N,MAAKvE,MAAK,KAAK,WAAW;AACpC,qBAAa,IAAIuE,MAAKvE,MAAK;AAAA,MAC7B;AACA,aAAO,IAAI,gBAAgB,UAAU,UAAU,QAAQ,YAAY,YAAY,CAAC;AAAA,IAClF;AAAA,EAGF,GAAG,CAAC,SAAS,YAAY,UAAU,UAAU,mBAAmB,CAAC;AAEjE,QAAM,OAA4B,UAC9B;AAAA,IACE;AAAA,IACA,CAAC,OAAe,SAA8B;AAC5C,UAAI,SAAS,WAAW;AACtB,eAAO,SAAS,sBAAsB,mBAAmB,KAAK,CAAC,EAAE;AAAA,MACnE,OAAO;AACL,eAAO,SAAS,oBAAoB,mBAAmB,KAAK,CAAC,EAAE;AAAA,MACjE;AAAA,IACF;AAAA,IACA;AAAA,EAAA,IAEF,CAAA;AACJ,SAAO;AACT;AAEO,MAAM,iBAAiB,CAC5B,SACA,kBACA,cACG;AACH,QAAM,YAAY,eAAe,SAAS;AAE1C,QAAM,OAA4B,CAAA;AAClC,aAAW8N,QAAO,QAAQ,mBAAmB;AAC3C,UAAM,gBAAgB,UAAUA,KAAI,EAAE;AACtC,UAAM,SAAS,iBAAiBA,KAAI,IAAI,SAAS;AACjD,QAAIA,KAAI,SAAS,iBAAiB,SAAS;AACzC,WAAK,KAAK;AAAA,QACR,IAAIA,KAAI;AAAA,QACR,MAAMA,KAAI;AAAA,QACV,aAAa;AAAA,QACb,SAAS;AAAA,MAAA,CACV;AAAA,IACH;AAAA,EACF;AAEA,aAAWA,QAAO,QAAQ,iBAAiB;AACzC,UAAM,gBAAgB,UAAUA,KAAI,EAAE;AACtC,UAAM,SAAS,iBAAiBA,KAAI,IAAI,OAAO;AAC/C,QAAIA,KAAI,SAAS,iBAAiB,SAAS;AACzC,WAAK,KAAK;AAAA,QACR,IAAIA,KAAI;AAAA,QACR,MAAMA,KAAI;AAAA,QACV,aAAa;AAAA,QACb,SAAS;AAAA,MAAA,CACV;AAAA,IACH;AAAA,EACF;AACA,SAAO;AACT;AAEA,MAAM,iBAAiB,CACrB,cACoC;AACpC,MAAI,CAAC,WAAW;AACd,WAAO,CAAA;AAAA,EACT;AAEA,MAAI,eAAe,SAAS,GAAG;AAC7B,QAAI,CAAC,UAAU,MAAM,IAAI;AACvB,aAAO,CAAA;AAAA,IACT;AACA,WAAO;AAAA,MACL,CAAC,UAAU,MAAM,EAAE,GAAG,MAAM;AAC1B,eACE/N,kCAAAA;AAAAA,UAAC;AAAA,UAAA;AAAA,YACC,UAAU,CAAC,UAAU,KAAK;AAAA,YAC1B,qCAAqC;AAAA,UAAA;AAAA,QAAA;AAAA,MAG3C;AAAA,IAAA;AAAA,EAEJ,WAAW,gBAAgB,SAAS,GAAG;AACrC,WAAO,UAAU,MAAM;AAAA,MACrB,CAAC,KAAK,QAAQ;AACZ,YAAI,IAAI,IAAI;AACV,cAAI,IAAI,EAAE,IAAI,MAAM;AAClB,mBACEA,kCAAAA;AAAAA,cAAC;AAAA,cAAA;AAAA,gBACC,UAAU,CAAC,GAAG;AAAA,gBACd,qCAAqC;AAAA,cAAA;AAAA,YAAA;AAAA,UAG3C;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,MACA,CAAA;AAAA,IAAC;AAAA,EAEL,WAAW,aAAa,SAAS,GAAG;AAClC,QAAI,CAAC,UAAU,MAAM,MAAM;AACzB,aAAO,CAAA;AAAA,IACT;AAEA,WAAO;AAAA,MACL,CAAC,UAAU,MAAM,IAAI,GAAG,MAAM;AAC5B,eACEA,kCAAAA;AAAAA,UAAC;AAAA,UAAA;AAAA,YACC,IAAI;AAAA,YACJ,QAAQ,CAAC,UAAU,KAAK;AAAA,UAAA;AAAA,QAAA;AAAA,MAG9B;AAAA,IAAA;AAAA,EAEJ,WAAW,cAAc,SAAS,GAAG;AACnC,WAAO,UAAU,MAAM;AAAA,MACrB,CAAC,KAAK,OAAO,UAAU;AACrB,YAAI,MAAM,MAAM;AACd,cAAI,MAAM,IAAI,IAAI,MAAM;AACtB,mBACEA,kCAAAA;AAAAA,cAAC;AAAA,cAAA;AAAA,gBACC,IAAI,uBAAuB,KAAK;AAAA,gBAChC,QAAQ,UAAU;AAAA,cAAA;AAAA,YAAA;AAAA,UAGxB;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,MACA,CAAA;AAAA,IAAC;AAAA,EAEL,WAAW,kBAAkB,SAAS,GAAG;AACvC,UAAM,aAAa,UAAU,MAAM,UAAU,CAAA,GAAI,OAE/C,CAAC,KAAK,UAAU;AAChB,UAAI,MAAM,MAAM;AACd,YAAI,MAAM,IAAI,IAAI,MAAM;AACtB,uDAAQ,gBAAA,EAAe,IAAI,uBAAuB,QAAQ,CAAC,KAAK,GAAG;AAAA,QACrE;AAAA,MACF;AACA,aAAO;AAAA,IACT,GAAG,CAAA,CAAE;AAEL,UAAM,eAAe,UAAU,MAAM,YAAY,CAAA,GAAI,OAEnD,CAAC,KAAK,QAAQ;AACd,UAAI,IAAI,IAAI;AACV,YAAI,IAAI,EAAE,IAAI,MAAM;AAClB,iBACEA,kCAAAA;AAAAA,YAAC;AAAA,YAAA;AAAA,cACC,UAAU,CAAC,GAAG;AAAA,cACd,qCAAqC;AAAA,YAAA;AAAA,UAAA;AAAA,QAG3C;AAAA,MACF;AACA,aAAO;AAAA,IACT,GAAG,CAAA,CAAE;AACL,WAAO,EAAE,GAAG,WAAW,GAAG,YAAA;AAAA,EAC5B,OAAO;AACL,WAAO,CAAA;AAAA,EACT;AACF;","x_google_ignoreList":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294]}