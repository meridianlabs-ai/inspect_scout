{"version":3,"file":"transcriptColumns.js","sources":["../../src/query/types.ts","../../src/query/conditionBuilder.ts","../../src/query/column.ts","../../src/query/transcriptColumns.ts"],"sourcesContent":["// Re-export from generated types (they're in components.schemas)\nimport type { components } from \"../types/generated\";\n\n/** SQL comparison operators. */\nexport type OperatorModel = components[\"schemas\"][\"Operator\"];\n\n/** Logical operators for combining conditions. */\nexport type LogicalOperatorModel = components[\"schemas\"][\"LogicalOperator\"];\n\n/** JSON representation of a Condition (matches Python Pydantic schema). */\nexport type ConditionModel = components[\"schemas\"][\"Condition\"];\n\n/** Scalar values that can be used in conditions (matching Python). */\nexport type ScalarValue = string | number | boolean | null;\n\n/**\n * Base interface with shared methods for all conditions.\n */\nexport interface ConditionBase {\n  /** Combine conditions with AND. */\n  and(other: Condition): Condition;\n  /** Combine conditions with OR. */\n  or(other: Condition): Condition;\n  /** Negate a condition with NOT. */\n  not(): Condition;\n  /** Serialize to JSON format (called automatically by JSON.stringify()). */\n  toJSON(): ConditionModel;\n}\n\n/**\n * Simple condition: column comparison (e.g., model = \"gpt-4\").\n */\nexport interface SimpleCondition extends ConditionBase {\n  /** Discriminant for simple conditions. */\n  readonly compound: false;\n  /** Column name. */\n  readonly left: string;\n  /** Comparison operator. */\n  readonly operator: OperatorModel;\n  /** Comparison value. */\n  readonly right: Exclude<ConditionValue, Condition> | null;\n}\n\n/**\n * Compound condition: logical combination (e.g., AND, OR, NOT).\n */\nexport interface CompoundCondition extends ConditionBase {\n  /** Discriminant for compound conditions. */\n  readonly compound: true;\n  /** Left operand. */\n  readonly left: Condition;\n  /** Logical operator. */\n  readonly operator: LogicalOperatorModel;\n  /** Right operand (null for NOT). */\n  readonly right: Condition | null;\n}\n\n/**\n * WHERE clause condition that can be combined with others.\n *\n * Discriminated union enables TypeScript to automatically narrow types\n * based on the `compound` property without requiring type assertions.\n */\nexport type Condition = SimpleCondition | CompoundCondition;\n\n// Internal builder types\nexport type ConditionValue =\n  | ScalarValue\n  | ScalarValue[]\n  | [ScalarValue, ScalarValue] // BETWEEN tuple\n  | Condition; // Nested condition\n\n// Type guards for narrowing (optional with discriminated union, kept for semantic clarity)\nexport function isSimpleCondition(\n  condition: Condition\n): condition is SimpleCondition {\n  return !condition.compound;\n}\n\nexport function isCompoundCondition(\n  condition: Condition\n): condition is CompoundCondition {\n  return condition.compound;\n}\n\n// Type guard utilities\nexport const isScalarArray = (val: unknown): val is ScalarValue[] =>\n  Array.isArray(val) && !isTuple(val);\n\nexport const isTuple = (val: unknown): val is [ScalarValue, ScalarValue] =>\n  Array.isArray(val) && val.length === 2;\n\n/** Sort column specification for ORDER BY clauses (matches Python Pydantic schema). */\nexport type OrderByModel = components[\"schemas\"][\"OrderBy\"];\n","import type {\n  OperatorModel,\n  LogicalOperatorModel,\n  ConditionValue,\n  Condition,\n  SimpleCondition,\n  CompoundCondition,\n  ConditionBase,\n  ConditionModel,\n  ScalarValue,\n} from \"./types\";\nimport { isScalarArray, isTuple } from \"./types\";\n\n/**\n * Internal builder for creating Condition instances.\n *\n * Type assertions in this class are necessary because:\n * - Constructor accepts `compound: boolean` (TypeScript widens true|false to boolean)\n * - Discriminated union requires literal types (`compound: true` or `compound: false`)\n * - Factories guarantee correct literal values at runtime\n * - TypeScript can't statically prove constructor only receives literals\n *\n * This is acceptable because:\n * - Assertions are localized to this internal implementation\n * - Public API (serializers) has zero type assertions\n * - Standard pattern for builder + discriminated union\n */\nexport class ConditionBuilder implements ConditionBase {\n  private constructor(\n    public readonly left: string | Condition | null,\n    public readonly operator: OperatorModel | LogicalOperatorModel,\n    public readonly right: ConditionValue | null,\n    public readonly compound: boolean\n  ) {}\n\n  // Factory for simple conditions\n  static simple(\n    field: string,\n    operator: OperatorModel,\n    value: ConditionValue\n  ): SimpleCondition {\n    const instance = new ConditionBuilder(field, operator, value, false);\n    return instance as SimpleCondition;\n  }\n\n  // Factory for logical conditions\n  static compound(\n    operator: LogicalOperatorModel,\n    left: Condition,\n    right: Condition | null = null\n  ): CompoundCondition {\n    const instance = new ConditionBuilder(left, operator, right, true);\n    return instance as CompoundCondition;\n  }\n\n  // Logical combinators (Python __and__, __or__, __invert__)\n  and(other: Condition): Condition {\n    // Safe cast: factories ensure compound is always a literal (true/false)\n    return ConditionBuilder.compound(\"AND\", this as Condition, other);\n  }\n\n  or(other: Condition): Condition {\n    // Safe cast: factories ensure compound is always a literal (true/false)\n    return ConditionBuilder.compound(\"OR\", this as Condition, other);\n  }\n\n  not(): Condition {\n    // Safe cast: factories ensure compound is always a literal (true/false)\n    return ConditionBuilder.compound(\"NOT\", this as Condition, null);\n  }\n\n  // Serialization for JSON.stringify()\n  toJSON(): ConditionModel {\n    if (this.compound) {\n      // TypeScript needs help narrowing to CompoundCondition\n      const self = this as CompoundCondition;\n      return {\n        is_compound: true,\n        left: self.left.toJSON(),\n        operator: self.operator,\n        right: self.right ? self.right.toJSON() : null,\n      };\n    } else {\n      // TypeScript needs help narrowing to SimpleCondition\n      const self = this as SimpleCondition;\n      return {\n        is_compound: false,\n        left: self.left,\n        operator: self.operator,\n        right: this.serializeValue(self.right),\n      };\n    }\n  }\n\n  private serializeValue(\n    value: Exclude<ConditionValue, Condition> | null\n  ): ConditionModel[\"right\"] {\n    if (value === null) return null;\n    if (isScalarArray(value)) return value;\n    if (isTuple(value)) return value;\n    return value as ScalarValue;\n  }\n}\n","import { ConditionBuilder } from \"./conditionBuilder\";\nimport type { Condition, OrderByModel, ScalarValue } from \"./types\";\n\nexport class Column {\n  constructor(private readonly name: string) {}\n\n  // Comparison operators (Python __eq__, __ne__, etc.)\n  eq(value: ScalarValue): Condition {\n    return value === null\n      ? ConditionBuilder.simple(this.name, \"IS NULL\", null)\n      : ConditionBuilder.simple(this.name, \"=\", value);\n  }\n\n  ne(value: ScalarValue): Condition {\n    return value === null\n      ? ConditionBuilder.simple(this.name, \"IS NOT NULL\", null)\n      : ConditionBuilder.simple(this.name, \"!=\", value);\n  }\n\n  lt(value: ScalarValue): Condition {\n    return ConditionBuilder.simple(this.name, \"<\", value);\n  }\n\n  lte(value: ScalarValue): Condition {\n    return ConditionBuilder.simple(this.name, \"<=\", value);\n  }\n\n  gt(value: ScalarValue): Condition {\n    return ConditionBuilder.simple(this.name, \">\", value);\n  }\n\n  gte(value: ScalarValue): Condition {\n    return ConditionBuilder.simple(this.name, \">=\", value);\n  }\n\n  // List operators\n  in(values: ScalarValue[]): Condition {\n    return ConditionBuilder.simple(this.name, \"IN\", values);\n  }\n\n  notIn(values: ScalarValue[]): Condition {\n    return ConditionBuilder.simple(this.name, \"NOT IN\", values);\n  }\n\n  // Pattern matching\n  like(pattern: string): Condition {\n    return ConditionBuilder.simple(this.name, \"LIKE\", pattern);\n  }\n\n  notLike(pattern: string): Condition {\n    return ConditionBuilder.simple(this.name, \"NOT LIKE\", pattern);\n  }\n\n  ilike(pattern: string): Condition {\n    return ConditionBuilder.simple(this.name, \"ILIKE\", pattern);\n  }\n\n  notIlike(pattern: string): Condition {\n    return ConditionBuilder.simple(this.name, \"NOT ILIKE\", pattern);\n  }\n\n  // Null checks\n  isNull(): Condition {\n    return ConditionBuilder.simple(this.name, \"IS NULL\", null);\n  }\n\n  isNotNull(): Condition {\n    return ConditionBuilder.simple(this.name, \"IS NOT NULL\", null);\n  }\n\n  // Range\n  between(low: ScalarValue, high: ScalarValue): Condition {\n    if (low === null || high === null) {\n      throw new Error(\"BETWEEN requires non-null bounds\");\n    }\n    return ConditionBuilder.simple(this.name, \"BETWEEN\", [low, high]);\n  }\n\n  notBetween(low: ScalarValue, high: ScalarValue): Condition {\n    if (low === null || high === null) {\n      throw new Error(\"NOT BETWEEN requires non-null bounds\");\n    }\n    return ConditionBuilder.simple(this.name, \"NOT BETWEEN\", [low, high]);\n  }\n\n  // Sorting\n  asc(): OrderByModel {\n    return { column: this.name, direction: \"ASC\" };\n  }\n\n  desc(): OrderByModel {\n    return { column: this.name, direction: \"DESC\" };\n  }\n}\n","import { Column } from \"./column\";\n\n/**\n * Transcript-specific column definitions for building filter conditions.\n *\n * Provides predefined columns matching the transcript schema, plus dynamic\n * field access for custom or nested fields.\n */\nexport class TranscriptColumns {\n  // Predefined transcript fields (matching Python columns.py)\n  readonly transcript_id = new Column(\"transcript_id\");\n  readonly source_type = new Column(\"source_type\");\n  readonly source_id = new Column(\"source_id\");\n  readonly source_uri = new Column(\"source_uri\");\n  readonly date = new Column(\"date\");\n  readonly task_set = new Column(\"task_set\");\n  readonly task_id = new Column(\"task_id\");\n  readonly task_repeat = new Column(\"task_repeat\");\n  readonly agent = new Column(\"agent\");\n  readonly agent_args = new Column(\"agent_args\");\n  readonly model = new Column(\"model\");\n  readonly model_options = new Column(\"model_options\");\n  readonly score = new Column(\"score\");\n  readonly success = new Column(\"success\");\n  readonly total_time = new Column(\"total_time\");\n  readonly message_count = new Column(\"message_count\");\n  readonly error = new Column(\"error\");\n  readonly limit = new Column(\"limit\");\n\n  // Dynamic field access via Proxy\n  private static createProxy(): TranscriptColumns {\n    const instance = new TranscriptColumns();\n    return new Proxy(instance, {\n      get(target, prop: string | symbol) {\n        if (typeof prop === \"symbol\") return undefined;\n        if (prop.startsWith(\"_\")) return undefined; // block private access\n\n        // Check if predefined field exists\n        if (prop in target) {\n          return Reflect.get(target, prop);\n        }\n\n        // Dynamic field creation for custom transcript fields\n        return new Column(prop);\n      },\n    });\n  }\n\n  // Singleton instance\n  private static _instance: TranscriptColumns | null = null;\n  static get instance(): TranscriptColumns {\n    if (!TranscriptColumns._instance) {\n      TranscriptColumns._instance = TranscriptColumns.createProxy();\n    }\n    return TranscriptColumns._instance;\n  }\n\n  // Bracket notation for JSON paths in transcript metadata\n  field(name: string): Column {\n    return new Column(name);\n  }\n}\n\n// Export singleton instance for transcript filtering\nexport const transcriptColumns = TranscriptColumns.instance;\n"],"names":[],"mappings":"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"}