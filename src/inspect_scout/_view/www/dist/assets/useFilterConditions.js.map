{"version":3,"file":"useFilterConditions.js","sources":["../../src/app/components/TranscriptsNavbar.tsx","../../src/app/hooks/useFilterConditions.ts"],"sourcesContent":["import { FC, useContext, useMemo } from \"react\";\nimport { useParams, useSearchParams } from \"react-router-dom\";\n\nimport { AppModeContext } from \"../../App\";\nimport { ApplicationIcons } from \"../../components/icons\";\nimport { transcriptsRoute } from \"../../router/url\";\nimport { useStore } from \"../../state/store\";\n\nimport { EditablePath } from \"./EditablePath\";\nimport { Navbar } from \"./Navbar\";\nimport { NavButton } from \"./NavButtons\";\n\ninterface TranscriptsNavbarProps {\n  transcriptsDir?: string | null;\n  transcriptsDirSource?: \"route\" | \"user\" | \"project\" | \"cli\" | \"unknown\";\n  filter?: string;\n  setTranscriptsDir: (path: string) => void;\n  bordered?: boolean;\n  children?: React.ReactNode;\n}\n\nexport const TranscriptsNavbar: FC<TranscriptsNavbarProps> = ({\n  transcriptsDir,\n  transcriptsDirSource,\n  filter,\n  setTranscriptsDir,\n  bordered = true,\n  children,\n}) => {\n  const appMode = useContext(AppModeContext);\n  const showNavButtons = appMode !== \"workbench\";\n  const singleFileMode = useStore((state) => state.singleFileMode);\n  const [searchParams] = useSearchParams();\n\n  const params = useParams<{ \"*\": string }>();\n  const transcriptId = params[\"transcriptId\"];\n\n  // Check if we're on a scan result page and calculate the appropriate back URL\n  const backUrl = !singleFileMode ? transcriptsRoute(searchParams) : undefined;\n\n  const navButtons: NavButton[] = useMemo(() => {\n    const buttons: NavButton[] = [];\n\n    if (backUrl) {\n      buttons.push({\n        title: \"Back\",\n        icon: ApplicationIcons.navbar.back,\n        route: backUrl,\n        enabled: !!transcriptId,\n      });\n    }\n\n    if (!singleFileMode) {\n      buttons.push({\n        title: \"Home\",\n        icon: ApplicationIcons.navbar.home,\n        route: transcriptsRoute(),\n        enabled: !!transcriptId,\n      });\n    }\n\n    return buttons;\n    // TODO: lint react-hooks/exhaustive-deps Fix this\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [backUrl, singleFileMode]);\n\n  const editable = false;\n  const filterText =\n    filter && !filter?.startsWith(\"(\")\n      ? `(${filter})`\n      : filter\n        ? filter\n        : undefined;\n\n  return (\n    <Navbar\n      bordered={bordered}\n      leftButtons={showNavButtons ? navButtons : undefined}\n      left={\n        <EditablePath\n          path={transcriptsDir}\n          secondaryText={filterText}\n          label=\"Transcripts\"\n          icon={\n            transcriptsDirSource === \"cli\"\n              ? ApplicationIcons.terminal\n              : undefined\n          }\n          title={\n            transcriptsDirSource === \"cli\"\n              ? \"Using transcripts directory from command line.\"\n              : undefined\n          }\n          onPathChanged={setTranscriptsDir}\n          placeholder={\n            editable\n              ? \"Select Transcripts Folder\"\n              : \"No transcripts directory configured.\"\n          }\n          className=\"text-size-smallest\"\n          editable={editable}\n        />\n      }\n      right={children}\n    />\n  );\n};\n","import { Condition } from \"../../query\";\nimport { SimpleCondition } from \"../../query/types\";\nimport { useStore } from \"../../state/store\";\n\n/**\n * Build a combined filter condition from column filters.\n * @param excludeColumnId - Optional column ID to exclude from the condition\n */\nexport const useFilterConditions = (excludeColumnId?: string) => {\n  // The applied filters\n  const columnFilters =\n    useStore((state) => state.transcriptsTableState.columnFilters) ?? {};\n\n  // Get conditions, optionally excluding a specific column\n  const filterConditions = Object.values(columnFilters)\n    .filter((filter) => !excludeColumnId || filter.columnId !== excludeColumnId)\n    .map((filter) => filter.condition)\n    .filter((condition): condition is SimpleCondition => Boolean(condition));\n\n  // Reduce to a single condition using 'and'\n  const condition = filterConditions.reduce<Condition | undefined>(\n    (acc, condition) => (acc ? acc.and(condition) : condition),\n    undefined\n  );\n  return condition;\n};\n"],"names":["useContext","useMemo","jsx","condition"],"mappings":";;AAqBO,MAAM,oBAAgD,CAAC;AAAA,EAC5D;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX;AACF,MAAM;AACJ,QAAM,UAAUA,aAAAA,WAAW,cAAc;AACzC,QAAM,iBAAiB,YAAY;AACnC,QAAM,iBAAiB,SAAS,CAAC,UAAU,MAAM,cAAc;AAC/D,QAAM,CAAC,YAAY,IAAI,gBAAA;AAEvB,QAAM,SAAS,UAAA;AACf,QAAM,eAAe,OAAO,cAAc;AAG1C,QAAM,UAAU,CAAC,iBAAiB,iBAAiB,YAAY,IAAI;AAEnE,QAAM,aAA0BC,aAAAA,QAAQ,MAAM;AAC5C,UAAM,UAAuB,CAAA;AAE7B,QAAI,SAAS;AACX,cAAQ,KAAK;AAAA,QACX,OAAO;AAAA,QACP,MAAM,iBAAiB,OAAO;AAAA,QAC9B,OAAO;AAAA,QACP,SAAS,CAAC,CAAC;AAAA,MAAA,CACZ;AAAA,IACH;AAEA,QAAI,CAAC,gBAAgB;AACnB,cAAQ,KAAK;AAAA,QACX,OAAO;AAAA,QACP,MAAM,iBAAiB,OAAO;AAAA,QAC9B,OAAO,iBAAA;AAAA,QACP,SAAS,CAAC,CAAC;AAAA,MAAA,CACZ;AAAA,IACH;AAEA,WAAO;AAAA,EAGT,GAAG,CAAC,SAAS,cAAc,CAAC;AAE5B,QAAM,WAAW;AACjB,QAAM,aACJ,UAAU,CAAC,QAAQ,WAAW,GAAG,IAC7B,IAAI,MAAM,MACV,SACE,SACA;AAER,SACEC,kCAAAA;AAAAA,IAAC;AAAA,IAAA;AAAA,MACC;AAAA,MACA,aAAa,iBAAiB,aAAa;AAAA,MAC3C,MACEA,kCAAAA;AAAAA,QAAC;AAAA,QAAA;AAAA,UACC,MAAM;AAAA,UACN,eAAe;AAAA,UACf,OAAM;AAAA,UACN,MACE,yBAAyB,QACrB,iBAAiB,WACjB;AAAA,UAEN,OACE,yBAAyB,QACrB,mDACA;AAAA,UAEN,eAAe;AAAA,UACf,aAGM;AAAA,UAEN,WAAU;AAAA,UACV;AAAA,QAAA;AAAA,MAAA;AAAA,MAGJ,OAAO;AAAA,IAAA;AAAA,EAAA;AAGb;AClGO,MAAM,sBAAsB,CAAC,oBAA6B;AAE/D,QAAM,gBACJ,SAAS,CAAC,UAAU,MAAM,sBAAsB,aAAa,KAAK,CAAA;AAGpE,QAAM,mBAAmB,OAAO,OAAO,aAAa,EACjD,OAAO,CAAC,WAAW,CAAC,mBAAmB,OAAO,aAAa,eAAe,EAC1E,IAAI,CAAC,WAAW,OAAO,SAAS,EAChC,OAAO,CAACC,eAA4C,QAAQA,UAAS,CAAC;AAGzE,QAAM,YAAY,iBAAiB;AAAA,IACjC,CAAC,KAAKA,eAAe,MAAM,IAAI,IAAIA,UAAS,IAAIA;AAAAA,IAChD;AAAA,EAAA;AAEF,SAAO;AACT;"}