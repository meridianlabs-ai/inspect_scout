import { JsonValue } from "./json-value";
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/scans": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List scans
         * @description Returns all scans in the results directory. Supports ETag caching.
         */
        get: operations["scans_scans_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans-dir": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get default scans directory
         * @description Returns the default directory path where scans are stored.
         */
        get: operations["scans_dir_scans_dir_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans/{scan}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scan status
         * @description Returns detailed status and metadata for a single scan.
         */
        get: operations["scan_scans__scan__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans/{scan}/{scanner}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scanner dataframe containing results for all transcripts
         * @description Streams scanner results as Arrow IPC format with LZ4 compression. Excludes input column for efficiency; use the input endpoint for input text.
         */
        get: operations["scan_df_scans__scan___scanner__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans/{scan}/{scanner}/{uuid}/input": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scanner input for a specific transcript
         * @description Returns the original input text for a specific scanner result. The input type is returned in the X-Input-Type response header.
         */
        get: operations["scanner_input_scans__scan___scanner___uuid__input_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transcripts-dir": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get default transcripts directory
         * @description Returns the default directory path where transcripts are stored.
         */
        get: operations["transcripts_dir_transcripts_dir_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transcripts/{dir}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * List transcripts
         * @description Returns transcripts from specified directory. Optional filter condition uses SQL-like DSL. Optional order_by for sorting results. Optional pagination for cursor-based pagination.
         */
        post: operations["transcripts_transcripts__dir__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transcripts/{dir}/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get transcript
         * @description Returns a single transcript with full content (messages and events).
         */
        get: operations["transcript_transcripts__dir___id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * ApprovalEvent
         * @description Tool approval.
         */
        ApprovalEvent: {
            /** Approver */
            approver: string;
            call: components["schemas"]["ToolCall"];
            /**
             * Decision
             * @enum {string}
             */
            decision: "approve" | "modify" | "reject" | "escalate" | "terminate";
            /**
             * Event
             * @default approval
             * @constant
             */
            event: "approval";
            /** Explanation */
            explanation?: string | null;
            /** Message */
            message: string;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            modified?: components["schemas"]["ToolCall"] | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            view?: components["schemas"]["ToolCallView"] | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * BatchConfig
         * @description Batch processing configuration.
         */
        BatchConfig: {
            /** Max Batches */
            max_batches?: number | null;
            /** Max Consecutive Check Failures */
            max_consecutive_check_failures?: number | null;
            /** Max Size */
            max_size?: number | null;
            /** Send Delay */
            send_delay?: number | null;
            /** Size */
            size?: number | null;
            /** Tick */
            tick?: number | null;
        };
        /**
         * CachePolicy
         * @description Caching options for model generation.
         */
        CachePolicy: {
            /**
             * Expiry
             * @default 1W
             */
            expiry: string | null;
            /**
             * Per Epoch
             * @default true
             */
            per_epoch: boolean;
            /** Scopes */
            scopes: {
                [key: string]: string;
            };
        };
        /**
         * ChatCompletionChoice
         * @description Choice generated for completion.
         */
        ChatCompletionChoice: {
            logprobs?: components["schemas"]["Logprobs"] | null;
            message: components["schemas"]["ChatMessageAssistant"];
            /**
             * Stop Reason
             * @default unknown
             * @enum {string}
             */
            stop_reason: "stop" | "max_tokens" | "model_length" | "tool_calls" | "content_filter" | "unknown";
        };
        ChatMessage: components["schemas"]["ChatMessageSystem"] | components["schemas"]["ChatMessageUser"] | components["schemas"]["ChatMessageAssistant"] | components["schemas"]["ChatMessageTool"];
        /**
         * ChatMessageAssistant
         * @description Assistant chat message.
         */
        ChatMessageAssistant: {
            /** Content */
            content: string | (components["schemas"]["ContentText"] | components["schemas"]["ContentReasoning"] | components["schemas"]["ContentImage"] | components["schemas"]["ContentAudio"] | components["schemas"]["ContentVideo"] | components["schemas"]["ContentData"] | components["schemas"]["ContentToolUse"] | components["schemas"]["ContentDocument"])[];
            /**
             * Id
             * @default null
             */
            id: string | null;
            /**
             * Metadata
             * @default null
             */
            metadata: {
                [key: string]: unknown;
            } | null;
            /**
             * Model
             * @default null
             */
            model: string | null;
            /**
             * Role
             * @default assistant
             * @constant
             */
            role: "assistant";
            /**
             * Source
             * @default null
             */
            source: ("input" | "generate") | null;
            /**
             * Tool Calls
             * @default null
             */
            tool_calls: components["schemas"]["ToolCall"][] | null;
        };
        /**
         * ChatMessageSystem
         * @description System chat message.
         */
        ChatMessageSystem: {
            /** Content */
            content: string | (components["schemas"]["ContentText"] | components["schemas"]["ContentReasoning"] | components["schemas"]["ContentImage"] | components["schemas"]["ContentAudio"] | components["schemas"]["ContentVideo"] | components["schemas"]["ContentData"] | components["schemas"]["ContentToolUse"] | components["schemas"]["ContentDocument"])[];
            /**
             * Id
             * @default null
             */
            id: string | null;
            /**
             * Metadata
             * @default null
             */
            metadata: {
                [key: string]: unknown;
            } | null;
            /**
             * Role
             * @default system
             * @constant
             */
            role: "system";
            /**
             * Source
             * @default null
             */
            source: ("input" | "generate") | null;
        };
        /**
         * ChatMessageTool
         * @description Tool chat message.
         */
        ChatMessageTool: {
            /** Content */
            content: string | (components["schemas"]["ContentText"] | components["schemas"]["ContentReasoning"] | components["schemas"]["ContentImage"] | components["schemas"]["ContentAudio"] | components["schemas"]["ContentVideo"] | components["schemas"]["ContentData"] | components["schemas"]["ContentToolUse"] | components["schemas"]["ContentDocument"])[];
            /** @default null */
            error: components["schemas"]["ToolCallError"] | null;
            /**
             * Function
             * @default null
             */
            function: string | null;
            /**
             * Id
             * @default null
             */
            id: string | null;
            /**
             * Metadata
             * @default null
             */
            metadata: {
                [key: string]: unknown;
            } | null;
            /**
             * Role
             * @default tool
             * @constant
             */
            role: "tool";
            /**
             * Source
             * @default null
             */
            source: ("input" | "generate") | null;
            /**
             * Tool Call Id
             * @default null
             */
            tool_call_id: string | null;
        };
        /**
         * ChatMessageUser
         * @description User chat message.
         */
        ChatMessageUser: {
            /** Content */
            content: string | (components["schemas"]["ContentText"] | components["schemas"]["ContentReasoning"] | components["schemas"]["ContentImage"] | components["schemas"]["ContentAudio"] | components["schemas"]["ContentVideo"] | components["schemas"]["ContentData"] | components["schemas"]["ContentToolUse"] | components["schemas"]["ContentDocument"])[];
            /**
             * Id
             * @default null
             */
            id: string | null;
            /**
             * Metadata
             * @default null
             */
            metadata: {
                [key: string]: unknown;
            } | null;
            /**
             * Role
             * @default user
             * @constant
             */
            role: "user";
            /**
             * Source
             * @default null
             */
            source: ("input" | "generate") | null;
            /**
             * Tool Call Id
             * @default null
             */
            tool_call_id: string[] | null;
        };
        /**
         * Condition
         * @description WHERE clause condition that can be combined with others.
         */
        "Condition-Input": {
            /**
             * Is Compound
             * @default false
             */
            is_compound: boolean;
            /** Left */
            left?: string | components["schemas"]["Condition-Input"] | null;
            /** Operator */
            operator?: components["schemas"]["Operator"] | components["schemas"]["LogicalOperator"] | null;
            /** Right */
            right?: components["schemas"]["Condition-Input"] | (string | number | boolean | null)[] | [
                string | number | boolean | null,
                string | number | boolean | null
            ] | string | number | boolean | null;
        };
        /**
         * Condition
         * @description WHERE clause condition that can be combined with others.
         */
        "Condition-Output": {
            /**
             * Is Compound
             * @default false
             */
            is_compound: boolean;
            /** Left */
            left?: string | components["schemas"]["Condition-Output"] | null;
            /** Operator */
            operator?: components["schemas"]["Operator"] | components["schemas"]["LogicalOperator"] | null;
            /** Right */
            right?: components["schemas"]["Condition-Output"] | (string | number | boolean | null)[] | [
                string | number | boolean | null,
                string | number | boolean | null
            ] | string | number | boolean | null;
        };
        /**
         * ContentAudio
         * @description Audio content.
         */
        ContentAudio: {
            /** Audio */
            audio: string;
            /**
             * Format
             * @enum {string}
             */
            format: "wav" | "mp3";
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /**
             * Type
             * @default audio
             * @constant
             */
            type: "audio";
        };
        /**
         * ContentCitation
         * @description A generic content citation.
         */
        ContentCitation: {
            /**
             * Cited Text
             * @default null
             */
            cited_text: string | number[] | null;
            /**
             * Internal
             * @default null
             */
            internal: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            /**
             * Title
             * @default null
             */
            title: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "content";
        };
        /**
         * ContentData
         * @description Model internal.
         */
        ContentData: {
            /** Data */
            data: {
                [key: string]: components["schemas"]["JsonValue"];
            };
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /**
             * Type
             * @default data
             * @constant
             */
            type: "data";
        };
        /**
         * ContentDocument
         * @description Document content (e.g. a PDF).
         */
        ContentDocument: {
            /** Document */
            document: string;
            /** Filename */
            filename: string;
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /** Mime Type */
            mime_type: string;
            /**
             * Type
             * @default document
             * @constant
             */
            type: "document";
        };
        /**
         * ContentImage
         * @description Image content.
         */
        ContentImage: {
            /**
             * Detail
             * @default auto
             * @enum {string}
             */
            detail: "auto" | "low" | "high";
            /** Image */
            image: string;
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /**
             * Type
             * @default image
             * @constant
             */
            type: "image";
        };
        /**
         * ContentReasoning
         * @description Reasoning content.
         *
         *     See the specification for [thinking blocks](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking#understanding-thinking-blocks) for Claude models.
         */
        ContentReasoning: {
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /** Reasoning */
            reasoning: string;
            /**
             * Redacted
             * @default false
             */
            redacted: boolean;
            /**
             * Signature
             * @default null
             */
            signature: string | null;
            /**
             * Summary
             * @default null
             */
            summary: string | null;
            /**
             * Type
             * @default reasoning
             * @constant
             */
            type: "reasoning";
        };
        /**
         * ContentText
         * @description Text content.
         */
        ContentText: {
            /**
             * Citations
             * @default null
             */
            citations: (components["schemas"]["ContentCitation"] | components["schemas"]["DocumentCitation"] | components["schemas"]["UrlCitation"])[] | null;
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /**
             * Refusal
             * @default null
             */
            refusal: boolean | null;
            /** Text */
            text: string;
            /**
             * Type
             * @default text
             * @constant
             */
            type: "text";
        };
        /**
         * ContentToolUse
         * @description Server side tool use.
         */
        ContentToolUse: {
            /** Arguments */
            arguments: string;
            /**
             * Context
             * @default null
             */
            context: string | null;
            /**
             * Error
             * @default null
             */
            error: string | null;
            /** Id */
            id: string;
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /** Name */
            name: string;
            /** Result */
            result: string;
            /**
             * Tool Type
             * @enum {string}
             */
            tool_type: "web_search" | "mcp_call" | "code_execution";
            /**
             * Type
             * @default tool_use
             * @constant
             */
            type: "tool_use";
        };
        /**
         * ContentVideo
         * @description Video content.
         */
        ContentVideo: {
            /**
             * Format
             * @enum {string}
             */
            format: "mp4" | "mpeg" | "mov";
            /** @default null */
            internal: components["schemas"]["JsonValue"] | null;
            /**
             * Type
             * @default video
             * @constant
             */
            type: "video";
            /** Video */
            video: string;
        };
        /**
         * DocumentCitation
         * @description A citation that refers to a page range in a document.
         */
        DocumentCitation: {
            /**
             * Cited Text
             * @default null
             */
            cited_text: string | number[] | null;
            /**
             * Internal
             * @default null
             */
            internal: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            /** @default null */
            range: components["schemas"]["DocumentRange"] | null;
            /**
             * Title
             * @default null
             */
            title: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "document";
        };
        /**
         * DocumentRange
         * @description A range specifying a section of a document.
         */
        DocumentRange: {
            /** End Index */
            end_index: number;
            /** Start Index */
            start_index: number;
            /**
             * Type
             * @enum {string}
             */
            type: "block" | "page" | "char";
        };
        /**
         * Error
         * @description Scan error (runtime error which occurred during scan).
         */
        Error: {
            /** Error */
            error: string;
            /** Refusal */
            refusal: boolean;
            /** Scanner */
            scanner: string;
            /** Traceback */
            traceback: string;
            /** Transcript Id */
            transcript_id: string;
        };
        /**
         * ErrorEvent
         * @description Event with sample error.
         */
        ErrorEvent: {
            error: components["schemas"]["EvalError"];
            /**
             * Event
             * @default error
             * @constant
             */
            event: "error";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * EvalError
         * @description Eval error details.
         */
        EvalError: {
            /** Message */
            message: string;
            /** Traceback */
            traceback: string;
            /** Traceback Ansi */
            traceback_ansi: string;
        };
        /**
         * GenerateConfig
         * @description Model generation options.
         */
        GenerateConfig: {
            /** Attempt Timeout */
            attempt_timeout?: number | null;
            /** Batch */
            batch?: boolean | number | components["schemas"]["BatchConfig"] | null;
            /** Best Of */
            best_of?: number | null;
            /** Cache */
            cache?: boolean | components["schemas"]["CachePolicy"] | null;
            /** Cache Prompt */
            cache_prompt?: "auto" | boolean | null;
            /** Effort */
            effort?: ("low" | "medium" | "high") | null;
            /** Extra Body */
            extra_body?: {
                [key: string]: unknown;
            } | null;
            /** Frequency Penalty */
            frequency_penalty?: number | null;
            /** Internal Tools */
            internal_tools?: boolean | null;
            /** Logit Bias */
            logit_bias?: {
                [key: string]: number;
            } | null;
            /** Logprobs */
            logprobs?: boolean | null;
            /** Max Connections */
            max_connections?: number | null;
            /** Max Retries */
            max_retries?: number | null;
            /** Max Tokens */
            max_tokens?: number | null;
            /** Max Tool Output */
            max_tool_output?: number | null;
            /** Num Choices */
            num_choices?: number | null;
            /** Parallel Tool Calls */
            parallel_tool_calls?: boolean | null;
            /** Presence Penalty */
            presence_penalty?: number | null;
            /** Reasoning Effort */
            reasoning_effort?: ("none" | "minimal" | "low" | "medium" | "high" | "xhigh") | null;
            /** Reasoning History */
            reasoning_history?: ("none" | "all" | "last" | "auto") | null;
            /** Reasoning Summary */
            reasoning_summary?: ("none" | "concise" | "detailed" | "auto") | null;
            /** Reasoning Tokens */
            reasoning_tokens?: number | null;
            response_schema?: components["schemas"]["ResponseSchema"] | null;
            /** Seed */
            seed?: number | null;
            /** Stop Seqs */
            stop_seqs?: string[] | null;
            /** System Message */
            system_message?: string | null;
            /** Temperature */
            temperature?: number | null;
            /** Timeout */
            timeout?: number | null;
            /** Top K */
            top_k?: number | null;
            /** Top Logprobs */
            top_logprobs?: number | null;
            /** Top P */
            top_p?: number | null;
            /** Verbosity */
            verbosity?: ("low" | "medium" | "high") | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * InfoEvent
         * @description Event with custom info/data.
         */
        InfoEvent: {
            data: components["schemas"]["JsonValue"];
            /**
             * Event
             * @default info
             * @constant
             */
            event: "info";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Source */
            source?: string | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * InputEvent
         * @description Input screen interaction.
         */
        InputEvent: {
            /**
             * Event
             * @default input
             * @constant
             */
            event: "input";
            /** Input */
            input: string;
            /** Input Ansi */
            input_ansi: string;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * JSONSchema
         * @description JSON Schema for type.
         */
        JSONSchema: {
            /** Additionalproperties */
            additionalProperties?: components["schemas"]["JSONSchema"] | boolean | null;
            /** Anyof */
            anyOf?: components["schemas"]["JSONSchema"][] | null;
            /** Default */
            default: unknown;
            /** Description */
            description?: string | null;
            /** Enum */
            enum?: unknown[] | null;
            /** Format */
            format?: string | null;
            items?: components["schemas"]["JSONSchema"] | null;
            /** Properties */
            properties?: {
                [key: string]: components["schemas"]["JSONSchema"];
            } | null;
            /** Required */
            required?: string[] | null;
            /** Type */
            type?: ("string" | "integer" | "number" | "boolean" | "array" | "object" | "null") | ("string" | "integer" | "number" | "boolean" | "array" | "object" | "null")[] | null;
        };
        /**
         * JsonChange
         * @description Describes a change to data using JSON Patch format.
         */
        JsonChange: {
            /** From */
            from?: string | null;
            /**
             * Op
             * @enum {string}
             */
            op: "remove" | "add" | "replace" | "move" | "test" | "copy";
            /** Path */
            path: string;
            replaced: components["schemas"]["JsonValue"];
            value: components["schemas"]["JsonValue"];
        };
        JsonValue: JsonValue;
        /**
         * LoggerEvent
         * @description Log message recorded with Python logger.
         */
        LoggerEvent: {
            /**
             * Event
             * @default logger
             * @constant
             */
            event: "logger";
            message: components["schemas"]["LoggingMessage"];
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * LoggingMessage
         * @description Message written to Python log.
         */
        LoggingMessage: {
            /** Created */
            created: number;
            /**
             * Filename
             * @default unknown
             */
            filename: string;
            /**
             * Level
             * @enum {string}
             */
            level: "debug" | "trace" | "http" | "sandbox" | "info" | "warning" | "error" | "critical";
            /**
             * Lineno
             * @default 0
             */
            lineno: number;
            /** Message */
            message: string;
            /**
             * Module
             * @default unknown
             */
            module: string;
            /** Name */
            name?: string | null;
        };
        /**
         * LogicalOperator
         * @description Logical operators for combining conditions.
         * @enum {string}
         */
        LogicalOperator: "AND" | "OR" | "NOT";
        /**
         * Logprob
         * @description Log probability for a token.
         */
        Logprob: {
            /** Bytes */
            bytes?: number[] | null;
            /** Logprob */
            logprob: number;
            /** Token */
            token: string;
            /** Top Logprobs */
            top_logprobs?: components["schemas"]["TopLogprob"][] | null;
        };
        /**
         * Logprobs
         * @description Log probability information for a completion choice.
         */
        Logprobs: {
            /** Content */
            content: components["schemas"]["Logprob"][];
        };
        /**
         * ModelCall
         * @description Model call (raw request/response data).
         */
        ModelCall: {
            /** Request */
            request: {
                [key: string]: components["schemas"]["JsonValue"];
            };
            /** Response */
            response: {
                [key: string]: components["schemas"]["JsonValue"];
            };
            /** Time */
            time?: number | null;
        };
        /**
         * ModelConfig
         * @description Model config.
         */
        ModelConfig: {
            /** Args */
            args: {
                [key: string]: unknown;
            };
            /** Base Url */
            base_url?: string | null;
            config: components["schemas"]["GenerateConfig"];
            /** Model */
            model: string;
        };
        /**
         * ModelEvent
         * @description Call to a language model.
         */
        ModelEvent: {
            /** Cache */
            cache?: ("read" | "write") | null;
            call?: components["schemas"]["ModelCall"] | null;
            /** Completed */
            completed?: string | null;
            config: components["schemas"]["GenerateConfig"];
            /** Error */
            error?: string | null;
            /**
             * Event
             * @default model
             * @constant
             */
            event: "model";
            /** Input */
            input: (components["schemas"]["ChatMessageSystem"] | components["schemas"]["ChatMessageUser"] | components["schemas"]["ChatMessageAssistant"] | components["schemas"]["ChatMessageTool"])[];
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Model */
            model: string;
            output: components["schemas"]["ModelOutput"];
            /** Pending */
            pending?: boolean | null;
            /** Retries */
            retries?: number | null;
            /** Role */
            role?: string | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Tool Choice */
            tool_choice: ("auto" | "any" | "none") | components["schemas"]["ToolFunction"];
            /** Tools */
            tools: components["schemas"]["ToolInfo"][];
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
            /** Working Time */
            working_time?: number | null;
        };
        /**
         * ModelOutput
         * @description Output from model generation.
         */
        ModelOutput: {
            /**
             * Choices
             * @default []
             */
            choices: components["schemas"]["ChatCompletionChoice"][];
            /**
             * Completion
             * @default
             */
            completion: string;
            /** Error */
            error?: string | null;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Model */
            model: string;
            /** Time */
            time?: number | null;
            usage?: components["schemas"]["ModelUsage"] | null;
        };
        /**
         * ModelUsage
         * @description Token usage for completion.
         */
        ModelUsage: {
            /**
             * Input Tokens
             * @default 0
             */
            input_tokens: number;
            /** Input Tokens Cache Read */
            input_tokens_cache_read?: number | null;
            /** Input Tokens Cache Write */
            input_tokens_cache_write?: number | null;
            /**
             * Output Tokens
             * @default 0
             */
            output_tokens: number;
            /** Reasoning Tokens */
            reasoning_tokens?: number | null;
            /**
             * Total Tokens
             * @default 0
             */
            total_tokens: number;
        };
        /**
         * Operator
         * @description SQL comparison operators.
         * @enum {string}
         */
        Operator: "=" | "!=" | "<" | "<=" | ">" | ">=" | "IN" | "NOT IN" | "LIKE" | "NOT LIKE" | "ILIKE" | "NOT ILIKE" | "IS NULL" | "IS NOT NULL" | "BETWEEN" | "NOT BETWEEN";
        /** OrderBy */
        OrderBy: {
            /** Column */
            column: string;
            /**
             * Direction
             * @enum {string}
             */
            direction: "ASC" | "DESC";
        };
        /** Pagination */
        Pagination: {
            /** Cursor */
            cursor?: {
                [key: string]: unknown;
            } | null;
            /**
             * Direction
             * @enum {string}
             */
            direction: "forward" | "backward";
            /** Limit */
            limit: number;
        };
        /**
         * ProvenanceData
         * @description Metadata about who made an edit and why.
         */
        ProvenanceData: {
            /** Author */
            author: string;
            /** Metadata */
            metadata: {
                [key: string]: unknown;
            };
            /** Reason */
            reason?: string | null;
            /**
             * Timestamp
             * Format: date-time
             */
            timestamp: string;
        };
        /**
         * ResponseSchema
         * @description Schema for model response when using Structured Output.
         */
        ResponseSchema: {
            /** Description */
            description?: string | null;
            json_schema: components["schemas"]["JSONSchema"];
            /** Name */
            name: string;
            /** Strict */
            strict?: boolean | null;
        };
        /**
         * Sample
         * @description Sample for an evaluation task.
         */
        Sample: {
            /** Choices */
            choices?: string[] | null;
            /** Files */
            files?: {
                [key: string]: string;
            } | null;
            /** Id */
            id?: number | string | null;
            /** Input */
            input: string | (components["schemas"]["ChatMessageSystem"] | components["schemas"]["ChatMessageUser"] | components["schemas"]["ChatMessageAssistant"] | components["schemas"]["ChatMessageTool"])[];
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            sandbox?: components["schemas"]["SandboxEnvironmentSpec"] | null;
            /** Setup */
            setup?: string | null;
            /** Target */
            target: string | string[];
        };
        /**
         * SampleInitEvent
         * @description Beginning of processing a Sample.
         */
        SampleInitEvent: {
            /**
             * Event
             * @default sample_init
             * @constant
             */
            event: "sample_init";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            sample: components["schemas"]["Sample"];
            /** Span Id */
            span_id?: string | null;
            state: components["schemas"]["JsonValue"];
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * SampleLimitEvent
         * @description The sample was unable to finish processing due to a limit
         */
        SampleLimitEvent: {
            /**
             * Event
             * @default sample_limit
             * @constant
             */
            event: "sample_limit";
            /** Limit */
            limit?: number | null;
            /** Message */
            message: string;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /**
             * Type
             * @enum {string}
             */
            type: "message" | "time" | "working" | "token" | "operator" | "custom";
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * SandboxEnvironmentSpec
         * @description Specification of a SandboxEnvironment.
         */
        SandboxEnvironmentSpec: {
            /** Config */
            config: unknown;
            /** Type */
            type: string;
        };
        /**
         * SandboxEvent
         * @description Sandbox execution or I/O
         */
        SandboxEvent: {
            /**
             * Action
             * @enum {string}
             */
            action: "exec" | "read_file" | "write_file";
            /** Cmd */
            cmd?: string | null;
            /** Completed */
            completed?: string | null;
            /**
             * Event
             * @default sandbox
             * @constant
             */
            event: "sandbox";
            /** File */
            file?: string | null;
            /** Input */
            input?: string | null;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Options */
            options?: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            /** Output */
            output?: string | null;
            /** Pending */
            pending?: boolean | null;
            /** Result */
            result?: number | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * ScanOptions
         * @description Options used for scan.
         */
        ScanOptions: {
            /** Limit */
            limit?: number | null;
            /** Max Processes */
            max_processes?: number | null;
            /**
             * Max Transcripts
             * @default 25
             */
            max_transcripts: number;
            /** Shuffle */
            shuffle?: boolean | number | null;
        };
        /**
         * ScanRevision
         * @description Git revision for scan.
         */
        ScanRevision: {
            /** Commit */
            commit: string;
            /** Origin */
            origin: string;
            /**
             * Type
             * @constant
             */
            type: "git";
            /**
             * Version
             * @default 0.0.0-dev.0+unknown
             */
            version: string;
        };
        /**
         * ScanSpec
         * @description Scan specification (scanners, transcripts, config).
         */
        ScanSpec: {
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            model?: components["schemas"]["ModelConfig"] | null;
            /** Model Roles */
            model_roles?: {
                [key: string]: components["schemas"]["ModelConfig"];
            } | null;
            options: components["schemas"]["ScanOptions"];
            /** Packages */
            packages: {
                [key: string]: string;
            };
            revision?: components["schemas"]["ScanRevision"] | null;
            /** Scan Args */
            scan_args?: {
                [key: string]: unknown;
            } | null;
            /** Scan File */
            scan_file?: string | null;
            /** Scan Id */
            scan_id: string;
            /** Scan Name */
            scan_name: string;
            /** Scanners */
            scanners: {
                [key: string]: components["schemas"]["ScannerSpec"];
            };
            /** Tags */
            tags?: string[] | null;
            /** Timestamp */
            timestamp: string;
            transcripts?: components["schemas"]["ScanTranscripts"] | null;
            /** Validation */
            validation?: {
                [key: string]: components["schemas"]["ValidationSet"];
            } | null;
            /** Worklist */
            worklist?: components["schemas"]["Worklist"][] | null;
        };
        /**
         * ScanTranscripts
         * @description Transcripts targeted by a scan.
         */
        ScanTranscripts: {
            /** Conditions */
            conditions?: components["schemas"]["Condition-Output"][] | null;
            /**
             * Count
             * @default 0
             */
            count: number;
            /** Data */
            data?: string | null;
            /** Fields */
            fields?: components["schemas"]["TranscriptField"][] | null;
            /** Location */
            location?: string | null;
            /** Transcript Ids */
            transcript_ids: {
                [key: string]: string | null;
            };
            /**
             * Type
             * @enum {string}
             */
            type: "eval_log" | "database";
        };
        /**
         * ScannerSpec
         * @description Scanner used by scan.
         */
        ScannerSpec: {
            /** File */
            file?: string | null;
            /** Name */
            name: string;
            /** Package Version */
            package_version?: string | null;
            /** Params */
            params: {
                [key: string]: unknown;
            };
            /**
             * Version
             * @default 0
             */
            version: number;
        };
        /**
         * ScannerSummary
         * @description Summary of scanner results.
         */
        ScannerSummary: {
            /**
             * Errors
             * @default 0
             */
            errors: number;
            /** Metrics */
            metrics?: {
                [key: string]: {
                    [key: string]: number;
                };
            } | null;
            /** Model Usage */
            model_usage: {
                [key: string]: components["schemas"]["ModelUsage"];
            };
            /**
             * Results
             * @default 0
             */
            results: number;
            /**
             * Scans
             * @default 0
             */
            scans: number;
            /**
             * Tokens
             * @default 0
             */
            tokens: number;
            /** Validations */
            validations: (boolean | {
                [key: string]: boolean;
            })[];
        };
        /**
         * Score
         * @description Score generated by a scorer.
         */
        Score: {
            /** Answer */
            answer?: string | null;
            /** Explanation */
            explanation?: string | null;
            /** History */
            history: components["schemas"]["ScoreEdit"][];
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Value */
            value: string | number | boolean | (string | number | boolean)[] | {
                [key: string]: string | number | boolean | null;
            };
        };
        /**
         * ScoreEdit
         * @description A single edit to a score.
         */
        ScoreEdit: {
            /**
             * Answer
             * @default UNCHANGED
             */
            answer: string | "UNCHANGED" | null;
            /**
             * Explanation
             * @default UNCHANGED
             */
            explanation: string | "UNCHANGED" | null;
            /**
             * Metadata
             * @default UNCHANGED
             */
            metadata: {
                [key: string]: unknown;
            } | "UNCHANGED";
            provenance?: components["schemas"]["ProvenanceData"] | null;
            /**
             * Value
             * @default UNCHANGED
             */
            value: string | number | boolean | (string | number | boolean)[] | {
                [key: string]: string | number | boolean | null;
            } | "UNCHANGED";
        };
        /**
         * ScoreEditEvent
         * @description Event recorded when a score is edited.
         */
        ScoreEditEvent: {
            edit: components["schemas"]["ScoreEdit"];
            /**
             * Event
             * @default score_edit
             * @constant
             */
            event: "score_edit";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Score Name */
            score_name: string;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * ScoreEvent
         * @description Event with score.
         *
         *     Can be the final score for a `Sample`, or can be an intermediate score
         *     resulting from a call to `score`.
         */
        ScoreEvent: {
            /**
             * Event
             * @default score
             * @constant
             */
            event: "score";
            /**
             * Intermediate
             * @default false
             */
            intermediate: boolean;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            score: components["schemas"]["Score"];
            /** Span Id */
            span_id?: string | null;
            /** Target */
            target?: string | string[] | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * SpanBeginEvent
         * @description Mark the beginning of a transcript span.
         */
        SpanBeginEvent: {
            /**
             * Event
             * @default span_begin
             * @constant
             */
            event: "span_begin";
            /** Id */
            id: string;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Name */
            name: string;
            /** Parent Id */
            parent_id?: string | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Type */
            type?: string | null;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * SpanEndEvent
         * @description Mark the end of a transcript span.
         */
        SpanEndEvent: {
            /**
             * Event
             * @default span_end
             * @constant
             */
            event: "span_end";
            /** Id */
            id: string;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * StateEvent
         * @description Change to the current `TaskState`
         */
        StateEvent: {
            /** Changes */
            changes: components["schemas"]["JsonChange"][];
            /**
             * Event
             * @default state
             * @constant
             */
            event: "state";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /** Status */
        Status: {
            /** Complete */
            complete: boolean;
            /** Errors */
            errors: components["schemas"]["Error"][];
            /** Location */
            location: string;
            spec: components["schemas"]["ScanSpec"];
            summary: components["schemas"]["Summary"];
        };
        /**
         * StepEvent
         * @description Step within current sample or subtask.
         */
        StepEvent: {
            /**
             * Action
             * @enum {string}
             */
            action: "begin" | "end";
            /**
             * Event
             * @default step
             * @constant
             */
            event: "step";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Name */
            name: string;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Type */
            type?: string | null;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * StoreEvent
         * @description Change to data within the current `Store`.
         */
        StoreEvent: {
            /** Changes */
            changes: components["schemas"]["JsonChange"][];
            /**
             * Event
             * @default store
             * @constant
             */
            event: "store";
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
        };
        /**
         * SubtaskEvent
         * @description Subtask spawned.
         */
        SubtaskEvent: {
            /** Completed */
            completed?: string | null;
            /**
             * Event
             * @default subtask
             * @constant
             */
            event: "subtask";
            /** Events */
            events: unknown[];
            /** Input */
            input: {
                [key: string]: unknown;
            };
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Name */
            name: string;
            /** Pending */
            pending?: boolean | null;
            /** Result */
            result: unknown;
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Type */
            type?: string | null;
            /** Uuid */
            uuid?: string | null;
            /** Working Start */
            working_start: number;
            /** Working Time */
            working_time?: number | null;
        };
        /**
         * Summary
         * @description Summary of scan results.
         */
        Summary: {
            /**
             * Complete
             * @default true
             */
            complete: boolean;
            /** Scanners */
            scanners: {
                [key: string]: components["schemas"]["ScannerSummary"];
            };
        };
        /** ToolCall */
        ToolCall: {
            /** Arguments */
            arguments: {
                [key: string]: unknown;
            };
            /** Function */
            function: string;
            /** Id */
            id: string;
            /**
             * Parse Error
             * @default null
             */
            parse_error: string | null;
            /**
             * Type
             * @default function
             * @enum {string}
             */
            type: "function" | "custom";
            /** @default null */
            view: components["schemas"]["ToolCallContent"] | null;
        };
        /**
         * ToolCallContent
         * @description Content to include in tool call view.
         */
        ToolCallContent: {
            /** Content */
            content: string;
            /**
             * Format
             * @enum {string}
             */
            format: "text" | "markdown";
            /**
             * Title
             * @default null
             */
            title: string | null;
        };
        /** ToolCallError */
        ToolCallError: {
            /** Message */
            message: string;
            /**
             * Type
             * @enum {string}
             */
            type: "parsing" | "timeout" | "unicode_decode" | "permission" | "file_not_found" | "is_a_directory" | "limit" | "approval" | "unknown" | "output_limit";
        };
        /**
         * ToolCallView
         * @description Custom view of a tool call.
         *
         *     Both `context` and `call` are optional. If `call` is not specified
         *     then the view will default to a syntax highlighted Python function call.
         */
        ToolCallView: {
            call?: components["schemas"]["ToolCallContent"] | null;
            context?: components["schemas"]["ToolCallContent"] | null;
        };
        /**
         * ToolEvent
         * @description Call to a tool.
         */
        ToolEvent: {
            /** Agent */
            agent?: string | null;
            /** Arguments */
            arguments: {
                [key: string]: components["schemas"]["JsonValue"];
            };
            /** Completed */
            completed?: string | null;
            error?: components["schemas"]["ToolCallError"] | null;
            /**
             * Event
             * @default tool
             * @constant
             */
            event: "tool";
            /** Events */
            events: unknown[];
            /** Failed */
            failed?: boolean | null;
            /** Function */
            function: string;
            /** Id */
            id: string;
            /** Message Id */
            message_id?: string | null;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** Pending */
            pending?: boolean | null;
            /** Result */
            result: string | number | boolean | components["schemas"]["ContentText"] | components["schemas"]["ContentImage"] | components["schemas"]["ContentAudio"] | components["schemas"]["ContentVideo"] | (components["schemas"]["ContentText"] | components["schemas"]["ContentImage"] | components["schemas"]["ContentAudio"] | components["schemas"]["ContentVideo"])[];
            /** Span Id */
            span_id?: string | null;
            /** Timestamp */
            timestamp: string;
            /** Truncated */
            truncated?: [
                number,
                number
            ] | null;
            /**
             * Type
             * @default function
             * @constant
             */
            type: "function";
            /** Uuid */
            uuid?: string | null;
            view?: components["schemas"]["ToolCallContent"] | null;
            /** Working Start */
            working_start: number;
            /** Working Time */
            working_time?: number | null;
        };
        /** ToolFunction */
        ToolFunction: {
            /** Name */
            name: string;
        };
        /**
         * ToolInfo
         * @description Specification of a tool (JSON Schema compatible)
         *
         *     If you are implementing a ModelAPI, most LLM libraries can
         *     be passed this object (dumped to a dict) directly as a function
         *     specification. For example, in the OpenAI provider:
         *
         *     ```python
         *     ChatCompletionToolParam(
         *         type="function",
         *         function=tool.model_dump(exclude_none=True),
         *     )
         *     ```
         *
         *     In some cases the field names don't match up exactly. In that case
         *     call `model_dump()` on the `parameters` field. For example, in the
         *     Anthropic provider:
         *
         *     ```python
         *     ToolParam(
         *         name=tool.name,
         *         description=tool.description,
         *         input_schema=tool.parameters.model_dump(exclude_none=True),
         *     )
         *     ```
         */
        ToolInfo: {
            /** Description */
            description: string;
            /** Name */
            name: string;
            /** Options */
            options?: {
                [key: string]: unknown;
            } | null;
            parameters: components["schemas"]["ToolParams"];
        };
        /**
         * ToolParams
         * @description Description of tool parameters object in JSON Schema format.
         */
        ToolParams: {
            /**
             * Additionalproperties
             * @default false
             */
            additionalProperties: boolean;
            /** Properties */
            properties: {
                [key: string]: components["schemas"]["JSONSchema"];
            };
            /** Required */
            required: string[];
            /**
             * Type
             * @default object
             * @constant
             */
            type: "object";
        };
        /**
         * TopLogprob
         * @description List of the most likely tokens and their log probability, at this token position.
         */
        TopLogprob: {
            /** Bytes */
            bytes?: number[] | null;
            /** Logprob */
            logprob: number;
            /** Token */
            token: string;
        };
        /**
         * Transcript
         * @description Transcript info and transcript content (messages and events).
         */
        Transcript: {
            /** Agent */
            agent?: string | null;
            /** Agent Args */
            agent_args?: {
                [key: string]: unknown;
            } | null;
            /** Date */
            date?: string | null;
            /** Error */
            error?: string | null;
            /** Events */
            events: (components["schemas"]["SampleInitEvent"] | components["schemas"]["SampleLimitEvent"] | components["schemas"]["SandboxEvent"] | components["schemas"]["StateEvent"] | components["schemas"]["StoreEvent"] | components["schemas"]["ModelEvent"] | components["schemas"]["ToolEvent"] | components["schemas"]["ApprovalEvent"] | components["schemas"]["InputEvent"] | components["schemas"]["ScoreEvent"] | components["schemas"]["ScoreEditEvent"] | components["schemas"]["ErrorEvent"] | components["schemas"]["LoggerEvent"] | components["schemas"]["InfoEvent"] | components["schemas"]["SpanBeginEvent"] | components["schemas"]["SpanEndEvent"] | components["schemas"]["StepEvent"] | components["schemas"]["SubtaskEvent"])[];
            /** Limit */
            limit?: string | null;
            /** Messages */
            messages: (components["schemas"]["ChatMessageSystem"] | components["schemas"]["ChatMessageUser"] | components["schemas"]["ChatMessageAssistant"] | components["schemas"]["ChatMessageTool"])[];
            /** Metadata */
            metadata: {
                [key: string]: unknown;
            };
            /** Model */
            model?: string | null;
            /** Model Options */
            model_options?: {
                [key: string]: unknown;
            } | null;
            score?: components["schemas"]["JsonValue"] | null;
            /** Source Id */
            source_id?: string | null;
            /** Source Type */
            source_type?: string | null;
            /** Source Uri */
            source_uri?: string | null;
            /** Success */
            success?: boolean | null;
            /** Task Id */
            task_id?: string | null;
            /** Task Repeat */
            task_repeat?: number | null;
            /** Task Set */
            task_set?: string | null;
            /** Total Time */
            total_time?: number | null;
            /** Total Tokens */
            total_tokens?: number | null;
            /** Transcript Id */
            transcript_id: string;
        };
        /**
         * TranscriptField
         * @description Field in transcript data frame.
         */
        TranscriptField: {
            /** Name */
            name: string;
            /** Type */
            type: string;
            /** Tz */
            tz: string;
        };
        /**
         * TranscriptInfo
         * @description Transcript identifier, location, and metadata.
         */
        TranscriptInfo: {
            /** Agent */
            agent?: string | null;
            /** Agent Args */
            agent_args?: {
                [key: string]: unknown;
            } | null;
            /** Date */
            date?: string | null;
            /** Error */
            error?: string | null;
            /** Limit */
            limit?: string | null;
            /** Metadata */
            metadata: {
                [key: string]: unknown;
            };
            /** Model */
            model?: string | null;
            /** Model Options */
            model_options?: {
                [key: string]: unknown;
            } | null;
            score?: components["schemas"]["JsonValue"] | null;
            /** Source Id */
            source_id?: string | null;
            /** Source Type */
            source_type?: string | null;
            /** Source Uri */
            source_uri?: string | null;
            /** Success */
            success?: boolean | null;
            /** Task Id */
            task_id?: string | null;
            /** Task Repeat */
            task_repeat?: number | null;
            /** Task Set */
            task_set?: string | null;
            /** Total Time */
            total_time?: number | null;
            /** Total Tokens */
            total_tokens?: number | null;
            /** Transcript Id */
            transcript_id: string;
        };
        /** TranscriptsRequest */
        TranscriptsRequest: {
            filter?: components["schemas"]["Condition-Input"] | null;
            /** Order By */
            order_by?: components["schemas"]["OrderBy"] | components["schemas"]["OrderBy"][] | null;
            pagination?: components["schemas"]["Pagination"] | null;
        };
        /** TranscriptsResponse */
        TranscriptsResponse: {
            /** Items */
            items: components["schemas"]["TranscriptInfo"][];
            /** Next Cursor */
            next_cursor?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * UrlCitation
         * @description A citation that refers to a URL.
         */
        UrlCitation: {
            /**
             * Cited Text
             * @default null
             */
            cited_text: string | number[] | null;
            /**
             * Internal
             * @default null
             */
            internal: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            /**
             * Title
             * @default null
             */
            title: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "url";
            /** Url */
            url: string;
        };
        /**
         * ValidationCase
         * @description Validation case for comparing to scanner results.
         *
         *     A `ValidationCase` specifies the ground truth for a scan of particular id (e.g. transcript id, message id, etc.
         *
         *     Use `target` for single-value or dict validation.
         *     Use `labels` for validating resultsets with label-specific expectations.
         */
        ValidationCase: {
            /** Id */
            id: string | string[];
            /**
             * Labels
             * @default null
             */
            labels: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            /** @default null */
            target: components["schemas"]["JsonValue"] | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * ValidationSet
         * @description Validation set for a scanner.
         */
        ValidationSet: {
            /** Cases */
            cases: components["schemas"]["ValidationCase"][];
            /** Predicate */
            predicate: string | null;
        };
        /**
         * Worklist
         * @description List of transcript ids to process for a scanner.
         */
        Worklist: {
            /** Scanner */
            scanner: string;
            /** Transcripts */
            transcripts: string[];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    scans_scans_get: {
        parameters: {
            query?: {
                /** @description Results directory containing scans. Required if not configured server-side. */
                results_dir?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"][];
                };
            };
        };
    };
    scans_dir_scans_dir_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    scan_scans__scan__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Scan path (base64url-encoded) */
                scan: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                };
            };
        };
    };
    scan_df_scans__scan___scanner__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Scan path (base64url-encoded) */
                scan: string;
                /** @description Scanner name */
                scanner: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    scanner_input_scans__scan___scanner___uuid__input_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Scan path (base64url-encoded) */
                scan: string;
                /** @description Scanner name */
                scanner: string;
                /** @description UUID of the specific result row */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    transcripts_dir_transcripts_dir_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    transcripts_transcripts__dir__post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Transcripts directory (base64url-encoded) */
                dir: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TranscriptsRequest"] | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TranscriptsResponse"];
                };
            };
        };
    };
    transcript_transcripts__dir___id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Transcripts directory (base64url-encoded) */
                dir: string;
                /** @description Transcript ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Transcript"];
                };
            };
        };
    };
}
