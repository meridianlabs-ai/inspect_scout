/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/scans": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List scans
         * @description Returns all scans in the results directory. Supports ETag caching.
         */
        get: operations["scans_scans_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans-dir": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get default scans directory
         * @description Returns the default directory path where scans are stored.
         */
        get: operations["scans_dir_scans_dir_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans/{scan}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scan status
         * @description Returns detailed status and metadata for a single scan.
         */
        get: operations["scan_scans__scan__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans/{scan}/{scanner}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scanner dataframe containing results for all transcripts
         * @description Streams scanner results as Arrow IPC format with LZ4 compression. Excludes input column for efficiency; use the input endpoint for input text.
         */
        get: operations["scan_df_scans__scan___scanner__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scans/{scan}/{scanner}/{uuid}/input": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get scanner input for a specific transcript
         * @description Returns the original input text for a specific scanner result. The input type is returned in the X-Input-Type response header.
         */
        get: operations["scanner_input_scans__scan___scanner___uuid__input_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transcripts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List transcripts
         * @description Returns metadata for all transcripts in the specified directory.
         */
        get: operations["transcripts_transcripts_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transcripts-dir": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get default transcripts directory
         * @description Returns the default directory path where transcripts are stored.
         */
        get: operations["transcripts_dir_transcripts_dir_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * BatchConfig
         * @description Batch processing configuration.
         */
        BatchConfig: {
            /** Max Batches */
            max_batches?: number | null;
            /** Max Consecutive Check Failures */
            max_consecutive_check_failures?: number | null;
            /** Max Size */
            max_size?: number | null;
            /** Send Delay */
            send_delay?: number | null;
            /** Size */
            size?: number | null;
            /** Tick */
            tick?: number | null;
        };
        /**
         * CachePolicy
         * @description Caching options for model generation.
         */
        CachePolicy: {
            /**
             * Expiry
             * @default 1W
             */
            expiry: string | null;
            /**
             * Per Epoch
             * @default true
             */
            per_epoch: boolean;
            /** Scopes */
            scopes?: {
                [key: string]: string;
            };
        };
        /**
         * Condition
         * @description WHERE clause condition that can be combined with others.
         */
        Condition: {
            /**
             * Is Compound
             * @default false
             */
            is_compound: boolean;
            /** Left */
            left?: string | components["schemas"]["Condition"] | null;
            /** Operator */
            operator?: components["schemas"]["Operator"] | components["schemas"]["LogicalOperator"] | null;
            /** Right */
            right?: components["schemas"]["Condition"] | (string | number | boolean | null)[] | [
                string | number | boolean | null,
                string | number | boolean | null
            ] | string | number | boolean | null;
        };
        /**
         * Error
         * @description Scan error (runtime error which occurred during scan).
         */
        Error: {
            /** Error */
            error: string;
            /** Refusal */
            refusal: boolean;
            /** Scanner */
            scanner: string;
            /** Traceback */
            traceback: string;
            /** Transcript Id */
            transcript_id: string;
        };
        /**
         * GenerateConfig
         * @description Model generation options.
         */
        GenerateConfig: {
            /** Attempt Timeout */
            attempt_timeout?: number | null;
            /** Batch */
            batch?: boolean | number | components["schemas"]["BatchConfig"] | null;
            /** Best Of */
            best_of?: number | null;
            /** Cache */
            cache?: boolean | components["schemas"]["CachePolicy"] | null;
            /** Cache Prompt */
            cache_prompt?: "auto" | boolean | null;
            /** Effort */
            effort?: ("low" | "medium" | "high") | null;
            /** Extra Body */
            extra_body?: {
                [key: string]: unknown;
            } | null;
            /** Frequency Penalty */
            frequency_penalty?: number | null;
            /** Internal Tools */
            internal_tools?: boolean | null;
            /** Logit Bias */
            logit_bias?: {
                [key: string]: number;
            } | null;
            /** Logprobs */
            logprobs?: boolean | null;
            /** Max Connections */
            max_connections?: number | null;
            /** Max Retries */
            max_retries?: number | null;
            /** Max Tokens */
            max_tokens?: number | null;
            /** Max Tool Output */
            max_tool_output?: number | null;
            /** Num Choices */
            num_choices?: number | null;
            /** Parallel Tool Calls */
            parallel_tool_calls?: boolean | null;
            /** Presence Penalty */
            presence_penalty?: number | null;
            /** Reasoning Effort */
            reasoning_effort?: ("none" | "minimal" | "low" | "medium" | "high" | "xhigh") | null;
            /** Reasoning History */
            reasoning_history?: ("none" | "all" | "last" | "auto") | null;
            /** Reasoning Summary */
            reasoning_summary?: ("none" | "concise" | "detailed" | "auto") | null;
            /** Reasoning Tokens */
            reasoning_tokens?: number | null;
            response_schema?: components["schemas"]["ResponseSchema"] | null;
            /** Seed */
            seed?: number | null;
            /** Stop Seqs */
            stop_seqs?: string[] | null;
            /** System Message */
            system_message?: string | null;
            /** Temperature */
            temperature?: number | null;
            /** Timeout */
            timeout?: number | null;
            /** Top K */
            top_k?: number | null;
            /** Top Logprobs */
            top_logprobs?: number | null;
            /** Top P */
            top_p?: number | null;
            /** Verbosity */
            verbosity?: ("low" | "medium" | "high") | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * JSONSchema
         * @description JSON Schema for type.
         */
        JSONSchema: {
            /** Additionalproperties */
            additionalProperties?: components["schemas"]["JSONSchema"] | boolean | null;
            /** Anyof */
            anyOf?: components["schemas"]["JSONSchema"][] | null;
            /** Default */
            default?: unknown;
            /** Description */
            description?: string | null;
            /** Enum */
            enum?: unknown[] | null;
            /** Format */
            format?: string | null;
            items?: components["schemas"]["JSONSchema"] | null;
            /** Properties */
            properties?: {
                [key: string]: components["schemas"]["JSONSchema"];
            } | null;
            /** Required */
            required?: string[] | null;
            /** Type */
            type?: ("string" | "integer" | "number" | "boolean" | "array" | "object" | "null") | ("string" | "integer" | "number" | "boolean" | "array" | "object" | "null")[] | null;
        };
        JsonValue: unknown;
        /**
         * LogicalOperator
         * @description Logical operators for combining conditions.
         * @enum {string}
         */
        LogicalOperator: "AND" | "OR" | "NOT";
        /**
         * ModelConfig
         * @description Model config.
         */
        ModelConfig: {
            /** Args */
            args?: {
                [key: string]: unknown;
            };
            /** Base Url */
            base_url?: string | null;
            config?: components["schemas"]["GenerateConfig"];
            /** Model */
            model: string;
        };
        /**
         * ModelUsage
         * @description Token usage for completion.
         */
        ModelUsage: {
            /**
             * Input Tokens
             * @default 0
             */
            input_tokens: number;
            /** Input Tokens Cache Read */
            input_tokens_cache_read?: number | null;
            /** Input Tokens Cache Write */
            input_tokens_cache_write?: number | null;
            /**
             * Output Tokens
             * @default 0
             */
            output_tokens: number;
            /** Reasoning Tokens */
            reasoning_tokens?: number | null;
            /**
             * Total Tokens
             * @default 0
             */
            total_tokens: number;
        };
        /**
         * Operator
         * @description SQL comparison operators.
         * @enum {string}
         */
        Operator: "=" | "!=" | "<" | "<=" | ">" | ">=" | "IN" | "NOT IN" | "LIKE" | "NOT LIKE" | "ILIKE" | "NOT ILIKE" | "IS NULL" | "IS NOT NULL" | "BETWEEN" | "NOT BETWEEN";
        /**
         * ResponseSchema
         * @description Schema for model response when using Structured Output.
         */
        ResponseSchema: {
            /** Description */
            description?: string | null;
            json_schema: components["schemas"]["JSONSchema"];
            /** Name */
            name: string;
            /** Strict */
            strict?: boolean | null;
        };
        /**
         * ScanOptions
         * @description Options used for scan.
         */
        ScanOptions: {
            /** Limit */
            limit?: number | null;
            /** Max Processes */
            max_processes?: number | null;
            /**
             * Max Transcripts
             * @default 25
             */
            max_transcripts: number;
            /** Shuffle */
            shuffle?: boolean | number | null;
        };
        /**
         * ScanRevision
         * @description Git revision for scan.
         */
        ScanRevision: {
            /** Commit */
            commit: string;
            /** Origin */
            origin: string;
            /**
             * Type
             * @constant
             */
            type: "git";
            /**
             * Version
             * @default 0.0.0-dev.0+unknown
             */
            version: string;
        };
        /**
         * ScanSpec
         * @description Scan specification (scanners, transcripts, config).
         */
        ScanSpec: {
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            } | null;
            model?: components["schemas"]["ModelConfig"] | null;
            /** Model Roles */
            model_roles?: {
                [key: string]: components["schemas"]["ModelConfig"];
            } | null;
            options?: components["schemas"]["ScanOptions"];
            /** Packages */
            packages?: {
                [key: string]: string;
            };
            revision?: components["schemas"]["ScanRevision"] | null;
            /** Scan Args */
            scan_args?: {
                [key: string]: unknown;
            } | null;
            /** Scan File */
            scan_file?: string | null;
            /** Scan Id */
            scan_id?: string;
            /** Scan Name */
            scan_name: string;
            /** Scanners */
            scanners: {
                [key: string]: components["schemas"]["ScannerSpec"];
            };
            /** Tags */
            tags?: string[] | null;
            /** Timestamp */
            timestamp?: string;
            transcripts?: components["schemas"]["ScanTranscripts"] | null;
            /** Validation */
            validation?: {
                [key: string]: components["schemas"]["ValidationSet"];
            } | null;
            /** Worklist */
            worklist?: components["schemas"]["Worklist"][] | null;
        };
        /**
         * ScanTranscripts
         * @description Transcripts targeted by a scan.
         */
        ScanTranscripts: {
            /** Conditions */
            conditions?: components["schemas"]["Condition"][] | null;
            /**
             * Count
             * @default 0
             */
            count: number;
            /** Data */
            data?: string | null;
            /** Fields */
            fields?: components["schemas"]["TranscriptField"][] | null;
            /** Location */
            location?: string | null;
            /** Transcript Ids */
            transcript_ids?: {
                [key: string]: string | null;
            };
            /**
             * Type
             * @enum {string}
             */
            type: "eval_log" | "database";
        };
        /**
         * ScannerSpec
         * @description Scanner used by scan.
         */
        ScannerSpec: {
            /** File */
            file?: string | null;
            /** Name */
            name: string;
            /** Package Version */
            package_version?: string | null;
            /** Params */
            params?: {
                [key: string]: unknown;
            };
            /**
             * Version
             * @default 0
             */
            version: number;
        };
        /**
         * ScannerSummary
         * @description Summary of scanner results.
         */
        ScannerSummary: {
            /**
             * Errors
             * @default 0
             */
            errors: number;
            /** Metrics */
            metrics?: {
                [key: string]: {
                    [key: string]: number;
                };
            } | null;
            /** Model Usage */
            model_usage?: {
                [key: string]: components["schemas"]["ModelUsage"];
            };
            /**
             * Results
             * @default 0
             */
            results: number;
            /**
             * Scans
             * @default 0
             */
            scans: number;
            /**
             * Tokens
             * @default 0
             */
            tokens: number;
            /** Validations */
            validations?: (boolean | {
                [key: string]: boolean;
            })[];
        };
        /** Status */
        Status: {
            /** Complete */
            complete: boolean;
            /** Errors */
            errors: components["schemas"]["Error"][];
            /** Location */
            location: string;
            spec: components["schemas"]["ScanSpec"];
            summary: components["schemas"]["Summary"];
        };
        /**
         * Summary
         * @description Summary of scan results.
         */
        Summary: {
            /**
             * Complete
             * @default true
             */
            complete: boolean;
            /** Scanners */
            scanners?: {
                [key: string]: components["schemas"]["ScannerSummary"];
            };
        };
        /**
         * TranscriptField
         * @description Field in transcript data frame.
         */
        TranscriptField: {
            /** Name */
            name: string;
            /** Type */
            type: string;
            /** Tz */
            tz?: string;
        };
        /**
         * TranscriptInfo
         * @description Transcript identifier, location, and metadata.
         */
        TranscriptInfo: {
            /** Agent */
            agent?: string | null;
            /** Agent Args */
            agent_args?: {
                [key: string]: unknown;
            } | null;
            /** Date */
            date?: string | null;
            /** Error */
            error?: string | null;
            /** Limit */
            limit?: string | null;
            /** Metadata */
            metadata?: {
                [key: string]: unknown;
            };
            /** Model */
            model?: string | null;
            /** Model Options */
            model_options?: {
                [key: string]: unknown;
            } | null;
            score?: components["schemas"]["JsonValue"] | null;
            /** Source Id */
            source_id?: string | null;
            /** Source Type */
            source_type?: string | null;
            /** Source Uri */
            source_uri?: string | null;
            /** Success */
            success?: boolean | null;
            /** Task Id */
            task_id?: string | null;
            /** Task Repeat */
            task_repeat?: number | null;
            /** Task Set */
            task_set?: string | null;
            /** Total Time */
            total_time?: number | null;
            /** Total Tokens */
            total_tokens?: number | null;
            /** Transcript Id */
            transcript_id: string;
        };
        /**
         * ValidationCase
         * @description Validation case for comparing to scanner results.
         *
         *     A `ValidationCase` specifies the ground truth for a scan of particular id (e.g. transcript id, message id, etc.
         *
         *     Use `target` for single-value or dict validation.
         *     Use `labels` for validating resultsets with label-specific expectations.
         */
        ValidationCase: {
            /** Id */
            id: string | string[];
            /** Labels */
            labels?: {
                [key: string]: components["schemas"]["JsonValue"];
            } | null;
            target?: components["schemas"]["JsonValue"] | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * ValidationSet
         * @description Validation set for a scanner.
         */
        ValidationSet: {
            /** Cases */
            cases: components["schemas"]["ValidationCase"][];
            /** Predicate */
            predicate?: string | null;
        };
        /**
         * Worklist
         * @description List of transcript ids to process for a scanner.
         */
        Worklist: {
            /** Scanner */
            scanner: string;
            /** Transcripts */
            transcripts: string[];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    scans_scans_get: {
        parameters: {
            query?: {
                /** @description Results directory containing scans. Required if not configured server-side. */
                results_dir?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"][];
                };
            };
        };
    };
    scans_dir_scans_dir_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    scan_scans__scan__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Scan path (base64url-encoded) */
                scan: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                };
            };
        };
    };
    scan_df_scans__scan___scanner__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Scan path (base64url-encoded) */
                scan: string;
                /** @description Scanner name */
                scanner: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    scanner_input_scans__scan___scanner___uuid__input_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Scan path (base64url-encoded) */
                scan: string;
                /** @description Scanner name */
                scanner: string;
                /** @description UUID of the specific result row */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    transcripts_transcripts_get: {
        parameters: {
            query?: {
                /** @description Transcripts directory path. Uses default if not specified. */
                dir?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TranscriptInfo"][];
                };
            };
        };
    };
    transcripts_dir_transcripts_dir_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
}
